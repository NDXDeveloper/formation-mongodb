ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.1 MongoDB Community Kubernetes Operator

## Introduction

Le MongoDB Community Kubernetes Operator est un opÃ©rateur open-source qui simplifie considÃ©rablement le dÃ©ploiement et la gestion de MongoDB sur Kubernetes. Il automatise les tÃ¢ches complexes telles que l'initialisation des Replica Sets, les rolling updates, le scaling, et la gestion du cycle de vie complet des dÃ©ploiements MongoDB.

L'opÃ©rateur suit le pattern Kubernetes de **rÃ©conciliation** : il observe continuellement l'Ã©tat dÃ©sirÃ© (dÃ©clarÃ© via des Custom Resources) et effectue les actions nÃ©cessaires pour aligner l'Ã©tat actuel avec l'Ã©tat dÃ©sirÃ©.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         MongoDB Community Operator Architecture                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Kubernetes Control Plane                    â”‚  â”‚
â”‚  â”‚                                                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚         MongoDB Operator Pod                       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                                    â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚      Operator Controller                    â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚                                             â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Watches MongoDBCommunity CRs             â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Reconciliation Loop                      â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Creates/Updates Resources                â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Manages Replica Set Lifecycle            â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                      â”‚                             â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                      â–¼                             â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚        Kubernetes API Server                â”‚   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                                    â”‚
â”‚                           â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Custom Resource (CR)                        â”‚  â”‚
â”‚  â”‚                                                          â”‚  â”‚
â”‚  â”‚  apiVersion: mongodbcommunity.mongodb.com/v1             â”‚  â”‚
â”‚  â”‚  kind: MongoDBCommunity                                  â”‚  â”‚
â”‚  â”‚  spec:                                                   â”‚  â”‚
â”‚  â”‚    members: 3                                            â”‚  â”‚
â”‚  â”‚    type: ReplicaSet                                      â”‚  â”‚
â”‚  â”‚    version: "7.0.5"                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚                                    â”‚
â”‚                           â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           Managed Kubernetes Resources                   â”‚  â”‚
â”‚  â”‚                                                          â”‚  â”‚
â”‚  â”‚  â€¢ StatefulSet (MongoDB pods)                            â”‚  â”‚
â”‚  â”‚  â€¢ Service (Headless + External)                         â”‚  â”‚
â”‚  â”‚  â€¢ ConfigMap (Configuration)                             â”‚  â”‚
â”‚  â”‚  â€¢ Secret (Credentials, Keyfile)                         â”‚  â”‚
â”‚  â”‚  â€¢ PersistentVolumeClaims                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Installation du Community Operator

### PrÃ©requis

```bash
# VÃ©rifier la version de Kubernetes
kubectl version --short
# Minimum requis: v1.23+

# VÃ©rifier les permissions RBAC
kubectl auth can-i create customresourcedefinitions --all-namespaces
# Doit retourner: yes

# VÃ©rifier la disponibilitÃ© de storage classes
kubectl get storageclass
```

### Installation via Helm

```bash
# Ajouter le repository Helm MongoDB
helm repo add mongodb https://mongodb.github.io/helm-charts
helm repo update

# CrÃ©er le namespace
kubectl create namespace mongodb-operator

# Installer l'opÃ©rateur
helm install community-operator mongodb/community-operator \
  --namespace mongodb-operator \
  --set operator.watchNamespace="*" \
  --set operator.replicas=2 \
  --set operator.resources.limits.cpu=500m \
  --set operator.resources.limits.memory=512Mi \
  --set operator.resources.requests.cpu=100m \
  --set operator.resources.requests.memory=128Mi

# VÃ©rifier l'installation
kubectl get pods -n mongodb-operator
kubectl get crd | grep mongodb
```

### Installation Manuelle avec YAML

```bash
# Cloner le repository
git clone https://github.com/mongodb/mongodb-kubernetes-operator.git
cd mongodb-kubernetes-operator

# Installer les CRDs
kubectl apply -f config/crd/bases/mongodbcommunity.mongodb.com_mongodbcommunity.yaml

# CrÃ©er le namespace
kubectl create namespace mongodb-operator

# Installer l'opÃ©rateur
kubectl apply -k config/rbac -n mongodb-operator
kubectl apply -f config/manager/manager.yaml -n mongodb-operator
```

### Configuration de l'OpÃ©rateur

```yaml
# operator-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: operator-config
  namespace: mongodb-operator
data:
  # Namespace Ã  surveiller (* = tous)
  WATCH_NAMESPACE: "*"

  # Niveau de logs
  LOG_LEVEL: "info"

  # Image MongoDB par dÃ©faut
  MONGODB_IMAGE: "mongo"
  MONGODB_VERSION: "7.0.5"

  # Image de l'agent
  AGENT_IMAGE: "mongodb-agent"

  # Ressources par dÃ©faut
  DEFAULT_MEMORY_LIMIT: "8Gi"
  DEFAULT_CPU_LIMIT: "2"
---
# operator-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb-kubernetes-operator
  namespace: mongodb-operator
spec:
  replicas: 2
  selector:
    matchLabels:
      name: mongodb-kubernetes-operator
  template:
    metadata:
      labels:
        name: mongodb-kubernetes-operator
    spec:
      serviceAccountName: mongodb-kubernetes-operator

      # Anti-affinity pour haute disponibilitÃ©
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchLabels:
                  name: mongodb-kubernetes-operator
              topologyKey: kubernetes.io/hostname

      containers:
        - name: operator
          image: quay.io/mongodb/community-operator:0.9.0

          command:
            - /usr/local/bin/entrypoint

          imagePullPolicy: Always

          env:
            - name: WATCH_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace

            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name

            - name: OPERATOR_NAME
              value: "mongodb-kubernetes-operator"

            - name: MANAGED_SECURITY_CONTEXT
              value: "true"

          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi

          livenessProbe:
            httpGet:
              path: /healthz
              port: 8081
            initialDelaySeconds: 15
            periodSeconds: 20

          readinessProbe:
            httpGet:
              path: /readyz
              port: 8081
            initialDelaySeconds: 5
            periodSeconds: 10
```

---

## Custom Resource Definition (CRD)

### Structure du MongoDBCommunity CR

```yaml
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: example-mongodb
  namespace: mongodb
spec:
  # Nombre de membres du Replica Set
  members: 3

  # Type de dÃ©ploiement
  type: ReplicaSet

  # Version de MongoDB
  version: "7.0.5"

  # Configuration de sÃ©curitÃ©
  security:
    authentication:
      modes: ["SCRAM"]
    tls:
      enabled: true
      certificateKeySecretRef:
        name: mongodb-tls-cert
      caCertificateSecretRef:
        name: mongodb-ca-cert

  # Utilisateurs MongoDB
  users:
    - name: admin
      db: admin
      passwordSecretRef:
        name: admin-password
      roles:
        - name: clusterAdmin
          db: admin
        - name: userAdminAnyDatabase
          db: admin
      scramCredentialsSecretName: admin-scram

  # Configuration additionnelle MongoDB
  additionalMongodConfig:
    storage.wiredTiger.engineConfig.cacheSizeGB: 3
    net.maxIncomingConnections: 10000

  # DÃ©finition du StatefulSet
  statefulSet:
    spec:
      # Template du pod
      template:
        spec:
          # Anti-affinity
          affinity:
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchLabels:
                      app: example-mongodb-svc
                  topologyKey: kubernetes.io/hostname

          # Conteneurs
          containers:
            - name: mongod
              resources:
                limits:
                  cpu: "2"
                  memory: "8Gi"
                requests:
                  cpu: "1"
                  memory: "4Gi"

            - name: mongodb-agent
              resources:
                limits:
                  cpu: "500m"
                  memory: "512Mi"
                requests:
                  cpu: "100m"
                  memory: "128Mi"

      # Template des volumes
      volumeClaimTemplates:
        - metadata:
            name: data-volume
          spec:
            accessModes: ["ReadWriteOnce"]
            storageClassName: fast-ssd
            resources:
              requests:
                storage: 100Gi

        - metadata:
            name: logs-volume
          spec:
            accessModes: ["ReadWriteOnce"]
            storageClassName: standard
            resources:
              requests:
                storage: 10Gi
```

---

## DÃ©ploiement d'un Replica Set

### Configuration ComplÃ¨te de Production

```yaml
# mongodb-replica-set-production.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: mongodb
  labels:
    name: mongodb
---
# Secret pour les credentials admin
apiVersion: v1
kind: Secret
metadata:
  name: admin-password
  namespace: mongodb
type: Opaque
stringData:
  password: "SecureP@ssw0rd123!"
---
# Secret pour le certificat TLS
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-tls-cert
  namespace: mongodb
type: kubernetes.io/tls
data:
  tls.crt: <base64-encoded-cert>
  tls.key: <base64-encoded-key>
---
# Secret pour le CA
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-ca-cert
  namespace: mongodb
type: Opaque
data:
  ca.crt: <base64-encoded-ca-cert>
---
# MongoDBCommunity Resource
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: production-mongodb
  namespace: mongodb
  labels:
    app: mongodb
    environment: production
spec:
  # Configuration du Replica Set
  members: 3
  type: ReplicaSet
  version: "7.0.5"

  # Configuration de sÃ©curitÃ©
  security:
    authentication:
      modes: ["SCRAM"]
      ignoreUnknownUsers: false

    tls:
      enabled: true
      optional: false
      certificateKeySecretRef:
        name: mongodb-tls-cert
      caCertificateSecretRef:
        name: mongodb-ca-cert

  # Utilisateurs
  users:
    # Admin principal
    - name: admin
      db: admin
      passwordSecretRef:
        name: admin-password
        key: password
      roles:
        - name: root
          db: admin
      scramCredentialsSecretName: admin-scram

    # Utilisateur application
    - name: app-user
      db: production_db
      passwordSecretRef:
        name: app-user-password
        key: password
      roles:
        - name: readWrite
          db: production_db
        - name: read
          db: config
      scramCredentialsSecretName: app-user-scram

    # Utilisateur backup
    - name: backup-user
      db: admin
      passwordSecretRef:
        name: backup-user-password
        key: password
      roles:
        - name: backup
          db: admin
        - name: restore
          db: admin
      scramCredentialsSecretName: backup-user-scram

    # Utilisateur monitoring
    - name: monitoring-user
      db: admin
      passwordSecretRef:
        name: monitoring-user-password
        key: password
      roles:
        - name: clusterMonitor
          db: admin
        - name: read
          db: local
      scramCredentialsSecretName: monitoring-user-scram

  # Configuration additionnelle MongoDB
  additionalMongodConfig:
    # Storage
    storage.wiredTiger.engineConfig.cacheSizeGB: 6
    storage.wiredTiger.engineConfig.journalCompressor: snappy
    storage.wiredTiger.collectionConfig.blockCompressor: snappy

    # Network
    net.maxIncomingConnections: 65536
    net.compression.compressors: "snappy,zstd,zlib"

    # Replication
    replication.oplogSizeMB: 10240

    # Operation Profiling
    operationProfiling.mode: slowOp
    operationProfiling.slowOpThresholdMs: 100

    # System Log
    systemLog.verbosity: 0
    systemLog.component.replication.verbosity: 1

    # Set Parameters
    setParameter.diagnosticDataCollectionEnabled: true
    setParameter.enableLocalhostAuthBypass: false
    setParameter.transactionLifetimeLimitSeconds: 60

  # Configuration du StatefulSet
  statefulSet:
    spec:
      # StratÃ©gie de mise Ã  jour
      updateStrategy:
        type: RollingUpdate

      # Politique de gestion des pods
      podManagementPolicy: OrderedReady

      # Template des pods
      template:
        metadata:
          labels:
            app: production-mongodb
          annotations:
            prometheus.io/scrape: "true"
            prometheus.io/port: "9216"

        spec:
          # Service Account
          serviceAccountName: mongodb-database

          # PÃ©riode de grÃ¢ce pour l'arrÃªt
          terminationGracePeriodSeconds: 60

          # AffinitÃ© et anti-affinitÃ©
          affinity:
            # Anti-affinitÃ© stricte entre pods MongoDB
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchExpressions:
                      - key: app
                        operator: In
                        values:
                          - production-mongodb-svc
                  topologyKey: kubernetes.io/hostname

            # AffinitÃ© de nÅ“ud (prÃ©fÃ©rer des nÅ“uds avec SSD)
            nodeAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 100
                  preference:
                    matchExpressions:
                      - key: disktype
                        operator: In
                        values:
                          - ssd

                # PrÃ©fÃ©rer des nÅ“uds dÃ©diÃ©s MongoDB
                - weight: 50
                  preference:
                    matchExpressions:
                      - key: workload
                        operator: In
                        values:
                          - database

          # Topology Spread Constraints
          topologySpreadConstraints:
            - maxSkew: 1
              topologyKey: topology.kubernetes.io/zone
              whenUnsatisfiable: DoNotSchedule
              labelSelector:
                matchLabels:
                  app: production-mongodb-svc

          # Security Context
          securityContext:
            runAsNonRoot: true
            runAsUser: 2000
            fsGroup: 2000
            fsGroupChangePolicy: "OnRootMismatch"

          # Init Containers
          initContainers:
            # PrÃ©parer les permissions des volumes
            - name: init-permissions
              image: busybox:1.35
              command:
                - sh
                - -c
                - |
                  chown -R 2000:2000 /data
                  chmod 750 /data
              volumeMounts:
                - name: data-volume
                  mountPath: /data
              securityContext:
                runAsUser: 0

          # Conteneurs
          containers:
            # Conteneur MongoDB principal
            - name: mongod
              image: mongo:7.0.5

              # Ressources
              resources:
                limits:
                  cpu: "4"
                  memory: "16Gi"
                requests:
                  cpu: "2"
                  memory: "8Gi"

              # Variables d'environnement
              env:
                - name: POD_NAME
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.name
                - name: POD_NAMESPACE
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.namespace

              # Probes de santÃ©
              livenessProbe:
                exec:
                  command:
                    - mongosh
                    - --tls
                    - --tlsCAFile=/var/lib/tls/ca/ca.crt
                    - --tlsCertificateKeyFile=/var/lib/tls/server/*.pem
                    - --eval
                    - "db.adminCommand('ping')"
                initialDelaySeconds: 30
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 3

              readinessProbe:
                exec:
                  command:
                    - mongosh
                    - --tls
                    - --tlsCAFile=/var/lib/tls/ca/ca.crt
                    - --tlsCertificateKeyFile=/var/lib/tls/server/*.pem
                    - --eval
                    - "db.adminCommand('ping')"
                initialDelaySeconds: 10
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 3

              startupProbe:
                exec:
                  command:
                    - mongosh
                    - --tls
                    - --tlsCAFile=/var/lib/tls/ca/ca.crt
                    - --tlsCertificateKeyFile=/var/lib/tls/server/*.pem
                    - --eval
                    - "db.adminCommand('ping')"
                initialDelaySeconds: 0
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 60

            # Agent de l'opÃ©rateur
            - name: mongodb-agent
              resources:
                limits:
                  cpu: "500m"
                  memory: "512Mi"
                requests:
                  cpu: "100m"
                  memory: "128Mi"

            # Sidecar pour monitoring (optionnel)
            - name: mongodb-exporter
              image: percona/mongodb_exporter:0.40
              args:
                - --mongodb.uri=mongodb://monitoring-user:$(MONITORING_PASSWORD)@localhost:27017/?tls=true&tlsCAFile=/var/lib/tls/ca/ca.crt&tlsCertificateKeyFile=/var/lib/tls/server/*.pem
                - --collect-all
                - --compatible-mode
                - --web.listen-address=:9216
              ports:
                - name: metrics
                  containerPort: 9216
              env:
                - name: MONITORING_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: monitoring-user-password
                      key: password
              resources:
                limits:
                  cpu: "200m"
                  memory: "256Mi"
                requests:
                  cpu: "50m"
                  memory: "64Mi"

      # Template des PVCs
      volumeClaimTemplates:
        # Volume des donnÃ©es
        - metadata:
            name: data-volume
          spec:
            accessModes: ["ReadWriteOnce"]
            storageClassName: fast-ssd
            resources:
              requests:
                storage: 500Gi

        # Volume des logs
        - metadata:
            name: logs-volume
          spec:
            accessModes: ["ReadWriteOnce"]
            storageClassName: standard
            resources:
              requests:
                storage: 50Gi
```

### DÃ©ploiement et VÃ©rification

```bash
#!/bin/bash
# scripts/deploy-mongodb.sh

set -euo pipefail

NAMESPACE="mongodb"
MONGODB_NAME="production-mongodb"

echo "ğŸš€ DÃ©ploiement de MongoDB Replica Set..."

# CrÃ©er les secrets
echo "ğŸ” CrÃ©ation des secrets..."

# GÃ©nÃ©rer les mots de passe
ADMIN_PASSWORD=$(openssl rand -base64 32)
APP_PASSWORD=$(openssl rand -base64 32)
BACKUP_PASSWORD=$(openssl rand -base64 32)
MONITORING_PASSWORD=$(openssl rand -base64 32)

kubectl create secret generic admin-password \
  --from-literal=password="$ADMIN_PASSWORD" \
  -n "$NAMESPACE" \
  --dry-run=client -o yaml | kubectl apply -f -

kubectl create secret generic app-user-password \
  --from-literal=password="$APP_PASSWORD" \
  -n "$NAMESPACE" \
  --dry-run=client -o yaml | kubectl apply -f -

kubectl create secret generic backup-user-password \
  --from-literal=password="$BACKUP_PASSWORD" \
  -n "$NAMESPACE" \
  --dry-run=client -o yaml | kubectl apply -f -

kubectl create secret generic monitoring-user-password \
  --from-literal=password="$MONITORING_PASSWORD" \
  -n "$NAMESPACE" \
  --dry-run=client -o yaml | kubectl apply -f -

# Appliquer le CR MongoDB
echo "ğŸ“¦ DÃ©ploiement du Replica Set..."
kubectl apply -f mongodb-replica-set-production.yaml

# Attendre que les pods soient prÃªts
echo "â³ Attente du dÃ©marrage des pods..."
kubectl wait --for=condition=ready pod \
  -l app="${MONGODB_NAME}-svc" \
  -n "$NAMESPACE" \
  --timeout=10m

# VÃ©rifier l'Ã©tat du Replica Set
echo "ğŸ“Š VÃ©rification de l'Ã©tat du Replica Set..."
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --tls \
  --tlsCAFile=/var/lib/tls/ca/ca.crt \
  --tlsCertificateKeyFile=/var/lib/tls/server/*.pem \
  -u admin -p "$ADMIN_PASSWORD" \
  --authenticationDatabase admin \
  --eval "rs.status()"

echo "âœ… DÃ©ploiement terminÃ© avec succÃ¨s!"
echo ""
echo "ğŸ“ Credentials:"
echo "   Admin: admin / $ADMIN_PASSWORD"
echo "   App User: app-user / $APP_PASSWORD"
echo "   Backup: backup-user / $BACKUP_PASSWORD"
echo "   Monitoring: monitoring-user / $MONITORING_PASSWORD"
```

---

## Gestion du Cycle de Vie

### Scaling Horizontal

```yaml
# Augmenter le nombre de membres
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: production-mongodb
  namespace: mongodb
spec:
  members: 5  # Passage de 3 Ã  5 membres
  # ... reste de la configuration inchangÃ©e
```

```bash
# Appliquer le changement
kubectl apply -f mongodb-replica-set-production.yaml

# L'opÃ©rateur va automatiquement:
# 1. CrÃ©er 2 nouveaux pods
# 2. Les ajouter au Replica Set
# 3. Attendre la synchronisation initiale

# Surveiller l'ajout
kubectl get pods -n mongodb -w

# VÃ©rifier l'Ã©tat
kubectl exec production-mongodb-0 -n mongodb -- \
  mongosh --eval "rs.status()"
```

### Scaling Vertical (Ressources)

```yaml
# Augmenter les ressources CPU/MÃ©moire
spec:
  statefulSet:
    spec:
      template:
        spec:
          containers:
            - name: mongod
              resources:
                limits:
                  cpu: "8"      # 4 â†’ 8
                  memory: "32Gi" # 16Gi â†’ 32Gi
                requests:
                  cpu: "4"      # 2 â†’ 4
                  memory: "16Gi" # 8Gi â†’ 16Gi
```

```bash
# Appliquer le changement (rolling restart)
kubectl apply -f mongodb-replica-set-production.yaml

# L'opÃ©rateur effectue un rolling restart:
# 1. Met Ã  jour le pod secondaire #2
# 2. Attend qu'il soit synchronisÃ©
# 3. Met Ã  jour le pod secondaire #1
# 4. Attend la synchronisation
# 5. Provoque une Ã©lection (stepDown)
# 6. Met Ã  jour l'ancien primary
```

### Upgrade de Version MongoDB

```yaml
# Upgrade de 7.0.5 vers 7.0.6
spec:
  version: "7.0.6"  # Changement de version
```

```bash
#!/bin/bash
# scripts/upgrade-mongodb.sh

set -euo pipefail

NAMESPACE="mongodb"
MONGODB_NAME="production-mongodb"
NEW_VERSION="7.0.6"

echo "ğŸ”„ Upgrade de MongoDB vers $NEW_VERSION"

# Backup avant upgrade
echo "ğŸ’¾ CrÃ©ation d'un backup avant upgrade..."
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongodump --out=/tmp/backup-pre-upgrade --gzip

# Mettre Ã  jour le CR
echo "ğŸ“ Mise Ã  jour du CR..."
kubectl patch mongodbcommunity "$MONGODB_NAME" \
  -n "$NAMESPACE" \
  --type=merge \
  -p "{\"spec\":{\"version\":\"$NEW_VERSION\"}}"

# Surveiller le rolling update
echo "â³ Surveillance du rolling update..."

for i in 2 1 0; do
  echo "Attente de la mise Ã  jour du pod ${MONGODB_NAME}-${i}..."

  kubectl wait pod/"${MONGODB_NAME}-${i}" \
    --for=condition=Ready \
    --timeout=10m \
    -n "$NAMESPACE"

  # VÃ©rifier la version
  VERSION=$(kubectl exec "${MONGODB_NAME}-${i}" -n "$NAMESPACE" -- \
    mongosh --quiet --eval "db.version()")

  echo "âœ… ${MONGODB_NAME}-${i} mis Ã  jour vers version: $VERSION"

  # Attendre un peu avant le prochain pod
  [ $i -gt 0 ] && sleep 30
done

# VÃ©rifier l'Ã©tat final
echo "ğŸ“Š VÃ©rification de l'Ã©tat final..."
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --eval "rs.status()"

echo "âœ… Upgrade terminÃ© avec succÃ¨s!"
```

---

## Configuration AvancÃ©e

### Multi-Cluster avec Zone Sharding

```yaml
# mongodb-multi-zone.yaml
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: multi-zone-mongodb
  namespace: mongodb
spec:
  members: 9  # 3 par zone
  type: ReplicaSet
  version: "7.0.5"

  # Configuration par membre
  memberConfig:
    # Zone 1 (Primary preferred)
    - priority: 5
      tags:
        zone: "zone1"
        datacenter: "dc1"
      votes: 1
    - priority: 5
      tags:
        zone: "zone1"
        datacenter: "dc1"
      votes: 1
    - priority: 5
      tags:
        zone: "zone1"
        datacenter: "dc1"
      votes: 1

    # Zone 2
    - priority: 3
      tags:
        zone: "zone2"
        datacenter: "dc1"
      votes: 1
    - priority: 3
      tags:
        zone: "zone2"
        datacenter: "dc1"
      votes: 1
    - priority: 3
      tags:
        zone: "zone2"
        datacenter: "dc1"
      votes: 1

    # Zone 3
    - priority: 1
      tags:
        zone: "zone3"
        datacenter: "dc2"
      votes: 1
    - priority: 1
      tags:
        zone: "zone3"
        datacenter: "dc2"
      votes: 1
    - priority: 1
      tags:
        zone: "zone3"
        datacenter: "dc2"
      votes: 1

  statefulSet:
    spec:
      template:
        spec:
          # Distribuer sur les zones
          topologySpreadConstraints:
            - maxSkew: 1
              topologyKey: topology.kubernetes.io/zone
              whenUnsatisfiable: DoNotSchedule
              labelSelector:
                matchLabels:
                  app: multi-zone-mongodb-svc
```

### Hidden Members pour Analytics

```yaml
# mongodb-with-hidden.yaml
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: analytics-mongodb
  namespace: mongodb
spec:
  members: 4  # 3 normaux + 1 hidden
  type: ReplicaSet
  version: "7.0.5"

  memberConfig:
    # Membres normaux
    - priority: 7
      votes: 1
    - priority: 6
      votes: 1
    - priority: 5
      votes: 1

    # Membre hidden pour analytics
    - priority: 0
      votes: 0
      hidden: true
      slaveDelay: 0
      tags:
        usage: "analytics"

  statefulSet:
    spec:
      template:
        spec:
          containers:
            - name: mongod
              # Plus de ressources pour le membre analytics
              resources:
                limits:
                  cpu: "8"
                  memory: "32Gi"
                requests:
                  cpu: "4"
                  memory: "16Gi"
```

### Arbiter Configuration

```yaml
# mongodb-with-arbiter.yaml
apiVersion: mongodbcommunity.mongodb.com/v1
kind: MongoDBCommunity
metadata:
  name: cost-optimized-mongodb
  namespace: mongodb
spec:
  members: 2  # 2 membres de donnÃ©es
  type: ReplicaSet
  version: "7.0.5"

  # Utiliser un arbiter pour le quorum
  arbiters: 1

  statefulSet:
    spec:
      template:
        spec:
          containers:
            - name: mongod
              resources:
                limits:
                  cpu: "4"
                  memory: "16Gi"
                requests:
                  cpu: "2"
                  memory: "8Gi"
```

---

## Monitoring et ObservabilitÃ©

### ServiceMonitor Prometheus

```yaml
# mongodb-servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: mongodb-metrics
  namespace: mongodb
  labels:
    app: mongodb
    release: prometheus
spec:
  selector:
    matchLabels:
      app: production-mongodb-svc

  endpoints:
    - port: metrics
      path: /metrics
      interval: 30s
      scrapeTimeout: 10s

      relabelings:
        # Ajouter le nom du pod
        - sourceLabels: [__meta_kubernetes_pod_name]
          targetLabel: mongodb_pod

        # Ajouter le membre du replica set
        - sourceLabels: [__meta_kubernetes_pod_label_statefulset_kubernetes_io_pod_name]
          targetLabel: replica_set_member

        # Ajouter la zone
        - sourceLabels: [__meta_kubernetes_pod_node_name]
          targetLabel: node

  namespaceSelector:
    matchNames:
      - mongodb
```

### Grafana Dashboard Automatique

```yaml
# mongodb-dashboard-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongodb-dashboard
  namespace: monitoring
  labels:
    grafana_dashboard: "1"
data:
  mongodb-community.json: |
    {
      "dashboard": {
        "title": "MongoDB Community Operator",
        "uid": "mongodb-community",
        "panels": [
          {
            "title": "Replica Set Members",
            "gridPos": {"x": 0, "y": 0, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "mongodb_mongod_replset_number_of_members",
                "legendFormat": "{{ mongodb_pod }}"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Replica Set State",
            "gridPos": {"x": 12, "y": 0, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "mongodb_mongod_replset_member_state",
                "legendFormat": "{{ replica_set_member }}: {{ state }}"
              }
            ],
            "type": "stat"
          },
          {
            "title": "Operations per Second",
            "gridPos": {"x": 0, "y": 8, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "rate(mongodb_op_counters_total[5m])",
                "legendFormat": "{{ mongodb_pod }}: {{ type }}"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Replication Lag",
            "gridPos": {"x": 12, "y": 8, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "mongodb_mongod_replset_member_replication_lag",
                "legendFormat": "{{ replica_set_member }}"
              }
            ],
            "type": "graph",
            "alert": {
              "conditions": [
                {
                  "evaluator": {
                    "type": "gt",
                    "params": [10]
                  },
                  "operator": {
                    "type": "and"
                  },
                  "query": {
                    "params": ["A", "5m", "now"]
                  },
                  "type": "query"
                }
              ]
            }
          },
          {
            "title": "Connections",
            "gridPos": {"x": 0, "y": 16, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "mongodb_connections{state=\"current\"}",
                "legendFormat": "{{ mongodb_pod }}: Current"
              },
              {
                "expr": "mongodb_connections{state=\"available\"}",
                "legendFormat": "{{ mongodb_pod }}: Available"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Memory Usage",
            "gridPos": {"x": 12, "y": 16, "w": 12, "h": 8},
            "targets": [
              {
                "expr": "mongodb_memory{type=\"resident\"}",
                "legendFormat": "{{ mongodb_pod }}: Resident"
              },
              {
                "expr": "mongodb_memory{type=\"virtual\"}",
                "legendFormat": "{{ mongodb_pod }}: Virtual"
              }
            ],
            "type": "graph"
          }
        ]
      }
    }
```

---

## Backup et Restore

### Configuration des Backups

```yaml
# mongodb-backup-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-scripts
  namespace: mongodb
data:
  backup.sh: |
    #!/bin/bash
    set -euo pipefail

    # Variables
    MONGODB_URI="${MONGODB_URI}"
    BACKUP_DIR="/backup"
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_PATH="${BACKUP_DIR}/${TIMESTAMP}"

    # S3 configuration
    S3_BUCKET="${S3_BUCKET}"
    S3_PREFIX="mongodb-backups"

    echo "ğŸ”„ Starting backup: ${TIMESTAMP}"

    # CrÃ©er le rÃ©pertoire de backup
    mkdir -p "${BACKUP_PATH}"

    # Effectuer le backup
    mongodump \
      --uri="${MONGODB_URI}" \
      --out="${BACKUP_PATH}" \
      --gzip \
      --oplog

    # Calculer la taille
    BACKUP_SIZE=$(du -sh "${BACKUP_PATH}" | cut -f1)
    echo "ğŸ“¦ Backup size: ${BACKUP_SIZE}"

    # CrÃ©er l'archive
    cd "${BACKUP_DIR}"
    tar czf "${TIMESTAMP}.tar.gz" "${TIMESTAMP}"

    # Upload vers S3
    echo "â˜ï¸  Uploading to S3..."
    aws s3 cp \
      "${TIMESTAMP}.tar.gz" \
      "s3://${S3_BUCKET}/${S3_PREFIX}/" \
      --storage-class STANDARD_IA \
      --metadata "backup-date=${TIMESTAMP},backup-size=${BACKUP_SIZE}"

    # VÃ©rifier l'upload
    if aws s3 ls "s3://${S3_BUCKET}/${S3_PREFIX}/${TIMESTAMP}.tar.gz"; then
      echo "âœ… Backup uploaded successfully"
      # Nettoyer le backup local
      rm -rf "${BACKUP_PATH}" "${TIMESTAMP}.tar.gz"
    else
      echo "âŒ Backup upload failed"
      exit 1
    fi

    # Cleanup des vieux backups (> 30 jours)
    echo "ğŸ§¹ Cleaning old backups..."
    aws s3 ls "s3://${S3_BUCKET}/${S3_PREFIX}/" | \
      awk '{print $4}' | \
      while read backup_file; do
        backup_date=$(echo "$backup_file" | grep -oP '\d{8}')
        if [ -n "$backup_date" ]; then
          days_old=$(( ($(date +%s) - $(date -d "$backup_date" +%s)) / 86400 ))
          if [ "$days_old" -gt 30 ]; then
            echo "Deleting old backup: ${backup_file}"
            aws s3 rm "s3://${S3_BUCKET}/${S3_PREFIX}/${backup_file}"
          fi
        fi
      done

    echo "âœ… Backup completed successfully"
---
# CronJob pour backups automatiques
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mongodb-backup
  namespace: mongodb
spec:
  # Tous les jours Ã  2h du matin
  schedule: "0 2 * * *"

  successfulJobsHistoryLimit: 7
  failedJobsHistoryLimit: 3

  jobTemplate:
    spec:
      backoffLimit: 3

      template:
        spec:
          restartPolicy: OnFailure

          serviceAccountName: mongodb-backup

          containers:
            - name: backup
              image: mongo:7.0.5

              command:
                - /bin/bash
                - /scripts/backup.sh

              env:
                - name: MONGODB_URI
                  valueFrom:
                    secretKeyRef:
                      name: backup-connection
                      key: uri

                - name: S3_BUCKET
                  value: "company-mongodb-backups"

                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: aws-credentials
                      key: access-key-id

                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: aws-credentials
                      key: secret-access-key

                - name: AWS_DEFAULT_REGION
                  value: "eu-west-3"

              volumeMounts:
                - name: backup-scripts
                  mountPath: /scripts
                  readOnly: true

                - name: backup-storage
                  mountPath: /backup

              resources:
                requests:
                  memory: "2Gi"
                  cpu: "500m"
                limits:
                  memory: "4Gi"
                  cpu: "1"

          volumes:
            - name: backup-scripts
              configMap:
                name: backup-scripts
                defaultMode: 0755

            - name: backup-storage
              emptyDir:
                sizeLimit: 100Gi
```

### Restore depuis Backup

```yaml
# mongodb-restore-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: mongodb-restore
  namespace: mongodb
spec:
  backoffLimit: 1

  template:
    spec:
      restartPolicy: Never

      containers:
        - name: restore
          image: mongo:7.0.5

          command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              BACKUP_DATE="${RESTORE_BACKUP_DATE}"
              S3_BUCKET="${S3_BUCKET}"
              S3_PREFIX="mongodb-backups"
              MONGODB_URI="${MONGODB_URI}"

              echo "ğŸ”„ Restoring from backup: ${BACKUP_DATE}"

              # TÃ©lÃ©charger le backup depuis S3
              echo "ğŸ“¥ Downloading backup from S3..."
              aws s3 cp \
                "s3://${S3_BUCKET}/${S3_PREFIX}/${BACKUP_DATE}.tar.gz" \
                "/tmp/backup.tar.gz"

              # Extraire l'archive
              echo "ğŸ“¦ Extracting backup..."
              cd /tmp
              tar xzf backup.tar.gz

              # Effectuer la restoration
              echo "ğŸ”„ Restoring data..."
              mongorestore \
                --uri="${MONGODB_URI}" \
                --dir="/tmp/${BACKUP_DATE}" \
                --gzip \
                --drop \
                --oplogReplay \
                --numParallelCollections=4 \
                --numInsertionWorkersPerCollection=2

              # VÃ©rifier la restauration
              echo "âœ… Checking restoration..."
              mongosh "${MONGODB_URI}" --eval "
                db.adminCommand({ listDatabases: 1 }).databases.forEach(function(db) {
                  print('Database: ' + db.name);
                  const dbObj = db.getSiblingDB(db.name);
                  dbObj.getCollectionNames().forEach(function(coll) {
                    const count = dbObj[coll].countDocuments();
                    print('  Collection ' + coll + ': ' + count + ' documents');
                  });
                });
              "

              echo "âœ… Restore completed successfully"

          env:
            - name: RESTORE_BACKUP_DATE
              value: "20240101_020000"

            - name: S3_BUCKET
              value: "company-mongodb-backups"

            - name: MONGODB_URI
              valueFrom:
                secretKeyRef:
                  name: backup-connection
                  key: uri

            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: aws-credentials
                  key: access-key-id

            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: aws-credentials
                  key: secret-access-key

          resources:
            requests:
              memory: "4Gi"
              cpu: "1"
            limits:
              memory: "8Gi"
              cpu: "2"
```

---

## Troubleshooting

### Diagnostic des ProblÃ¨mes Courants

```bash
#!/bin/bash
# scripts/diagnose-mongodb.sh

set -euo pipefail

NAMESPACE="mongodb"
MONGODB_NAME="production-mongodb"

echo "ğŸ” MongoDB Diagnostic Tool"
echo "=========================="
echo ""

# 1. VÃ©rifier l'Ã©tat du CR
echo "ğŸ“‹ Custom Resource Status:"
kubectl get mongodbcommunity "$MONGODB_NAME" -n "$NAMESPACE" -o yaml | \
  yq eval '.status' -

# 2. Ã‰tat des pods
echo ""
echo "ğŸ³ Pods Status:"
kubectl get pods -n "$NAMESPACE" -l app="${MONGODB_NAME}-svc"

# 3. Ã‰vÃ©nements rÃ©cents
echo ""
echo "ğŸ“° Recent Events:"
kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | tail -20

# 4. Logs de l'opÃ©rateur
echo ""
echo "ğŸ“ Operator Logs (last 50 lines):"
kubectl logs -n mongodb-operator \
  deployment/mongodb-kubernetes-operator \
  --tail=50

# 5. Ã‰tat du Replica Set
echo ""
echo "ğŸ“Š Replica Set Status:"
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --quiet --eval "
    try {
      const status = rs.status();
      print(JSON.stringify(status, null, 2));
    } catch (e) {
      print('Error getting replica set status: ' + e);
    }
  "

# 6. Configuration du Replica Set
echo ""
echo "âš™ï¸  Replica Set Configuration:"
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --quiet --eval "
    try {
      const config = rs.conf();
      print(JSON.stringify(config, null, 2));
    } catch (e) {
      print('Error getting replica set config: ' + e);
    }
  "

# 7. VÃ©rifier les PVCs
echo ""
echo "ğŸ’¾ PersistentVolumeClaims:"
kubectl get pvc -n "$NAMESPACE" -l app="${MONGODB_NAME}-svc"

# 8. VÃ©rifier les services
echo ""
echo "ğŸŒ Services:"
kubectl get svc -n "$NAMESPACE" -l app="${MONGODB_NAME}-svc"

# 9. Connexions actives
echo ""
echo "ğŸ”Œ Active Connections:"
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --quiet --eval "
    db.serverStatus().connections
  "

# 10. Slow queries rÃ©centes
echo ""
echo "ğŸŒ Recent Slow Queries:"
kubectl exec "${MONGODB_NAME}-0" -n "$NAMESPACE" -- \
  mongosh --quiet --eval "
    db.system.profile.find().sort({ts: -1}).limit(10).forEach(printjson)
  "

echo ""
echo "âœ… Diagnostic completed"
```

### ProblÃ¨mes FrÃ©quents et Solutions

```yaml
# troubleshooting-guide.yaml
---
issue: "Pods ne dÃ©marrent pas"
symptoms:
  - Pods en CrashLoopBackOff
  - Pods en Pending
  - Erreurs dans les events

causes:
  - Resources insuffisantes
  - PVC non disponible
  - Image pull errors
  - Configuration invalide

solutions:
  - name: "VÃ©rifier les ressources du nÅ“ud"
    command: "kubectl describe node <node-name>"

  - name: "VÃ©rifier les PVCs"
    command: "kubectl get pvc -n mongodb"

  - name: "VÃ©rifier les events"
    command: "kubectl get events -n mongodb --sort-by='.lastTimestamp'"

  - name: "VÃ©rifier les logs"
    command: "kubectl logs -n mongodb <pod-name> --previous"

---
issue: "Replica Set ne s'initialise pas"
symptoms:
  - Status du CR reste en "Pending"
  - rs.status() retourne "not initialized"
  - Pas de Primary Ã©lu

causes:
  - ProblÃ¨mes de rÃ©seau entre pods
  - DNS non rÃ©solu
  - Keyfile manquant ou invalide
  - Certificats TLS invalides

solutions:
  - name: "Tester la rÃ©solution DNS"
    command: |
      kubectl exec production-mongodb-0 -n mongodb -- \
        nslookup production-mongodb-1.production-mongodb-svc.mongodb.svc.cluster.local

  - name: "VÃ©rifier la connectivitÃ©"
    command: |
      kubectl exec production-mongodb-0 -n mongodb -- \
        mongosh production-mongodb-1.production-mongodb-svc:27017 --eval "db.adminCommand('ping')"

  - name: "VÃ©rifier les secrets"
    command: "kubectl get secret -n mongodb"

  - name: "RÃ©initialiser manuellement"
    command: |
      kubectl exec production-mongodb-0 -n mongodb -- \
        mongosh --eval "rs.initiate()"

---
issue: "High Replication Lag"
symptoms:
  - Alerte replication lag
  - Secondaires en retard
  - Performances dÃ©gradÃ©es

causes:
  - Charge Ã©criture Ã©levÃ©e
  - RÃ©seau lent entre membres
  - Ressources insuffisantes sur secondaires
  - Oplog trop petit

solutions:
  - name: "VÃ©rifier le lag actuel"
    command: |
      kubectl exec production-mongodb-0 -n mongodb -- \
        mongosh --eval "rs.printSecondaryReplicationInfo()"

  - name: "VÃ©rifier la taille de l'oplog"
    command: |
      kubectl exec production-mongodb-0 -n mongodb -- \
        mongosh --eval "db.oplog.rs.stats().maxSize"

  - name: "Augmenter les ressources"
    action: "Modifier spec.statefulSet.spec.template.spec.containers[0].resources"

  - name: "Augmenter l'oplog"
    action: "Modifier spec.additionalMongodConfig.replication.oplogSizeMB"
```

---

## Best Practices

### Checklist de Production

```yaml
# production-checklist.yaml
---
configuration:
  - âœ… Version de MongoDB stable (non-RC)
  - âœ… Minimum 3 membres pour le quorum
  - âœ… Anti-affinity configurÃ©e
  - âœ… Topology spread sur zones multiples
  - âœ… Resources limites dÃ©finies
  - âœ… PodDisruptionBudget configurÃ©

security:
  - âœ… Authentication SCRAM activÃ©e
  - âœ… TLS/SSL configurÃ© et forcÃ©
  - âœ… Keyfile pour rÃ©plication
  - âœ… Secrets Kubernetes utilisÃ©s
  - âœ… Least privilege pour ServiceAccount
  - âœ… Network Policies dÃ©finies

storage:
  - âœ… StorageClass avec reclaimPolicy: Retain
  - âœ… Volumes SSD ou Ã©quivalent (IOPS Ã©levÃ©s)
  - âœ… Taille appropriÃ©e (production + 30% growth)
  - âœ… Snapshots/backups configurÃ©s

monitoring:
  - âœ… ServiceMonitor pour Prometheus
  - âœ… Alertes configurÃ©es
  - âœ… Dashboards Grafana
  - âœ… Logs centralisÃ©s

backup:
  - âœ… Backups automatiques quotidiens
  - âœ… Retention policy dÃ©finie (30 jours minimum)
  - âœ… Backup storage off-cluster
  - âœ… Restore testÃ© rÃ©guliÃ¨rement
  - âœ… Documentation de la procÃ©dure

operations:
  - âœ… Documentation Ã  jour
  - âœ… Runbooks pour incidents
  - âœ… Rolling update testÃ©
  - âœ… Disaster recovery plan
  - âœ… Contact d'escalation dÃ©fini
```

### Dimensionnement RecommandÃ©

```yaml
# sizing-recommendations.yaml
---
small:
  description: "Dev/Test, < 100GB, < 1K ops/s"
  members: 3
  resources:
    limits:
      cpu: "2"
      memory: "8Gi"
    requests:
      cpu: "1"
      memory: "4Gi"
  storage: 100Gi
  storageClass: standard

medium:
  description: "Production, 100-500GB, 1K-5K ops/s"
  members: 3
  resources:
    limits:
      cpu: "4"
      memory: "16Gi"
    requests:
      cpu: "2"
      memory: "8Gi"
  storage: 500Gi
  storageClass: fast-ssd
  topology:
    multiZone: true

large:
  description: "Production critique, > 500GB, > 5K ops/s"
  members: 5
  resources:
    limits:
      cpu: "8"
      memory: "32Gi"
    requests:
      cpu: "4"
      memory: "16Gi"
  storage: 2Ti
  storageClass: premium-ssd
  topology:
    multiZone: true
    multiRegion: recommended
```

---

## Conclusion

Le MongoDB Community Kubernetes Operator simplifie considÃ©rablement le dÃ©ploiement et la gestion de MongoDB sur Kubernetes en :

**Automatisant :**
- L'initialisation et configuration des Replica Sets
- Le rolling update des versions
- Le scaling horizontal et vertical
- La gestion des secrets et certificats

**Fournissant :**
- Une API dÃ©clarative via Custom Resources
- Une rÃ©conciliation continue de l'Ã©tat dÃ©sirÃ©
- Une intÃ©gration native avec l'Ã©cosystÃ¨me Kubernetes
- Un support pour les configurations avancÃ©es

**Garantissant :**
- La haute disponibilitÃ© via PodDisruptionBudgets
- La rÃ©silience avec anti-affinity et topology constraints
- La sÃ©curitÃ© avec TLS et authentication
- L'observabilitÃ© via Prometheus et Grafana

Pour les dÃ©ploiements enterprise nÃ©cessitant des fonctionnalitÃ©s avancÃ©es (Ops Manager, backup automatique, monitoring avancÃ©), voir la section suivante sur le MongoDB Enterprise Operator.

---


â­ï¸ [MongoDB Enterprise Kubernetes Operator](/18-devops-deploiement/04.2-enterprise-kubernetes-operator.md)
