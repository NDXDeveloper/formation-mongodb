üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.5 Combinaison d'Options

## Introduction

Apr√®s avoir explor√© les options d'index individuellement (unique, partial, sparse, hidden), il est temps de d√©couvrir comment les **combiner** pour cr√©er des index encore plus puissants et optimis√©s. La combinaison judicieuse d'options permet de cr√©er des solutions sur mesure parfaitement adapt√©es √† vos besoins sp√©cifiques.

La combinaison d'options permet de :
- **Maximiser l'efficacit√©** : Plusieurs optimisations simultan√©es
- **R√©duire drastiquement la taille** : Filtrage multiple
- **Garanties multiples** : Unicit√© + conditions
- **Flexibilit√© maximale** : Solutions personnalis√©es

C'est l'art de choisir et combiner les bonnes options pour obtenir l'index parfait pour votre cas d'usage.

---

## Pourquoi Combiner des Options ?

### Probl√®me : Une Seule Option Ne Suffit Pas Toujours

**Sc√©nario** : Connexions sociales optionnelles

```javascript
// Collection users avec connexions sociales
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  googleId: "google-123456789",  // Optionnel
  facebookId: null,               // Optionnel
  status: "active"                // active, inactive, banned
}
```

**Besoins** :
1. Google ID doit √™tre **unique** (pas de doublons)
2. Google ID est **optionnel** (beaucoup d'utilisateurs n'en ont pas)
3. Beaucoup d'utilisateurs n'ont pas de connexion Google

**Avec une seule option** :

```javascript
// ‚ùå Option 1 : Unique seulement
db.users.createIndex({ googleId: 1 }, { unique: true })

// Probl√®me : Un seul document avec googleId = null autoris√©
db.users.insertOne({ username: "alice" })  // ‚úÖ googleId = null
db.users.insertOne({ username: "bob" })    // ‚ùå ERREUR (2√®me null)
```

```javascript
// ‚ùå Option 2 : Sparse seulement
db.users.createIndex({ googleId: 1 }, { sparse: true })

// Probl√®me : Pas de garantie d'unicit√©
db.users.insertOne({ username: "alice", googleId: "google-123" })  // ‚úÖ
db.users.insertOne({ username: "bob", googleId: "google-123" })    // ‚úÖ Doublon autoris√© !
```

**Avec combinaison d'options** ‚úÖ :

```javascript
// ‚úÖ Unique + Sparse
db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })

// ‚úÖ Plusieurs utilisateurs sans googleId
db.users.insertOne({ username: "alice" })
db.users.insertOne({ username: "bob" })
db.users.insertOne({ username: "charlie" })

// ‚úÖ Google IDs uniques
db.users.insertOne({ username: "dave", googleId: "google-123" })
db.users.insertOne({ username: "eve", googleId: "google-456" })

// ‚ùå Google ID dupliqu√©
db.users.insertOne({ username: "frank", googleId: "google-123" })
// ERREUR : Duplicate key
```

**R√©sultat** : Les deux probl√®mes sont r√©solus simultan√©ment !

---

## Matrice de Compatibilit√© des Options

### Vue d'Ensemble

| Combinaison | Compatible | Utile | Cas d'Usage |
|-------------|-----------|-------|-------------|
| **unique + sparse** | ‚úÖ Oui | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Champs optionnels uniques |
| **unique + partial** | ‚úÖ Oui | ‚≠ê‚≠ê‚≠ê‚≠ê | Unicit√© conditionnelle |
| **sparse + partial** | ‚úÖ Oui | ‚≠ê‚≠ê‚≠ê | Double filtrage |
| **unique + sparse + partial** | ‚úÖ Oui | ‚≠ê‚≠ê‚≠ê‚≠ê | Filtrage complexe |
| **unique + hidden** | ‚úÖ Oui | ‚≠ê‚≠ê | Test d'index unique |
| **partial + hidden** | ‚úÖ Oui | ‚≠ê‚≠ê | Test d'index partiel |
| **TTL + unique** | ‚úÖ Oui | ‚≠ê‚≠ê‚≠ê | Sessions uniques temporaires |
| **TTL + sparse** | ‚ö†Ô∏è Probl√©matique | ‚≠ê | √Ä √©viter g√©n√©ralement |
| **TTL + partial** | ‚ùå Non | - | Incompatible |
| **TTL + hidden** | ‚úÖ Oui | ‚≠ê‚≠ê | Test d'index TTL |

---

## Combinaisons Courantes et Puissantes

### 1. unique + sparse : La Combinaison Star ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Objectif** : Champ optionnel mais unique si pr√©sent

**Syntaxe** :
```javascript
db.collection.createIndex(
  { champ: 1 },
  {
    unique: true,
    sparse: true
  }
)
```

#### Cas d'Usage Pratiques

##### A. Connexions Sociales Optionnelles

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  googleId: "google-123456789",  // Optionnel
  facebookId: null,               // Optionnel
  githubId: null,                 // Optionnel
  twitterId: null                 // Optionnel
}

// Index unique + sparse pour chaque provider
db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ facebookId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ githubId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ twitterId: 1 }, { unique: true, sparse: true })
```

**R√©sultat** :
- ‚úÖ Utilisateurs sans connexion sociale : OK (plusieurs)
- ‚úÖ Chaque provider ID unique
- ‚úÖ Un utilisateur peut avoir 0, 1, 2, 3 ou 4 connexions

##### B. Num√©ro de T√©l√©phone Optionnel

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  phoneNumber: "+33612345678"  // Optionnel
}

// Index unique + sparse
db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })
```

**R√©sultat** :
- ‚úÖ Utilisateurs sans t√©l√©phone : OK (plusieurs)
- ‚úÖ T√©l√©phones uniques si pr√©sents
- ‚úÖ √âconomie d'espace (~70% si 70% sans t√©l√©phone)

##### C. Identifiants Externes Optionnels

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Product A",
  sku: "PROD-001",
  externalId: "EXT-12345",      // ID syst√®me externe (optionnel)
  supplierCode: "SUPP-ABC-001"  // Code fournisseur (optionnel)
}

// Index unique + sparse
db.products.createIndex({ externalId: 1 }, { unique: true, sparse: true })
db.products.createIndex({ supplierCode: 1 }, { unique: true, sparse: true })
```

**Avantages** :
- ‚úÖ Produits sans ID externe : OK
- ‚úÖ IDs externes uniques
- ‚úÖ Int√©gration flexible avec syst√®mes externes

##### D. Email Secondaire Optionnel

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",        // Obligatoire, unique
  secondaryEmail: "alice2@work.com"  // Optionnel, unique
}

// Email principal : unique classique
db.users.createIndex({ email: 1 }, { unique: true })

// Email secondaire : unique + sparse
db.users.createIndex({ secondaryEmail: 1 }, { unique: true, sparse: true })
```

**Statistiques** :
```
Collection : 1M utilisateurs
- 1M ont email principal (100%)
- 200k ont email secondaire (20%)

Index email : 1M entr√©es (~20 MB)
Index secondaryEmail : 200k entr√©es (~4 MB)
‚Üí √âconomie : 80%
```

---

### 2. unique + partial : Unicit√© Conditionnelle ‚≠ê‚≠ê‚≠ê‚≠ê

**Objectif** : Unicit√© seulement pour un sous-ensemble de documents

**Syntaxe** :
```javascript
db.collection.createIndex(
  { champ: 1 },
  {
    unique: true,
    partialFilterExpression: {
      condition: valeur
    }
  }
)
```

#### Cas d'Usage Pratiques

##### A. Email Unique pour Utilisateurs Actifs

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  status: "active"  // active, inactive, banned, deleted
}

// Email unique SEULEMENT pour utilisateurs actifs
db.users.createIndex(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: { status: "active" }
  }
)
```

**Comportement** :
```javascript
// ‚úÖ Utilisateurs actifs : emails uniques
db.users.insertOne({ email: "alice@example.com", status: "active" })
db.users.insertOne({ email: "bob@example.com", status: "active" })

// ‚úÖ Utilisateurs inactifs/supprim√©s : emails peuvent √™tre r√©utilis√©s
db.users.insertOne({ email: "old@example.com", status: "inactive" })
db.users.insertOne({ email: "old@example.com", status: "deleted" })  // ‚úÖ OK

// ‚ùå Deux utilisateurs actifs avec m√™me email
db.users.insertOne({ email: "alice@example.com", status: "active" })
// ERREUR : Duplicate key
```

**Cas d'usage** : Permettre r√©utilisation d'emails apr√®s d√©sactivation/suppression de compte.

##### B. SKU Unique pour Produits Publi√©s

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Product A",
  sku: "PROD-001",
  status: "published"  // draft, published, archived
}

// SKU unique SEULEMENT pour produits publi√©s
db.products.createIndex(
  { sku: 1 },
  {
    unique: true,
    partialFilterExpression: { status: "published" }
  }
)
```

**Comportement** :
- ‚úÖ Brouillons peuvent avoir SKU dupliqu√©s (tests)
- ‚úÖ Produits publi√©s ont SKU uniques (e-commerce)
- ‚úÖ Produits archiv√©s peuvent r√©utiliser SKU

##### C. Num√©ro de Commande Unique par Ann√©e

```javascript
// Collection orders
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001234",
  year: 2024,
  status: "completed"
}

// Num√©ro unique par ann√©e
db.orders.createIndex(
  { orderNumber: 1 },
  {
    unique: true,
    partialFilterExpression: { year: 2024 }
  }
)
```

**Note** : Pour chaque ann√©e, cr√©er un index partiel ou utiliser index compos√© unique.

##### D. Username Unique pour Utilisateurs V√©rifi√©s

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  emailVerified: true
}

// Username unique SEULEMENT pour utilisateurs v√©rifi√©s
db.users.createIndex(
  { username: 1 },
  {
    unique: true,
    partialFilterExpression: { emailVerified: true }
  }
)
```

**Cas d'usage** : √âviter squatting de usernames par comptes non v√©rifi√©s.

---

### 3. sparse + partial : Double Filtrage ‚≠ê‚≠ê‚≠ê

**Objectif** : Combiner deux types de filtres

**Syntaxe** :
```javascript
db.collection.createIndex(
  { champ: 1 },
  {
    sparse: true,
    partialFilterExpression: {
      condition: valeur
    }
  }
)
```

#### Cas d'Usage Pratique

##### Produits en Stock avec SKU

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Product A",
  sku: "PROD-001",          // Optionnel (pas tous les produits)
  stock: 25,
  status: "published"
}

// Index sur SKU : seulement produits en stock ET avec SKU
db.products.createIndex(
  { sku: 1 },
  {
    unique: true,
    sparse: true,  // Exclut documents sans SKU
    partialFilterExpression: {
      $and: [
        { stock: { $gt: 0 } },
        { status: "published" }
      ]
    }
  }
)
```

**R√©sultat** :
- ‚ùå Produits sans SKU : Non index√©s (sparse)
- ‚ùå Produits en rupture de stock : Non index√©s (partial)
- ‚ùå Produits non publi√©s : Non index√©s (partial)
- ‚úÖ Produits publi√©s, en stock, avec SKU : Index√©s

**√âconomies** :
```
1M produits :
- 300k sans SKU (30%)
- 200k en rupture de stock (20%)
- 100k non publi√©s (10%)
= 600k exclus ‚Üí Index de 400k entr√©es (60% d'√©conomie)
```

---

### 4. unique + sparse + partial : Triple Combinaison ‚≠ê‚≠ê‚≠ê‚≠ê

**Objectif** : Unicit√© conditionnelle avec double filtrage

**Syntaxe** :
```javascript
db.collection.createIndex(
  { champ: 1 },
  {
    unique: true,
    sparse: true,
    partialFilterExpression: {
      condition: valeur
    }
  }
)
```

#### Cas d'Usage Pratique

##### SKU Unique pour Produits Publi√©s avec SKU

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Product A",
  sku: "PROD-001",    // Optionnel
  status: "published"
}

// Index unique + sparse + partial
db.products.createIndex(
  { sku: 1 },
  {
    unique: true,
    sparse: true,  // Exclut sans SKU
    partialFilterExpression: { status: "published" }  // Seulement publi√©s
  }
)
```

**Comportement** :
```javascript
// ‚úÖ Produits sans SKU : OK (plusieurs, sparse)
db.products.insertOne({ name: "Product A", status: "published" })
db.products.insertOne({ name: "Product B", status: "published" })

// ‚úÖ Brouillons avec SKU dupliqu√© : OK (pas publi√©s, partial)
db.products.insertOne({ name: "Test 1", sku: "TEST-001", status: "draft" })
db.products.insertOne({ name: "Test 2", sku: "TEST-001", status: "draft" })

// ‚úÖ Produits publi√©s avec SKU unique
db.products.insertOne({ name: "Product C", sku: "PROD-001", status: "published" })
db.products.insertOne({ name: "Product D", sku: "PROD-002", status: "published" })

// ‚ùå Produits publi√©s avec SKU dupliqu√©
db.products.insertOne({ name: "Product E", sku: "PROD-001", status: "published" })
// ERREUR : Duplicate key
```

**Avantages** :
- ‚úÖ Flexibilit√© maximale (3 niveaux de filtrage)
- ‚úÖ Unicit√© seulement o√π n√©cessaire
- ‚úÖ Index minimal (seulement produits publi√©s avec SKU)
- ‚úÖ √âconomies maximales d'espace

---

### 5. TTL + unique : Sessions Uniques Temporaires ‚≠ê‚≠ê‚≠ê

**Objectif** : Documents uniques qui expirent automatiquement

**Syntaxe** :
```javascript
db.collection.createIndex(
  { champDate: 1 },
  {
    expireAfterSeconds: duree,
    unique: true
  }
)
```

#### Cas d'Usage Pratiques

##### A. Tokens de R√©initialisation Uniques

```javascript
// Collection password_reset_tokens
{
  _id: ObjectId("..."),
  token: "reset-abc123xyz789",
  userId: 12345,
  email: "alice@example.com",
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index TTL + unique sur token
db.password_reset_tokens.createIndex(
  { token: 1 },
  {
    unique: true  // Token unique
  }
)

// Index TTL sur createdAt
db.password_reset_tokens.createIndex(
  { createdAt: 1 },
  {
    expireAfterSeconds: 3600  // 1 heure
  }
)
```

**Note** : Deux index s√©par√©s car on ne peut pas combiner TTL et unique sur champs diff√©rents.

##### B. Sessions Utilisateur Uniques

```javascript
// Collection sessions
{
  _id: ObjectId("..."),
  sessionId: "sess-abc123",  // Unique
  userId: 12345,
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index 1 : sessionId unique
db.sessions.createIndex({ sessionId: 1 }, { unique: true })

// Index 2 : TTL sur createdAt
db.sessions.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 1800 }  // 30 minutes
)
```

**Comportement** :
- ‚úÖ Sessions ID uniques (pas de doublons)
- ‚úÖ Expiration automatique apr√®s 30 min
- ‚úÖ Nettoyage automatique

##### C. Codes de V√©rification Uniques Temporaires

```javascript
// Collection verification_codes
{
  _id: ObjectId("..."),
  code: "VERIFY-123456",
  type: "email_verification",
  userId: 12345,
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index unique sur code
db.verification_codes.createIndex({ code: 1 }, { unique: true })

// Index TTL pour expiration
db.verification_codes.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 86400 }  // 24 heures
)
```

---

### 6. Options + hidden : Test Avant Production ‚≠ê‚≠ê

**Objectif** : Tester un index avec options sans impacter la production

**Syntaxe** :
```javascript
// Cr√©er l'index cach√© avec options
db.collection.createIndex(
  { champ: 1 },
  {
    unique: true,
    sparse: true,
    hidden: true  // Cach√© pour test
  }
)
```

#### Workflow de Test

```javascript
// √âtape 1 : Cr√©er index cach√© avec options
db.users.createIndex(
  { phoneNumber: 1 },
  {
    unique: true,
    sparse: true,
    hidden: true
  }
)

// √âtape 2 : L'index est maintenu mais pas utilis√©
// V√©rifier qu'il n'y a pas d'erreurs d'unicit√© sur insertions

// √âtape 3 : Si validation OK ‚Üí Afficher l'index
db.users.unhideIndex({ phoneNumber: 1 })

// √âtape 4 : Si probl√®me ‚Üí Supprimer
db.users.dropIndex({ phoneNumber: 1 })
```

---

## Combinaisons Probl√©matiques ou Incompatibles

### 1. TTL + partial : Incompatible ‚ùå

```javascript
// ‚ùå Cette combinaison ne fonctionne PAS
db.sessions.createIndex(
  { createdAt: 1 },
  {
    expireAfterSeconds: 3600,
    partialFilterExpression: { status: "active" }
  }
)
// ERREUR : Cannot combine expireAfterSeconds with partialFilterExpression
```

**Raison** : Le thread TTL doit pouvoir parcourir tous les documents expir√©s, pas seulement un sous-ensemble.

**Solution** : Utiliser deux index s√©par√©s ou g√©rer l'expiration dans l'application.

### 2. TTL + sparse : Probl√©matique ‚ö†Ô∏è

```javascript
// ‚ö†Ô∏è Techniquement possible mais probl√©matique
db.sessions.createIndex(
  { expiresAt: 1 },
  {
    expireAfterSeconds: 0,
    sparse: true
  }
)

// Probl√®me : Documents sans expiresAt ne sont PAS dans l'index
// ‚Üí Ne seront JAMAIS supprim√©s par TTL !
```

**Risque** : Documents sans le champ ne sont pas supprim√©s.

**Solution** : √âviter cette combinaison ou s'assurer que tous les documents ont le champ.

### 3. Multiple unique sur M√™me Champ : Impossible ‚ùå

```javascript
// ‚ùå Impossible d'avoir deux index uniques sur le m√™me champ
db.users.createIndex({ email: 1 }, { unique: true })
db.users.createIndex({ email: 1 }, { unique: true, sparse: true })
// ERREUR : Index already exists with different options
```

**Solution** : Supprimer l'ancien index avant de cr√©er le nouveau.

### 4. partial avec Op√©rateurs Non Support√©s ‚ùå

```javascript
// ‚ùå Regex non support√© dans partialFilterExpression
db.users.createIndex(
  { username: 1 },
  {
    partialFilterExpression: {
      username: { $regex: /^admin/ }  // Non support√©
    }
  }
)
// ERREUR
```

**Op√©rateurs non support√©s** :
- `$regex`
- `$text`
- `$where`
- Op√©rateurs g√©ospatiaux (`$near`, `$geoWithin`)

---

## Strat√©gie de S√©lection de Combinaison

### Arbre de D√©cision

```
Quel est votre besoin ?

‚îú‚îÄ Champ OPTIONNEL + doit √™tre UNIQUE ?
‚îÇ  ‚îî‚îÄ‚Üí unique: true, sparse: true
‚îÇ     Exemples : phoneNumber, googleId, externalId
‚îÇ
‚îú‚îÄ Unicit√© SEULEMENT pour un SOUS-ENSEMBLE ?
‚îÇ  ‚îî‚îÄ‚Üí unique: true, partialFilterExpression: {...}
‚îÇ     Exemples : Email unique pour utilisateurs actifs
‚îÇ
‚îú‚îÄ Filtrer par CONDITION + champ OPTIONNEL ?
‚îÇ  ‚îî‚îÄ‚Üí sparse: true, partialFilterExpression: {...}
‚îÇ     Exemples : SKU optionnel sur produits en stock
‚îÇ
‚îú‚îÄ Unicit√© CONDITIONNELLE + champ OPTIONNEL ?
‚îÇ  ‚îî‚îÄ‚Üí unique: true, sparse: true, partialFilterExpression: {...}
‚îÇ     Exemples : SKU unique pour produits publi√©s avec SKU
‚îÇ
‚îú‚îÄ Document UNIQUE qui EXPIRE ?
‚îÇ  ‚îî‚îÄ‚Üí unique (index 1) + TTL (index 2)
‚îÇ     Exemples : Sessions, tokens temporaires
‚îÇ
‚îî‚îÄ TESTER avant production ?
   ‚îî‚îÄ‚Üí Ajouter hidden: true
      Tester 24-48h puis unhide ou drop
```

### Checklist de Validation

Avant de cr√©er un index avec combinaison d'options :

**Questions √† poser** :

1. **Le champ doit-il √™tre unique ?**
   - [ ] Oui ‚Üí Ajouter `unique: true`
   - [ ] Non ‚Üí Continuer

2. **Le champ est-il optionnel ?**
   - [ ] Oui, et beaucoup n'ont pas le champ ‚Üí Ajouter `sparse: true`
   - [ ] Non ‚Üí Continuer

3. **Interrogez-vous toujours un sous-ensemble sp√©cifique ?**
   - [ ] Oui, et < 30% du total ‚Üí Ajouter `partialFilterExpression`
   - [ ] Non ‚Üí Continuer

4. **Le document doit-il expirer ?**
   - [ ] Oui ‚Üí Cr√©er index TTL s√©par√©
   - [ ] Non ‚Üí Continuer

5. **Voulez-vous tester d'abord ?**
   - [ ] Oui ‚Üí Ajouter `hidden: true` temporairement
   - [ ] Non ‚Üí Index final

**Valider la compatibilit√©** :

- [ ] TTL et partial ne sont PAS combin√©s ensemble ?
- [ ] Si TTL et sparse, tous les documents ont le champ ?
- [ ] Si partial, op√©rateurs support√©s (pas regex, g√©ospatial) ?
- [ ] Combinaison test√©e en environnement de staging ?

---

## Exemples Complets par Sc√©nario

### Sc√©nario 1 : Plateforme SaaS Multi-Tenant

```javascript
// Collection organizations
{
  _id: ObjectId("..."),
  name: "Company A",
  slug: "company-a",          // URL-friendly name
  vatNumber: "FR12345678901", // Optionnel (seulement entreprises)
  stripeCustomerId: "cus_...",// Optionnel (apr√®s premier paiement)
  status: "active",           // active, suspended, deleted
  tier: "premium"             // free, basic, premium
}

// Index 1 : Slug unique pour organisations actives
db.organizations.createIndex(
  { slug: 1 },
  {
    unique: true,
    partialFilterExpression: {
      status: { $ne: "deleted" }
    }
  }
)

// Index 2 : VAT unique + sparse (entreprises seulement)
db.organizations.createIndex(
  { vatNumber: 1 },
  {
    unique: true,
    sparse: true
  }
)

// Index 3 : Stripe Customer ID unique + sparse
db.organizations.createIndex(
  { stripeCustomerId: 1 },
  {
    unique: true,
    sparse: true
  }
)

// Index 4 : Recherche d'organisations actives premium
db.organizations.createIndex(
  { tier: 1, name: 1 },
  {
    partialFilterExpression: {
      status: "active"
    }
  }
)
```

**R√©sultats** :
- ‚úÖ Slugs uniques (sauf pour organisations supprim√©es)
- ‚úÖ VAT uniques si pr√©sents
- ‚úÖ Stripe IDs uniques si pr√©sents
- ‚úÖ Index optimis√©s par statut

### Sc√©nario 2 : Application de R√©seaux Sociaux

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  phoneNumber: "+33612345678",  // Optionnel
  googleId: "google-123",       // Optionnel
  facebookId: "fb-456",         // Optionnel
  status: "active",             // active, suspended, banned, deleted
  emailVerified: true,
  phoneVerified: false
}

// Index 1 : Email unique pour utilisateurs non supprim√©s
db.users.createIndex(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: {
      status: { $ne: "deleted" }
    }
  }
)

// Index 2 : Username unique pour utilisateurs v√©rifi√©s actifs
db.users.createIndex(
  { username: 1 },
  {
    unique: true,
    partialFilterExpression: {
      $and: [
        { status: "active" },
        { emailVerified: true }
      ]
    }
  }
)

// Index 3 : T√©l√©phone unique + sparse
db.users.createIndex(
  { phoneNumber: 1 },
  {
    unique: true,
    sparse: true
  }
)

// Index 4 : Google ID unique + sparse
db.users.createIndex(
  { googleId: 1 },
  {
    unique: true,
    sparse: true
  }
)

// Index 5 : Facebook ID unique + sparse
db.users.createIndex(
  { facebookId: 1 },
  {
    unique: true,
    sparse: true
  }
)
```

### Sc√©nario 3 : E-commerce avec Gestion de Stock

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Laptop Dell XPS",
  sku: "LAPTOP-DELL-XPS-2024",  // Unique
  externalId: "EXT-12345",       // Optionnel (syst√®me externe)
  category: "Electronics",
  price: 1299.99,
  stock: 25,
  status: "published",           // draft, published, archived
  featured: false
}

// Index 1 : SKU unique pour tous les produits
db.products.createIndex({ sku: 1 }, { unique: true })

// Index 2 : External ID unique + sparse
db.products.createIndex(
  { externalId: 1 },
  {
    unique: true,
    sparse: true
  }
)

// Index 3 : Produits en stock publi√©s
db.products.createIndex(
  { category: 1, featured: -1, price: -1 },
  {
    partialFilterExpression: {
      $and: [
        { status: "published" },
        { stock: { $gt: 0 } }
      ]
    }
  }
)

// Index 4 : Recherche texte seulement sur publi√©s
db.products.createIndex(
  { name: "text", description: "text" },
  {
    partialFilterExpression: {
      status: "published"
    }
  }
)
```

### Sc√©nario 4 : Syst√®me de Tickets Support

```javascript
// Collection support_tickets
{
  _id: ObjectId("..."),
  ticketNumber: "TICKET-2024-001234",  // Unique
  customerId: 12345,
  subject: "Cannot login",
  status: "open",                      // open, in_progress, resolved, closed
  priority: "high",                    // low, medium, high, urgent
  assignedTo: ObjectId("..."),         // Optionnel
  createdAt: ISODate("2024-01-15"),
  resolvedAt: null                     // Optionnel
}

// Index 1 : Num√©ro de ticket unique
db.support_tickets.createIndex({ ticketNumber: 1 }, { unique: true })

// Index 2 : Tickets actifs assign√©s
db.support_tickets.createIndex(
  { assignedTo: 1, priority: -1, createdAt: 1 },
  {
    sparse: true,  // Tickets non assign√©s exclus
    partialFilterExpression: {
      status: { $in: ["open", "in_progress"] }
    }
  }
)

// Index 3 : Tickets r√©solus r√©cemment (pour stats)
db.support_tickets.createIndex(
  { resolvedAt: -1 },
  {
    sparse: true,  // Tickets non r√©solus exclus
    partialFilterExpression: {
      status: "resolved"
    }
  }
)
```

---

## Bonnes Pratiques de Combinaison

### ‚úÖ √Ä Faire

1. **Commencer simple puis ajouter options progressivement**
   ```javascript
   // √âtape 1 : Index basique
   db.users.createIndex({ phoneNumber: 1 })

   // √âtape 2 : Ajouter unique
   db.users.dropIndex({ phoneNumber: 1 })
   db.users.createIndex({ phoneNumber: 1 }, { unique: true })

   // √âtape 3 : Ajouter sparse pour optionnels
   db.users.dropIndex({ phoneNumber: 1 })
   db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })
   ```

2. **Documenter chaque combinaison**
   ```javascript
   // Index unique + sparse sur phoneNumber
   // - unique : Pas de doublons de t√©l√©phone
   // - sparse : Utilisateurs sans t√©l√©phone OK (70%)
   // √âconomie : ~70% d'espace
   // Utilis√© par : API de recherche utilisateurs, v√©rification SMS
   db.users.createIndex(
     { phoneNumber: 1 },
     {
       unique: true,
       sparse: true,
       name: "phoneNumber_unique_sparse"
     }
   )
   ```

3. **Tester en staging avec toutes les combinaisons**
   ```javascript
   // Test complet en staging
   // 1. Cr√©er index avec combinaison
   // 2. V√©rifier que contraintes fonctionnent
   // 3. Mesurer performances
   // 4. Valider avec explain()
   // 5. Si OK ‚Üí D√©ployer en prod
   ```

4. **Valider les √©conomies r√©elles**
   ```javascript
   // Calculer les √©conomies
   let stats = db.users.stats()
   let totalDocs = stats.count

   // Documents dans l'index
   let indexedDocs = db.users.countDocuments({
     phoneNumber: { $exists: true, $ne: null },
     status: "active"
   })

   let saving = ((totalDocs - indexedDocs) / totalDocs * 100).toFixed(2)
   console.log(`√âconomie : ${saving}%`)
   ```

5. **Utiliser hidden pour tester les combinaisons complexes**
   ```javascript
   // Test d'une nouvelle combinaison
   db.users.createIndex(
     { email: 1 },
     {
       unique: true,
       partialFilterExpression: { status: "active" },
       hidden: true  // Tester d'abord
     }
   )

   // Valider pendant 48h
   // Si OK : unhideIndex
   // Si KO : dropIndex
   ```

6. **Nommer explicitement les index avec combinaisons**
   ```javascript
   // Nom descriptif incluant les options
   db.users.createIndex(
     { googleId: 1 },
     {
       unique: true,
       sparse: true,
       name: "googleId_unique_sparse"
     }
   )
   ```

### ‚ùå √Ä √âviter

1. **Ne pas combiner TTL et partial**
   ```javascript
   // ‚ùå Incompatible
   db.sessions.createIndex(
     { createdAt: 1 },
     {
       expireAfterSeconds: 3600,
       partialFilterExpression: { status: "active" }
     }
   )
   ```

2. **Ne pas utiliser sparse + TTL sans pr√©caution**
   ```javascript
   // ‚ö†Ô∏è Probl√©matique
   db.tokens.createIndex(
     { expiresAt: 1 },
     {
       expireAfterSeconds: 0,
       sparse: true
     }
   )
   // Documents sans expiresAt ne seront jamais supprim√©s !
   ```

3. **Ne pas sur-combiner sans raison**
   ```javascript
   // ‚ùå Trop complexe sans b√©n√©fice
   db.users.createIndex(
     { email: 1 },
     {
       unique: true,
       sparse: true,  // Email obligatoire ‚Üí sparse inutile
       partialFilterExpression: { status: "active" }
     }
   )

   // ‚úÖ Plus simple suffit
   db.users.createIndex(
     { email: 1 },
     {
       unique: true,
       partialFilterExpression: { status: "active" }
     }
   )
   ```

4. **Ne pas oublier de nettoyer les doublons avant unique**
   ```javascript
   // ‚ùå Cr√©er unique sans v√©rifier
   db.users.createIndex({ email: 1 }, { unique: true, sparse: true })
   // ERREUR si doublons existants

   // ‚úÖ V√©rifier et nettoyer d'abord
   db.users.aggregate([
     { $match: { email: { $exists: true, $ne: null } } },
     { $group: { _id: "$email", count: { $sum: 1 } } },
     { $match: { count: { $gt: 1 } } }
   ])
   // Nettoyer les doublons
   // PUIS cr√©er l'index
   ```

5. **Ne pas ignorer les requ√™tes qui n'utilisent pas l'index**
   ```javascript
   // Index partial
   db.orders.createIndex(
     { customerId: 1 },
     {
       partialFilterExpression: { status: "active" }
     }
   )

   // ‚ùå Requ√™te sans condition ‚Üí N'utilise PAS l'index
   db.orders.find({ customerId: 12345 })

   // ‚úÖ Inclure la condition
   db.orders.find({
     customerId: 12345,
     status: "active"
   })
   ```

---

## Conclusion

La **combinaison d'options d'index** est un outil puissant qui permet de cr√©er des solutions sur mesure parfaitement adapt√©es √† vos besoins. En comprenant comment les options interagissent, vous pouvez cr√©er des index qui sont √† la fois performants, √©conomes en espace et qui garantissent l'int√©grit√© des donn√©es.

### Points Cl√©s √† Retenir

- ‚úÖ Combiner options = Multiplicateur de puissance
- ‚úÖ unique + sparse = Combinaison star (champs optionnels uniques)
- ‚úÖ unique + partial = Unicit√© conditionnelle
- ‚úÖ sparse + partial = Double filtrage
- ‚úÖ TTL + unique = Sessions/tokens temporaires uniques
- ‚úÖ TTL + partial = Incompatible ‚ùå
- ‚úÖ Tester avec hidden avant production
- ‚úÖ Documenter chaque combinaison
- ‚úÖ Commencer simple, ajouter options progressivement
- ‚úÖ Valider √©conomies et performances r√©elles

### Combinaisons les Plus Utiles

- ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **unique + sparse** : Champs optionnels uniques
- ‚≠ê‚≠ê‚≠ê‚≠ê **unique + partial** : Unicit√© conditionnelle
- ‚≠ê‚≠ê‚≠ê‚≠ê **unique + sparse + partial** : Triple filtrage
- ‚≠ê‚≠ê‚≠ê **TTL + unique** : Documents temporaires uniques
- ‚≠ê‚≠ê‚≠ê **sparse + partial** : Double filtrage
- ‚≠ê‚≠ê **Options + hidden** : Test avant production

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les combinaisons d'options, explorez :
- **[Cr√©ation et suppression d'index](./05-creation-suppression-index.md)** : Gestion compl√®te
- **[Analyse avec explain()](./06-analyse-explain.md)** : Diagnostic approfondi
- **[Strat√©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avanc√©es
- **[Gestion des index en production](./10-gestion-index-production.md)** : Best practices op√©rationnelles

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - Index Properties](https://docs.mongodb.com/manual/core/index-properties/)
- [Unique Indexes](https://docs.mongodb.com/manual/core/index-unique/)
- [Partial Indexes](https://docs.mongodb.com/manual/core/index-partial/)
- [Sparse Indexes](https://docs.mongodb.com/manual/core/index-sparse/)
- [TTL Indexes](https://docs.mongodb.com/manual/core/index-ttl/)

‚è≠Ô∏è [Cr√©ation et suppression d'index](/05-index-et-optimisation/05-creation-suppression-index.md)
