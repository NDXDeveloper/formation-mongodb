ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.3.3 Index HachÃ© (Hashed)

## Introduction

Un **index hachÃ©** (ou **Hashed Index**) est un type d'index spÃ©cialisÃ© dans MongoDB qui utilise une **fonction de hachage** pour calculer une valeur dÃ©rivÃ©e d'un champ, puis indexe cette valeur hachÃ©e plutÃ´t que la valeur originale.

Les index hachÃ©s sont principalement utilisÃ©s pour :
1. **Sharding** : Distribution uniforme des donnÃ©es Ã  travers les shards
2. **Recherches d'Ã©galitÃ©** : Optimisation des requÃªtes avec `{ field: value }`

Contrairement aux index standards qui prÃ©servent l'ordre des valeurs, les index hachÃ©s sacrifient l'ordre pour obtenir une **distribution uniforme** des donnÃ©es.

---

## Comprendre le Hachage

### Qu'est-ce qu'une Fonction de Hachage ?

Une **fonction de hachage** transforme n'importe quelle valeur en une valeur numÃ©rique de taille fixe, appelÃ©e **hash** ou **empreinte**.

**Analogie** : Imaginez un broyeur qui transforme n'importe quel document (petit ou grand) en confettis de taille uniforme. Peu importe la taille du document original, vous obtenez toujours la mÃªme quantitÃ© de confettis.

### Exemple SimplifiÃ©

```
Valeur originale          â†’ Fonction de hachage â†’ Hash (nombre)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"alice@example.com"       â†’     hash()          â†’ 5234876123
"bob@example.com"         â†’     hash()          â†’ 9871234567
"charlie@example.com"     â†’     hash()          â†’ 1234567890
"a"                       â†’     hash()          â†’ 7654321098
"very_long_email@..."     â†’     hash()          â†’ 3456789012
```

### PropriÃ©tÃ©s Importantes du Hachage

1. **DÃ©terministe** : La mÃªme valeur produit toujours le mÃªme hash
   ```
   hash("alice@example.com") = 5234876123
   hash("alice@example.com") = 5234876123  â† Toujours identique
   ```

2. **Distribution uniforme** : Les valeurs hachÃ©es sont rÃ©parties uniformÃ©ment
   ```
   "user1" â†’ hash â†’ 1234
   "user2" â†’ hash â†’ 8765
   "user3" â†’ hash â†’ 4321
   "user4" â†’ hash â†’ 9999
   "user5" â†’ hash â†’ 2468
   ```
   Les hash sont dispersÃ©s sur toute la plage possible

3. **Taille fixe** : Peu importe la taille de l'entrÃ©e, le hash a une taille fixe
   ```
   "a"              â†’ hash â†’ 64 bits
   "trÃ¨s long..."   â†’ hash â†’ 64 bits
   ```

4. **Pas d'ordre** : Les valeurs hachÃ©es perdent l'ordre original
   ```
   Ordre alphabÃ©tique : "alice" < "bob" < "charlie"
   Ordre des hash :     9871   < 1234  < 5234
                        â†‘ bob    â†‘ charlie  â†‘ alice
   ```

---

## Pourquoi les Index HachÃ©s ?

### ProblÃ¨me : Distribution InÃ©gale avec Index Classique

Avec un index classique, les donnÃ©es peuvent Ãªtre distribuÃ©es de maniÃ¨re **inÃ©gale** :

```javascript
// Collection avec usernames ordonnÃ©s
{ username: "alice" }
{ username: "bob" }
{ username: "charlie" }
{ username: "david" }
// ...
{ username: "zoe" }

// Index classique : { username: 1 }
Index : alice â†’ bob â†’ charlie â†’ david â†’ ... â†’ zoe
        [â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€]
         Distribution sÃ©quentielle
```

**ProblÃ¨me en sharding** :
- Si vous partitionnez par plage (range sharding) sur username
- Shard 1 : a-m (beaucoup d'utilisateurs)
- Shard 2 : n-z (peu d'utilisateurs)
- **Distribution dÃ©sÃ©quilibrÃ©e** ! âŒ

### Solution : Index HachÃ©

Avec un index hachÃ©, les valeurs sont **mÃ©langÃ©es** uniformÃ©ment :

```javascript
// MÃªme collection
{ username: "alice" }   â†’ hash â†’ 8234
{ username: "bob" }     â†’ hash â†’ 1567
{ username: "charlie" } â†’ hash â†’ 9876
{ username: "david" }   â†’ hash â†’ 3421
{ username: "zoe" }     â†’ hash â†’ 5678

// Distribution uniforme des hash
1567 â†’ 3421 â†’ 5678 â†’ 8234 â†’ 9876
```

**Avantage en sharding** :
- Les utilisateurs sont rÃ©partis uniformÃ©ment
- Shard 1 : ~50% des hash
- Shard 2 : ~50% des hash
- **Distribution Ã©quilibrÃ©e** ! âœ…

---

## Syntaxe de CrÃ©ation

### Index HachÃ© Simple

```javascript
db.collection.createIndex({ champ: "hashed" })
```

**Exemple** :
```javascript
// Index hachÃ© sur le champ username
db.users.createIndex({ username: "hashed" })
```

### Limitation : Un Seul Champ

âš ï¸ **Important** : Un index hachÃ© ne peut contenir qu'**un seul champ hachÃ©**.

**Permis** âœ… :
```javascript
// Index hachÃ© simple
db.users.createIndex({ username: "hashed" })
```

**Interdit** âŒ :
```javascript
// ERREUR : Plusieurs champs hachÃ©s
db.users.createIndex({ username: "hashed", email: "hashed" })
```

### Index ComposÃ© avec HachÃ©

Vous pouvez combiner un champ hachÃ© avec des champs classiques, mais :
- **Un seul champ hachÃ©** maximum
- Le **champ hachÃ© doit Ãªtre en premier** (prÃ©fixe)

**Permis** âœ… :
```javascript
// Index composÃ© : hachÃ© + classique
db.users.createIndex({
  username: "hashed",  // HachÃ© en premier
  age: 1               // Classique ensuite
})
```

**Interdit** âŒ :
```javascript
// ERREUR : Champ hachÃ© pas en premier
db.users.createIndex({
  age: 1,              // Classique en premier
  username: "hashed"   // HachÃ© aprÃ¨s
})
```

---

## RequÃªtes SupportÃ©es

### RequÃªtes d'Ã‰galitÃ© âœ…

Les index hachÃ©s sont **optimaux** pour les recherches d'Ã©galitÃ© :

```javascript
// âœ… Recherche d'Ã©galitÃ© - Utilise l'index hachÃ© efficacement
db.users.find({ username: "alice" })

// âœ… Recherche d'Ã©galitÃ© avec $eq
db.users.find({ username: { $eq: "alice" } })

// âœ… Recherche avec $in
db.users.find({ username: { $in: ["alice", "bob", "charlie"] } })
```

### RequÃªtes NON SupportÃ©es âŒ

Les index hachÃ©s **ne supportent pas** :

#### 1. RequÃªtes de Plage

```javascript
// âŒ N'utilise PAS l'index hachÃ©
db.products.find({ price: { $gte: 100, $lte: 500 } })

// âŒ N'utilise PAS l'index hachÃ©
db.users.find({ age: { $gt: 18 } })
```

**Raison** : Les valeurs hachÃ©es ne conservent pas l'ordre, donc impossible de faire des comparaisons.

#### 2. Tri

```javascript
// âŒ N'utilise PAS l'index hachÃ© pour le tri
db.users.find().sort({ username: 1 })
```

**Raison** : L'ordre des hash n'a aucun rapport avec l'ordre alphabÃ©tique.

#### 3. Expressions RÃ©guliÃ¨res

```javascript
// âŒ N'utilise PAS l'index hachÃ©
db.users.find({ username: { $regex: /^ali/ } })
```

**Raison** : Impossible de hasher partiellement une valeur.

### Tableau RÃ©capitulatif

| Type de RequÃªte | Index HachÃ© | Index Classique |
|-----------------|-------------|-----------------|
| **Ã‰galitÃ©** (`=`) | âœ… Oui | âœ… Oui |
| **$in** | âœ… Oui | âœ… Oui |
| **Plage** (`<`, `>`, `<=`, `>=`) | âŒ Non | âœ… Oui |
| **Tri** | âŒ Non | âœ… Oui |
| **Regex** | âŒ Non | âš ï¸ LimitÃ© |
| **Distribution sharding** | âœ… Excellente | âš ï¸ Variable |

---

## Index HachÃ© et Sharding

### Le Principal Cas d'Usage

L'**utilisation principale** des index hachÃ©s est le **hashed sharding** (sharding hachÃ©).

### ProblÃ¨me du Range Sharding

Avec le **range sharding** (partitionnement par plage), les donnÃ©es peuvent Ãªtre distribuÃ©es de maniÃ¨re inÃ©gale :

```
Collection : orders
Shard Key : { orderDate: 1 }

Shard 1 : 2020-01-01 â†’ 2022-12-31  (vieilles commandes, peu actives)
Shard 2 : 2023-01-01 â†’ 2024-12-31  (nouvelles commandes, trÃ¨s actives)

ProblÃ¨me : Shard 2 reÃ§oit TOUTES les nouvelles Ã©critures
          â†’ DÃ©sÃ©quilibre de charge
          â†’ Hotspot sur Shard 2
```

### Solution : Hashed Sharding

Avec le **hashed sharding**, les donnÃ©es sont **mÃ©langÃ©es** uniformÃ©ment :

```
Collection : orders
Shard Key : { orderId: "hashed" }

hash(orderId) â†’ RÃ©partition uniforme

Shard 1 : ~50% des commandes (mÃ©lange de dates)
Shard 2 : ~50% des commandes (mÃ©lange de dates)

RÃ©sultat : Ã‰critures rÃ©parties uniformÃ©ment
          â†’ Pas de hotspot
          â†’ Charge Ã©quilibrÃ©e
```

### CrÃ©er un Cluster ShardÃ© avec Index HachÃ©

```javascript
// 1. Activer le sharding sur la base
sh.enableSharding("mydb")

// 2. CrÃ©er un index hachÃ©
db.orders.createIndex({ orderId: "hashed" })

// 3. Sharder la collection avec la clÃ© hachÃ©e
sh.shardCollection("mydb.orders", { orderId: "hashed" })
```

**RÃ©sultat** : Les documents sont automatiquement distribuÃ©s uniformÃ©ment Ã  travers les shards ! âœ…

### Avantages du Hashed Sharding

âœ… **Distribution uniforme**
- Pas de hotspot
- Charge Ã©quilibrÃ©e entre shards

âœ… **Insertions rapides**
- Pas besoin d'analyser les plages
- Calcul de hash simple et rapide

âœ… **Pas de prÃ©-splitting nÃ©cessaire**
- MongoDB gÃ¨re automatiquement

âœ… **PrÃ©visible**
- Performance constante

### InconvÃ©nients du Hashed Sharding

âŒ **Pas de requÃªtes par plage ciblÃ©es**
```javascript
// Cette requÃªte doit interroger TOUS les shards
db.orders.find({ orderId: { $gte: 1000, $lte: 2000 } })
```

âŒ **Pas de tri efficace**
```javascript
// Le tri nÃ©cessite de fusionner les rÃ©sultats de tous les shards
db.orders.find().sort({ orderId: 1 })
```

âŒ **Pas de requÃªtes gÃ©ographiquement localisÃ©es**
- Impossible de co-localiser des donnÃ©es liÃ©es

---

## Cas d'Usage

### 1. Sharding de Collections Ã  Forte Croissance

**Contexte** : Collection avec insertions constantes et croissantes

```javascript
// Collection de logs avec ID incrÃ©mental
{
  _id: ObjectId("..."),
  logId: 1234567890,
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  message: "User logged in",
  level: "info"
}

// Index hachÃ© pour distribution uniforme
db.logs.createIndex({ logId: "hashed" })

// Sharding hachÃ©
sh.shardCollection("mydb.logs", { logId: "hashed" })
```

**Avantage** : Toutes les nouvelles insertions sont rÃ©parties uniformÃ©ment.

### 2. Utilisateurs avec ID SÃ©quentiel

**Contexte** : SystÃ¨me avec IDs auto-incrÃ©mentaux

```javascript
// Collection users
{
  _id: ObjectId("..."),
  userId: 123456,  // ID auto-incrÃ©mental
  username: "alice",
  email: "alice@example.com"
}

// Index hachÃ© sur userId
db.users.createIndex({ userId: "hashed" })

// Sharding hachÃ©
sh.shardCollection("mydb.users", { userId: "hashed" })
```

**Avantage** : Ã‰vite le hotspot sur le shard contenant les IDs les plus rÃ©cents.

### 3. Sessions avec Recherche par ID

**Contexte** : Sessions utilisateur avec recherches frÃ©quentes par sessionId

```javascript
// Collection sessions
{
  _id: ObjectId("..."),
  sessionId: "abc123xyz789",
  userId: 5678,
  createdAt: ISODate("2024-01-15T10:30:00Z"),
  data: { /* session data */ }
}

// Index hachÃ© sur sessionId
db.sessions.createIndex({ sessionId: "hashed" })

// RequÃªtes d'Ã©galitÃ© optimisÃ©es
db.sessions.find({ sessionId: "abc123xyz789" })
```

**Avantage** : Recherches rapides et distribution uniforme si sharding.

### 4. Documents avec ClÃ©s Naturelles

**Contexte** : Utilisation d'un champ existant comme clÃ© de sharding

```javascript
// Collection products avec SKU
{
  _id: ObjectId("..."),
  sku: "LAPTOP-DELL-XPS15-2024",
  name: "Dell XPS 15",
  price: 1299.99
}

// Index hachÃ© sur SKU
db.products.createIndex({ sku: "hashed" })

// Sharding hachÃ©
sh.shardCollection("mydb.products", { sku: "hashed" })
```

**Avantage** : Pas besoin de champ supplÃ©mentaire, distribution uniforme.

### 5. Cache DistribuÃ©

**Contexte** : SystÃ¨me de cache avec clÃ©s variÃ©es

```javascript
// Collection cache
{
  _id: ObjectId("..."),
  cacheKey: "user:1234:profile",
  value: { /* cached data */ },
  expiresAt: ISODate("2024-01-15T12:00:00Z")
}

// Index hachÃ© sur cacheKey
db.cache.createIndex({ cacheKey: "hashed" })

// TTL index pour expiration
db.cache.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 })

// RequÃªte de cache
db.cache.findOne({ cacheKey: "user:1234:profile" })
```

**Avantage** : AccÃ¨s rapide et distribution uniforme des entrÃ©es de cache.

---

## Quand Utiliser un Index HachÃ©

### âœ… Utilisez un Index HachÃ© Quand

1. **Sharding avec distribution uniforme**
   - Vous voulez Ã©viter les hotspots
   - Les donnÃ©es croissent rapidement
   - L'ordre des donnÃ©es n'est pas important

2. **Recherches d'Ã©galitÃ© uniquement**
   - Vos requÃªtes sont principalement `{ field: value }`
   - Pas besoin de recherches par plage
   - Pas besoin de tri sur ce champ

3. **IDs sÃ©quentiels ou temporels**
   - IDs auto-incrÃ©mentaux
   - Timestamps
   - ObjectIds (composant temporel)

4. **Forte charge d'Ã©criture**
   - Insertions massives
   - Besoin de rÃ©partir la charge

### âŒ N'utilisez PAS un Index HachÃ© Quand

1. **RequÃªtes par plage frÃ©quentes**
   ```javascript
   // Si vous faites souvent ce type de requÃªte
   db.products.find({ price: { $gte: 100, $lte: 500 } })
   ```

2. **Besoin de tri sur le champ**
   ```javascript
   // Si vous devez trier sur ce champ
   db.users.find().sort({ username: 1 })
   ```

3. **RequÃªtes avec regex**
   ```javascript
   // Si vous cherchez par pattern
   db.users.find({ username: { $regex: /^ali/ } })
   ```

4. **DonnÃ©es dÃ©jÃ  bien distribuÃ©es**
   - Si vos donnÃ©es naturelles sont dÃ©jÃ  uniformÃ©ment rÃ©parties
   - Un index classique suffit

5. **Petite collection**
   - Collections < 100 000 documents
   - Le sharding n'est probablement pas nÃ©cessaire

---

## Comparaison : Index HachÃ© vs Index Classique

### Exemple de Comparaison

**Collection** : 1 million d'utilisateurs

#### ScÃ©nario 1 : Index Classique

```javascript
// Index classique
db.users.createIndex({ userId: 1 })

// RequÃªtes
db.users.find({ userId: 123456 })                    // âœ… Rapide
db.users.find({ userId: { $gte: 100000 } })          // âœ… Rapide
db.users.find().sort({ userId: 1 })                  // âœ… Rapide

// Sharding range
sh.shardCollection("mydb.users", { userId: 1 })
// âš ï¸ Risque de hotspot sur nouveaux users
```

#### ScÃ©nario 2 : Index HachÃ©

```javascript
// Index hachÃ©
db.users.createIndex({ userId: "hashed" })

// RequÃªtes
db.users.find({ userId: 123456 })                    // âœ… Rapide
db.users.find({ userId: { $gte: 100000 } })          // âŒ Lent (scan complet)
db.users.find().sort({ userId: 1 })                  // âŒ Lent (tri en mÃ©moire)

// Sharding hashed
sh.shardCollection("mydb.users", { userId: "hashed" })
// âœ… Distribution uniforme garantie
```

### Tableau DÃ©cisionnel

| CritÃ¨re | Index Classique | Index HachÃ© |
|---------|----------------|-------------|
| **Ã‰galitÃ©** | âœ… Excellent | âœ… Excellent |
| **Plage** | âœ… Excellent | âŒ N/A |
| **Tri** | âœ… Excellent | âŒ N/A |
| **Distribution sharding** | âš ï¸ Variable | âœ… Parfaite |
| **RequÃªtes ciblÃ©es (sharding)** | âœ… Oui | âŒ Broadcast |
| **Taille index** | ğŸ“Š Normale | ğŸ“Š Normale |
| **Performance insertion** | âœ… Rapide | âœ… TrÃ¨s rapide |

---

## Performance et ConsidÃ©rations

### Avantages

âœ… **Distribution uniforme**
- Garantie mathÃ©matique de rÃ©partition Ã©gale
- Pas de dÃ©sÃ©quilibre entre shards

âœ… **Insertion rapide**
- Calcul de hash simple et rapide
- O(1) pour dÃ©terminer le shard cible

âœ… **PrÃ©visibilitÃ©**
- Performance constante
- Pas de surprises avec la croissance des donnÃ©es

âœ… **SimplicitÃ©**
- Pas besoin de prÃ©-splitting manuel
- MongoDB gÃ¨re automatiquement

### Limitations

âŒ **Pas de locality**
```javascript
// Documents liÃ©s dispersÃ©s sur diffÃ©rents shards
{ userId: 1001, orderId: 1 }  â†’ Shard A
{ userId: 1001, orderId: 2 }  â†’ Shard C
{ userId: 1001, orderId: 3 }  â†’ Shard B
```

âŒ **Broadcast queries**
```javascript
// Recherche par plage = interroger TOUS les shards
db.orders.find({ userId: { $gte: 1000, $lte: 2000 } })
```

âŒ **ImpossibilitÃ© de co-localiser**
- Impossible de garantir que des donnÃ©es liÃ©es soient sur le mÃªme shard

âŒ **Overhead de calcul**
- Calcul de hash pour chaque opÃ©ration
- GÃ©nÃ©ralement nÃ©gligeable mais existe

### Taille de l'Index

La taille d'un index hachÃ© est similaire Ã  celle d'un index classique :

```
Taille â‰ˆ (nombre de documents) Ã— (taille moyenne du champ + pointeur)
```

**Exemple** :
```
1 million de documents
Champ : userId (integer, 8 bytes)
Index hachÃ© â‰ˆ 1M Ã— (8 bytes + 8 bytes) = ~16 MB
```

---

## Analyse et VÃ©rification

### VÃ©rifier l'Index HachÃ©

```javascript
db.users.getIndexes()
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "userId": "hashed" },
    "name": "userId_hashed"
  }
]
```

### Analyser une RequÃªte

```javascript
db.users.find({ userId: 123456 }).explain("executionStats")
```

**Points clÃ©s** :
```javascript
{
  "winningPlan": {
    "stage": "FETCH",
    "inputStage": {
      "stage": "IXSCAN",
      "indexName": "userId_hashed",  // âœ… Utilise l'index hachÃ©
      "keysExamined": 1,
      "docsExamined": 1
    }
  },
  "executionStats": {
    "totalDocsExamined": 1,
    "executionTimeMillis": 1
  }
}
```

### VÃ©rifier la Distribution (Sharding)

```javascript
// Statistiques du sharding
db.users.getShardDistribution()
```

**RÃ©sultat idÃ©al** :
```
Shard A : 500,000 documents (50%)
Shard B : 500,000 documents (50%)
```

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Utiliser pour le sharding avec forte croissance**
   ```javascript
   // Collections avec insertions constantes
   sh.shardCollection("mydb.events", { eventId: "hashed" })
   ```

2. **Utiliser pour IDs sÃ©quentiels**
   ```javascript
   // Ã‰viter hotspots avec IDs incrÃ©mentaux
   db.orders.createIndex({ orderId: "hashed" })
   ```

3. **Documenter le choix**
   ```javascript
   // Commentaire dans le code
   // Index hachÃ© sur userId pour distribution uniforme en sharding
   // RequÃªtes principales : Ã©galitÃ© sur userId
   db.users.createIndex({ userId: "hashed" })
   ```

4. **Combiner avec index classique si nÃ©cessaire**
   ```javascript
   // Index hachÃ© pour sharding
   db.orders.createIndex({ orderId: "hashed" })

   // Index classique pour requÃªtes par plage
   db.orders.createIndex({ orderDate: -1 })
   ```

5. **Tester la distribution**
   ```javascript
   // VÃ©rifier rÃ©guliÃ¨rement l'Ã©quilibre
   db.collection.getShardDistribution()
   ```

### âŒ Ã€ Ã‰viter

1. **Ne pas utiliser pour requÃªtes par plage**
   ```javascript
   // âŒ Mauvais choix si vous faites souvent :
   db.products.find({ price: { $gte: 100, $lte: 500 } })
   ```

2. **Ne pas utiliser si tri nÃ©cessaire**
   ```javascript
   // âŒ Mauvais choix si vous triez souvent :
   db.users.find().sort({ username: 1 })
   ```

3. **Ne pas utiliser pour petites collections**
   ```javascript
   // âŒ Inutile pour < 100K documents
   // Un index classique suffit
   ```

4. **Ne pas oublier les autres index**
   ```javascript
   // âœ… Index hachÃ© pour sharding
   db.orders.createIndex({ orderId: "hashed" })

   // âœ… MAIS aussi index pour autres requÃªtes
   db.orders.createIndex({ customerId: 1, orderDate: -1 })
   db.orders.createIndex({ status: 1 })
   ```

5. **Ne pas utiliser sur champs avec faible cardinalitÃ©**
   ```javascript
   // âŒ Mauvais choix sur boolÃ©en
   db.users.createIndex({ isActive: "hashed" })
   // Seulement 2 valeurs possibles !
   ```

---

## Migration et Gestion

### Ajouter un Index HachÃ© Ã  une Collection Existante

```javascript
// 1. CrÃ©er l'index hachÃ©
db.users.createIndex({ userId: "hashed" })

// 2. VÃ©rifier l'index
db.users.getIndexes()

// 3. Tester les requÃªtes
db.users.find({ userId: 123456 }).explain("executionStats")
```

### Convertir de Range Ã  Hashed Sharding

âš ï¸ **Attention** : Cette opÃ©ration est complexe et nÃ©cessite une planification !

**Ã‰tapes gÃ©nÃ©rales** :
1. CrÃ©er une nouvelle collection
2. Configurer le hashed sharding sur la nouvelle collection
3. Migrer les donnÃ©es (avec downtime ou double-write)
4. Basculer l'application
5. Supprimer l'ancienne collection

**Recommandation** : Consultez la documentation officielle et testez en environnement de staging.

### Supprimer un Index HachÃ©

```javascript
// Par nom
db.users.dropIndex("userId_hashed")

// Par spÃ©cification
db.users.dropIndex({ userId: "hashed" })
```

âš ï¸ **Attention** : Si l'index est utilisÃ© comme shard key, vous ne pouvez PAS le supprimer !

---

## Alternatives

### Quand un Index HachÃ© N'est Pas AppropriÃ©

Si vous avez besoin de :
- âœ… RequÃªtes par plage
- âœ… Tri sur le champ
- âœ… Co-localisation de donnÃ©es liÃ©es

**ConsidÃ©rez** :

1. **Index classique avec zone sharding**
   ```javascript
   // Sharding par zones gÃ©ographiques
   sh.addShardTag("shard0", "EU")
   sh.addShardTag("shard1", "US")
   sh.addTagRange("mydb.users", { country: "FR" }, { country: "GB" }, "EU")
   ```

2. **Index composÃ© pour sharding**
   ```javascript
   // Sharding sur clÃ© composÃ©e
   sh.shardCollection("mydb.orders", { customerId: 1, orderDate: 1 })
   ```

3. **PrÃ©-splitting manuel**
   ```javascript
   // Diviser manuellement les plages avant sharding
   for (let i = 0; i < 100; i++) {
     sh.splitAt("mydb.users", { userId: i * 10000 })
   }
   ```

---

## Cas Pratique Complet

### ScÃ©nario : Plateforme IoT

**Contexte** : Millions de capteurs envoyant des donnÃ©es constamment

```javascript
// Collection sensor_data
{
  _id: ObjectId("..."),
  sensorId: "SENSOR-123456",
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  temperature: 22.5,
  humidity: 65.2,
  location: { type: "Point", coordinates: [2.3522, 48.8566] }
}
```

**Besoins** :
- âœ… Insertions massives (1000+ par seconde)
- âœ… Recherches par sensorId (Ã©galitÃ©)
- âœ… Recherches par timestamp (plage)
- âœ… Distribution uniforme pour Ã©viter hotspots

**Solution : Combinaison d'index**

```javascript
// 1. Index hachÃ© pour sharding (distribution uniforme)
db.sensor_data.createIndex({ sensorId: "hashed" })

// 2. Sharding hachÃ©
sh.enableSharding("iot_db")
sh.shardCollection("iot_db.sensor_data", { sensorId: "hashed" })

// 3. Index classique pour requÃªtes temporelles
db.sensor_data.createIndex({ timestamp: -1 })

// 4. Index composÃ© pour requÃªtes frÃ©quentes
db.sensor_data.createIndex({ sensorId: 1, timestamp: -1 })

// 5. Index TTL pour suppression automatique des vieilles donnÃ©es
db.sensor_data.createIndex(
  { timestamp: 1 },
  { expireAfterSeconds: 2592000 }  // 30 jours
)
```

**RequÃªtes optimisÃ©es** :

```javascript
// âœ… Recherche par capteur (utilise index hachÃ© ou composÃ©)
db.sensor_data.find({ sensorId: "SENSOR-123456" })

// âœ… DonnÃ©es rÃ©centes d'un capteur (utilise index composÃ©)
db.sensor_data.find({
  sensorId: "SENSOR-123456",
  timestamp: { $gte: ISODate("2024-01-14T00:00:00Z") }
}).sort({ timestamp: -1 })

// âœ… Toutes les donnÃ©es rÃ©centes (utilise index timestamp)
db.sensor_data.find({
  timestamp: { $gte: ISODate("2024-01-14T00:00:00Z") }
}).sort({ timestamp: -1 })
```

**RÃ©sultat** :
- âœ… Insertions distribuÃ©es uniformÃ©ment sur tous les shards
- âœ… Pas de hotspot
- âœ… Toutes les requÃªtes sont optimisÃ©es
- âœ… Gestion automatique de la rÃ©tention de donnÃ©es

---

## Conclusion

Les **index hachÃ©s** sont un outil spÃ©cialisÃ© mais puissant dans MongoDB, principalement utilisÃ©s pour garantir une **distribution uniforme** des donnÃ©es dans un environnement shardÃ©. Bien qu'ils sacrifient certaines fonctionnalitÃ©s (requÃªtes par plage, tri), ils apportent des avantages significatifs en termes de rÃ©partition de charge et de prÃ©vention des hotspots.

### Points ClÃ©s Ã  Retenir

- âœ… Index hachÃ© = Distribution uniforme garantie
- âœ… Syntaxe : `db.collection.createIndex({ field: "hashed" })`
- âœ… **Principal usage** : Hashed sharding
- âœ… Optimal pour recherches d'Ã©galitÃ© uniquement
- âœ… Ne supporte PAS : plage, tri, regex
- âœ… Un seul champ hachÃ© par index
- âœ… Parfait pour IDs sÃ©quentiels ou donnÃ©es temporelles
- âœ… Ã‰vite les hotspots en sharding
- âœ… Combiner avec index classiques pour autres requÃªtes

### Quand Utiliser

âœ… **Utilisez pour** :
- Sharding avec distribution uniforme
- Collections Ã  forte croissance
- IDs sÃ©quentiels ou temporels
- Recherches d'Ã©galitÃ© uniquement
- PrÃ©vention des hotspots

âŒ **N'utilisez PAS pour** :
- RequÃªtes par plage frÃ©quentes
- Besoin de tri sur le champ
- Recherches par pattern/regex
- Petites collections (<100K docs)
- DonnÃ©es dÃ©jÃ  bien distribuÃ©es

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez les index hachÃ©s, explorez :
- **[Index wildcard](./03.4-index-wildcard.md)** : Index sur champs dynamiques
- **[Index TTL](./03.5-index-ttl.md)** : Expiration automatique
- **[Sharding](/10-sharding/README.md)** : Architecture distribuÃ©e complÃ¨te
- **[StratÃ©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avancÃ©es

---

**ğŸ“š Ressources ComplÃ©mentaires**
- [Documentation officielle - Hashed Indexes](https://docs.mongodb.com/manual/core/index-hashed/)
- [Hashed Sharding](https://docs.mongodb.com/manual/core/hashed-sharding/)
- [Shard Keys](https://docs.mongodb.com/manual/core/sharding-shard-key/)
- [Choose a Shard Key](https://docs.mongodb.com/manual/core/sharding-choose-a-shard-key/)

â­ï¸ [Index Wildcard](/05-index-et-optimisation/03.4-index-wildcard.md)
