üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.3 Index Multicl√© (Multikey)

## Introduction

Un **index multicl√©** (ou **Multikey Index**) est un type d'index sp√©cial dans MongoDB con√ßu pour indexer efficacement des **champs contenant des tableaux**. Lorsqu'un champ index√© contient un tableau, MongoDB cr√©e automatiquement une entr√©e d'index pour **chaque √©l√©ment** du tableau, permettant des recherches rapides sur les valeurs individuelles contenues dans les tableaux.

Les index multicl√© sont essentiels dans MongoDB car les tableaux sont une structure de donn√©es tr√®s courante et puissante dans les documents NoSQL.

---

## Le Probl√®me : Indexer des Tableaux

### Documents avec Tableaux

Dans MongoDB, il est tr√®s courant d'avoir des champs contenant des tableaux :

```javascript
// Document utilisateur avec un tableau de tags
{
  _id: 1,
  name: "Alice",
  email: "alice@example.com",
  tags: ["developer", "javascript", "mongodb", "nodejs"]
}

// Document produit avec un tableau de cat√©gories
{
  _id: 101,
  name: "Laptop Dell XPS",
  price: 1299.99,
  categories: ["Electronics", "Computers", "Laptops"]
}

// Document article de blog avec un tableau d'auteurs
{
  _id: 501,
  title: "Introduction √† MongoDB",
  authors: ["Jean Dupont", "Marie Martin"],
  publishedAt: ISODate("2024-01-15")
}
```

### Requ√™tes sur des Tableaux

Nous voulons souvent rechercher des documents bas√©s sur des valeurs **contenues dans** ces tableaux :

```javascript
// Trouver tous les utilisateurs ayant le tag "mongodb"
db.users.find({ tags: "mongodb" })

// Trouver tous les produits dans la cat√©gorie "Laptops"
db.products.find({ categories: "Laptops" })

// Trouver tous les articles √©crits par "Jean Dupont"
db.articles.find({ authors: "Jean Dupont" })
```

### Sans Index : Scan Complet

Sans index, MongoDB doit :
1. Examiner **chaque document** de la collection
2. Parcourir **chaque √©l√©ment** de chaque tableau
3. V√©rifier si la valeur recherch√©e est pr√©sente

**R√©sultat** : Tr√®s lent sur de grandes collections ! ‚ùå

---

## La Solution : Index Multicl√©

### Cr√©ation Automatique

La magie des index multicl√©, c'est que vous n'avez **rien de sp√©cial √† faire** ! MongoDB d√©tecte automatiquement qu'un champ contient un tableau et cr√©e un index multicl√© :

```javascript
// Cr√©ation d'un index sur un champ tableau
db.users.createIndex({ tags: 1 })

// MongoDB d√©tecte automatiquement que tags est un tableau
// et cr√©e un index multicl√©
```

### Comment √ßa Fonctionne

Pour chaque document, MongoDB cr√©e une entr√©e d'index pour **chaque √©l√©ment** du tableau :

**Document** :
```javascript
{
  _id: 1,
  name: "Alice",
  tags: ["developer", "javascript", "mongodb"]
}
```

**Index multicl√© cr√©√©** :
```
Index sur "tags"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Valeur        ‚Üí Document    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "developer"   ‚Üí Doc #1      ‚îÇ
‚îÇ "javascript"  ‚Üí Doc #1      ‚îÇ
‚îÇ "mongodb"     ‚Üí Doc #1      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Autre document** :
```javascript
{
  _id: 2,
  name: "Bob",
  tags: ["designer", "photoshop", "javascript"]
}
```

**Index mis √† jour** :
```
Index sur "tags"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Valeur        ‚Üí Document    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "designer"    ‚Üí Doc #2      ‚îÇ
‚îÇ "developer"   ‚Üí Doc #1      ‚îÇ
‚îÇ "javascript"  ‚Üí Doc #1, #2  ‚îÇ ‚Üê Plusieurs documents
‚îÇ "mongodb"     ‚Üí Doc #1      ‚îÇ
‚îÇ "photoshop"   ‚Üí Doc #2      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### R√©sultat

Les requ√™tes sur le tableau deviennent ultra-rapides car MongoDB peut directement localiser tous les documents contenant une valeur sp√©cifique ! ‚úÖ

---

## Syntaxe de Cr√©ation

### Index Simple sur Tableau

```javascript
db.collection.createIndex({ champTableau: 1 })
```

La syntaxe est **identique** √† celle d'un index simple. MongoDB d√©tecte automatiquement que le champ contient des tableaux.

### Exemples Pratiques

#### Exemple 1 : Tags d'Utilisateurs

```javascript
// Collection users
{
  _id: 1,
  name: "Alice",
  tags: ["developer", "javascript", "mongodb"]
}

// Cr√©er un index multicl√© sur tags
db.users.createIndex({ tags: 1 })
```

**Requ√™tes optimis√©es** :
```javascript
// ‚úÖ Recherche rapide gr√¢ce √† l'index multicl√©
db.users.find({ tags: "mongodb" })

// ‚úÖ Recherche avec plusieurs valeurs
db.users.find({ tags: { $in: ["mongodb", "postgresql"] } })

// ‚úÖ Recherche avec $all (contient toutes les valeurs)
db.users.find({ tags: { $all: ["mongodb", "javascript"] } })
```

#### Exemple 2 : Cat√©gories de Produits

```javascript
// Collection products
{
  _id: 101,
  name: "Laptop Dell XPS",
  categories: ["Electronics", "Computers", "Laptops"]
}

// Cr√©er un index multicl√© sur categories
db.products.createIndex({ categories: 1 })

// Requ√™te optimis√©e
db.products.find({ categories: "Laptops" })
```

#### Exemple 3 : Tableau de Sous-Documents

```javascript
// Collection orders avec tableau d'items
{
  _id: 1001,
  orderNumber: "ORD-2024-001",
  items: [
    { productId: 101, quantity: 2, price: 50 },
    { productId: 102, quantity: 1, price: 30 },
    { productId: 103, quantity: 3, price: 20 }
  ]
}

// Index sur un champ dans le tableau de sous-documents
db.orders.createIndex({ "items.productId": 1 })

// Requ√™te optimis√©e
db.orders.find({ "items.productId": 102 })
```

---

## V√©rification d'un Index Multicl√©

### Identifier un Index Multicl√©

Utilisez `getIndexes()` pour lister les index. Un index multicl√© est identifi√© par la propri√©t√© `"multikey": true` :

```javascript
db.users.getIndexes()
```

**R√©sultat** :
```json
[
  {
    "v": 2,
    "key": { "_id": 1 },
    "name": "_id_"
  },
  {
    "v": 2,
    "key": { "tags": 1 },
    "name": "tags_1",
    "multikey": true  // ‚úÖ C'est un index multicl√©
  }
]
```

### Note Importante

La propri√©t√© `"multikey": true` n'appara√Æt que si au moins un document de la collection contient un tableau pour ce champ. Si tous les documents ont une valeur scalaire (non-tableau), l'index reste un index simple jusqu'√† ce qu'un document avec un tableau soit ins√©r√©.

---

## Index Multicl√© et Tableaux de Scalaires

### Tableaux de Valeurs Simples

Les index multicl√© fonctionnent parfaitement avec des tableaux de valeurs simples (strings, numbers, dates, etc.) :

```javascript
// Tableau de strings
{
  tags: ["mongodb", "database", "nosql"]
}

// Tableau de numbers
{
  scores: [85, 92, 78, 95]
}

// Tableau de dates
{
  importantDates: [
    ISODate("2024-01-15"),
    ISODate("2024-02-20"),
    ISODate("2024-03-10")
  ]
}
```

**Index multicl√©** :
```javascript
db.collection.createIndex({ tags: 1 })
db.collection.createIndex({ scores: 1 })
db.collection.createIndex({ importantDates: 1 })
```

### Requ√™tes Optimis√©es

```javascript
// Recherche d'√©galit√©
db.students.find({ scores: 92 })

// Recherche par plage
db.students.find({ scores: { $gte: 90 } })

// Recherche avec op√©rateurs de tableau
db.students.find({ scores: { $all: [92, 95] } })
db.students.find({ scores: { $in: [85, 90, 95] } })
```

---

## Index Multicl√© sur Tableaux de Sous-Documents

### Structure de Donn√©es

Un cas d'usage tr√®s courant : tableaux contenant des objets (sous-documents) :

```javascript
{
  _id: 1,
  name: "Alice",
  addresses: [
    {
      type: "home",
      city: "Paris",
      zipCode: "75001",
      country: "France"
    },
    {
      type: "work",
      city: "Lyon",
      zipCode: "69001",
      country: "France"
    }
  ]
}
```

### Indexer un Champ Sp√©cifique

Utilisez la notation point√©e pour indexer un champ sp√©cifique dans les sous-documents :

```javascript
// Index multicl√© sur le champ "city" dans addresses
db.users.createIndex({ "addresses.city": 1 })
```

**Fonctionnement** : MongoDB cr√©e une entr√©e d'index pour chaque valeur de `city` dans chaque √©l√©ment du tableau `addresses`.

**Index cr√©√©** :
```
Index sur "addresses.city"
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Valeur        ‚Üí Document    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ "Lyon"        ‚Üí Doc #1      ‚îÇ
‚îÇ "Paris"       ‚Üí Doc #1      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Requ√™te optimis√©e** :
```javascript
// ‚úÖ Utilise l'index multicl√©
db.users.find({ "addresses.city": "Paris" })
```

### Index sur Plusieurs Champs

Vous pouvez cr√©er plusieurs index sur diff√©rents champs des sous-documents :

```javascript
// Index sur city
db.users.createIndex({ "addresses.city": 1 })

// Index sur zipCode
db.users.createIndex({ "addresses.zipCode": 1 })

// Index sur type
db.users.createIndex({ "addresses.type": 1 })
```

---

## Index Multicl√© Compos√©

### Concept

Un **index multicl√© compos√©** combine un index multicl√© avec d'autres champs (scalaires ou tableaux).

### Limitation Importante

‚ö†Ô∏è **R√àGLE CRITIQUE** : Un index compos√© peut contenir **au maximum UN seul champ de type tableau**.

**Permis** ‚úÖ :
```javascript
// Un champ tableau + un champ scalaire
db.products.createIndex({ categories: 1, price: 1 })

// Un champ scalaire + un champ tableau
db.products.createIndex({ brand: 1, tags: 1 })

// Deux champs scalaires + un champ tableau
db.orders.createIndex({ customerId: 1, status: 1, "items.productId": 1 })
```

**Interdit** ‚ùå :
```javascript
// ERREUR : Deux champs tableaux dans le m√™me index compos√©
db.products.createIndex({ categories: 1, tags: 1 })
// MongoDB retournera une erreur
```

**Raison** : Avec deux tableaux, le nombre de combinaisons devient explosif. Pour un document avec 5 cat√©gories et 10 tags, il faudrait cr√©er 50 entr√©es d'index (5 √ó 10), ce qui est inefficace.

### Exemples d'Index Multicl√© Compos√©

#### Exemple 1 : Cat√©gorie + Prix

```javascript
// Documents produits
{
  _id: 101,
  name: "Laptop",
  categories: ["Electronics", "Computers"],
  price: 999.99
}

// Index multicl√© compos√©
db.products.createIndex({ categories: 1, price: 1 })
```

**Requ√™tes optimis√©es** :
```javascript
// ‚úÖ Recherche par cat√©gorie et prix
db.products.find({
  categories: "Electronics",
  price: { $lte: 1000 }
})

// ‚úÖ Recherche par cat√©gorie seule (pr√©fixe valide)
db.products.find({ categories: "Electronics" })
```

**Requ√™te NON optimis√©e** :
```javascript
// ‚ùå Recherche par prix seul (pas de pr√©fixe valide)
db.products.find({ price: { $lte: 1000 } })
```

#### Exemple 2 : Client + Items

```javascript
// Collection orders
{
  _id: 1001,
  customerId: 5678,
  status: "pending",
  items: [
    { productId: 101, quantity: 2 },
    { productId: 105, quantity: 1 }
  ]
}

// Index multicl√© compos√©
db.orders.createIndex({
  customerId: 1,
  "items.productId": 1
})

// Requ√™te optimis√©e
db.orders.find({
  customerId: 5678,
  "items.productId": 101
})
```

---

## Op√©rateurs de Tableaux et Index Multicl√©

### $elemMatch

L'op√©rateur `$elemMatch` permet de filtrer sur plusieurs champs d'un m√™me √©l√©ment du tableau :

```javascript
// Documents
{
  _id: 1,
  items: [
    { name: "Laptop", price: 999, inStock: true },
    { name: "Mouse", price: 25, inStock: false }
  ]
}

// Recherche avec $elemMatch
db.products.find({
  items: {
    $elemMatch: {
      price: { $lte: 1000 },
      inStock: true
    }
  }
})
```

**Index recommand√©** :
```javascript
// Index compos√© sur plusieurs champs du tableau
db.products.createIndex({
  "items.price": 1,
  "items.inStock": 1
})
```

### $all

L'op√©rateur `$all` v√©rifie qu'un tableau contient toutes les valeurs sp√©cifi√©es :

```javascript
// Trouver les documents ayant √† la fois "mongodb" ET "javascript"
db.users.find({
  tags: { $all: ["mongodb", "javascript"] }
})
```

**Index utilis√©** :
```javascript
db.users.createIndex({ tags: 1 })
// L'index multicl√© est utilis√© pour cette requ√™te
```

### $size

‚ö†Ô∏è L'op√©rateur `$size` ne peut **pas utiliser d'index** :

```javascript
// ‚ùå Cette requ√™te ne peut pas utiliser d'index
db.users.find({ tags: { $size: 3 } })
```

**Alternative** : Stocker la taille du tableau dans un champ s√©par√© si vous devez filtrer par taille fr√©quemment :

```javascript
// Document avec champ de taille
{
  _id: 1,
  tags: ["mongodb", "javascript", "nodejs"],
  tagsCount: 3  // ‚Üê Stocker la taille
}

// Index sur la taille
db.users.createIndex({ tagsCount: 1 })

// Requ√™te optimis√©e
db.users.find({ tagsCount: 3 })
```

---

## Cas d'Usage Courants

### 1. Syst√®me de Tags

**Contexte** : Blog, e-commerce, r√©seau social

```javascript
// Articles de blog avec tags
{
  _id: 1,
  title: "Introduction √† MongoDB",
  content: "...",
  tags: ["database", "mongodb", "nosql", "tutorial"]
}

// Index multicl√©
db.articles.createIndex({ tags: 1 })

// Recherches fr√©quentes
db.articles.find({ tags: "mongodb" })
db.articles.find({ tags: { $in: ["mongodb", "postgresql"] } })
```

### 2. Syst√®me de Cat√©gories Hi√©rarchiques

**Contexte** : E-commerce avec cat√©gories multiples

```javascript
// Produits avec plusieurs cat√©gories
{
  _id: 101,
  name: "MacBook Pro",
  categories: [
    "Electronics",
    "Computers",
    "Laptops",
    "Apple Products",
    "Professional Equipment"
  ],
  price: 2499
}

// Index multicl√© compos√©
db.products.createIndex({ categories: 1, price: 1 })

// Recherche optimis√©e
db.products.find({
  categories: "Laptops",
  price: { $lte: 3000 }
}).sort({ price: 1 })
```

### 3. Gestion des Permissions et R√¥les

**Contexte** : Syst√®me de gestion des utilisateurs

```javascript
// Utilisateurs avec plusieurs r√¥les
{
  _id: 1,
  username: "alice",
  email: "alice@example.com",
  roles: ["admin", "editor", "moderator"]
}

// Index multicl√©
db.users.createIndex({ roles: 1 })

// V√©rifier les permissions
db.users.find({ roles: "admin" })
db.users.find({ roles: { $all: ["admin", "editor"] } })
```

### 4. Commandes avec Articles Multiples

**Contexte** : E-commerce, gestion des commandes

```javascript
// Commandes avec plusieurs produits
{
  _id: 1001,
  orderNumber: "ORD-2024-001",
  customerId: 5678,
  items: [
    { productId: 101, name: "Laptop", quantity: 1, price: 999 },
    { productId: 205, name: "Mouse", quantity: 2, price: 25 },
    { productId: 310, name: "Keyboard", quantity: 1, price: 75 }
  ],
  totalAmount: 1124,
  status: "shipped"
}

// Index multicl√© compos√©
db.orders.createIndex({
  "items.productId": 1,
  customerId: 1
})

// Trouver toutes les commandes contenant un produit sp√©cifique
db.orders.find({ "items.productId": 101 })

// Trouver les commandes d'un client contenant un produit
db.orders.find({
  customerId: 5678,
  "items.productId": 101
})
```

### 5. Recherche Multi-Langues

**Contexte** : Application multilingue

```javascript
// Documents avec traductions multiples
{
  _id: 1,
  code: "welcome_message",
  translations: [
    { language: "en", text: "Welcome!" },
    { language: "fr", text: "Bienvenue !" },
    { language: "es", text: "¬°Bienvenido!" }
  ]
}

// Index multicl√©
db.translations.createIndex({ "translations.language": 1 })

// Recherche par langue
db.translations.find({ "translations.language": "fr" })
```

---

## Performance et Consid√©rations

### Avantages

‚úÖ **Recherches rapides sur tableaux**
- Acc√®s direct aux documents contenant une valeur sp√©cifique

‚úÖ **Flexibilit√©**
- Fonctionne avec tableaux de tailles variables
- G√®re tableaux de scalaires et de sous-documents

‚úÖ **Transparent**
- Cr√©ation automatique (m√™me syntaxe qu'un index simple)

### Inconv√©nients et Limitations

‚ùå **Taille de l'Index**
```
Index multicl√© g√©n√©ralement plus volumineux qu'un index simple

Document avec 10 tags ‚Üí 10 entr√©es d'index
1000 documents √ó 10 tags en moyenne = 10,000 entr√©es
```

‚ùå **Impact sur les √âcritures**
```
Insertion/Mise √† jour plus co√ªteuse :
- Ajout d'un √©l√©ment au tableau ‚Üí Nouvelle entr√©e d'index
- Suppression d'un √©l√©ment ‚Üí Suppression d'entr√©e d'index
```

‚ùå **Un seul champ tableau par index compos√©**
```javascript
// ‚ùå INTERDIT
db.collection.createIndex({ tags: 1, categories: 1 })
```

‚ùå **Limite de taille**
- Nombre maximum d'entr√©es d'index par document : environ 1024 (limite pratique)
- Si un tableau contient plus de 1000 √©l√©ments, consid√©rez une autre approche

### Quand √âviter les Index Multicl√©

‚ö†Ô∏è **Tableaux tr√®s volumineux**
```javascript
// Document avec 10,000 tags = 10,000 entr√©es d'index !
{
  _id: 1,
  tags: ["tag1", "tag2", ..., "tag10000"]  // ‚ùå Trop !
}
```

**Alternative** : Restructurer les donn√©es ou utiliser une collection s√©par√©e.

‚ö†Ô∏è **Tableaux mis √† jour tr√®s fr√©quemment**
```javascript
// Si vous ajoutez/supprimez des √©l√©ments constamment
// Impact n√©gatif sur les performances d'√©criture
```

‚ö†Ô∏è **Cardinalit√© tr√®s √©lev√©e dans les tableaux**
```javascript
// Si chaque document a des valeurs totalement uniques
// L'index ne r√©duit pas efficacement l'ensemble de r√©sultats
```

---

## Analyse et V√©rification

### V√©rifier l'Utilisation de l'Index

```javascript
db.users.find({ tags: "mongodb" }).explain("executionStats")
```

**Points cl√©s √† v√©rifier** :
```javascript
{
  "winningPlan": {
    "stage": "FETCH",
    "inputStage": {
      "stage": "IXSCAN",
      "indexName": "tags_1",  // ‚úÖ Index multicl√© utilis√©
      "isMultiKey": true,      // ‚úÖ Confirme que c'est multicl√©
      "multiKeyPaths": {
        "tags": [ "tags" ]     // ‚úÖ Champ tableau index√©
      },
      "keysExamined": 25,
      "docsExamined": 25
    }
  },
  "executionStats": {
    "executionTimeMillis": 2
  }
}
```

### Statistiques d'Index

```javascript
db.users.aggregate([{ $indexStats: {} }])
```

**R√©sultat** :
```json
[
  {
    "name": "tags_1",
    "key": { "tags": 1 },
    "host": "...",
    "accesses": {
      "ops": 1543,
      "since": ISODate("...")
    }
  }
]
```

---

## Exemples Comparatifs

### Sans Index Multicl√© ‚ùå

```javascript
// Requ√™te
db.users.find({ tags: "mongodb" })

// Performance
- Stage: COLLSCAN (scan complet)
- Documents examin√©s: 100,000
- Temps: 450ms
```

### Avec Index Multicl√© ‚úÖ

```javascript
// Index cr√©√©
db.users.createIndex({ tags: 1 })

// M√™me requ√™te
db.users.find({ tags: "mongodb" })

// Performance
- Stage: IXSCAN (utilise l'index)
- Documents examin√©s: 1,234
- Temps: 5ms
- Am√©lioration: 90x plus rapide !
```

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **Indexer les tableaux fr√©quemment recherch√©s**
   ```javascript
   // Si vous filtrez souvent par tags
   db.articles.createIndex({ tags: 1 })
   ```

2. **Combiner avec des champs scalaires**
   ```javascript
   // Index multicl√© compos√© efficace
   db.products.createIndex({ category: 1, tags: 1 })
   ```

3. **Utiliser pour les syst√®mes de tags et cat√©gories**
   ```javascript
   db.items.createIndex({ tags: 1 })
   db.items.createIndex({ categories: 1 })
   ```

4. **Surveiller la taille des tableaux**
   ```javascript
   // V√©rifier la distribution des tailles
   db.collection.aggregate([
     {
       $project: {
         tagsCount: { $size: "$tags" }
       }
     },
     {
       $group: {
         _id: null,
         avgSize: { $avg: "$tagsCount" },
         maxSize: { $max: "$tagsCount" }
       }
     }
   ])
   ```

5. **Documenter l'index et son usage**
   ```javascript
   // Nommer explicitement l'index
   db.users.createIndex(
     { tags: 1 },
     { name: "idx_user_tags" }
   )
   ```

### ‚ùå √Ä √âviter

1. **Ne pas cr√©er deux index multicl√© dans un index compos√©**
   ```javascript
   // ‚ùå ERREUR
   db.products.createIndex({ categories: 1, tags: 1 })
   ```

2. **Ne pas indexer des tableaux tr√®s volumineux**
   ```javascript
   // ‚ùå Document avec 5000+ √©l√©ments = probl√®me
   {
     largeArray: [/* 5000 √©l√©ments */]
   }
   ```

3. **Ne pas utiliser d'index multicl√© pour $size**
   ```javascript
   // ‚ùå N'utilise pas d'index
   db.users.find({ tags: { $size: 5 } })

   // ‚úÖ Alternative : stocker la taille
   db.users.createIndex({ tagsCount: 1 })
   db.users.find({ tagsCount: 5 })
   ```

4. **Ne pas oublier la r√®gle du pr√©fixe**
   ```javascript
   // Index
   db.orders.createIndex({ status: 1, "items.productId": 1 })

   // ‚ùå N'utilise pas l'index (pas de pr√©fixe)
   db.orders.find({ "items.productId": 101 })

   // ‚úÖ Utilise l'index (pr√©fixe valide)
   db.orders.find({
     status: "shipped",
     "items.productId": 101
   })
   ```

---

## Alternatives aux Index Multicl√©

### Collection S√©par√©e

Pour des relations many-to-many complexes, consid√©rez une collection s√©par√©e :

**Avant (avec tableau)** :
```javascript
// Collection users
{
  _id: 1,
  name: "Alice",
  groups: [101, 102, 103, 104, ..., 150]  // Tableau volumineux
}
```

**Apr√®s (collection s√©par√©e)** :
```javascript
// Collection users
{
  _id: 1,
  name: "Alice"
}

// Collection user_groups (relation)
{ userId: 1, groupId: 101 }
{ userId: 1, groupId: 102 }
{ userId: 1, groupId: 103 }
// ...

// Index compos√© sur la relation
db.user_groups.createIndex({ userId: 1, groupId: 1 })
```

**Avantages** :
- ‚úÖ Plus flexible pour de grandes quantit√©s de relations
- ‚úÖ Requ√™tes bidirectionnelles efficaces
- ‚úÖ Moins de limitations

---

## Index Multicl√© et Sharding

### Shard Key avec Champ Tableau

‚ö†Ô∏è **Limitation** : Vous ne pouvez pas utiliser un champ tableau comme **shard key** :

```javascript
// ‚ùå INTERDIT
sh.shardCollection("mydb.products", { categories: 1 })
```

**Raison** : Le routage des requ√™tes devient complexe et inefficace.

### Alternative

Utilisez un champ scalaire comme shard key et conservez l'index multicl√© :

```javascript
// ‚úÖ Shard key scalaire
sh.shardCollection("mydb.products", { productId: 1 })

// ‚úÖ Index multicl√© s√©par√© pour les cat√©gories
db.products.createIndex({ categories: 1 })
```

---

## Conclusion

Les **index multicl√©** sont une fonctionnalit√© puissante et transparente de MongoDB qui rend l'indexation de tableaux simple et efficace. Ils sont essentiels pour optimiser les requ√™tes sur des structures de donn√©es contenant des collections de valeurs, comme les tags, cat√©gories, permissions, et bien d'autres cas d'usage.

### Points Cl√©s √† Retenir

- ‚úÖ MongoDB cr√©e automatiquement un index multicl√© sur les champs tableaux
- ‚úÖ Chaque √©l√©ment du tableau obtient sa propre entr√©e d'index
- ‚úÖ Syntaxe identique √† un index simple : `db.collection.createIndex({ field: 1 })`
- ‚úÖ Fonctionne avec tableaux de scalaires et de sous-documents
- ‚úÖ Un seul champ tableau maximum par index compos√©
- ‚úÖ Efficace pour les op√©rateurs `$in`, `$all`, `$elemMatch`
- ‚úÖ Plus volumineux qu'un index simple, mais les performances justifient le co√ªt
- ‚úÖ √âviter pour les tableaux tr√®s volumineux (>1000 √©l√©ments)

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les index multicl√©, explorez :
- **[Index texte](03.1-index-texte.md)** : Recherche full-text avanc√©e
- **[Index g√©ospatial](03.2-index-geospatial.md)** : Requ√™tes g√©ographiques
- **[Index partiel](04.2-index-partiel.md)** : Indexer seulement un sous-ensemble
- **[Strat√©gies d'optimisation](08-strategies-optimisation.md)** : Techniques avanc√©es

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - Multikey Indexes](https://docs.mongodb.com/manual/core/index-multikey/)
- [Array Query Operators](https://docs.mongodb.com/manual/reference/operator/query-array/)
- [Multikey Index Bounds](https://docs.mongodb.com/manual/core/multikey-index-bounds/)
- [Performance Best Practices](https://www.mongodb.com/basics/best-practices)

‚è≠Ô∏è [Index sp√©cialis√©s](/05-index-et-optimisation/03-index-specialises.md)
