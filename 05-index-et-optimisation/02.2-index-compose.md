ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.2 Index ComposÃ© (Compound)

## Introduction

Un **index composÃ©** (ou **Compound Index**) est un index crÃ©Ã© sur **plusieurs champs** d'un document. Contrairement Ã  l'index simple qui n'indexe qu'un seul champ, l'index composÃ© combine plusieurs champs dans une structure d'index unique, permettant d'optimiser les requÃªtes qui filtrent, trient ou recherchent sur plusieurs champs simultanÃ©ment.

Les index composÃ©s sont essentiels pour optimiser les requÃªtes complexes et reprÃ©sentent l'un des outils les plus puissants de MongoDB pour amÃ©liorer les performances.

---

## Pourquoi les Index ComposÃ©s sont NÃ©cessaires

### Limite des Index Simples

Imaginons une collection d'utilisateurs oÃ¹ nous effectuons souvent cette requÃªte :

```javascript
// Rechercher les utilisateurs actifs de la ville de Paris
db.users.find({ city: "Paris", isActive: true })
```

Avec deux index simples sÃ©parÃ©s :
```javascript
db.users.createIndex({ city: 1 })
db.users.createIndex({ isActive: 1 })
```

**ProblÃ¨me** : MongoDB ne peut utiliser efficacement qu'**un seul** de ces index, puis doit filtrer manuellement les rÃ©sultats avec le second critÃ¨re. C'est sous-optimal.

### Solution : Index ComposÃ©

Avec un index composÃ© sur les deux champs :

```javascript
db.users.createIndex({ city: 1, isActive: 1 })
```

**Avantage** : MongoDB peut utiliser l'index pour **les deux critÃ¨res simultanÃ©ment**, rÃ©sultant en des performances bien meilleures.

---

## Anatomie d'un Index ComposÃ©

### Structure Interne

Un index composÃ© maintient une structure triÃ©e basÃ©e sur **la combinaison des valeurs** des champs indexÃ©s, dans l'ordre spÃ©cifiÃ©.

```
Index composÃ© : { city: 1, isActive: 1 }

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ city          isActive    â†’ Document    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Bordeaux      false       â†’ Doc #5      â”‚
â”‚ Bordeaux      true        â†’ Doc #8      â”‚
â”‚ Lyon          false       â†’ Doc #3      â”‚
â”‚ Lyon          true        â†’ Doc #9      â”‚
â”‚ Paris         false       â†’ Doc #2      â”‚
â”‚ Paris         true        â†’ Doc #1      â”‚
â”‚ Paris         true        â†’ Doc #4      â”‚
â”‚ ...                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

L'index est d'abord triÃ© par `city`, puis par `isActive` pour chaque valeur de city.

---

## Syntaxe de CrÃ©ation

### Syntaxe de Base

```javascript
db.collection.createIndex({
  champ1: ordre1,
  champ2: ordre2,
  champ3: ordre3,
  ...
})
```

- `champ1, champ2, ...` : Les champs Ã  indexer dans l'ordre souhaitÃ©
- `ordre` : `1` (ascendant) ou `-1` (descendant)

### Exemples Pratiques

#### Exemple 1 : Index Ã  2 champs

```javascript
// Index composÃ© sur ville et statut
db.users.createIndex({ city: 1, isActive: 1 })
```

#### Exemple 2 : Index Ã  3 champs

```javascript
// Index composÃ© sur catÃ©gorie, prix et disponibilitÃ©
db.products.createIndex({
  category: 1,
  price: -1,      // Prix dÃ©croissant
  inStock: 1
})
```

#### Exemple 3 : Index Ã  4 champs

```javascript
// Index pour requÃªtes complexes sur les commandes
db.orders.createIndex({
  status: 1,
  customerId: 1,
  createdAt: -1,
  totalAmount: -1
})
```

---

## L'Ordre des Champs : Crucial !

### Principe Fondamental

L'**ordre des champs** dans un index composÃ© est **extrÃªmement important** et impacte directement quelles requÃªtes peuvent utiliser l'index efficacement.

### Analogie : Annuaire TÃ©lÃ©phonique

Pensez Ã  un annuaire tÃ©lÃ©phonique traditionnel :

**Index composÃ©** : `{ lastName: 1, firstName: 1 }`
- Ã‰quivalent Ã  : Annuaire triÃ© par NOM puis PRÃ‰NOM
- âœ… Efficace pour : Chercher "DUPONT"
- âœ… Efficace pour : Chercher "DUPONT Jean"
- âŒ Inefficace pour : Chercher tous les "Jean" (quel que soit le nom)

**Index composÃ© inversÃ©** : `{ firstName: 1, lastName: 1 }`
- Ã‰quivalent Ã  : Annuaire triÃ© par PRÃ‰NOM puis NOM
- âœ… Efficace pour : Chercher tous les "Jean"
- âŒ Inefficace pour : Chercher "DUPONT" (sans prÃ©nom)

### Exemple Concret

```javascript
// Index crÃ©Ã©
db.users.createIndex({ city: 1, age: 1 })
```

**RequÃªtes optimisÃ©es** :
```javascript
// âœ… Utilise l'index efficacement
db.users.find({ city: "Paris" })

// âœ… Utilise l'index efficacement
db.users.find({ city: "Paris", age: 25 })

// âœ… Utilise l'index efficacement
db.users.find({ city: "Paris", age: { $gte: 18, $lte: 65 } })
```

**RequÃªtes NON optimisÃ©es** :
```javascript
// âŒ N'utilise PAS l'index (age seul, sans city)
db.users.find({ age: 25 })

// âš ï¸ Utilise partiellement l'index (scan sur tous les city)
db.users.find({ age: { $gte: 18, $lte: 65 } })
```

---

## Concept de PrÃ©fixe d'Index

### DÃ©finition

Un **prÃ©fixe d'index** est une portion initiale des champs d'un index composÃ©. MongoDB peut utiliser un index composÃ© pour des requÃªtes qui correspondent Ã  n'importe quel prÃ©fixe de l'index.

### RÃ¨gle du PrÃ©fixe

Pour un index composÃ© sur `{ A: 1, B: 1, C: 1 }`, MongoDB peut l'utiliser pour :

âœ… **PrÃ©fixes valides** :
- RequÃªtes sur `A`
- RequÃªtes sur `A, B`
- RequÃªtes sur `A, B, C`

âŒ **PrÃ©fixes invalides** (n'utilisent pas l'index efficacement) :
- RequÃªtes sur `B` seul
- RequÃªtes sur `C` seul
- RequÃªtes sur `B, C`

### Exemple DÃ©taillÃ©

```javascript
// Index crÃ©Ã©
db.products.createIndex({
  category: 1,    // 1er champ
  brand: 1,       // 2Ã¨me champ
  price: 1        // 3Ã¨me champ
})
```

**Utilisations efficaces** :
```javascript
// âœ… PrÃ©fixe : category
db.products.find({ category: "Electronics" })

// âœ… PrÃ©fixe : category, brand
db.products.find({
  category: "Electronics",
  brand: "Samsung"
})

// âœ… PrÃ©fixe complet : category, brand, price
db.products.find({
  category: "Electronics",
  brand: "Samsung",
  price: { $lte: 500 }
})
```

**Utilisations inefficaces** :
```javascript
// âŒ Pas de prÃ©fixe valide (commence par brand)
db.products.find({ brand: "Samsung" })

// âŒ Pas de prÃ©fixe valide (commence par price)
db.products.find({ price: { $lte: 500 } })

// âŒ Pas de prÃ©fixe valide (saute category)
db.products.find({
  brand: "Samsung",
  price: { $lte: 500 }
})
```

### Implication Pratique

ðŸ’¡ **Placez les champs les plus sÃ©lectifs et les plus frÃ©quemment utilisÃ©s en premier dans l'index.**

---

## La RÃ¨gle ESR (Equality, Sort, Range)

### Principe ESR

Pour dÃ©terminer l'ordre optimal des champs dans un index composÃ©, suivez la rÃ¨gle **ESR** :

1. **E** - **Equality** (Ã‰galitÃ©) : Champs avec des tests d'Ã©galitÃ© (`=`)
2. **S** - **Sort** (Tri) : Champs utilisÃ©s pour le tri
3. **R** - **Range** (Plage) : Champs avec des tests de plage (`>`, `<`, `>=`, `<=`, `$in`)

### Pourquoi Cet Ordre ?

- **Equality** en premier rÃ©duit drastiquement l'ensemble de documents Ã  examiner
- **Sort** ensuite permet un tri efficace sans charge supplÃ©mentaire
- **Range** en dernier car il nÃ©cessite de scanner plusieurs valeurs

### Exemple d'Application

**RequÃªte cible** :
```javascript
db.orders.find({
  status: "shipped",           // Equality
  customerId: 1234,            // Equality
  totalAmount: { $gte: 100 }   // Range
}).sort({
  orderDate: -1                // Sort
})
```

**Analyse ESR** :
- **E** : `status`, `customerId` (Ã©galitÃ©)
- **S** : `orderDate` (tri)
- **R** : `totalAmount` (plage)

**Index optimal** :
```javascript
db.orders.createIndex({
  status: 1,          // E - Equality
  customerId: 1,      // E - Equality
  orderDate: -1,      // S - Sort
  totalAmount: 1      // R - Range
})
```

### Exemple Avec Explication

**Mauvais ordre** âŒ :
```javascript
// Range en premier = inefficace
db.orders.createIndex({
  totalAmount: 1,     // R - Range (trop tÃ´t !)
  status: 1,          // E - Equality
  orderDate: -1       // S - Sort
})
```

**ProblÃ¨me** : L'index doit scanner toutes les valeurs de `totalAmount` avant de pouvoir filtrer par `status`, ce qui est inefficace.

**Bon ordre** âœ… :
```javascript
db.orders.createIndex({
  status: 1,          // E - Equality (rÃ©duit l'ensemble)
  orderDate: -1,      // S - Sort (tri efficace)
  totalAmount: 1      // R - Range (en dernier)
})
```

---

## Ordre de Tri : Ascendant vs Descendant

### Importance dans les Index ComposÃ©s

Contrairement aux index simples, l'**ordre de tri** (1 ou -1) dans un index composÃ© **est important** lorsque votre requÃªte effectue un tri sur plusieurs champs.

### RÃ¨gle GÃ©nÃ©rale

L'ordre de tri dans l'index doit **correspondre** ou Ãªtre l'**inverse exact** de l'ordre de tri de la requÃªte.

### Exemples

#### Cas 1 : MÃªme Direction

**Index** :
```javascript
db.users.createIndex({ lastName: 1, firstName: 1 })
```

**RequÃªtes optimisÃ©es** :
```javascript
// âœ… Ordre identique
db.users.find().sort({ lastName: 1, firstName: 1 })

// âœ… Inverse exact (MongoDB peut traverser l'index Ã  l'envers)
db.users.find().sort({ lastName: -1, firstName: -1 })
```

#### Cas 2 : Directions Mixtes

**Index** :
```javascript
db.events.createIndex({ date: 1, priority: -1 })
```

**RequÃªtes optimisÃ©es** :
```javascript
// âœ… Ordre identique
db.events.find().sort({ date: 1, priority: -1 })

// âœ… Inverse exact
db.events.find().sort({ date: -1, priority: 1 })
```

**RequÃªtes NON optimisÃ©es** :
```javascript
// âŒ Ordre mixte diffÃ©rent
db.events.find().sort({ date: 1, priority: 1 })

// âŒ Ordre mixte diffÃ©rent
db.events.find().sort({ date: -1, priority: -1 })
```

### Cas Particulier : Tri sur un Seul Champ

Si vous triez sur un seul champ de l'index composÃ©, l'ordre de cet unique champ n'a pas d'importance :

```javascript
// Index
db.users.createIndex({ city: 1, age: -1 })

// âœ… Les deux fonctionnent
db.users.find({ city: "Paris" }).sort({ age: 1 })
db.users.find({ city: "Paris" }).sort({ age: -1 })
```

---

## Quand Utiliser un Index ComposÃ©

### Cas d'Usage IdÃ©aux

âœ… **RequÃªtes multi-critÃ¨res frÃ©quentes**
```javascript
// Recherche frÃ©quente par statut ET client
db.orders.find({ status: "pending", customerId: 1234 })

// Index recommandÃ©
db.orders.createIndex({ status: 1, customerId: 1 })
```

âœ… **RequÃªtes avec filtrage ET tri**
```javascript
// Produits d'une catÃ©gorie triÃ©s par prix
db.products.find({ category: "Electronics" }).sort({ price: -1 })

// Index recommandÃ©
db.products.createIndex({ category: 1, price: -1 })
```

âœ… **RequÃªtes complexes rÃ©pÃ©titives**
```javascript
// Recherche avancÃ©e de produits
db.products.find({
  category: "Electronics",
  brand: "Samsung",
  inStock: true,
  price: { $lte: 1000 }
}).sort({ rating: -1 })

// Index recommandÃ© (ESR)
db.products.createIndex({
  category: 1,    // E
  brand: 1,       // E
  inStock: 1,     // E
  rating: -1,     // S
  price: 1        // R
})
```

âœ… **Covered Queries (requÃªtes couvertes)**
```javascript
// RequÃªte couverte : tous les champs sont dans l'index
db.users.find(
  { city: "Paris", isActive: true },
  { _id: 0, city: 1, isActive: 1, lastName: 1 }  // Projection
)

// Index couvrant
db.users.createIndex({ city: 1, isActive: 1, lastName: 1 })
```

### Cas oÃ¹ un Index ComposÃ© est Moins AppropriÃ©

âŒ **Un seul champ utilisÃ© dans les requÃªtes**
```javascript
// Si vous ne filtrez que par ville
db.users.find({ city: "Paris" })

// Un index simple suffit
db.users.createIndex({ city: 1 })
```

âŒ **Champs utilisÃ©s de maniÃ¨re totalement indÃ©pendante**
```javascript
// TantÃ´t recherche par email
db.users.find({ email: "user@example.com" })

// TantÃ´t recherche par phone (jamais ensemble)
db.users.find({ phone: "+33123456789" })

// CrÃ©er deux index simples sÃ©parÃ©s
db.users.createIndex({ email: 1 })
db.users.createIndex({ phone: 1 })
```

âŒ **Premier champ avec trÃ¨s faible cardinalitÃ©**
```javascript
// isActive n'a que 2 valeurs (true/false)
db.users.createIndex({ isActive: 1, email: 1 })

// Inversez l'ordre !
db.users.createIndex({ email: 1, isActive: 1 })
```

---

## Index ComposÃ© vs Multiples Index Simples

### Comparaison

| CritÃ¨re | Index ComposÃ© | Multiples Index Simples |
|---------|---------------|-------------------------|
| **Performance requÃªte multi-critÃ¨res** | âœ… Excellent | âš ï¸ Moyen (un seul utilisÃ©) |
| **FlexibilitÃ©** | âš ï¸ Moins flexible | âœ… Plus flexible |
| **Espace disque** | âœ… 1 index | âŒ N index |
| **Impact sur les Ã©critures** | âœ… 1 mise Ã  jour | âŒ N mises Ã  jour |
| **ComplexitÃ© de gestion** | âœ… Simple | âš ï¸ Plus complexe |

### Exemple Comparatif

**RequÃªte cible** :
```javascript
db.orders.find({ status: "pending", customerId: 1234 })
```

**Option 1 : Index composÃ©** âœ…
```javascript
db.orders.createIndex({ status: 1, customerId: 1 })
// RÃ©sultat : Utilise l'index pour les 2 critÃ¨res = rapide
```

**Option 2 : Deux index simples** âš ï¸
```javascript
db.orders.createIndex({ status: 1 })
db.orders.createIndex({ customerId: 1 })
// RÃ©sultat : N'utilise qu'un seul index (gÃ©nÃ©ralement le plus sÃ©lectif)
//            Doit ensuite filtrer manuellement avec le 2Ã¨me critÃ¨re = moins rapide
```

### Index Intersection

Ã€ partir de MongoDB 2.6, il existe l'**Index Intersection** qui permet d'utiliser plusieurs index simples ensemble, mais :
- âŒ C'est gÃ©nÃ©ralement moins performant qu'un index composÃ©
- âŒ LimitÃ© Ã  certains types de requÃªtes
- âŒ Consomme plus de ressources

**Recommandation** : PrÃ©fÃ©rez un index composÃ© pour les requÃªtes multi-critÃ¨res frÃ©quentes.

---

## Nombre Maximum de Champs

### Limite Technique

Un index composÃ© peut contenir jusqu'Ã  **32 champs** maximum (limite MongoDB).

### Recommandation Pratique

En pratique, limitez-vous Ã  **3-5 champs** maximum :
- âœ… Plus facile Ã  maintenir
- âœ… Moins d'impact sur les performances d'Ã©criture
- âœ… Moins d'espace disque
- âœ… Plus comprÃ©hensible

### Signe d'un ProblÃ¨me de ModÃ©lisation

Si vous avez besoin de plus de 5 champs dans un index composÃ©, c'est souvent le signe que :
- âš ï¸ Votre modÃ©lisation de donnÃ©es n'est pas optimale
- âš ï¸ Vos requÃªtes sont trop complexes
- âš ï¸ Vous devriez peut-Ãªtre revoir votre architecture

---

## Exemples Pratiques Complets

### Exemple 1 : Site E-commerce

**Collection de produits** :
```javascript
{
  _id: ObjectId("..."),
  name: "Laptop Dell",
  category: "Electronics",
  subcategory: "Computers",
  brand: "Dell",
  price: 899.99,
  inStock: true,
  rating: 4.5,
  createdAt: ISODate("2024-01-15")
}
```

**RequÃªtes frÃ©quentes** :
```javascript
// 1. Produits d'une catÃ©gorie triÃ©s par prix
db.products.find({ category: "Electronics" }).sort({ price: -1 })

// 2. Produits en stock d'une marque triÃ©s par note
db.products.find({
  brand: "Dell",
  inStock: true
}).sort({ rating: -1 })

// 3. Nouveaux produits d'une sous-catÃ©gorie
db.products.find({
  category: "Electronics",
  subcategory: "Computers"
}).sort({ createdAt: -1 })
```

**Index composÃ©s recommandÃ©s** :
```javascript
// Pour requÃªte 1
db.products.createIndex({ category: 1, price: -1 })

// Pour requÃªte 2
db.products.createIndex({ brand: 1, inStock: 1, rating: -1 })

// Pour requÃªte 3
db.products.createIndex({ category: 1, subcategory: 1, createdAt: -1 })
```

### Exemple 2 : Application de Gestion de Commandes

**Collection de commandes** :
```javascript
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001",
  customerId: 1234,
  status: "pending",
  totalAmount: 299.99,
  createdAt: ISODate("2024-01-15T10:30:00Z"),
  shippingCountry: "France"
}
```

**RequÃªte complexe frÃ©quente** :
```javascript
// Commandes en attente d'un client spÃ©cifique, triÃ©es par date
db.orders.find({
  status: "pending",
  customerId: 1234,
  shippingCountry: "France"
}).sort({ createdAt: -1 })
```

**Application de la rÃ¨gle ESR** :
- **E** (Equality) : `status`, `customerId`, `shippingCountry`
- **S** (Sort) : `createdAt`
- **R** (Range) : Aucun

**Index optimal** :
```javascript
db.orders.createIndex({
  status: 1,
  customerId: 1,
  shippingCountry: 1,
  createdAt: -1
})
```

### Exemple 3 : SystÃ¨me de Logs

**Collection de logs** :
```javascript
{
  _id: ObjectId("..."),
  level: "error",
  service: "authentication",
  timestamp: ISODate("2024-01-15T14:30:00Z"),
  message: "Login failed",
  userId: 5678
}
```

**RequÃªtes d'analyse** :
```javascript
// Logs d'erreur d'un service sur les derniÃ¨res 24h
db.logs.find({
  level: "error",
  service: "authentication",
  timestamp: { $gte: ISODate("2024-01-14T14:30:00Z") }
}).sort({ timestamp: -1 })
```

**Index optimal (ESR)** :
```javascript
db.logs.createIndex({
  level: 1,        // E - Equality
  service: 1,      // E - Equality
  timestamp: -1    // S - Sort + R - Range
})
```

---

## VÃ©rification et Analyse

### VÃ©rifier l'Utilisation de l'Index

```javascript
db.orders.find({
  status: "pending",
  customerId: 1234
}).explain("executionStats")
```

**Points Ã  vÃ©rifier** :
```javascript
{
  // Stage doit Ãªtre IXSCAN (pas COLLSCAN)
  "winningPlan": {
    "stage": "FETCH",
    "inputStage": {
      "stage": "IXSCAN",
      "indexName": "status_1_customerId_1",  // Nom de l'index utilisÃ©
      "keysExamined": 15,
      "docsExamined": 15
    }
  },
  "executionStats": {
    "totalDocsExamined": 15,    // Peu de documents examinÃ©s = bon
    "totalKeysExamined": 15,
    "executionTimeMillis": 2    // Temps d'exÃ©cution faible
  }
}
```

### Analyse de la Couverture

Pour une **covered query** (requÃªte couverte), tous les champs retournÃ©s sont dans l'index :

```javascript
// RequÃªte couverte
db.orders.find(
  { status: "pending", customerId: 1234 },
  { _id: 0, status: 1, customerId: 1, createdAt: 1 }  // Projection
).explain("executionStats")
```

**RÃ©sultat idÃ©al** :
```javascript
{
  "winningPlan": {
    "stage": "PROJECTION_COVERED",  // âœ… Covered query !
    "inputStage": {
      "stage": "IXSCAN"
    }
  },
  "totalDocsExamined": 0  // âœ… Aucun document examinÃ© !
}
```

---

## Gestion des Index ComposÃ©s

### Lister les Index

```javascript
db.orders.getIndexes()
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "_id": 1 },
    "name": "_id_"
  },
  {
    "v": 2,
    "key": { "status": 1, "customerId": 1, "createdAt": -1 },
    "name": "status_1_customerId_1_createdAt_-1"
  }
]
```

### Nommer un Index ComposÃ©

```javascript
db.orders.createIndex(
  { status: 1, customerId: 1 },
  { name: "idx_orders_status_customer" }
)
```

### Supprimer un Index ComposÃ©

```javascript
// Par nom
db.orders.dropIndex("status_1_customerId_1_createdAt_-1")

// Par spÃ©cification
db.orders.dropIndex({ status: 1, customerId: 1, createdAt: -1 })
```

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Analyser vos requÃªtes rÃ©elles**
   - Identifier les patterns de requÃªtes frÃ©quents
   - CrÃ©er des index pour les requÃªtes les plus coÃ»teuses

2. **Appliquer la rÃ¨gle ESR**
   - Equality â†’ Sort â†’ Range
   - Optimise la plupart des cas

3. **Placer les champs sÃ©lectifs en premier**
   - Champs qui rÃ©duisent le plus l'ensemble de rÃ©sultats
   - GÃ©nÃ©ralement ceux avec haute cardinalitÃ©

4. **Utiliser explain() systÃ©matiquement**
   - VÃ©rifier que l'index est utilisÃ©
   - Analyser les mÃ©triques de performance

5. **Documenter vos index**
   - Expliquer pourquoi chaque index existe
   - Noter les requÃªtes qu'il optimise

6. **Surveiller l'utilisation des index**
   ```javascript
   db.orders.aggregate([{ $indexStats: {} }])
   ```

### âŒ Ã€ Ã‰viter

1. **Ne pas crÃ©er d'index redondants**
   ```javascript
   // âŒ Redondant si vous avez { city: 1, age: 1 }
   db.users.createIndex({ city: 1 })

   // âœ… L'index composÃ© couvre dÃ©jÃ  les requÃªtes sur city seul
   ```

2. **Ne pas inverser l'ordre sans raison**
   ```javascript
   // âŒ Mauvais ordre (range en premier)
   db.products.createIndex({ price: 1, category: 1 })

   // âœ… Bon ordre (equality en premier)
   db.products.createIndex({ category: 1, price: 1 })
   ```

3. **Ne pas crÃ©er trop d'index composÃ©s**
   - Maximum 5-10 index par collection recommandÃ©
   - Chaque index ralentit les Ã©critures

4. **Ne pas ignorer l'ordre de tri**
   - Pour les requÃªtes avec tri multi-champs
   - VÃ©rifier que l'ordre correspond ou est l'inverse exact

5. **Ne pas oublier les champs de faible cardinalitÃ©**
   ```javascript
   // âŒ isActive (true/false) en premier
   db.users.createIndex({ isActive: 1, email: 1 })

   // âœ… email (haute cardinalitÃ©) en premier
   db.users.createIndex({ email: 1, isActive: 1 })
   ```

---

## Limitations et ConsidÃ©rations

### Taille Maximale

- **ClÃ© d'index** : Maximum 1024 bytes pour MongoDB < 4.2
- **Nombre de champs** : Maximum 32 champs
- **Recommandation** : 3-5 champs en pratique

### Impact sur les Performances

**Lectures** :
- âœ… AccÃ©lÃ©ration significative des requÃªtes

**Ã‰critures** :
```
Chaque INSERT/UPDATE/DELETE doit mettre Ã  jour tous les index concernÃ©s
Plus d'index = Ã‰critures plus lentes
```

**Espace Disque** :
```
Index composÃ© â‰ˆ 5-20% de la taille des donnÃ©es indexÃ©es
Plus de champs = Plus d'espace
```

### Cas Particulier : Ordre des Mises Ã  Jour

Si vous mettez Ã  jour frÃ©quemment certains champs :

```javascript
// âŒ Mise Ã  jour frÃ©quente de lastLoginAt nÃ©cessite rebuild d'index
db.users.createIndex({ email: 1, lastLoginAt: 1 })

// âœ… Mieux : index sans le champ frÃ©quemment mis Ã  jour
db.users.createIndex({ email: 1 })
```

---

## Comparaison : Index Simple vs ComposÃ© vs Multiple

### ScÃ©nario : Recherche Multi-CritÃ¨res

**RequÃªte** :
```javascript
db.products.find({ category: "Electronics", inStock: true })
```

**Option 1 : Aucun index** âŒ
- Temps : ~500ms
- Documents examinÃ©s : 100,000

**Option 2 : Un index simple** âš ï¸
```javascript
db.products.createIndex({ category: 1 })
```
- Temps : ~50ms
- Documents examinÃ©s : 10,000
- AmÃ©lioration : 10x

**Option 3 : Deux index simples** âš ï¸
```javascript
db.products.createIndex({ category: 1 })
db.products.createIndex({ inStock: 1 })
```
- Temps : ~45ms
- Documents examinÃ©s : 9,000
- AmÃ©lioration : 11x
- N'utilise qu'un seul index

**Option 4 : Index composÃ©** âœ…
```javascript
db.products.createIndex({ category: 1, inStock: 1 })
```
- Temps : ~5ms
- Documents examinÃ©s : 1,000
- AmÃ©lioration : 100x

---

## Cas AvancÃ©s

### Index ComposÃ© avec Champs ImbriquÃ©s

```javascript
// Documents
{
  name: "John Doe",
  address: {
    city: "Paris",
    zipCode: "75001"
  },
  preferences: {
    newsletter: true
  }
}

// Index sur champs imbriquÃ©s
db.users.createIndex({
  "address.city": 1,
  "preferences.newsletter": 1
})

// RequÃªte optimisÃ©e
db.users.find({
  "address.city": "Paris",
  "preferences.newsletter": true
})
```

### Index ComposÃ© avec Options

```javascript
// Index unique composÃ© (combinaison unique)
db.users.createIndex(
  { email: 1, provider: 1 },
  { unique: true }
)
// Permet : alice@example.com + Google, alice@example.com + Facebook
// Interdit : alice@example.com + Google (doublon)

// Index partiel composÃ©
db.orders.createIndex(
  { customerId: 1, createdAt: -1 },
  {
    partialFilterExpression: {
      status: "active"
    }
  }
)
// Index seulement les commandes actives
```

---

## Conclusion

Les **index composÃ©s** sont un outil puissant et essentiel pour optimiser les requÃªtes MongoDB complexes. En comprenant les principes de prÃ©fixe, la rÃ¨gle ESR, et l'importance de l'ordre des champs, vous pouvez crÃ©er des index qui transforment vos requÃªtes lentes en requÃªtes ultra-rapides.

### Points ClÃ©s Ã  Retenir

- âœ… Un index composÃ© indexe **plusieurs champs** dans un ordre prÃ©cis
- âœ… L'**ordre des champs** est crucial et impacte les performances
- âœ… RÃ¨gle du **prÃ©fixe** : Les requÃªtes doivent commencer par le(s) premier(s) champ(s)
- âœ… RÃ¨gle **ESR** : Equality â†’ Sort â†’ Range
- âœ… L'ordre de tri (1/-1) devient important pour les tris multi-champs
- âœ… Plus efficace que plusieurs index simples pour requÃªtes multi-critÃ¨res
- âœ… Utiliser `explain()` pour vÃ©rifier l'utilisation
- âœ… Limiter Ã  3-5 champs en pratique

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez les index composÃ©s, explorez :
- **[Index multiclÃ©](02.3-index-multicle.md)** : Index sur des tableaux
- **[Index texte](03.1-index-texte.md)** : Recherche full-text
- **[Index gÃ©ospatial](03.2-index-geospatial.md)** : RequÃªtes gÃ©ographiques
- **[StratÃ©gies d'optimisation](08-strategies-optimisation.md)** : Techniques avancÃ©es

---

**ðŸ“š Ressources ComplÃ©mentaires**
- [Documentation officielle - Compound Indexes](https://docs.mongodb.com/manual/core/index-compound/)
- [ESR Rule Explained](https://docs.mongodb.com/manual/tutorial/equality-sort-range-rule/)
- [Index Strategies](https://docs.mongodb.com/manual/applications/indexes/)
- [Performance Best Practices](https://www.mongodb.com/basics/best-practices)

â­ï¸ [Index multiclÃ© (Multikey)](/05-index-et-optimisation/02.3-index-multicle.md)
