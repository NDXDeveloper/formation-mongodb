üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.2 Index Partiel (Partial)

## Introduction

Un **index partiel** (ou **Partial Index**) est un index qui n'indexe qu'un **sous-ensemble** de documents d'une collection, selon une condition sp√©cifique. Au lieu d'indexer tous les documents, vous d√©finissez un filtre qui d√©termine quels documents sont inclus dans l'index.

Les index partiels sont utiles pour :
- **R√©duire la taille des index** : N'indexer que les documents pertinents
- **Am√©liorer les performances** : Index plus petits = plus rapides
- **√âconomiser de l'espace disque** : Moins d'entr√©es dans l'index
- **Cibler des requ√™tes sp√©cifiques** : Optimiser uniquement les cas importants

C'est l'√©quivalent d'un **index avec filtre** : "Indexe seulement les documents qui correspondent √† ce crit√®re".

---

## Le Probl√®me : Index Trop Volumineux

### Sans Index Partiel

Imaginons une collection de commandes avec des millions de documents :

```javascript
// Collection orders
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001234",
  customerId: 12345,
  status: "completed",  // completed, pending, cancelled, returned
  total: 299.99,
  createdAt: ISODate("2024-01-15")
}
```

**Sc√©nario** : Vous recherchez fr√©quemment les commandes par `customerId`, mais **uniquement les commandes actives** (`status: "pending"` ou `"processing"`).

**Approche classique** :
```javascript
// Index sur customerId
db.orders.createIndex({ customerId: 1 })

// Requ√™te
db.orders.find({
  customerId: 12345,
  status: { $in: ["pending", "processing"] }
})
```

**Probl√®mes** :
- ‚ùå L'index contient **tous** les documents (completed, cancelled, returned aussi)
- ‚ùå 90% des commandes sont "completed" (termin√©es)
- ‚ùå L'index est donc 10x plus gros que n√©cessaire
- ‚ùå Performance d√©grad√©e (index volumineux)
- ‚ùå Gaspillage d'espace disque

**Exemple de taille** :
```
10 millions de commandes :
- 9 millions completed (90%)
- 1 million pending/processing (10%)

Index classique : Indexe 10 millions de documents
Index partiel : Indexe 1 million de documents
‚Üí Index 10x plus petit !
```

### Avec Index Partiel ‚úÖ

```javascript
// Index partiel : seulement commandes actives
db.orders.createIndex(
  { customerId: 1 },
  {
    partialFilterExpression: {
      status: { $in: ["pending", "processing"] }
    }
  }
)
```

**R√©sultat** :
- ‚úÖ Index 10x plus petit (seulement 1 million d'entr√©es)
- ‚úÖ Recherches plus rapides (moins de donn√©es √† parcourir)
- ‚úÖ Moins d'espace disque utilis√©
- ‚úÖ Impact r√©duit sur les √©critures

---

## Qu'est-ce qu'un Index Partiel ?

### Analogie : L'Annuaire Filtr√©

Imaginez un annuaire t√©l√©phonique :

**Annuaire complet** = Index classique
```
Contient TOUS les contacts :
- Particuliers
- Entreprises
- Num√©ros sp√©ciaux
- Num√©ros inactifs
‚Üí Tr√®s volumineux, lourd √† transporter
```

**Annuaire professionnel** = Index partiel
```
Contient SEULEMENT les entreprises :
- Filtre : type = "entreprise"
- Exclut : particuliers, num√©ros inactifs
‚Üí Beaucoup plus l√©ger et cibl√©
```

### Principe de Fonctionnement

Un index partiel √©value une **condition** pour chaque document :
- ‚úÖ Si le document **correspond** au filtre ‚Üí Il est inclus dans l'index
- ‚ùå Si le document **ne correspond pas** ‚Üí Il est exclu de l'index

```
Document ‚Üí √âvaluer partialFilterExpression ‚Üí Inclure dans l'index ?
                                                    ‚Üì
                                              Oui   |   Non
                                               ‚Üì         ‚Üì
                                          Index√©   Pas index√©
```

---

## Syntaxe de Cr√©ation

### Syntaxe de Base

```javascript
db.collection.createIndex(
  { champ: 1 },
  {
    partialFilterExpression: {
      // Condition de filtrage
      champFiltre: valeur
    }
  }
)
```

### Exemples de Base

#### Exemple 1 : Indexer seulement documents actifs

```javascript
// Index partiel : seulement utilisateurs actifs
db.users.createIndex(
  { email: 1 },
  {
    partialFilterExpression: {
      status: "active"
    }
  }
)

// Optimis√© avec l'index
db.users.find({
  email: "alice@example.com",
  status: "active"  // ‚Üê Doit correspondre au filtre !
})

// N'utilise PAS l'index (status diff√©rent)
db.users.find({
  email: "alice@example.com",
  status: "inactive"
})
```

#### Exemple 2 : Indexer seulement valeurs √©lev√©es

```javascript
// Index partiel : seulement produits chers
db.products.createIndex(
  { category: 1, price: -1 },
  {
    partialFilterExpression: {
      price: { $gte: 1000 }
    }
  }
)

// Optimis√© avec l'index
db.products.find({
  category: "Electronics",
  price: { $gte: 1000 }
})

// N'utilise PAS l'index (prix < 1000)
db.products.find({
  category: "Electronics",
  price: { $lt: 100 }
})
```

---

## partialFilterExpression : Op√©rateurs Support√©s

### Op√©rateurs de Comparaison

```javascript
// √âgalit√©
{ field: value }
{ field: { $eq: value } }

// Comparaisons num√©riques
{ field: { $gt: value } }
{ field: { $gte: value } }
{ field: { $lt: value } }
{ field: { $lte: value } }

// In√©galit√©
{ field: { $ne: value } }
```

**Exemples** :
```javascript
// Prix >= 100
partialFilterExpression: { price: { $gte: 100 } }

// Stock > 0
partialFilterExpression: { stock: { $gt: 0 } }

// Status != "deleted"
partialFilterExpression: { status: { $ne: "deleted" } }
```

### Op√©rateurs Logiques

```javascript
// ET logique (tous doivent √™tre vrais)
{ $and: [
  { condition1 },
  { condition2 }
]}

// OU logique (au moins un doit √™tre vrai)
{ $or: [
  { condition1 },
  { condition2 }
]}

// NOT
{ field: { $not: { $eq: value } } }
```

**Exemples** :
```javascript
// Actif ET v√©rifi√©
partialFilterExpression: {
  $and: [
    { status: "active" },
    { emailVerified: true }
  ]
}

// Commande pending OU processing
partialFilterExpression: {
  $or: [
    { status: "pending" },
    { status: "processing" }
  ]
}
```

### Op√©rateurs d'Existence

```javascript
// Champ existe
{ field: { $exists: true } }

// Champ n'existe pas
{ field: { $exists: false } }
```

**Exemples** :
```javascript
// Documents avec champ email
partialFilterExpression: { email: { $exists: true } }

// Documents avec une date d'expiration
partialFilterExpression: { expiresAt: { $exists: true } }
```

### Op√©rateurs de Type

```javascript
// Type sp√©cifique
{ field: { $type: "string" } }
{ field: { $type: "number" } }
{ field: { $type: "date" } }
```

**Exemples** :
```javascript
// Champ est une cha√Æne
partialFilterExpression: { phone: { $type: "string" } }

// Champ est un nombre
partialFilterExpression: { quantity: { $type: "number" } }
```

### Op√©rateur $in

```javascript
// Valeur dans une liste
{ field: { $in: [value1, value2, value3] } }
```

**Exemple** :
```javascript
// Status est pending, processing, ou shipping
partialFilterExpression: {
  status: { $in: ["pending", "processing", "shipping"] }
}
```

### Op√©rateurs NON Support√©s ‚ùå

Certains op√©rateurs ne sont **pas support√©s** dans `partialFilterExpression` :

```javascript
// ‚ùå Expressions r√©guli√®res
{ field: { $regex: /pattern/ } }

// ‚ùå Op√©rateurs g√©ospatiaux
{ location: { $near: ... } }

// ‚ùå Op√©rateurs de texte
{ $text: { $search: "..." } }

// ‚ùå $where (JavaScript)
{ $where: "this.field > 100" }

// ‚ùå Op√©rateurs d'agr√©gation ($sum, $avg, etc.)
```

---

## Cas d'Usage Pratiques

### 1. Documents Actifs ou Non Supprim√©s

**Contexte** : Soft delete (marquage plut√¥t que suppression)

```javascript
// Collection users avec soft delete
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  isDeleted: false,  // false = actif, true = supprim√©
  createdAt: ISODate("2024-01-15")
}

// Index partiel : seulement utilisateurs actifs
db.users.createIndex(
  { email: 1 },
  {
    partialFilterExpression: {
      isDeleted: false
    }
  }
)

// Requ√™tes optimis√©es
db.users.find({
  email: "alice@example.com",
  isDeleted: false
})
```

**Avantage** :
- Si 90% des utilisateurs sont actifs, index 10x plus petit
- Recherches dans utilisateurs actifs ultra-rapides

### 2. Produits en Stock

**Contexte** : E-commerce avec gestion de stock

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Laptop Dell XPS",
  sku: "LAPTOP-DELL-001",
  category: "Electronics",
  price: 1299.99,
  stock: 25  // Quantit√© en stock
}

// Index partiel : seulement produits en stock
db.products.createIndex(
  { category: 1, price: -1 },
  {
    partialFilterExpression: {
      stock: { $gt: 0 }
    }
  }
)

// Recherche de produits disponibles
db.products.find({
  category: "Electronics",
  stock: { $gt: 0 }
}).sort({ price: -1 })
```

**Avantage** :
- Exclut les produits en rupture de stock (non pertinents pour recherche)
- Index plus petit et plus rapide

### 3. Commandes Non Finalis√©es

**Contexte** : Tableau de bord admin - commandes en cours

```javascript
// Collection orders
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001",
  customerId: 12345,
  status: "pending",  // pending, processing, shipped, completed, cancelled
  total: 299.99
}

// Index partiel : seulement commandes non finalis√©es
db.orders.createIndex(
  { customerId: 1, createdAt: -1 },
  {
    partialFilterExpression: {
      status: { $in: ["pending", "processing", "shipped"] }
    }
  }
)

// Requ√™tes du dashboard
db.orders.find({
  customerId: 12345,
  status: { $in: ["pending", "processing", "shipped"] }
}).sort({ createdAt: -1 })
```

**Avantage** :
- 90% des commandes sont "completed" (termin√©es)
- Index 10x plus petit pour commandes actives
- Dashboard plus rapide

### 4. Documents R√©cents

**Contexte** : Logs, analytics - seulement donn√©es r√©centes pertinentes

```javascript
// Collection logs
{
  _id: ObjectId("..."),
  level: "error",
  service: "api-server",
  message: "Connection timeout",
  timestamp: ISODate("2024-01-15T10:30:00Z")
}

// Index partiel : seulement logs des 30 derniers jours
db.logs.createIndex(
  { level: 1, timestamp: -1 },
  {
    partialFilterExpression: {
      timestamp: {
        $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
      }
    }
  }
)
```

‚ö†Ô∏è **Note** : La date dans `partialFilterExpression` est fixe. Pour un filtre dynamique, recr√©ez l'index p√©riodiquement ou utilisez un index TTL.

**Alternative recommand√©e** : Index TTL pour suppression automatique
```javascript
db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 2592000 })
```

### 5. Donn√©es Premium ou Payantes

**Contexte** : Plateforme avec contenu gratuit et premium

```javascript
// Collection articles
{
  _id: ObjectId("..."),
  title: "Advanced MongoDB Techniques",
  author: "John Doe",
  category: "Technology",
  isPremium: true,  // Contenu premium
  publishedAt: ISODate("2024-01-15")
}

// Index partiel : seulement contenu premium
db.articles.createIndex(
  { category: 1, publishedAt: -1 },
  {
    partialFilterExpression: {
      isPremium: true
    }
  }
)

// Recherche dans le catalogue premium
db.articles.find({
  category: "Technology",
  isPremium: true
}).sort({ publishedAt: -1 })
```

**Avantage** :
- Si 20% du contenu est premium
- Index 5x plus petit
- Recherche dans catalogue premium optimis√©e

### 6. √âv√©nements Futurs

**Contexte** : Plateforme d'√©v√©nements - filtrer √©v√©nements pass√©s

```javascript
// Collection events
{
  _id: ObjectId("..."),
  name: "MongoDB Conference 2024",
  location: "Paris",
  startDate: ISODate("2024-06-15T09:00:00Z"),
  endDate: ISODate("2024-06-17T18:00:00Z")
}

// Index partiel : seulement √©v√©nements futurs
db.events.createIndex(
  { location: 1, startDate: 1 },
  {
    partialFilterExpression: {
      startDate: { $gte: new Date() }
    }
  }
)
```

‚ö†Ô∏è **Note** : Date fixe dans le filtre. Pour des r√©sultats dynamiques, utilisez une strat√©gie diff√©rente ou combinez avec requ√™te applicative.

### 7. Utilisateurs V√©rifi√©s

**Contexte** : Fonctionnalit√©s r√©serv√©es aux utilisateurs v√©rifi√©s

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  emailVerified: true,
  phoneVerified: true
}

// Index partiel : seulement utilisateurs compl√®tement v√©rifi√©s
db.users.createIndex(
  { username: 1 },
  {
    partialFilterExpression: {
      $and: [
        { emailVerified: true },
        { phoneVerified: true }
      ]
    }
  }
)

// Recherche d'utilisateurs v√©rifi√©s
db.users.find({
  username: "alice",
  emailVerified: true,
  phoneVerified: true
})
```

### 8. Prix dans une Plage Sp√©cifique

**Contexte** : Produits haut de gamme

```javascript
// Collection luxury_products
{
  _id: ObjectId("..."),
  name: "Luxury Watch",
  brand: "Rolex",
  price: 15000,
  category: "Watches"
}

// Index partiel : seulement produits > 10000‚Ç¨
db.luxury_products.createIndex(
  { brand: 1, price: -1 },
  {
    partialFilterExpression: {
      price: { $gte: 10000 }
    }
  }
)

// Recherche dans catalogue haut de gamme
db.luxury_products.find({
  brand: "Rolex",
  price: { $gte: 10000 }
}).sort({ price: -1 })
```

---

## Utilisation de l'Index Partiel

### Condition Critique : La Requ√™te DOIT Correspondre au Filtre

Pour qu'une requ√™te utilise un index partiel, elle **doit inclure** une condition qui **correspond** au `partialFilterExpression` :

```javascript
// Index partiel
db.users.createIndex(
  { email: 1 },
  {
    partialFilterExpression: { status: "active" }
  }
)

// ‚úÖ Utilise l'index (status: "active" dans la requ√™te)
db.users.find({
  email: "alice@example.com",
  status: "active"
})

// ‚ùå N'utilise PAS l'index (status: "inactive")
db.users.find({
  email: "alice@example.com",
  status: "inactive"
})

// ‚ùå N'utilise PAS l'index (pas de condition sur status)
db.users.find({
  email: "alice@example.com"
})
```

### V√©rifier avec explain()

```javascript
// V√©rifier si l'index est utilis√©
db.users.find({
  email: "alice@example.com",
  status: "active"
}).explain("executionStats")
```

**Dans les r√©sultats** :
```javascript
{
  "winningPlan": {
    "stage": "FETCH",
    "inputStage": {
      "stage": "IXSCAN",
      "indexName": "email_1",  // ‚úÖ Index utilis√©
      "isPartial": true         // ‚úÖ Index partiel
    }
  }
}
```

---

## Comparaison : Index Partiel vs Index Sparse

### Index Sparse

```javascript
// Index sparse : exclut documents sans le champ ou avec null
db.users.createIndex({ email: 1 }, { sparse: true })
```

**Comportement** :
- Exclut documents o√π `email` est absent ou `null`
- Cas d'usage : Champs optionnels

### Index Partiel

```javascript
// Index partiel : exclut selon condition personnalis√©e
db.users.createIndex(
  { email: 1 },
  {
    partialFilterExpression: { status: "active" }
  }
)
```

**Comportement** :
- Exclut documents selon **n'importe quelle condition**
- Plus flexible que sparse

### Tableau Comparatif

| Crit√®re | Index Sparse | Index Partiel |
|---------|-------------|---------------|
| **Condition** | Fixe (champ absent/null) | Personnalisable |
| **Flexibilit√©** | Limit√©e | Totale |
| **Syntaxe** | `sparse: true` | `partialFilterExpression: {...}` |
| **Peut combiner** | Oui | Oui |
| **Cas d'usage** | Champs optionnels | Filtres complexes |

### √âquivalence Sparse avec Partial

Un index sparse peut √™tre reproduit avec un index partiel :

```javascript
// Index sparse
db.users.createIndex({ email: 1 }, { sparse: true })

// √âquivalent avec index partiel
db.users.createIndex(
  { email: 1 },
  {
    partialFilterExpression: {
      email: { $exists: true, $ne: null }
    }
  }
)
```

---

## Combinaisons d'Options

### Index Partiel + Unique

Combiner `unique` et `partialFilterExpression` pour unicit√© conditionnelle :

```javascript
// Email unique SEULEMENT pour utilisateurs actifs
db.users.createIndex(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: { status: "active" }
  }
)
```

**Comportement** :
- Email unique parmi les utilisateurs actifs
- Les utilisateurs inactifs peuvent avoir des emails dupliqu√©s

**Cas d'usage** :
```javascript
// ‚úÖ Permis : Deux utilisateurs avec m√™me email si l'un est inactif
{ email: "alice@example.com", status: "active" }
{ email: "alice@example.com", status: "inactive" }  // ‚úÖ OK

// ‚ùå Interdit : Deux utilisateurs actifs avec m√™me email
{ email: "bob@example.com", status: "active" }
{ email: "bob@example.com", status: "active" }  // ‚ùå ERREUR
```

### Index Partiel + Sparse

Combiner les deux pour encore plus de contr√¥le :

```javascript
// Index partiel ET sparse
db.products.createIndex(
  { sku: 1 },
  {
    unique: true,
    sparse: true,
    partialFilterExpression: {
      status: "published"
    }
  }
)
```

**Comportement** :
- Indexe seulement produits publi√©s (`status: "published"`)
- ET qui ont un SKU (sparse)
- SKU unique parmi les produits publi√©s avec SKU

### Index Partiel + TTL

Vous **ne pouvez pas** combiner directement `partialFilterExpression` avec un index TTL :

```javascript
// ‚ùå Non support√©
db.sessions.createIndex(
  { createdAt: 1 },
  {
    expireAfterSeconds: 3600,
    partialFilterExpression: { status: "active" }
  }
)
// ERREUR : TTL et partial incompatibles
```

**Solution** : Utilisez deux index s√©par√©s si n√©cessaire.

---

## Limitations et Contraintes

### Op√©rateurs de Requ√™te Limit√©s

Seulement certains op√©rateurs sont support√©s dans `partialFilterExpression` :

‚úÖ **Support√©s** :
- Comparaisons : `$eq`, `$gt`, `$gte`, `$lt`, `$lte`, `$ne`
- Logique : `$and`, `$or`
- Existence : `$exists`
- Type : `$type`
- Liste : `$in`, `$nin`

‚ùå **Non support√©s** :
- Regex : `$regex`
- G√©ospatial : `$near`, `$geoWithin`, etc.
- Texte : `$text`
- JavaScript : `$where`
- Agr√©gation : `$expr`, op√©rateurs d'agr√©gation

### Dates Fixes dans le Filtre

```javascript
// ‚ö†Ô∏è Date fixe - ne change pas automatiquement
db.events.createIndex(
  { location: 1 },
  {
    partialFilterExpression: {
      startDate: { $gte: ISODate("2024-01-15") }
    }
  }
)
```

**Probl√®me** : La date dans le filtre est **statique**. Pour un filtre "√©v√©nements futurs", vous devrez recr√©er l'index p√©riodiquement.

**Solution** : G√©rer la logique de date dans l'application plut√¥t que dans l'index.

### Index _id

Vous **ne pouvez pas** cr√©er un index partiel sur `_id` :

```javascript
// ‚ùå Non support√©
db.collection.createIndex(
  { _id: 1 },
  {
    partialFilterExpression: { status: "active" }
  }
)
```

L'index sur `_id` est toujours complet.

### Sharding

Dans un environnement shard√©, l'index partiel doit inclure la shard key dans le filtre ou √™tre compatible :

```javascript
// Shard key : { customerId: 1 }

// ‚úÖ OK : partialFilterExpression compatible
db.orders.createIndex(
  { customerId: 1, createdAt: -1 },
  {
    partialFilterExpression: { status: "pending" }
  }
)

// V√©rifier la compatibilit√© avec votre configuration
```

---

## Performance et Consid√©rations

### Avantages

‚úÖ **Taille r√©duite**
```
Index classique : 10 millions d'entr√©es
Index partiel : 1 million d'entr√©es (si filtre = 10%)
‚Üí 90% d'espace √©conomis√©
```

‚úÖ **Performances am√©lior√©es**
- Index plus petits = plus rapides
- Moins de donn√©es √† parcourir
- Tient mieux en m√©moire RAM

‚úÖ **Impact r√©duit sur les √©critures**
- Moins de documents √† indexer
- Insertions/mises √† jour plus rapides pour documents exclus

‚úÖ **√âconomie d'espace disque**
- Stockage r√©duit
- Co√ªts cloud r√©duits

### Inconv√©nients

‚ùå **Requ√™tes sans filtre non optimis√©es**
```javascript
// N'utilise PAS l'index partiel
db.users.find({ email: "alice@example.com" })
// Il faut absolument inclure la condition du filtre
```

‚ùå **Maintenance**
- Doit correspondre aux patterns de requ√™tes
- Modifier le filtre = recr√©er l'index

‚ùå **Complexit√©**
- Plus difficile √† comprendre et maintenir
- N√©cessite documentation claire

### Quand Utiliser un Index Partiel

‚úÖ **Utilisez un index partiel quand** :

1. **Sous-ensemble clair et stable**
   - Vous interrogez toujours le m√™me sous-ensemble
   - Exemple : documents actifs, commandes non finalis√©es

2. **Grande diff√©rence de taille**
   - Le sous-ensemble est beaucoup plus petit (< 20% du total)
   - √âconomies significatives

3. **Requ√™tes incluent toujours le filtre**
   - Vos requ√™tes contiennent naturellement la condition
   - Exemple : `status: "active"` toujours pr√©sent

4. **Espace disque limit√©**
   - Index classiques trop volumineux
   - Besoin d'optimiser l'espace

5. **Performance critique**
   - Besoin de requ√™tes ultra-rapides
   - Index petits = performances maximales

‚ùå **N'utilisez PAS un index partiel quand** :

1. **Requ√™tes vari√©es**
   - Vous interrogez diff√©rents sous-ensembles
   - Pas de pattern coh√©rent

2. **Sous-ensemble grand**
   - > 50% des documents
   - Gains limit√©s

3. **Filtre complexe ou changeant**
   - Condition difficile √† maintenir
   - √âvolution fr√©quente des besoins

---

## Exemples Complets

### Exemple 1 : Plateforme E-commerce

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Laptop Dell XPS",
  sku: "LAPTOP-001",
  category: "Electronics",
  price: 1299.99,
  stock: 25,
  status: "published",  // draft, published, archived
  featured: true
}

// Index 1 : Produits publi√©s en stock (recherche utilisateurs)
db.products.createIndex(
  { category: 1, featured: -1, price: -1 },
  {
    partialFilterExpression: {
      $and: [
        { status: "published" },
        { stock: { $gt: 0 } }
      ]
    }
  }
)

// Index 2 : Produits publi√©s (gestion catalogue)
db.products.createIndex(
  { name: "text" },
  {
    partialFilterExpression: {
      status: "published"
    }
  }
)

// Requ√™te utilisateur
db.products.find({
  category: "Electronics",
  status: "published",
  stock: { $gt: 0 }
}).sort({ featured: -1, price: -1 })
```

### Exemple 2 : Syst√®me de Tickets Support

```javascript
// Collection support_tickets
{
  _id: ObjectId("..."),
  ticketNumber: "TICKET-2024-001",
  customerId: 12345,
  subject: "Cannot login",
  status: "open",  // open, in_progress, resolved, closed
  priority: "high",  // low, medium, high, urgent
  createdAt: ISODate("2024-01-15"),
  assignedTo: ObjectId("...")
}

// Index partiel : tickets ouverts ou en cours
db.support_tickets.createIndex(
  { assignedTo: 1, priority: -1, createdAt: 1 },
  {
    partialFilterExpression: {
      status: { $in: ["open", "in_progress"] }
    }
  }
)

// Dashboard agent support
db.support_tickets.find({
  assignedTo: agentId,
  status: { $in: ["open", "in_progress"] }
}).sort({ priority: -1, createdAt: 1 })
```

### Exemple 3 : R√©seaux Sociaux - Posts Actifs

```javascript
// Collection posts
{
  _id: ObjectId("..."),
  userId: 12345,
  content: "My first post!",
  likes: 150,
  comments: 23,
  createdAt: ISODate("2024-01-15"),
  isDeleted: false,
  isSpam: false
}

// Index partiel : posts valides non supprim√©s
db.posts.createIndex(
  { userId: 1, createdAt: -1 },
  {
    partialFilterExpression: {
      $and: [
        { isDeleted: false },
        { isSpam: false }
      ]
    }
  }
)

// Index partiel : posts populaires (pour trending)
db.posts.createIndex(
  { likes: -1, createdAt: -1 },
  {
    partialFilterExpression: {
      $and: [
        { isDeleted: false },
        { isSpam: false },
        { likes: { $gte: 100 } }
      ]
    }
  }
)

// Feed utilisateur
db.posts.find({
  userId: 12345,
  isDeleted: false,
  isSpam: false
}).sort({ createdAt: -1 })
```

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **Analyser les patterns de requ√™tes**
   ```javascript
   // Identifier les filtres fr√©quents
   // 90% des requ√™tes ont status: "active"
   // ‚Üí Cr√©er index partiel avec ce filtre
   ```

2. **Documenter clairement le filtre**
   ```javascript
   // Index partiel : seulement commandes actives (pending, processing, shipped)
   // Utilis√© par : Dashboard admin, API commandes en cours
   // √âconomie : 90% (9M completed vs 1M actives)
   db.orders.createIndex(
     { customerId: 1 },
     {
       partialFilterExpression: {
         status: { $in: ["pending", "processing", "shipped"] }
       }
     }
   )
   ```

3. **V√©rifier avec explain()**
   ```javascript
   // Toujours v√©rifier que l'index est utilis√©
   db.collection.find({...}).explain("executionStats")
   ```

4. **Calculer les √©conomies**
   ```javascript
   // Comparer taille index classique vs partiel
   db.collection.stats().indexSizes
   ```

5. **Combiner avec unique si pertinent**
   ```javascript
   // Email unique seulement pour utilisateurs actifs
   db.users.createIndex(
     { email: 1 },
     {
       unique: true,
       partialFilterExpression: { status: "active" }
     }
   )
   ```

6. **Utiliser pour sous-ensembles < 20%**
   ```javascript
   // Maximum d'√©conomies quand le sous-ensemble est petit
   // 10% du total ‚Üí Index 10x plus petit
   ```

### ‚ùå √Ä √âviter

1. **Ne pas cr√©er pour sous-ensembles > 50%**
   ```javascript
   // ‚ùå Si 80% des documents correspondent au filtre
   // ‚Üí √âconomies limit√©es, complexit√© inutile
   // ‚Üí Utilisez un index classique
   ```

2. **Ne pas oublier le filtre dans les requ√™tes**
   ```javascript
   // ‚ùå N'utilise PAS l'index partiel
   db.users.find({ email: "alice@example.com" })

   // ‚úÖ Utilise l'index partiel
   db.users.find({
     email: "alice@example.com",
     status: "active"
   })
   ```

3. **Ne pas utiliser avec filtres changeants**
   ```javascript
   // ‚ùå Filtre bas√© sur date "maintenant"
   // Devra √™tre recr√©√© r√©guli√®rement
   partialFilterExpression: {
     createdAt: { $gte: new Date() }
   }
   ```

4. **Ne pas compliquer inutilement**
   ```javascript
   // ‚ùå Filtre trop complexe
   partialFilterExpression: {
     $or: [
       { $and: [{ a: 1 }, { b: 2 }] },
       { $and: [{ c: 3 }, { d: 4 }] }
     ]
   }
   // ‚Üí Difficile √† maintenir et √† utiliser correctement
   ```

5. **Ne pas ignorer les requ√™tes sans filtre**
   ```javascript
   // Si certaines requ√™tes n'ont pas le filtre :
   // ‚Üí Cr√©er aussi un index classique ou revoir la strat√©gie
   ```

---

## Analyse et V√©rification

### V√©rifier les Index Partiels

```javascript
// Lister tous les index
db.collection.getIndexes()

// Identifier les index partiels
db.collection.getIndexes().filter(idx =>
  idx.partialFilterExpression !== undefined
)
```

**R√©sultat** :
```json
[
  {
    "v": 2,
    "key": { "email": 1 },
    "name": "email_1",
    "partialFilterExpression": {
      "status": "active"
    }
  }
]
```

### Tester l'Index Partiel

```javascript
// Test 1 : Avec condition du filtre (doit utiliser l'index)
db.users.find({
  email: "alice@example.com",
  status: "active"
}).explain("executionStats")

// V√©rifier : "indexName" doit √™tre pr√©sent

// Test 2 : Sans condition du filtre (ne doit PAS utiliser l'index)
db.users.find({
  email: "alice@example.com"
}).explain("executionStats")

// V√©rifier : "COLLSCAN" ou autre index utilis√©
```

### Calculer les √âconomies

```javascript
// Taille totale de la collection
let totalDocs = db.collection.countDocuments()

// Documents dans l'index partiel
let filteredDocs = db.collection.countDocuments({
  status: "active"
})

// Pourcentage index√©
let percentage = (filteredDocs / totalDocs * 100).toFixed(2)
console.log(`Index partiel couvre ${percentage}% des documents`)

// Taille de l'index
let indexSize = db.collection.stats().indexSizes["email_1"]
console.log(`Taille de l'index : ${indexSize} bytes`)
```

---

## Conclusion

Les **index partiels** sont un outil puissant pour optimiser les performances et r√©duire la consommation d'espace disque en n'indexant qu'un sous-ensemble pertinent de documents. Ils sont particuli√®rement utiles quand vous interrogez r√©guli√®rement le m√™me sous-ensemble de donn√©es.

### Points Cl√©s √† Retenir

- ‚úÖ Index partiel = Index + Filtre sur documents
- ‚úÖ Syntaxe : `partialFilterExpression: { condition }`
- ‚úÖ N'indexe que les documents correspondant au filtre
- ‚úÖ R√©duit taille, am√©liore performances, √©conomise espace
- ‚úÖ Requ√™te DOIT inclure condition du filtre pour utiliser l'index
- ‚úÖ Peut combiner avec unique, sparse
- ‚úÖ Ne peut PAS combiner avec TTL
- ‚úÖ Op√©rateurs limit√©s (pas regex, g√©ospatial, texte)
- ‚úÖ Optimal pour sous-ensembles < 20% du total
- ‚úÖ Documenter clairement le filtre et cas d'usage

### Cas d'Usage Typiques

- üîÑ Documents actifs (soft delete)
- üì¶ Produits en stock
- üìã Commandes non finalis√©es
- ‚úÖ Utilisateurs v√©rifi√©s
- üíé Produits premium ou haut de gamme
- üìù Tickets support ouverts
- üìä Posts valides (non supprim√©s, non spam)
- üéØ Donn√©es r√©centes ou futures

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les index partiels, explorez :
- **[Index sparse](./04.3-index-sparse.md)** : Gestion des valeurs manquantes
- **[Index cach√© (Hidden)](./04.4-index-cache.md)** : Tester sans supprimer
- **[Strat√©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avanc√©es
- **[Gestion des index en production](./10-gestion-index-production.md)** : Best practices op√©rationnelles

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - Partial Indexes](https://docs.mongodb.com/manual/core/index-partial/)
- [Index Properties](https://docs.mongodb.com/manual/core/index-properties/)
- [Query Optimization](https://docs.mongodb.com/manual/core/query-optimization/)
- [Create Indexes to Support Queries](https://docs.mongodb.com/manual/tutorial/create-indexes-to-support-queries/)

‚è≠Ô∏è [Index sparse](/05-index-et-optimisation/04.3-index-sparse.md)
