üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.3.5 Index TTL (Time-To-Live)

## Introduction

Un **index TTL** (ou **Time-To-Live Index**) est un type d'index sp√©cialis√© dans MongoDB qui permet de **supprimer automatiquement** des documents apr√®s un certain d√©lai. C'est l'√©quivalent d'un "minuteur d'auto-destruction" pour vos donn√©es.

Les index TTL sont particuli√®rement utiles pour :
- **Sessions utilisateur** : Expiration automatique apr√®s inactivit√©
- **Cache temporaire** : Nettoyage automatique des entr√©es obsol√®tes
- **Logs** : Suppression automatique des anciens logs
- **Donn√©es temporaires** : Tokens, codes de v√©rification, invitations
- **Conformit√© RGPD** : Suppression automatique des donn√©es apr√®s une p√©riode l√©gale

Plut√¥t que d'√©crire des scripts complexes pour nettoyer r√©guli√®rement vos collections, MongoDB s'occupe de tout automatiquement avec les index TTL.

---

## Le Probl√®me : Nettoyage Manuel des Donn√©es

### Sans Index TTL

Imaginons une collection de sessions utilisateur :

```javascript
// Collection sessions
{
  _id: ObjectId("..."),
  userId: 12345,
  token: "abc123xyz789",
  createdAt: ISODate("2024-01-15T10:00:00Z"),
  lastAccessedAt: ISODate("2024-01-15T10:30:00Z")
}
```

**Question** : Comment supprimer les sessions de plus de 30 minutes ?

**Approche manuelle** ‚ùå :

```javascript
// Script √† ex√©cuter r√©guli√®rement (cron job)
const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);

db.sessions.deleteMany({
  lastAccessedAt: { $lt: thirtyMinutesAgo }
});
```

**Probl√®mes** :
- ‚ùå N√©cessite un script externe (cron, scheduler)
- ‚ùå Doit tourner r√©guli√®rement (charge serveur)
- ‚ùå Complexe √† maintenir
- ‚ùå Peut rater des suppressions entre deux ex√©cutions
- ‚ùå Risque d'oubli ou de bug

### Avec Index TTL ‚úÖ

```javascript
// Cr√©er un index TTL de 30 minutes
db.sessions.createIndex(
  { lastAccessedAt: 1 },
  { expireAfterSeconds: 1800 }  // 30 minutes = 1800 secondes
)

// C'est tout ! MongoDB supprime automatiquement
// les documents anciens en arri√®re-plan
```

**Avantages** :
- ‚úÖ Automatique (pas de script externe)
- ‚úÖ G√©r√© par MongoDB en arri√®re-plan
- ‚úÖ Simple √† configurer
- ‚úÖ Aucune maintenance
- ‚úÖ Fiable et garanti

---

## Qu'est-ce qu'un Index TTL ?

### Analogie : Le Lait avec Date de P√©remption

Imaginez votre r√©frig√©rateur :

**Sans TTL** = Vous devez v√©rifier manuellement les dates de p√©remption
```
Chaque jour, vous ouvrez le frigo :
"Ce lait est p√©rim√© ? Oui ‚Üí Poubelle"
"Ce yaourt est p√©rim√© ? Non ‚Üí Garder"
...r√©p√©ter pour chaque produit
```

**Avec TTL** = Le r√©frig√©rateur intelligent supprime automatiquement
```
Le r√©frig√©rateur v√©rifie automatiquement :
- Lait achet√© il y a 8 jours ‚Üí SUPPRESSION AUTO
- Yaourt achet√© il y a 3 jours ‚Üí Garder
- Fromage achet√© il y a 6 jours ‚Üí SUPPRESSION AUTO
```

### Principe de Fonctionnement

Un index TTL surveille un **champ de date** dans vos documents. Quand la date + d√©lai d'expiration est atteinte, MongoDB supprime automatiquement le document.

```
Document cr√©√© √† 10h00 + D√©lai de 30 minutes = Suppression √† 10h30
```

**Formule** :
```
Date d'expiration = Valeur du champ de date + expireAfterSeconds
```

---

## Syntaxe de Cr√©ation

### Syntaxe de Base

```javascript
db.collection.createIndex(
  { champDate: 1 },
  { expireAfterSeconds: <secondes> }
)
```

**Param√®tres** :
- `champDate` : Champ contenant une date (type `Date` ou `ISODate`)
- `expireAfterSeconds` : D√©lai en secondes avant suppression

### Exemples Pratiques

#### Exemple 1 : Sessions de 30 Minutes

```javascript
// Documents
{
  _id: ObjectId("..."),
  userId: 12345,
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index TTL : expire apr√®s 30 minutes
db.sessions.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 1800 }  // 30 minutes
)
```

**R√©sultat** : Document cr√©√© √† 10h00 ‚Üí Supprim√© vers 10h30

#### Exemple 2 : Cache de 1 Heure

```javascript
// Documents cache
{
  _id: ObjectId("..."),
  key: "user:1234:profile",
  value: { /* data */ },
  cachedAt: ISODate("2024-01-15T14:00:00Z")
}

// Index TTL : expire apr√®s 1 heure
db.cache.createIndex(
  { cachedAt: 1 },
  { expireAfterSeconds: 3600 }  // 1 heure
)
```

#### Exemple 3 : Logs de 7 Jours

```javascript
// Documents logs
{
  _id: ObjectId("..."),
  level: "error",
  message: "Connection timeout",
  timestamp: ISODate("2024-01-15T10:30:00Z")
}

// Index TTL : expire apr√®s 7 jours
db.logs.createIndex(
  { timestamp: 1 },
  { expireAfterSeconds: 604800 }  // 7 jours = 604800 secondes
)
```

#### Exemple 4 : Tokens de V√©rification (24h)

```javascript
// Tokens de r√©initialisation de mot de passe
{
  _id: ObjectId("..."),
  userId: 5678,
  token: "reset-token-xyz",
  createdAt: ISODate("2024-01-15T08:00:00Z")
}

// Index TTL : expire apr√®s 24 heures
db.reset_tokens.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 86400 }  // 24 heures
)
```

### Conversions de Temps Utiles

| Dur√©e | Secondes | Formule |
|-------|----------|---------|
| **1 minute** | 60 | `60` |
| **5 minutes** | 300 | `5 * 60` |
| **15 minutes** | 900 | `15 * 60` |
| **30 minutes** | 1800 | `30 * 60` |
| **1 heure** | 3600 | `60 * 60` |
| **6 heures** | 21600 | `6 * 60 * 60` |
| **12 heures** | 43200 | `12 * 60 * 60` |
| **24 heures** | 86400 | `24 * 60 * 60` |
| **7 jours** | 604800 | `7 * 24 * 60 * 60` |
| **30 jours** | 2592000 | `30 * 24 * 60 * 60` |
| **90 jours** | 7776000 | `90 * 24 * 60 * 60` |

---

## Expiration Imm√©diate (expireAfterSeconds: 0)

### Supprimer D√®s qu'une Date est Atteinte

Vous pouvez d√©finir `expireAfterSeconds: 0` pour supprimer un document **imm√©diatement** quand la date dans le champ est atteinte.

**Syntaxe** :
```javascript
db.collection.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 0 }
)
```

**Exemple** : Invitations avec date d'expiration sp√©cifique

```javascript
// Document
{
  _id: ObjectId("..."),
  email: "guest@example.com",
  invitationCode: "INV-12345",
  expiresAt: ISODate("2024-01-20T23:59:59Z")  // Expire le 20 jan √† 23h59
}

// Index TTL : suppression quand expiresAt est atteint
db.invitations.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 0 }
)
```

**R√©sultat** : Le document sera supprim√© **apr√®s** le 20 janvier 23h59

**Cas d'usage** :
- Invitations avec date d'expiration pr√©cise
- √âv√©nements temporaires
- Promotions avec date de fin
- Licences logicielles avec date d'expiration

---

## Fonctionnement Interne

### Processus en Arri√®re-Plan

MongoDB ex√©cute un **thread de suppression TTL** qui :

1. **Parcourt** tous les index TTL toutes les **60 secondes**
2. **Identifie** les documents expir√©s
3. **Supprime** les documents en lots

```
                    Thread TTL MongoDB
                           |
                    Toutes les 60s
                           |
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        |                                     |
   Collection A                          Collection B
   (Index TTL)                           (Index TTL)
        |                                     |
   Supprime docs                        Supprime docs
   expir√©s                              expir√©s
```

### D√©lai de Suppression

‚ö†Ô∏è **Important** : La suppression n'est **pas instantan√©e** !

**D√©lai possible** : Jusqu'√† **60 secondes** apr√®s l'expiration

**Exemple** :
```
Document cr√©√© √†     : 10h00
D√©lai expiration    : 30 minutes
Expiration th√©orique: 10h30
Suppression r√©elle  : Entre 10h30 et 10h31
```

**Raison** : Le thread TTL s'ex√©cute toutes les 60 secondes, donc il peut y avoir un d√©lai.

### Charge et Performance

Le thread TTL :
- ‚úÖ S'ex√©cute en arri√®re-plan
- ‚úÖ Ne bloque pas les autres op√©rations
- ‚úÖ Supprime en lots (efficace)
- ‚ö†Ô∏è Peut ralentir si beaucoup de documents √† supprimer simultan√©ment

---

## Cas d'Usage Pratiques

### 1. Sessions Utilisateur

**Contexte** : Sessions web expir√©es apr√®s inactivit√©

```javascript
// Collection user_sessions
{
  _id: ObjectId("..."),
  sessionId: "sess_abc123xyz",
  userId: 12345,
  ipAddress: "192.168.1.100",
  userAgent: "Mozilla/5.0...",
  lastActivityAt: ISODate("2024-01-15T10:30:00Z"),
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index TTL : expire apr√®s 30 minutes d'inactivit√©
db.user_sessions.createIndex(
  { lastActivityAt: 1 },
  { expireAfterSeconds: 1800 }  // 30 minutes
)

// Mise √† jour de lastActivityAt √† chaque activit√©
db.user_sessions.updateOne(
  { sessionId: "sess_abc123xyz" },
  {
    $set: { lastActivityAt: new Date() }
  }
)
```

**Avantage** : Nettoyage automatique des sessions inactives.

### 2. Syst√®me de Cache

**Contexte** : Cache temporaire de r√©sultats d'API

```javascript
// Collection api_cache
{
  _id: ObjectId("..."),
  cacheKey: "weather:paris:20240115",
  data: {
    temperature: 12,
    condition: "Cloudy",
    humidity: 65
  },
  cachedAt: ISODate("2024-01-15T14:00:00Z")
}

// Index TTL : cache valide 1 heure
db.api_cache.createIndex(
  { cachedAt: 1 },
  { expireAfterSeconds: 3600 }  // 1 heure
)

// Requ√™te avec cache
function getWeather(city) {
  // Chercher dans le cache
  let cached = db.api_cache.findOne({
    cacheKey: `weather:${city}:${today}`
  });

  if (cached) {
    return cached.data;  // Retourner depuis cache
  }

  // Sinon, appeler l'API et mettre en cache
  let data = callWeatherAPI(city);
  db.api_cache.insertOne({
    cacheKey: `weather:${city}:${today}`,
    data: data,
    cachedAt: new Date()
  });

  return data;
}
```

**Avantage** : Expiration automatique du cache obsol√®te.

### 3. Logs Applicatifs

**Contexte** : Logs conserv√©s 30 jours

```javascript
// Collection app_logs
{
  _id: ObjectId("..."),
  level: "error",
  service: "api-server",
  message: "Database connection timeout",
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  metadata: {
    userId: 12345,
    endpoint: "/api/users",
    duration: 5000
  }
}

// Index TTL : logs conserv√©s 30 jours
db.app_logs.createIndex(
  { timestamp: 1 },
  { expireAfterSeconds: 2592000 }  // 30 jours
)
```

**Avantage** : Conformit√© avec politique de r√©tention, pas de croissance infinie.

### 4. Tokens de V√©rification

**Contexte** : Tokens d'email de v√©rification valides 24h

```javascript
// Collection verification_tokens
{
  _id: ObjectId("..."),
  userId: 5678,
  email: "user@example.com",
  token: "verify-abc123xyz789",
  type: "email_verification",
  createdAt: ISODate("2024-01-15T08:00:00Z")
}

// Index TTL : tokens valides 24 heures
db.verification_tokens.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 86400 }  // 24 heures
)

// V√©rification de token
function verifyEmail(token) {
  let doc = db.verification_tokens.findOne({ token: token });

  if (!doc) {
    return { error: "Token invalide ou expir√©" };
  }

  // Marquer l'email comme v√©rifi√©
  db.users.updateOne(
    { _id: doc.userId },
    { $set: { emailVerified: true } }
  );

  // Supprimer le token imm√©diatement apr√®s utilisation
  db.verification_tokens.deleteOne({ _id: doc._id });

  return { success: true };
}
```

**Avantage** : Nettoyage automatique des tokens non utilis√©s.

### 5. √âv√©nements Temporaires

**Contexte** : Notifications push qui expirent

```javascript
// Collection push_notifications
{
  _id: ObjectId("..."),
  userId: 12345,
  title: "Nouvelle promotion !",
  message: "50% de r√©duction jusqu'√† minuit",
  expiresAt: ISODate("2024-01-15T23:59:59Z"),  // Expire √† minuit
  sent: false,
  createdAt: ISODate("2024-01-15T10:00:00Z")
}

// Index TTL : suppression √† la date d'expiration
db.push_notifications.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 0 }
)
```

**Avantage** : Suppression automatique des notifications obsol√®tes.

### 6. Donn√©es de Tracking Temporaires

**Contexte** : Suivi d'√©v√©nements web (analytics)

```javascript
// Collection page_views
{
  _id: ObjectId("..."),
  sessionId: "sess_xyz",
  userId: 12345,
  page: "/products/laptop-123",
  timestamp: ISODate("2024-01-15T14:30:00Z"),
  duration: 45,  // secondes
  referrer: "https://google.com"
}

// Index TTL : donn√©es conserv√©es 90 jours (conformit√© RGPD)
db.page_views.createIndex(
  { timestamp: 1 },
  { expireAfterSeconds: 7776000 }  // 90 jours
)
```

**Avantage** : Conformit√© RGPD automatique (suppression apr√®s 90 jours).

### 7. Files d'Attente de T√¢ches

**Contexte** : T√¢ches qui doivent √™tre trait√©es ou expirer

```javascript
// Collection task_queue
{
  _id: ObjectId("..."),
  taskType: "send_email",
  payload: {
    to: "user@example.com",
    subject: "Welcome!",
    body: "..."
  },
  status: "pending",
  createdAt: ISODate("2024-01-15T10:00:00Z"),
  expiresAt: ISODate("2024-01-15T10:05:00Z")  // 5 minutes pour traiter
}

// Index TTL : t√¢ches non trait√©es expir√©es apr√®s 5 minutes
db.task_queue.createIndex(
  { expiresAt: 1 },
  { expireAfterSeconds: 0 }
)

// Worker traite les t√¢ches
function processTask() {
  let task = db.task_queue.findOne({ status: "pending" });

  if (task) {
    // Traiter la t√¢che
    executeTask(task);

    // Marquer comme compl√©t√©e ou supprimer
    db.task_queue.deleteOne({ _id: task._id });
  }
}
```

**Avantage** : Nettoyage automatique des t√¢ches non trait√©es.

---

## Limitations et Contraintes

### Exigences du Champ

#### Type de Donn√©es

‚úÖ **Permis** : Champ de type **Date**
```javascript
{
  createdAt: ISODate("2024-01-15T10:00:00Z")  // ‚úÖ Type Date
}
```

‚ùå **Interdit** : Autres types
```javascript
{
  createdAt: "2024-01-15T10:00:00Z"  // ‚ùå String
}
{
  createdAt: 1705315200000  // ‚ùå Timestamp (number)
}
{
  createdAt: null  // ‚ùå null
}
```

#### Champ Unique

Un seul champ de date par index TTL :

‚úÖ **Permis** :
```javascript
db.collection.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 3600 }
)
```

‚ùå **Interdit** :
```javascript
// Index TTL compos√© impossible
db.collection.createIndex(
  { createdAt: 1, userId: 1 },
  { expireAfterSeconds: 3600 }
)
```

### Index TTL et R√©plication

‚ö†Ô∏è **Attention** : Dans un Replica Set, le **Primary** effectue les suppressions TTL. Les secondaries r√©pliquent ces suppressions via l'oplog.

**Impact** :
- Pas de charge suppl√©mentaire sur les secondaries
- Les suppressions se propagent normalement

### Index TTL et Sharding

‚úÖ Les index TTL fonctionnent normalement dans un cluster shard√©.

**Comportement** :
- Chaque shard ex√©cute son propre thread TTL
- Supprime les documents expir√©s sur ce shard uniquement
- Ind√©pendant des autres shards

### Tableau ne peut pas avoir d'Index TTL

‚ùå **Impossible** : Le champ ne peut pas √™tre un tableau
```javascript
{
  dates: [
    ISODate("2024-01-15T10:00:00Z"),
    ISODate("2024-01-16T10:00:00Z")
  ]
}

// ‚ùå Index TTL sur un tableau ne fonctionne pas
db.collection.createIndex(
  { dates: 1 },
  { expireAfterSeconds: 3600 }
)
```

### Un Seul Index TTL par Collection

‚ö†Ô∏è **Limitation** : Vous pouvez avoir **plusieurs index TTL** sur une collection, mais chacun doit √™tre sur un **champ diff√©rent**.

‚úÖ **Permis** :
```javascript
// Index TTL #1 sur createdAt
db.docs.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })

// Index TTL #2 sur updatedAt
db.docs.createIndex({ updatedAt: 1 }, { expireAfterSeconds: 7200 })
```

**Comportement** : Le document sera supprim√© d√®s que **l'un des** crit√®res TTL est rempli.

---

## Modification d'un Index TTL

### Changer la Dur√©e d'Expiration

Utilisez la commande `collMod` :

```javascript
db.runCommand({
  collMod: "sessions",
  index: {
    keyPattern: { createdAt: 1 },
    expireAfterSeconds: 7200  // Nouvelle valeur : 2 heures
  }
})
```

**Exemple complet** :
```javascript
// Index initial : 30 minutes
db.sessions.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 1800 }
)

// Modifier pour 1 heure
db.runCommand({
  collMod: "sessions",
  index: {
    keyPattern: { createdAt: 1 },
    expireAfterSeconds: 3600
  }
})
```

### D√©sactiver Temporairement un Index TTL

Pour d√©sactiver sans supprimer l'index, d√©finissez une valeur tr√®s √©lev√©e :

```javascript
// D√©sactiver (en pratique)
db.runCommand({
  collMod: "logs",
  index: {
    keyPattern: { timestamp: 1 },
    expireAfterSeconds: 999999999  // ~31 ans
  }
})

// R√©activer plus tard
db.runCommand({
  collMod: "logs",
  index: {
    keyPattern: { timestamp: 1 },
    expireAfterSeconds: 2592000  // 30 jours
  }
})
```

### Supprimer un Index TTL

```javascript
// Par nom
db.sessions.dropIndex("createdAt_1")

// Par sp√©cification
db.sessions.dropIndex({ createdAt: 1 })
```

---

## Performance et Consid√©rations

### Avantages

‚úÖ **Automatique**
- Pas de script externe n√©cessaire
- MongoDB g√®re tout en arri√®re-plan

‚úÖ **Fiable**
- Ex√©cution garantie toutes les 60 secondes
- Pas de risque d'oubli

‚úÖ **Efficace**
- Suppression en lots
- Ne bloque pas les autres op√©rations

‚úÖ **Simple**
- Configuration en une ligne
- Aucune maintenance

### Inconv√©nients et Limitations

‚ùå **D√©lai de suppression**
```
Suppression pas instantan√©e : jusqu'√† 60 secondes de d√©lai
```

‚ùå **Impact sur les performances**
```
Si beaucoup de documents expirent simultan√©ment :
- Charge CPU/IO pour les suppressions
- Peut ralentir temporairement
```

‚ùå **Pas de notification**
```
Impossible de savoir quand un document est supprim√©
Pas de hook "onDelete"
```

‚ùå **Pas de granularit√© fine**
```
expireAfterSeconds minimum : 1 seconde
Pas de millisecondes
```

### Monitoring du Thread TTL

Surveillez le statut du thread TTL :

```javascript
// Statistiques de serveur
db.serverStatus().ttl
```

**R√©sultat** :
```json
{
  "passes": 1234,        // Nombre de passages du thread
  "deletedDocuments": 5678  // Documents supprim√©s au total
}
```

### Optimisation

Pour de grandes quantit√©s de suppressions :

1. **Partitionner par date**
   ```javascript
   // Au lieu d'une seule grande collection
   // Utiliser des collections par p√©riode
   db.logs_2024_01
   db.logs_2024_02
   // Supprimer la collection enti√®re (plus rapide)
   db.logs_2023_12.drop()
   ```

2. **Index compos√© pour requ√™tes fr√©quentes**
   ```javascript
   // Index TTL + index pour requ√™tes
   db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 2592000 })
   db.logs.createIndex({ level: 1, timestamp: -1 })
   ```

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **D√©finir des dur√©es appropri√©es**
   ```javascript
   // Sessions : 30 minutes - 2 heures
   db.sessions.createIndex({ lastActivityAt: 1 }, { expireAfterSeconds: 1800 })

   // Cache : 15 minutes - 1 heure
   db.cache.createIndex({ cachedAt: 1 }, { expireAfterSeconds: 900 })

   // Logs : 7-90 jours
   db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 2592000 })
   ```

2. **Utiliser des noms de champs coh√©rents**
   ```javascript
   // Conventions recommand√©es :
   // - createdAt : date de cr√©ation
   // - updatedAt : date de derni√®re modification
   // - lastAccessedAt : dernier acc√®s
   // - expiresAt : date d'expiration explicite
   ```

3. **Documenter la politique de r√©tention**
   ```javascript
   // Commentaire dans le code
   // Index TTL : sessions expir√©es apr√®s 30 min d'inactivit√©
   // Conformit√© : Politique de s√©curit√© interne
   db.sessions.createIndex(
     { lastActivityAt: 1 },
     { expireAfterSeconds: 1800 }
   )
   ```

4. **Tester avant production**
   ```javascript
   // Environnement de test
   db.test_sessions.createIndex(
     { createdAt: 1 },
     { expireAfterSeconds: 60 }  // 1 minute pour test
   )

   // V√©rifier que les suppressions fonctionnent
   db.test_sessions.insertOne({ createdAt: new Date() })
   // Attendre 2 minutes
   db.test_sessions.find()  // Doit √™tre vide
   ```

5. **Surveiller les m√©triques TTL**
   ```javascript
   // V√©rifier r√©guli√®rement
   db.serverStatus().ttl

   // Alerter si anomalies
   if (db.serverStatus().ttl.passes === previousPasses) {
     alert("Thread TTL bloqu√© !")
   }
   ```

6. **Combiner avec index de requ√™te**
   ```javascript
   // Index TTL
   db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 2592000 })

   // Index pour requ√™tes fr√©quentes
   db.logs.createIndex({ level: 1, service: 1, timestamp: -1 })
   ```

### ‚ùå √Ä √âviter

1. **Ne pas utiliser des dur√©es trop courtes**
   ```javascript
   // ‚ùå 1 seconde = trop court, charge excessive
   db.collection.createIndex({ date: 1 }, { expireAfterSeconds: 1 })

   // ‚úÖ Minimum recommand√© : 60 secondes
   db.collection.createIndex({ date: 1 }, { expireAfterSeconds: 60 })
   ```

2. **Ne pas compter sur une suppression instantan√©e**
   ```javascript
   // ‚ùå Mauvaise hypoth√®se
   db.tokens.insertOne({
     token: "abc",
     createdAt: new Date()
   })
   // Attendre 60 secondes
   // Supposer que le document n'existe plus ‚Üí FAUX !

   // ‚úÖ Toujours v√©rifier explicitement
   if (db.tokens.findOne({ token: "abc" })) {
     // Le document existe encore
   }
   ```

3. **Ne pas oublier le type Date**
   ```javascript
   // ‚ùå String au lieu de Date
   db.sessions.insertOne({
     createdAt: "2024-01-15T10:00:00Z"  // ‚ùå String
   })

   // ‚úÖ Utiliser new Date() ou ISODate()
   db.sessions.insertOne({
     createdAt: new Date()  // ‚úÖ Date
   })
   ```

4. **Ne pas cr√©er d'index TTL sur _id**
   ```javascript
   // ‚ùå _id contient un timestamp mais ce n'est pas un champ Date
   db.collection.createIndex({ _id: 1 }, { expireAfterSeconds: 3600 })
   // Ne fonctionnera pas !

   // ‚úÖ Utiliser un champ Date d√©di√©
   db.collection.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })
   ```

5. **Ne pas utiliser TTL pour des donn√©es importantes**
   ```javascript
   // ‚ùå Donn√©es m√©tier critiques
   db.orders.createIndex({ createdAt: 1 }, { expireAfterSeconds: 86400 })
   // Les commandes ne doivent PAS √™tre supprim√©es automatiquement !

   // ‚úÖ TTL uniquement pour donn√©es temporaires/transitoires
   ```

---

## Analyse et V√©rification

### V√©rifier les Index TTL

```javascript
db.sessions.getIndexes()
```

**R√©sultat** :
```json
[
  {
    "v": 2,
    "key": { "createdAt": 1 },
    "name": "createdAt_1",
    "expireAfterSeconds": 1800  // ‚úÖ Index TTL de 30 min
  }
]
```

### Surveiller les Suppressions TTL

```javascript
// Statistiques du serveur
db.serverStatus().ttl
```

**R√©sultat** :
```json
{
  "passes": 15234,           // Nombre de passages du thread
  "deletedDocuments": 128456  // Total de documents supprim√©s
}
```

### Tester un Index TTL

```javascript
// 1. Cr√©er un index TTL de test (10 secondes)
db.test_ttl.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 10 }
)

// 2. Ins√©rer un document
db.test_ttl.insertOne({
  message: "Test TTL",
  createdAt: new Date()
})

// 3. V√©rifier imm√©diatement
db.test_ttl.find()  // Document pr√©sent

// 4. Attendre 70 secondes (10s expiration + 60s thread)
// ...

// 5. V√©rifier √† nouveau
db.test_ttl.find()  // Document supprim√© (collection vide)

// 6. Nettoyer
db.test_ttl.drop()
```

### Calculer le Nombre de Documents Expir√©s

```javascript
// Compter les documents qui devraient √™tre expir√©s
const cutoff = new Date(Date.now() - 1800 * 1000);  // 30 min ago

db.sessions.countDocuments({
  createdAt: { $lt: cutoff }
})
```

---

## Cas Pratique Complet

### Sc√©nario : Syst√®me de R√©servation en Ligne

**Contexte** : Application de r√©servation de restaurants avec paniers temporaires

```javascript
// Collection reservation_carts (paniers de r√©servation)
{
  _id: ObjectId("..."),
  userId: 12345,
  restaurantId: "rest-789",
  guests: 4,
  date: ISODate("2024-01-20T19:00:00Z"),
  items: [
    { name: "Entr√©e", price: 12 },
    { name: "Plat", price: 25 }
  ],
  total: 37,
  createdAt: ISODate("2024-01-15T14:00:00Z"),
  status: "pending"
}

// Index TTL : paniers abandonn√©s expir√©s apr√®s 15 minutes
db.reservation_carts.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 900 }  // 15 minutes
)

// Collection confirmations (r√©servations confirm√©es)
{
  _id: ObjectId("..."),
  cartId: ObjectId("..."),
  userId: 12345,
  restaurantId: "rest-789",
  confirmationCode: "CONF-ABC123",
  confirmedAt: ISODate("2024-01-15T14:10:00Z"),
  status: "confirmed"
}
// Pas d'index TTL - les confirmations sont permanentes

// Collection verification_tokens (tokens de confirmation email)
{
  _id: ObjectId("..."),
  cartId: ObjectId("..."),
  email: "user@example.com",
  token: "verify-xyz789",
  createdAt: ISODate("2024-01-15T14:05:00Z")
}

// Index TTL : tokens expir√©s apr√®s 1 heure
db.verification_tokens.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 3600 }  // 1 heure
)
```

**Flux complet** :

1. **Utilisateur cr√©e un panier** (expire apr√®s 15 min)
2. **Email de confirmation envoy√©** avec token (expire apr√®s 1h)
3. **Si confirmation** ‚Üí Panier converti en r√©servation (supprim√© manuellement)
4. **Si pas de confirmation** ‚Üí Panier et token supprim√©s automatiquement par TTL

---

## Conclusion

Les **index TTL** sont un outil puissant et simple pour g√©rer automatiquement l'expiration et la suppression de documents temporaires dans MongoDB. Ils √©liminent le besoin de scripts de nettoyage manuels et garantissent que vos collections ne croissent pas ind√©finiment avec des donn√©es obsol√®tes.

### Points Cl√©s √† Retenir

- ‚úÖ Index TTL = Suppression automatique apr√®s d√©lai
- ‚úÖ Syntaxe : `createIndex({ date: 1 }, { expireAfterSeconds: X })`
- ‚úÖ Champ doit √™tre de type **Date**
- ‚úÖ Suppression toutes les **60 secondes** (d√©lai possible)
- ‚úÖ `expireAfterSeconds: 0` = suppression √† la date sp√©cifi√©e
- ‚úÖ Modifiable avec `collMod`
- ‚úÖ Un seul champ par index TTL
- ‚úÖ Fonctionne en r√©plication et sharding
- ‚úÖ Parfait pour sessions, cache, logs, tokens

### Cas d'Usage Typiques

- üîê Sessions utilisateur (30 min - 2h)
- üíæ Cache temporaire (15 min - 1h)
- üìù Logs applicatifs (7-90 jours)
- üîë Tokens de v√©rification (1-24h)
- üìÖ √âv√©nements temporaires (date sp√©cifique)
- üìä Donn√©es analytics (90 jours - RGPD)
- üìã Files d'attente de t√¢ches (minutes)

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les index TTL, explorez :
- **[Index partiel](./04.2-index-partiel.md)** : Indexer un sous-ensemble de documents
- **[Index unique](./04.1-index-unique.md)** : Garantir l'unicit√© des valeurs
- **[Strat√©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avanc√©es
- **[Capped Collections](/16-fonctionnalites-avancees/03-capped-collections.md)** : Alternative pour logs

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - TTL Indexes](https://docs.mongodb.com/manual/core/index-ttl/)
- [Expire Data from Collections](https://docs.mongodb.com/manual/tutorial/expire-data/)
- [TTL Index Limitations](https://docs.mongodb.com/manual/core/index-ttl/#limitations)
- [collMod Command](https://docs.mongodb.com/manual/reference/command/collMod/)

‚è≠Ô∏è [Options et modificateurs d'index](/05-index-et-optimisation/04-options-modificateurs-index.md)
