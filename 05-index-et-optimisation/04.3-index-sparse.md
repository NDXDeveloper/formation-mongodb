ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.3 Index Sparse

## Introduction

Un **index sparse** (ou **Sparse Index**) est un index qui n'inclut que les documents oÃ¹ le **champ indexÃ© existe** et a une **valeur non-null**. Les documents oÃ¹ le champ est absent, `null`, ou `undefined` sont **exclus** de l'index.

Les index sparse sont essentiels pour :
- **Champs optionnels** : Indexer uniquement les documents qui ont le champ
- **RÃ©duire la taille des index** : Exclure les documents sans valeur
- **UnicitÃ© conditionnelle** : Permettre plusieurs documents sans le champ
- **Performance** : Index plus petits et plus rapides

C'est l'Ã©quivalent d'un filtre automatique : "N'indexe que les documents qui ont une valeur pour ce champ".

---

## Le ProblÃ¨me : Champs Optionnels

### Sans Index Sparse

Imaginons une collection d'utilisateurs oÃ¹ le numÃ©ro de tÃ©lÃ©phone est **optionnel** :

```javascript
// Collection users
{
  _id: 1,
  username: "alice",
  email: "alice@example.com",
  phoneNumber: "+33612345678"  // TÃ©lÃ©phone prÃ©sent
}

{
  _id: 2,
  username: "bob",
  email: "bob@example.com"
  // phoneNumber absent (optionnel)
}

{
  _id: 3,
  username: "charlie",
  email: "charlie@example.com",
  phoneNumber: null  // Explicitement null
}
```

**ProblÃ¨me 1 : Index classique**

```javascript
// Index classique sur phoneNumber
db.users.createIndex({ phoneNumber: 1 })
```

**ConsÃ©quences** :
- âœ… Documents avec tÃ©lÃ©phone : IndexÃ©s
- âš ï¸ Documents sans tÃ©lÃ©phone : IndexÃ©s avec valeur `null`
- âš ï¸ Index contient TOUS les documents (mÃªme sans tÃ©lÃ©phone)
- âš ï¸ Gaspillage d'espace si beaucoup n'ont pas de tÃ©lÃ©phone

**ProblÃ¨me 2 : Index unique classique**

```javascript
// Index unique sur phoneNumber
db.users.createIndex({ phoneNumber: 1 }, { unique: true })

// âœ… Premier utilisateur sans tÃ©lÃ©phone
db.users.insertOne({ username: "david", email: "david@example.com" })

// âŒ DeuxiÃ¨me utilisateur sans tÃ©lÃ©phone
db.users.insertOne({ username: "eve", email: "eve@example.com" })
// ERREUR : Duplicate key error (null)
```

**Explication** :
```
User 1 : phoneNumber = null
User 2 : phoneNumber = null
â†’ Doublon sur null â†’ ERREUR !
```

MongoDB considÃ¨re `null` comme une valeur, donc un index unique n'autorise qu'**un seul document** avec `null`.

### Avec Index Sparse âœ…

```javascript
// Index sparse sur phoneNumber
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })
```

**RÃ©sultat** :
- âœ… Documents **avec** tÃ©lÃ©phone : IndexÃ©s
- âœ… Documents **sans** tÃ©lÃ©phone : **Exclus** de l'index
- âœ… Index plus petit (seulement documents pertinents)
- âœ… Plusieurs documents peuvent ne pas avoir de tÃ©lÃ©phone

**Index unique + sparse** :

```javascript
// Index unique sparse sur phoneNumber
db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })

// âœ… Plusieurs utilisateurs sans tÃ©lÃ©phone
db.users.insertOne({ username: "alice", email: "alice@example.com" })
db.users.insertOne({ username: "bob", email: "bob@example.com" })
db.users.insertOne({ username: "charlie", email: "charlie@example.com" })
// Tous acceptÃ©s (pas dans l'index)

// âœ… TÃ©lÃ©phones uniques si prÃ©sents
db.users.insertOne({ username: "dave", phoneNumber: "+33612345678" })
db.users.insertOne({ username: "eve", phoneNumber: "+33698765432" })

// âŒ TÃ©lÃ©phone dupliquÃ©
db.users.insertOne({ username: "frank", phoneNumber: "+33612345678" })
// ERREUR : Duplicate key (tÃ©lÃ©phone dÃ©jÃ  utilisÃ©)
```

---

## Qu'est-ce qu'un Index Sparse ?

### Analogie : L'Annuaire TÃ©lÃ©phonique

Imaginez un annuaire tÃ©lÃ©phonique :

**Annuaire classique** = Index standard
```
Contient TOUTES les personnes :
- Alice : +33612345678
- Bob : (pas de numÃ©ro) â†’ entrÃ©e vide
- Charlie : (pas de numÃ©ro) â†’ entrÃ©e vide
- Dave : +33698765432
â†’ EntrÃ©es inutiles pour personnes sans numÃ©ro
```

**Annuaire compact** = Index sparse
```
Contient SEULEMENT les personnes avec numÃ©ro :
- Alice : +33612345678
- Dave : +33698765432
â†’ Plus compact, seulement les entrÃ©es utiles
```

### Principe de Fonctionnement

Un index sparse Ã©value chaque document :

```
Document â†’ Le champ existe et n'est pas null ?
                    â†“
              Oui   |   Non
               â†“         â†“
          Indexer   Ne pas indexer
```

**Valeurs considÃ©rÃ©es comme "absentes"** :
- Champ n'existe pas dans le document
- Champ = `null`
- Champ = `undefined`

**Valeurs indexÃ©es** :
- Toutes les autres valeurs (string, number, date, objet, tableau, etc.)
- Y compris les valeurs "fausses" comme `false`, `0`, `""`

---

## Syntaxe de CrÃ©ation

### Syntaxe de Base

```javascript
db.collection.createIndex(
  { champ: 1 },
  { sparse: true }
)
```

### Exemples de Base

#### Exemple 1 : NumÃ©ro de TÃ©lÃ©phone Optionnel

```javascript
// Index sparse sur phoneNumber
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })

// Documents
{ username: "alice", phoneNumber: "+33612345678" }  // âœ… IndexÃ©
{ username: "bob" }                                 // âŒ Non indexÃ©
{ username: "charlie", phoneNumber: null }          // âŒ Non indexÃ©
```

#### Exemple 2 : Date d'Expiration Optionnelle

```javascript
// Index sparse sur expiresAt
db.tokens.createIndex({ expiresAt: 1 }, { sparse: true })

// Documents
{ token: "abc123", expiresAt: ISODate("2024-02-01") }  // âœ… IndexÃ©
{ token: "xyz789" }                                     // âŒ Non indexÃ©
{ token: "def456", expiresAt: null }                    // âŒ Non indexÃ©
```

#### Exemple 3 : ID de Connexion Sociale Optionnel

```javascript
// Index sparse sur googleId
db.users.createIndex({ googleId: 1 }, { sparse: true })

// Documents
{ username: "alice", googleId: "google-123456" }  // âœ… IndexÃ©
{ username: "bob" }                                // âŒ Non indexÃ© (connexion locale)
{ username: "charlie", googleId: null }            // âŒ Non indexÃ©
```

---

## Comportement DÃ©taillÃ©

### Valeurs IndexÃ©es vs Non IndexÃ©es

```javascript
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })

// âœ… IndexÃ© (valeur prÃ©sente)
{ username: "alice", phoneNumber: "+33612345678" }

// âœ… IndexÃ© (mÃªme si chaÃ®ne vide)
{ username: "bob", phoneNumber: "" }

// âœ… IndexÃ© (mÃªme si 0)
{ username: "charlie", phoneNumber: 0 }

// âœ… IndexÃ© (mÃªme si false)
{ username: "dave", phoneNumber: false }

// âŒ Non indexÃ© (champ absent)
{ username: "eve" }

// âŒ Non indexÃ© (null)
{ username: "frank", phoneNumber: null }

// âŒ Non indexÃ© (undefined)
{ username: "grace", phoneNumber: undefined }
```

**Important** : Les valeurs "fausses" (`""`, `0`, `false`) sont **indexÃ©es** car elles existent et ne sont pas `null`.

### Impact sur les RequÃªtes

#### RequÃªtes avec Valeur SpÃ©cifique

```javascript
// Index sparse sur phoneNumber
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })

// âœ… Utilise l'index (recherche de valeur)
db.users.find({ phoneNumber: "+33612345678" })

// âœ… Utilise l'index (plage sur valeurs existantes)
db.users.find({ phoneNumber: { $gte: "+33600000000" } })
```

#### RequÃªtes sur Valeurs Null ou Absentes

```javascript
// âš ï¸ Ne peut PAS utiliser l'index sparse
db.users.find({ phoneNumber: null })
db.users.find({ phoneNumber: { $exists: false } })

// RÃ©sultat : COLLSCAN (scan de collection complet)
```

**Explication** : L'index sparse n'inclut pas les documents avec `phoneNumber: null` ou absent, donc il ne peut pas Ãªtre utilisÃ© pour ces requÃªtes.

#### RequÃªtes sans Filtre sur le Champ Sparse

```javascript
// âš ï¸ Ne peut PAS utiliser l'index sparse pour le tri
db.users.find().sort({ phoneNumber: 1 })

// RÃ©sultat : In-memory sort ou COLLSCAN
```

**Explication** : Pour trier tous les documents, MongoDB doit inclure ceux sans `phoneNumber`, qui ne sont pas dans l'index sparse.

---

## Index Sparse + Unique : La Combinaison Puissante

### Le Cas d'Usage Principal

La combinaison **sparse + unique** est extrÃªmement utile pour les **champs optionnels qui doivent Ãªtre uniques s'ils existent** :

```javascript
db.users.createIndex(
  { phoneNumber: 1 },
  { unique: true, sparse: true }
)
```

**Comportement** :
- âœ… Plusieurs documents **sans** tÃ©lÃ©phone : AutorisÃ©s
- âœ… TÃ©lÃ©phones **uniques** si prÃ©sents : Garantis
- âŒ TÃ©lÃ©phones **dupliquÃ©s** : Interdits

### Exemples Pratiques

#### Exemple 1 : Connexions Sociales Optionnelles

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  googleId: "google-123456789",  // Optionnel
  facebookId: null,               // Optionnel
  githubId: null                  // Optionnel
}

// Index unique sparse sur chaque provider
db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ facebookId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ githubId: 1 }, { unique: true, sparse: true })
```

**RÃ©sultat** :
- âœ… Utilisateurs sans connexion sociale : OK (plusieurs)
- âœ… googleId unique si prÃ©sent
- âœ… facebookId unique si prÃ©sent
- âœ… Un utilisateur peut avoir 0, 1, 2, ou 3 connexions

#### Exemple 2 : NumÃ©ro de TVA (Entreprises)

```javascript
// Collection organizations
{
  _id: ObjectId("..."),
  name: "Company A",
  type: "business",
  vatNumber: "FR12345678901"  // Seulement pour entreprises
}

{
  _id: ObjectId("..."),
  name: "John Doe",
  type: "individual"
  // Pas de vatNumber (particulier)
}

// Index unique sparse sur vatNumber
db.organizations.createIndex({ vatNumber: 1 }, { unique: true, sparse: true })
```

**RÃ©sultat** :
- âœ… Particuliers sans TVA : OK (plusieurs)
- âœ… NumÃ©ros de TVA uniques pour entreprises

#### Exemple 3 : Codes Promo Uniques

```javascript
// Collection orders
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001",
  customerId: 12345,
  total: 299.99,
  promoCode: "WINTER2024"  // Optionnel
}

{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-002",
  customerId: 67890,
  total: 149.99
  // Pas de promoCode
}

// Index unique sparse : un code promo ne peut Ãªtre utilisÃ© qu'une fois
db.orders.createIndex({ promoCode: 1 }, { unique: true, sparse: true })
```

**RÃ©sultat** :
- âœ… Commandes sans code promo : OK (plusieurs)
- âœ… Chaque code promo utilisable une seule fois

---

## Sparse vs Index Classique

### Comparaison Visuelle

**Collection avec 5 utilisateurs** :

```javascript
// Documents
{ _id: 1, username: "alice", phoneNumber: "+33612345678" }
{ _id: 2, username: "bob" }  // Pas de phoneNumber
{ _id: 3, username: "charlie", phoneNumber: "+33698765432" }
{ _id: 4, username: "dave" }  // Pas de phoneNumber
{ _id: 5, username: "eve", phoneNumber: null }
```

**Index classique** :
```
phoneNumber Index (5 entrÃ©es) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ null         â†’ [2, 4, 5]     â”‚
â”‚ +33612345678 â†’ [1]           â”‚
â”‚ +33698765432 â†’ [3]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Taille : 5 entrÃ©es
```

**Index sparse** :
```
phoneNumber Index (2 entrÃ©es) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ +33612345678 â†’ [1]           â”‚
â”‚ +33698765432 â†’ [3]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Taille : 2 entrÃ©es (60% plus petit !)
```

### Tableau Comparatif

| CritÃ¨re | Index Classique | Index Sparse |
|---------|----------------|--------------|
| **Documents indexÃ©s** | Tous (100%) | Seulement avec valeur non-null |
| **Taille** | Plus grand | Plus petit |
| **RequÃªte = valeur** | âœ… Rapide | âœ… Rapide |
| **RequÃªte = null** | âœ… Utilise index | âŒ Ne peut pas utiliser |
| **RequÃªte $exists: false** | âœ… Utilise index | âŒ Ne peut pas utiliser |
| **Tri tous documents** | âœ… Utilise index | âŒ Ne peut pas utiliser |
| **Unique + null multiple** | âŒ 1 seul null | âœ… Plusieurs null/absents |
| **Cas d'usage** | Champ obligatoire | Champ optionnel |

---

## Sparse vs Partial : Quelle DiffÃ©rence ?

### Index Sparse

```javascript
// Index sparse : exclut null et champs absents
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })
```

**Ã‰quivalent avec index partiel** :
```javascript
db.users.createIndex(
  { phoneNumber: 1 },
  {
    partialFilterExpression: {
      phoneNumber: { $exists: true, $ne: null }
    }
  }
)
```

### Index Partial

```javascript
// Index partiel : filtre personnalisÃ©
db.users.createIndex(
  { phoneNumber: 1 },
  {
    partialFilterExpression: {
      phoneVerified: true  // Condition personnalisÃ©e
    }
  }
)
```

### Comparaison

| CritÃ¨re | Sparse | Partial |
|---------|--------|---------|
| **Syntaxe** | `sparse: true` | `partialFilterExpression: {...}` |
| **Condition** | Fixe (champ existe et â‰  null) | Personnalisable |
| **FlexibilitÃ©** | LimitÃ©e | Totale |
| **SimplicitÃ©** | âœ… TrÃ¨s simple | âš ï¸ Plus complexe |
| **Cas d'usage** | Champs optionnels | Filtres complexes |
| **Peut combiner** | Oui (avec unique, etc.) | Oui |

**Quand utiliser quoi** :

```
Champ optionnel simple (null/absent) â†’ sparse

Filtre complexe (status, date, etc.) â†’ partial

Les deux sont possibles â†’ sparse (plus simple)
```

---

## Cas d'Usage Pratiques

### 1. Champs de Contact Optionnels

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",  // Obligatoire
  phoneNumber: "+33612345678",  // Optionnel
  secondaryEmail: null,          // Optionnel
  address: null                  // Optionnel
}

// Index unique sur email (obligatoire)
db.users.createIndex({ email: 1 }, { unique: true })

// Index unique sparse sur champs optionnels
db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })
db.users.createIndex({ secondaryEmail: 1 }, { unique: true, sparse: true })
```

### 2. Identifiants Externes Optionnels

```javascript
// Collection products avec rÃ©fÃ©rences externes optionnelles
{
  _id: ObjectId("..."),
  name: "Product A",
  sku: "PROD-001",
  externalId: "EXT-12345",      // ID dans systÃ¨me externe (optionnel)
  supplierCode: "SUPP-ABC-001"  // Code fournisseur (optionnel)
}

// Index unique sparse sur identifiants externes
db.products.createIndex({ externalId: 1 }, { unique: true, sparse: true })
db.products.createIndex({ supplierCode: 1 }, { unique: true, sparse: true })
```

### 3. MÃ©tadonnÃ©es Optionnelles

```javascript
// Collection documents avec mÃ©tadonnÃ©es variables
{
  _id: ObjectId("..."),
  title: "Document A",
  author: "John Doe",
  isbn: "978-1234567890",  // Seulement pour livres (optionnel)
  doi: null,               // Seulement pour articles scientifiques (optionnel)
  patentNumber: null       // Seulement pour brevets (optionnel)
}

// Index sparse pour recherche rapide quand prÃ©sent
db.documents.createIndex({ isbn: 1 }, { sparse: true })
db.documents.createIndex({ doi: 1 }, { sparse: true })
db.documents.createIndex({ patentNumber: 1 }, { sparse: true })
```

### 4. Dates Optionnelles

```javascript
// Collection tasks
{
  _id: ObjectId("..."),
  title: "Complete project",
  status: "in_progress",
  createdAt: ISODate("2024-01-15"),
  completedAt: null  // Seulement quand terminÃ© (optionnel)
}

// Index sparse sur completedAt
db.tasks.createIndex({ completedAt: -1 }, { sparse: true })

// Recherche des tÃ¢ches terminÃ©es (rapide)
db.tasks.find({ completedAt: { $exists: true } }).sort({ completedAt: -1 })
```

### 5. RÃ©fÃ©rences Optionnelles

```javascript
// Collection posts avec mentions optionnelles
{
  _id: ObjectId("..."),
  content: "Great article!",
  authorId: 12345,
  replyToPostId: ObjectId("..."),  // Optionnel (null si post original)
  createdAt: ISODate("2024-01-15")
}

// Index sparse pour retrouver rÃ©ponses rapidement
db.posts.createIndex({ replyToPostId: 1, createdAt: -1 }, { sparse: true })

// Trouver toutes les rÃ©ponses Ã  un post
db.posts.find({
  replyToPostId: originalPostId
}).sort({ createdAt: -1 })
```

### 6. DonnÃ©es d'Abonnement Optionnelles

```javascript
// Collection users avec abonnement premium optionnel
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  subscriptionId: "SUB-ABC-123",  // Optionnel (null si gratuit)
  subscriptionEndsAt: ISODate("2024-12-31")  // Optionnel
}

// Index sparse sur abonnement
db.users.createIndex({ subscriptionId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ subscriptionEndsAt: 1 }, { sparse: true })

// Trouver abonnements qui expirent bientÃ´t
db.users.find({
  subscriptionEndsAt: {
    $gte: new Date(),
    $lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)  // 7 jours
  }
})
```

---

## Index Sparse ComposÃ©

### Syntaxe

```javascript
db.collection.createIndex(
  { champ1: 1, champ2: 1 },
  { sparse: true }
)
```

### Comportement

Un index sparse composÃ© exclut un document si **au moins un** des champs indexÃ©s est absent ou null :

```javascript
// Index sparse composÃ©
db.locations.createIndex(
  { latitude: 1, longitude: 1 },
  { sparse: true }
)

// âœ… IndexÃ© (les deux champs prÃ©sents)
{ name: "Paris", latitude: 48.8566, longitude: 2.3522 }

// âŒ Non indexÃ© (latitude null)
{ name: "Unknown", latitude: null, longitude: 2.3522 }

// âŒ Non indexÃ© (longitude absent)
{ name: "Unknown", latitude: 48.8566 }

// âŒ Non indexÃ© (les deux absents)
{ name: "Unknown" }
```

### Exemple Pratique

```javascript
// Collection events avec localisation optionnelle
{
  _id: ObjectId("..."),
  name: "MongoDB Conference",
  date: ISODate("2024-06-15"),
  location: {
    latitude: 48.8566,
    longitude: 2.3522
  }
}

{
  _id: ObjectId("..."),
  name: "Online Webinar",
  date: ISODate("2024-06-20")
  // Pas de location (Ã©vÃ©nement en ligne)
}

// Index sparse composÃ© sur coordonnÃ©es
db.events.createIndex(
  { "location.latitude": 1, "location.longitude": 1 },
  { sparse: true }
)

// Recherche d'Ã©vÃ©nements proches d'une position
db.events.find({
  "location.latitude": { $gte: 48.0, $lte: 49.0 },
  "location.longitude": { $gte: 2.0, $lte: 3.0 }
})
```

---

## Limitations et Contraintes

### RequÃªtes Non OptimisÃ©es

```javascript
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })

// âŒ Ces requÃªtes ne peuvent PAS utiliser l'index sparse :

// Recherche de null
db.users.find({ phoneNumber: null })

// Recherche de champs absents
db.users.find({ phoneNumber: { $exists: false } })

// Tri de tous les documents
db.users.find().sort({ phoneNumber: 1 })
```

**Raison** : L'index ne contient pas les documents avec `phoneNumber: null` ou absent.

### Solution : Index Classique SupplÃ©mentaire

Si vous devez rechercher Ã  la fois les valeurs et les null :

```javascript
// Index sparse pour valeurs (petit et rapide)
db.users.createIndex({ phoneNumber: 1 }, { sparse: true })

// Index classique pour requÃªtes gÃ©nÃ©rales (si nÃ©cessaire)
db.users.createIndex({ phoneNumber: 1 })
```

âš ï¸ **Attention** : Deux index sur le mÃªme champ consomment plus d'espace.

### Index Sparse et Couverture de RequÃªte

Un index sparse ne peut **pas couvrir** une requÃªte qui retourne tous les documents :

```javascript
db.users.createIndex({ phoneNumber: 1, username: 1 }, { sparse: true })

// âŒ Pas une covered query (doit accÃ©der aux documents sans phoneNumber)
db.users.find({}, { phoneNumber: 1, username: 1, _id: 0 })
```

---

## Performance et ConsidÃ©rations

### Avantages

âœ… **Taille rÃ©duite**
```
Collection : 1 million d'utilisateurs
- 300k avec tÃ©lÃ©phone (30%)
- 700k sans tÃ©lÃ©phone (70%)

Index classique : 1 million d'entrÃ©es
Index sparse : 300k entrÃ©es
â†’ 70% d'espace Ã©conomisÃ© !
```

âœ… **Recherches plus rapides**
- Index plus petit = plus rapide
- Tient mieux en mÃ©moire RAM
- Moins de donnÃ©es Ã  parcourir

âœ… **Moins d'impact sur les Ã©critures**
- Documents sans champ : Pas d'opÃ©ration d'index
- Insertions/mises Ã  jour plus rapides pour documents incomplets

âœ… **UnicitÃ© conditionnelle**
- Combine unique + sparse pour champs optionnels uniques
- TrÃ¨s utile pour identifiants externes

### InconvÃ©nients

âŒ **Ne peut pas optimiser toutes les requÃªtes**
```javascript
// RequÃªtes sur null/absent : Pas optimisÃ©es
db.users.find({ phoneNumber: null })
db.users.find({ phoneNumber: { $exists: false } })
```

âŒ **Tri limitÃ©**
```javascript
// Tri de tous documents : Pas optimisÃ©
db.users.find().sort({ phoneNumber: 1 })
```

âŒ **ComplexitÃ© potentielle**
- Doit comprendre quand l'index est utilisÃ©
- Documentation nÃ©cessaire

### Quand Utiliser un Index Sparse

âœ… **Utilisez sparse quand** :

1. **Champ optionnel**
   - Beaucoup de documents n'ont pas le champ
   - > 30% sans le champ â†’ Ã‰conomies significatives

2. **Besoin d'unicitÃ© conditionnelle**
   - Le champ doit Ãªtre unique s'il existe
   - Plusieurs documents peuvent ne pas l'avoir

3. **Recherche sur valeurs prÃ©sentes**
   - Vous ne cherchez jamais null ou champs absents
   - Focus sur documents avec valeur

4. **Optimisation espace/performance**
   - Espace disque limitÃ©
   - Besoin de performances maximales

âŒ **N'utilisez PAS sparse quand** :

1. **Champ obligatoire**
   - Tous les documents ont le champ
   - Pas d'Ã©conomies

2. **Recherche frÃ©quente de null**
   - Vous cherchez souvent les documents sans valeur
   - Index sparse n'aide pas

3. **Tri de tous documents nÃ©cessaire**
   - Besoin de trier incluant documents sans valeur
   - Index sparse pas utilisable

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Utiliser pour champs optionnels**
   ```javascript
   // Champs de contact optionnels
   db.users.createIndex({ phoneNumber: 1 }, { sparse: true })
   db.users.createIndex({ secondaryEmail: 1 }, { sparse: true })
   ```

2. **Combiner avec unique pour identifiants optionnels**
   ```javascript
   // Connexions sociales optionnelles mais uniques
   db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })
   db.users.createIndex({ facebookId: 1 }, { unique: true, sparse: true })
   ```

3. **Documenter clairement**
   ```javascript
   // Index sparse : phoneNumber optionnel
   // Utilisateurs sans tÃ©lÃ©phone : Non indexÃ©s (OK)
   // Ã‰conomie : ~70% si 70% sans tÃ©lÃ©phone
   db.users.createIndex({ phoneNumber: 1 }, { sparse: true })
   ```

4. **VÃ©rifier avec explain()**
   ```javascript
   // VÃ©rifier que l'index est utilisÃ©
   db.users.find({ phoneNumber: "+33612345678" })
     .explain("executionStats")
   ```

5. **Calculer les Ã©conomies**
   ```javascript
   // Documents total
   let total = db.users.countDocuments()

   // Documents avec phoneNumber
   let withPhone = db.users.countDocuments({
     phoneNumber: { $exists: true, $ne: null }
   })

   // Pourcentage Ã©conomisÃ©
   let saved = ((total - withPhone) / total * 100).toFixed(2)
   console.log(`Ã‰conomie : ${saved}%`)
   ```

6. **Utiliser pour rÃ©fÃ©rences optionnelles**
   ```javascript
   // Index sparse sur champs de relation optionnelle
   db.posts.createIndex({ replyToPostId: 1 }, { sparse: true })
   db.tasks.createIndex({ parentTaskId: 1 }, { sparse: true })
   ```

### âŒ Ã€ Ã‰viter

1. **Ne pas utiliser sur champs obligatoires**
   ```javascript
   // âŒ Email obligatoire : pas besoin de sparse
   db.users.createIndex({ email: 1 }, { sparse: true })

   // âœ… Email obligatoire : index classique
   db.users.createIndex({ email: 1 }, { unique: true })
   ```

2. **Ne pas oublier les limitations de requÃªte**
   ```javascript
   // âŒ Cette requÃªte n'utilise pas l'index sparse
   db.users.find({ phoneNumber: null })

   // Si vous cherchez souvent null :
   // â†’ N'utilisez pas sparse, utilisez index classique
   ```

3. **Ne pas combiner sparse avec TTL**
   ```javascript
   // âŒ TTL + sparse : problÃ©matique
   // Documents sans champ ne sont pas dans l'index
   // Donc pas supprimÃ©s par TTL !
   db.sessions.createIndex(
     { expiresAt: 1 },
     { expireAfterSeconds: 3600, sparse: true }
   )
   ```

4. **Ne pas crÃ©er sparse si < 20% sans valeur**
   ```javascript
   // Si 90% des documents ont le champ :
   // â†’ Ã‰conomies limitÃ©es (10%)
   // â†’ ComplexitÃ© pas justifiÃ©e
   // â†’ Utilisez index classique
   ```

5. **Ne pas oublier de valider les donnÃ©es**
   ```javascript
   // Sparse permet null, mais validez dans votre application
   function createUser(userData) {
     // âœ… Valider format si phoneNumber prÃ©sent
     if (userData.phoneNumber && !isValidPhone(userData.phoneNumber)) {
       throw new Error("Format de tÃ©lÃ©phone invalide");
     }

     return db.users.insertOne(userData);
   }
   ```

---

## Analyse et VÃ©rification

### VÃ©rifier les Index Sparse

```javascript
// Lister tous les index
db.users.getIndexes()

// Filtrer les index sparse
db.users.getIndexes().filter(idx => idx.sparse === true)
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "phoneNumber": 1 },
    "name": "phoneNumber_1",
    "sparse": true
  }
]
```

### Tester l'Index Sparse

```javascript
// Test 1 : Insertion avec valeur (devrait Ãªtre indexÃ©)
db.test_users.insertOne({
  username: "alice",
  phoneNumber: "+33612345678"
})

// Test 2 : Insertion sans valeur (ne devrait pas Ãªtre indexÃ©)
db.test_users.insertOne({
  username: "bob"
})

// Test 3 : VÃ©rifier avec explain()
db.test_users.find({ phoneNumber: "+33612345678" })
  .explain("executionStats")
// Devrait utiliser l'index

db.test_users.find({ phoneNumber: null })
  .explain("executionStats")
// Ne devrait PAS utiliser l'index (COLLSCAN)

// Nettoyer
db.test_users.drop()
```

### Calculer l'EfficacitÃ©

```javascript
// Statistiques de collection
let stats = db.users.stats()

// Total de documents
let totalDocs = stats.count

// Documents dans l'index sparse
let docsWithPhone = db.users.countDocuments({
  phoneNumber: { $exists: true, $ne: null }
})

// Taille de l'index
let indexSize = stats.indexSizes["phoneNumber_1"]

// Calculs
let percentageIndexed = (docsWithPhone / totalDocs * 100).toFixed(2)
let percentageSaved = ((totalDocs - docsWithPhone) / totalDocs * 100).toFixed(2)

console.log(`Documents indexÃ©s : ${percentageIndexed}%`)
console.log(`Espace Ã©conomisÃ© : ${percentageSaved}%`)
console.log(`Taille de l'index : ${indexSize} bytes`)
```

---

## Conclusion

Les **index sparse** sont un outil simple mais puissant pour optimiser les index sur des champs optionnels. En n'indexant que les documents avec une valeur, ils rÃ©duisent la taille des index, amÃ©liorent les performances et permettent l'unicitÃ© conditionnelle.

### Points ClÃ©s Ã  Retenir

- âœ… Index sparse = N'indexe que documents avec valeur non-null
- âœ… Syntaxe : `createIndex({ field: 1 }, { sparse: true })`
- âœ… Exclut : null, undefined, champ absent
- âœ… Indexe : Toutes autres valeurs (mÃªme `""`, `0`, `false`)
- âœ… Parfait pour champs optionnels
- âœ… Combine avec unique pour unicitÃ© conditionnelle
- âœ… RÃ©duit taille, amÃ©liore performances
- âœ… Ne peut pas optimiser recherches de null/absent
- âœ… Ne peut pas optimiser tri de tous documents
- âœ… Plus simple que partial pour cas basique (null/absent)

### Cas d'Usage Typiques

- ğŸ“± NumÃ©ros de tÃ©lÃ©phone optionnels
- âœ‰ï¸ Emails secondaires
- ğŸŒ IDs connexions sociales (Google, Facebook, GitHub)
- ğŸ¢ NumÃ©ros de TVA (entreprises seulement)
- ğŸ“‹ Codes promo (optionnels)
- ğŸ”— RÃ©fÃ©rences optionnelles (parentId, replyToId)
- ğŸ“… Dates optionnelles (completedAt, expiresAt)
- ğŸ·ï¸ Identifiants externes optionnels

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez les index sparse, explorez :
- **[Index cachÃ© (Hidden)](./04.4-index-cache.md)** : Tester sans supprimer
- **[StratÃ©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avancÃ©es
- **[Gestion des index en production](./10-gestion-index-production.md)** : Best practices opÃ©rationnelles
- **[Analyse avec explain()](./06-analyse-explain.md)** : Diagnostic approfondi

---

**ğŸ“š Ressources ComplÃ©mentaires**
- [Documentation officielle - Sparse Indexes](https://docs.mongodb.com/manual/core/index-sparse/)
- [Index Properties](https://docs.mongodb.com/manual/core/index-properties/)
- [Unique Indexes](https://docs.mongodb.com/manual/core/index-unique/)
- [Partial Indexes](https://docs.mongodb.com/manual/core/index-partial/)

â­ï¸ [Index cachÃ© (Hidden)](/05-index-et-optimisation/04.4-index-cache.md)
