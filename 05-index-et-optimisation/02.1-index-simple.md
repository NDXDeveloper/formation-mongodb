ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.1 Index Simple (Single Field)

## Introduction

Un **index simple** (ou **Single Field Index**) est le type d'index le plus fondamental dans MongoDB. Il s'agit d'un index crÃ©Ã© sur un seul champ d'un document, permettant d'accÃ©lÃ©rer considÃ©rablement les requÃªtes qui filtrent, trient ou effectuent des recherches sur ce champ spÃ©cifique.

Les index simples constituent la base de l'optimisation des performances dans MongoDB et sont gÃ©nÃ©ralement les premiers index Ã  mettre en place lors de la conception d'une base de donnÃ©es.

---

## Pourquoi les Index Simples sont Importants

### Sans Index

Lorsqu'une requÃªte est exÃ©cutÃ©e sans index appropriÃ©, MongoDB doit effectuer un **scan complet de la collection** (Collection Scan), c'est-Ã -dire examiner chaque document un par un pour trouver ceux qui correspondent aux critÃ¨res de recherche.

**Exemple** : Dans une collection de 1 million d'utilisateurs, rechercher un utilisateur par son email sans index nÃ©cessiterait d'examiner potentiellement tous les documents.

### Avec Index

Avec un index sur le champ recherchÃ©, MongoDB peut localiser directement les documents pertinents grÃ¢ce Ã  une structure de donnÃ©es optimisÃ©e (arbre B), rÃ©duisant drastiquement le nombre de documents Ã  examiner.

**Impact sur les performances** :
- âœ… RequÃªtes jusqu'Ã  **1000x plus rapides** avec un index appropriÃ©
- âœ… RÃ©duction de la charge CPU et mÃ©moire
- âœ… AmÃ©lioration de l'expÃ©rience utilisateur
- âš ï¸ CoÃ»t : espace disque supplÃ©mentaire et ralentissement lÃ©ger des Ã©critures

---

## Anatomie d'un Index Simple

Un index simple dans MongoDB est composÃ© de :

1. **Le champ indexÃ©** : Le champ du document sur lequel l'index est crÃ©Ã©
2. **L'ordre de tri** : Ascendant (1) ou descendant (-1)
3. **Les pointeurs** : RÃ©fÃ©rences vers les documents rÃ©els dans la collection

### Structure Interne

```
Index sur le champ "email"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ email (triÃ©)        â†’ Document  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ alice@example.com   â†’ Doc #1    â”‚
â”‚ bob@example.com     â†’ Doc #2    â”‚
â”‚ charlie@example.com â†’ Doc #3    â”‚
â”‚ ...                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

L'index maintient une structure triÃ©e des valeurs, permettant des recherches rapides (recherche binaire ou traversÃ©e d'arbre).

---

## Syntaxe de CrÃ©ation

### Syntaxe de Base

```javascript
db.collection.createIndex({ <champ>: <ordre> })
```

- `<champ>` : Le nom du champ Ã  indexer
- `<ordre>` :
  - `1` pour un tri **ascendant** (croissant : Aâ†’Z, 0â†’9)
  - `-1` pour un tri **descendant** (dÃ©croissant : Zâ†’A, 9â†’0)

### Exemples Pratiques

#### Exemple 1 : Index sur un champ texte

```javascript
// CrÃ©er un index ascendant sur le champ "email"
db.users.createIndex({ email: 1 })
```

**RÃ©sultat** :
```json
{
  "numIndexesBefore": 1,
  "numIndexesAfter": 2,
  "createdCollectionAutomatically": false,
  "ok": 1
}
```

#### Exemple 2 : Index sur un champ numÃ©rique

```javascript
// CrÃ©er un index descendant sur le champ "age"
db.users.createIndex({ age: -1 })
```

#### Exemple 3 : Index sur un champ de date

```javascript
// CrÃ©er un index ascendant sur la date de crÃ©ation
db.orders.createIndex({ createdAt: 1 })
```

---

## Ordre de Tri : Ascendant vs Descendant

### Ascendant (1)

L'ordre ascendant trie les valeurs du plus petit au plus grand :

```javascript
db.products.createIndex({ price: 1 })
```

**Ordre dans l'index** : 10â‚¬ â†’ 20â‚¬ â†’ 50â‚¬ â†’ 100â‚¬ â†’ 500â‚¬

**Optimal pour** :
- RequÃªtes avec tri croissant : `sort({ price: 1 })`
- Recherches de valeurs minimales
- Plages de valeurs du bas vers le haut

### Descendant (-1)

L'ordre descendant trie les valeurs du plus grand au plus petit :

```javascript
db.products.createIndex({ price: -1 })
```

**Ordre dans l'index** : 500â‚¬ â†’ 100â‚¬ â†’ 50â‚¬ â†’ 20â‚¬ â†’ 10â‚¬

**Optimal pour** :
- RequÃªtes avec tri dÃ©croissant : `sort({ price: -1 })`
- Recherches de valeurs maximales
- Affichage des Ã©lÃ©ments les plus rÃ©cents en premier

### Important : Pour les Index Simples

Pour un **index simple**, l'ordre (1 ou -1) a peu d'importance en termes de performance car MongoDB peut traverser l'index dans les deux sens efficacement. La diffÃ©rence devient significative pour les **index composÃ©s** (voir section 5.2.2).

**Recommandation** : Par convention, utilisez `1` (ascendant) pour les index simples, sauf si vous avez une raison spÃ©cifique de faire autrement.

---

## Quand Utiliser un Index Simple

### Cas d'Usage IdÃ©aux

âœ… **Recherches d'Ã©galitÃ©**
```javascript
// Rechercher un utilisateur par email
db.users.find({ email: "alice@example.com" })

// Index recommandÃ©
db.users.createIndex({ email: 1 })
```

âœ… **Recherches par plage**
```javascript
// Rechercher des produits entre 10â‚¬ et 50â‚¬
db.products.find({ price: { $gte: 10, $lte: 50 } })

// Index recommandÃ©
db.products.createIndex({ price: 1 })
```

âœ… **Tris sur un champ**
```javascript
// Afficher les commandes les plus rÃ©centes
db.orders.find().sort({ createdAt: -1 })

// Index recommandÃ©
db.orders.createIndex({ createdAt: -1 })
```

âœ… **VÃ©rifications d'existence**
```javascript
// Trouver tous les documents ayant un champ "premium"
db.users.find({ premium: { $exists: true } })

// Index recommandÃ©
db.users.createIndex({ premium: 1 })
```

### Cas oÃ¹ un Index Simple est Moins Efficace

âŒ **RequÃªtes sur plusieurs champs**
```javascript
// Recherche combinÃ©e sur nom ET prÃ©nom
db.users.find({ lastName: "Dupont", firstName: "Jean" })

// Un index simple sur lastName OU firstName sera utilisÃ©,
// mais un index composÃ© serait plus efficace
```

âŒ **Champs avec trÃ¨s peu de valeurs distinctes** (faible cardinalitÃ©)
```javascript
// Champ boolÃ©en avec seulement true/false
db.users.createIndex({ isActive: 1 })

// Peu efficace : seulement 2 valeurs possibles
// L'index ne rÃ©duit pas significativement les documents Ã  examiner
```

âŒ **Champs rarement utilisÃ©s dans les requÃªtes**
```javascript
// Si "notes" n'est jamais utilisÃ© pour filtrer
db.users.createIndex({ notes: 1 })

// Index inutile qui consomme de l'espace et ralentit les Ã©critures
```

---

## Index sur l'_id

### Index Automatique

MongoDB crÃ©e **automatiquement** un index unique sur le champ `_id` lors de la crÃ©ation de chaque collection. Cet index ne peut pas Ãªtre supprimÃ©.

```javascript
// Cet index existe dÃ©jÃ  automatiquement
db.users.getIndexes()
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "_id": 1 },
    "name": "_id_"
  }
]
```

### Performance des RequÃªtes sur _id

Les requÃªtes sur `_id` sont toujours trÃ¨s rapides grÃ¢ce Ã  cet index automatique :

```javascript
// TrÃ¨s rapide grÃ¢ce Ã  l'index sur _id
db.users.find({ _id: ObjectId("507f1f77bcf86cd799439011") })
```

---

## Index sur Champs ImbriquÃ©s

MongoDB permet de crÃ©er des index simples sur des champs imbriquÃ©s (nested fields) en utilisant la notation pointÃ©e.

### Syntaxe

```javascript
db.collection.createIndex({ "champ.sousChamp": 1 })
```

### Exemple

Document exemple :
```json
{
  "_id": ObjectId("..."),
  "name": "Alice",
  "address": {
    "city": "Paris",
    "zipCode": "75001",
    "country": "France"
  }
}
```

CrÃ©er un index sur le champ imbriquÃ© :
```javascript
// Index sur la ville (champ imbriquÃ©)
db.users.createIndex({ "address.city": 1 })
```

RequÃªte optimisÃ©e :
```javascript
// Cette requÃªte utilisera l'index
db.users.find({ "address.city": "Paris" })
```

### Important

âš ï¸ L'index sur `"address.city"` est diffÃ©rent d'un index sur `"address"` :
- Index sur `"address"` : indexe le document complet
- Index sur `"address.city"` : indexe uniquement la valeur de city

---

## Options de CrÃ©ation d'Index

### Nom PersonnalisÃ©

Par dÃ©faut, MongoDB gÃ©nÃ¨re un nom d'index basÃ© sur le champ et l'ordre (ex: `email_1`). Vous pouvez spÃ©cifier un nom personnalisÃ© :

```javascript
db.users.createIndex(
  { email: 1 },
  { name: "idx_user_email" }
)
```

### Index Unique

Pour garantir l'unicitÃ© des valeurs dans un champ :

```javascript
db.users.createIndex(
  { email: 1 },
  { unique: true }
)
```

Cette option empÃªche l'insertion de documents avec des valeurs en double.

### Index en ArriÃ¨re-Plan

Pour les grandes collections en production, crÃ©ez l'index en arriÃ¨re-plan pour ne pas bloquer les opÃ©rations :

```javascript
db.users.createIndex(
  { email: 1 },
  { background: true }
)
```

âš ï¸ **Note** : Ã€ partir de MongoDB 4.2, les index sont construits de maniÃ¨re optimisÃ©e par dÃ©faut et l'option `background` est dÃ©prÃ©ciÃ©e.

---

## VÃ©rifier l'Utilisation d'un Index

### Lister les Index d'une Collection

```javascript
db.users.getIndexes()
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "_id": 1 },
    "name": "_id_"
  },
  {
    "v": 2,
    "key": { "email": 1 },
    "name": "email_1"
  }
]
```

### VÃ©rifier qu'une RequÃªte Utilise l'Index

Utilisez `.explain("executionStats")` pour analyser l'exÃ©cution d'une requÃªte :

```javascript
db.users.find({ email: "alice@example.com" }).explain("executionStats")
```

**Points clÃ©s Ã  vÃ©rifier** :
- `winningPlan.stage` doit Ãªtre `"IXSCAN"` (Index Scan) et non `"COLLSCAN"` (Collection Scan)
- `executionStats.totalDocsExamined` doit Ãªtre faible

---

## Suppression d'un Index Simple

### Par Nom

```javascript
db.users.dropIndex("email_1")
```

### Par SpÃ©cification

```javascript
db.users.dropIndex({ email: 1 })
```

### Supprimer Tous les Index (sauf _id)

```javascript
db.users.dropIndexes()
```

âš ï¸ **Attention** : La suppression d'un index utilisÃ© par des requÃªtes frÃ©quentes peut dÃ©grader gravement les performances.

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Indexer les champs frÃ©quemment recherchÃ©s**
   - Champs utilisÃ©s dans `find()`, `findOne()`, et conditions de `$match`

2. **Indexer les champs de tri**
   - Champs utilisÃ©s dans `.sort()`

3. **CrÃ©er des index uniques quand nÃ©cessaire**
   - Email, numÃ©ro de tÃ©lÃ©phone, identifiants externes

4. **Nommer explicitement les index importants**
   - Facilite la maintenance et la documentation

5. **Surveiller l'utilisation des index**
   - Supprimer les index inutilisÃ©s avec `db.collection.aggregate([{$indexStats: {}}])`

### âŒ Ã€ Ã‰viter

1. **Ne pas crÃ©er trop d'index**
   - Chaque index consomme de l'espace et ralentit les Ã©critures
   - RÃ¨gle gÃ©nÃ©rale : 5-10 index maximum par collection

2. **Ne pas indexer des champs avec faible cardinalitÃ©**
   - BoolÃ©ens, statuts avec 2-3 valeurs possibles

3. **Ne pas indexer des champs rarement utilisÃ©s**
   - Analyser les requÃªtes rÃ©elles avant de crÃ©er un index

4. **Ne pas crÃ©er d'index redondants**
   - Si vous avez un index composÃ© `{ lastName: 1, firstName: 1 }`, un index simple sur `lastName` est redondant

---

## Exemple Complet

### Contexte : Collection de Produits E-commerce

```javascript
// Structure des documents
{
  _id: ObjectId("..."),
  name: "Laptop Dell XPS 15",
  category: "Electronics",
  price: 1299.99,
  stock: 45,
  brand: "Dell",
  rating: 4.5,
  createdAt: ISODate("2024-01-15T10:30:00Z")
}
```

### Index Simples RecommandÃ©s

```javascript
// 1. Index sur la catÃ©gorie (recherches frÃ©quentes)
db.products.createIndex({ category: 1 })

// 2. Index sur le prix (recherches par plage, tri)
db.products.createIndex({ price: 1 })

// 3. Index sur la marque
db.products.createIndex({ brand: 1 })

// 4. Index sur la date de crÃ©ation (tri par nouveautÃ©)
db.products.createIndex({ createdAt: -1 })

// 5. Index unique sur le SKU (si vous en avez un)
db.products.createIndex({ sku: 1 }, { unique: true })
```

### RequÃªtes OptimisÃ©es

```javascript
// Recherche par catÃ©gorie - utilise l'index category_1
db.products.find({ category: "Electronics" })

// Recherche par plage de prix - utilise l'index price_1
db.products.find({ price: { $gte: 500, $lte: 1500 } })

// Tri par date - utilise l'index createdAt_-1
db.products.find().sort({ createdAt: -1 }).limit(10)

// Recherche de produits d'une marque - utilise l'index brand_1
db.products.find({ brand: "Dell" })
```

---

## Limitations et ConsidÃ©rations

### Taille d'un Index

- Les index consomment de l'espace RAM pour de meilleures performances
- Si tous les index ne tiennent pas en RAM, les performances se dÃ©gradent
- **Surveiller** : Utiliser `db.stats()` et `db.collection.stats()`

### Impact sur les Ã‰critures

Chaque index doit Ãªtre mis Ã  jour lors des opÃ©rations `insert`, `update`, et `delete` :

```
Sans index :  INSERT â†’ Document
Avec 3 index : INSERT â†’ Document + Mise Ã  jour index 1 + Mise Ã  jour index 2 + Mise Ã  jour index 3
```

**Compromis** : Les index accÃ©lÃ¨rent les lectures mais ralentissent lÃ©gÃ¨rement les Ã©critures.

### Limite du Nombre d'Index

- **Maximum** : 64 index par collection (limite MongoDB)
- **RecommandÃ©** : 5-10 index par collection en pratique

---

## Conclusion

Les **index simples** sont le fondement de l'optimisation des performances dans MongoDB. En indexant correctement les champs les plus sollicitÃ©s par vos requÃªtes, vous pouvez obtenir des gains de performance spectaculaires avec un minimum d'effort.

### Points ClÃ©s Ã  Retenir

- âœ… Un index simple s'applique Ã  un seul champ
- âœ… Syntaxe : `db.collection.createIndex({ champ: 1 })`
- âœ… L'ordre (1 ou -1) a peu d'importance pour les index simples
- âœ… Indexer les champs utilisÃ©s dans `find()`, `sort()`, et conditions de filtrage
- âœ… VÃ©rifier l'utilisation avec `.explain()`
- âœ… Ã‰quilibrer le nombre d'index (performances lectures vs Ã©critures)

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez les index simples, vous Ãªtes prÃªt Ã  explorer :
- **[Index composÃ©s](02.2-index-compose.md)** : Index sur plusieurs champs
- **[Index multiclÃ©](02.3-index-multicle.md)** : Index sur des tableaux
- **[Index spÃ©cialisÃ©s](03-index-specialises.md)** : Index texte, gÃ©ospatial, etc.

---

**ğŸ“š Ressources ComplÃ©mentaires**
- [Documentation officielle MongoDB - Single Field Indexes](https://docs.mongodb.com/manual/core/index-single/)
- [Performance Best Practices: Indexing](https://docs.mongodb.com/manual/core/indexes/)
- [Index Strategies](https://docs.mongodb.com/manual/applications/indexes/)

â­ï¸ [Index composÃ© (Compound)](/05-index-et-optimisation/02.2-index-compose.md)
