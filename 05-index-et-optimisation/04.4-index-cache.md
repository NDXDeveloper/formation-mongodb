ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.4 Index CachÃ© (Hidden)

## Introduction

Un **index cachÃ©** (ou **Hidden Index**) est un index qui existe physiquement dans la base de donnÃ©es mais qui est **invisible** pour le query planner de MongoDB. Le query planner ne peut pas utiliser un index cachÃ© pour optimiser les requÃªtes, mais l'index continue d'Ãªtre **maintenu Ã  jour** lors des insertions, mises Ã  jour et suppressions.

Les index cachÃ©s sont utiles pour :
- **Tester l'impact** : Ã‰valuer l'effet de la suppression d'un index sans le supprimer
- **DÃ©sactiver temporairement** : Masquer un index problÃ©matique sans le perdre
- **Validation prudente** : S'assurer qu'un index n'est plus utilisÃ© avant de le supprimer dÃ©finitivement
- **Rollback facile** : Pouvoir rÃ©activer rapidement un index si nÃ©cessaire

C'est l'Ã©quivalent d'un **interrupteur on/off** pour un index : vous pouvez le dÃ©sactiver sans le dÃ©truire.

---

## Le ProblÃ¨me : Supprimer un Index est RisquÃ©

### ScÃ©nario ProblÃ©matique

Vous gÃ©rez une application en production et vous pensez qu'un index n'est plus utilisÃ© :

```javascript
// Index suspect : crÃ©Ã© il y a 2 ans, semble inutile
db.users.getIndexes()
// {
//   "v": 2,
//   "key": { "lastLoginDate": 1 },
//   "name": "lastLoginDate_1"
// }
```

**Question** : Cet index est-il vraiment utilisÃ© ?

### Approche RisquÃ©e : Suppression Directe âŒ

```javascript
// âŒ Suppression immÃ©diate
db.users.dropIndex("lastLoginDate_1")
```

**ProblÃ¨mes** :
- âŒ Si l'index Ã©tait utilisÃ© â†’ **Performance dÃ©gradÃ©e immÃ©diatement**
- âŒ Peut affecter des requÃªtes critiques non documentÃ©es
- âŒ RecrÃ©er l'index prend du temps (minutes/heures pour grandes collections)
- âŒ Pas de rollback facile

**ConsÃ©quences en production** :
```
15h00 : Suppression de l'index
15h05 : Dashboard admin devient lent (30s â†’ timeout)
15h10 : Ã‰quipe support submergÃ©e d'appels
15h15 : On dÃ©couvre que l'index Ã©tait utilisÃ© !
15h20 : DÃ©but recrÃ©ation index (ETA: 2 heures)
17h20 : Index recrÃ©Ã©, service restaurÃ©
â†’ 2h20 d'interruption de service !
```

### Approche SÃ»re : Index CachÃ© âœ…

```javascript
// âœ… Cacher l'index d'abord
db.users.hideIndex("lastLoginDate_1")

// Attendre et surveiller (24-48h)
// - Les mÃ©triques restent bonnes ?
// - Pas de plaintes utilisateurs ?
// - Pas de ralentissements ?

// Si tout va bien â†’ Supprimer dÃ©finitivement
db.users.dropIndex("lastLoginDate_1")

// Si problÃ¨me dÃ©tectÃ© â†’ RÃ©activer instantanÃ©ment
db.users.unhideIndex("lastLoginDate_1")
```

**Avantages** :
- âœ… Test sans risque
- âœ… Rollback instantanÃ© (millisecondes)
- âœ… Validation en conditions rÃ©elles
- âœ… Aucune interruption de service

---

## Qu'est-ce qu'un Index CachÃ© ?

### Analogie : Le Livre Invisible

Imaginez une bibliothÃ¨que :

**Index normal** = Livre sur l'Ã©tagÃ¨re visible
```
Le bibliothÃ©caire voit le livre
â†’ Peut le recommander aux visiteurs
â†’ Livre utilisÃ© rÃ©guliÃ¨rement
```

**Index cachÃ©** = Livre dans le dÃ©pÃ´t
```
Le livre existe toujours
Le bibliothÃ©caire ne le voit PAS
â†’ Ne peut PAS le recommander
â†’ Mais le livre est toujours cataloguÃ© et conservÃ©
```

Si finalement le livre est utile :
```
Le ramener sur l'Ã©tagÃ¨re = Unhide (instantanÃ©)
```

Si le livre n'est vraiment pas utile :
```
Le jeter dÃ©finitivement = Drop (Ã©conomise espace)
```

### Principe de Fonctionnement

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Index CachÃ©                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Query Planner                          â”‚
â”‚       â†“                                 â”‚
â”‚  âŒ Ne voit PAS l'index                 â”‚
â”‚  âŒ Ne peut PAS l'utiliser              â”‚
â”‚                                         â”‚
â”‚  OpÃ©rations d'Ã©criture                  â”‚
â”‚       â†“                                 â”‚
â”‚  âœ… Index maintenu Ã  jour               â”‚
â”‚  âœ… Insertions indexÃ©es                 â”‚
â”‚  âœ… Mises Ã  jour reflÃ©tÃ©es              â”‚
â”‚  âœ… Suppressions appliquÃ©es             â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Important** : Un index cachÃ© consomme toujours de l'espace disque et a un impact sur les performances d'Ã©criture.

---

## Syntaxe et OpÃ©rations

### CrÃ©er un Index CachÃ©

#### Option 1 : Ã€ la CrÃ©ation

```javascript
// CrÃ©er directement un index cachÃ©
db.collection.createIndex(
  { champ: 1 },
  { hidden: true }
)
```

**Exemple** :
```javascript
// Index crÃ©Ã© cachÃ© dÃ¨s le dÃ©part
db.users.createIndex(
  { tempField: 1 },
  { hidden: true }
)
```

#### Option 2 : Cacher un Index Existant

```javascript
// Cacher un index existant
db.collection.hideIndex("nomIndex")

// Ou avec la spÃ©cification
db.collection.hideIndex({ champ: 1 })
```

**Exemples** :
```javascript
// Par nom d'index
db.users.hideIndex("email_1")

// Par spÃ©cification de clÃ©
db.users.hideIndex({ email: 1 })
```

### Afficher un Index CachÃ©

```javascript
// Rendre visible un index cachÃ©
db.collection.unhideIndex("nomIndex")

// Ou avec la spÃ©cification
db.collection.unhideIndex({ champ: 1 })
```

**Exemples** :
```javascript
// Par nom
db.users.unhideIndex("email_1")

// Par spÃ©cification
db.users.unhideIndex({ email: 1 })
```

### VÃ©rifier si un Index est CachÃ©

```javascript
// Lister tous les index
db.collection.getIndexes()

// RÃ©sultat pour un index cachÃ© :
// {
//   "v": 2,
//   "key": { "email": 1 },
//   "name": "email_1",
//   "hidden": true  // â† PropriÃ©tÃ© hidden
// }
```

### Modifier l'Ã‰tat (Alternative)

Vous pouvez aussi utiliser `collMod` :

```javascript
// Cacher
db.runCommand({
  collMod: "users",
  index: {
    keyPattern: { email: 1 },
    hidden: true
  }
})

// Afficher
db.runCommand({
  collMod: "users",
  index: {
    keyPattern: { email: 1 },
    hidden: false
  }
})
```

---

## Comportement DÃ©taillÃ©

### Query Planner : Index Invisible

Quand un index est cachÃ©, le query planner l'ignore complÃ¨tement :

```javascript
// CrÃ©er et cacher un index
db.products.createIndex({ category: 1 }, { hidden: true })

// RequÃªte
db.products.find({ category: "Electronics" }).explain("executionStats")
```

**RÃ©sultat** :
```javascript
{
  "winningPlan": {
    "stage": "COLLSCAN"  // âŒ Scan de collection (index ignorÃ©)
  }
}
```

L'index cachÃ© est **complÃ¨tement ignorÃ©** par le query planner.

### Maintenance de l'Index

MalgrÃ© qu'il soit cachÃ©, l'index est maintenu Ã  jour :

```javascript
// Index cachÃ©
db.users.createIndex({ email: 1 }, { hidden: true })

// âœ… Insertion : Index mis Ã  jour
db.users.insertOne({
  username: "alice",
  email: "alice@example.com"
})

// âœ… Mise Ã  jour : Index mis Ã  jour
db.users.updateOne(
  { username: "alice" },
  { $set: { email: "newalice@example.com" } }
)

// âœ… Suppression : Index mis Ã  jour
db.users.deleteOne({ username: "alice" })
```

**ConsÃ©quence** : L'index cachÃ© a toujours un **impact sur les performances d'Ã©criture**.

### Index _id : Exception

L'index sur `_id` **ne peut PAS** Ãªtre cachÃ© :

```javascript
// âŒ Impossible
db.users.hideIndex("_id_")
// Erreur : cannot hide _id index
```

L'index `_id` est fondamental et doit toujours Ãªtre visible.

---

## Cas d'Usage Pratiques

### 1. Tester la Suppression d'un Index Suspect

**Contexte** : Index qui semble inutilisÃ©

```javascript
// Ã‰tape 1 : Identifier l'index suspect
db.users.aggregate([{ $indexStats: {} }])
// {
//   "name": "lastLoginDate_1",
//   "accesses": {
//     "ops": 5,  // â† Seulement 5 utilisations !
//     "since": ISODate("2023-01-01")
//   }
// }

// Ã‰tape 2 : Cacher l'index
db.users.hideIndex("lastLoginDate_1")
console.log("Index cachÃ© - surveillance en cours...")

// Ã‰tape 3 : Attendre 24-48h et surveiller
// - MÃ©triques de performance
// - Logs de requÃªtes lentes
// - Retours utilisateurs

// Ã‰tape 4a : Si tout va bien â†’ Supprimer
db.users.dropIndex("lastLoginDate_1")
console.log("Index supprimÃ© dÃ©finitivement")

// Ã‰tape 4b : Si problÃ¨me dÃ©tectÃ© â†’ RÃ©activer
db.users.unhideIndex("lastLoginDate_1")
console.log("Index rÃ©activÃ© - enquÃªte nÃ©cessaire")
```

### 2. Migration Progressif d'Index

**Contexte** : Remplacer un index par un meilleur

```javascript
// Ancien index : category seul
db.products.getIndexes()
// { "key": { "category": 1 }, "name": "category_1" }

// Ã‰tape 1 : CrÃ©er le nouvel index (meilleur)
db.products.createIndex({ category: 1, price: -1 })
console.log("Nouvel index crÃ©Ã©")

// Ã‰tape 2 : Cacher l'ancien index
db.products.hideIndex("category_1")
console.log("Ancien index cachÃ©")

// Ã‰tape 3 : Tester pendant 48h
// - VÃ©rifier que le nouvel index est utilisÃ©
// - VÃ©rifier les performances

// Ã‰tape 4 : Supprimer l'ancien si tout va bien
db.products.dropIndex("category_1")
console.log("Ancien index supprimÃ©")
```

### 3. Debug de RequÃªtes Lentes

**Contexte** : Identifier quel index cause un problÃ¨me

```javascript
// Plusieurs index sur la mÃªme collection
db.orders.getIndexes()
// - index1 : { customerId: 1 }
// - index2 : { customerId: 1, orderDate: -1 }
// - index3 : { status: 1, customerId: 1 }

// ProblÃ¨me : RequÃªtes lentes malgrÃ© les index

// Test : Cacher chaque index un par un pour identifier le coupable
// Test 1 : Cacher index1
db.orders.hideIndex({ customerId: 1 })
// Tester les requÃªtes â†’ Toujours lentes

// Test 2 : RÃ©activer index1, cacher index2
db.orders.unhideIndex({ customerId: 1 })
db.orders.hideIndex({ customerId: 1, orderDate: -1 })
// Tester â†’ RequÃªtes RAPIDES !
// â†’ Index2 Ã©tait le problÃ¨me !

// Solution : Supprimer index2 problÃ©matique
db.orders.dropIndex({ customerId: 1, orderDate: -1 })
```

### 4. Maintenance PlanifiÃ©e

**Contexte** : DÃ©sactiver temporairement un index pendant une opÃ©ration lourde

```javascript
// Grande opÃ©ration de mise Ã  jour prÃ©vue
// DÃ©sactiver index temporairement pour accÃ©lÃ©rer

// Ã‰tape 1 : Cacher l'index
db.products.hideIndex("description_text")
console.log("Index texte cachÃ©")

// Ã‰tape 2 : Effectuer l'opÃ©ration lourde
db.products.updateMany(
  {},
  { $set: { updatedAt: new Date() } }
)
console.log("Mise Ã  jour massive terminÃ©e")

// Ã‰tape 3 : RÃ©activer l'index
db.products.unhideIndex("description_text")
console.log("Index texte rÃ©activÃ©")
```

âš ï¸ **Note** : L'index cachÃ© est toujours maintenu, donc cette approche n'accÃ©lÃ¨re PAS vraiment les Ã©critures. Pour de vraies performances, il faut supprimer et recrÃ©er l'index.

### 5. A/B Testing d'Index

**Contexte** : Comparer les performances avec et sans un index

```javascript
// Baseline : Avec index
db.users.find({ age: { $gte: 18, $lte: 65 } }).explain("executionStats")
// executionTimeMillis: 50

// Test : Sans index
db.users.hideIndex("age_1")
db.users.find({ age: { $gte: 18, $lte: 65 } }).explain("executionStats")
// executionTimeMillis: 2000

// Conclusion : Index utile (50ms vs 2000ms)
db.users.unhideIndex("age_1")
```

### 6. Environnement de Staging

**Contexte** : Tester une configuration d'index en staging avant production

```javascript
// Staging : Tester nouvelle stratÃ©gie d'index
// Cacher ancien index
db.products.hideIndex("old_index")

// CrÃ©er nouvel index
db.products.createIndex({ newField: 1 })

// Tester pendant 1 semaine
// Collecter mÃ©triques

// Si succÃ¨s â†’ Appliquer en production
// Si Ã©chec â†’ Rollback (unhide ancien index)
```

---

## Index CachÃ© vs Suppression

### Tableau Comparatif

| CritÃ¨re | Index CachÃ© | Index SupprimÃ© |
|---------|-------------|----------------|
| **Visible par query planner** | âŒ Non | âŒ Non |
| **Utilise espace disque** | âœ… Oui | âŒ Non |
| **Impact sur Ã©critures** | âœ… Oui | âŒ Non |
| **Maintenu Ã  jour** | âœ… Oui | âŒ N/A |
| **Temps de rÃ©activation** | âš¡ InstantanÃ© (ms) | ğŸŒ Long (min/heures) |
| **Rollback** | âœ… Facile | âŒ Difficile |
| **Usage** | Test temporaire | Suppression dÃ©finitive |

### Exemple de Temps de RÃ©activation

```javascript
// Collection : 10 millions de documents

// ScÃ©nario 1 : Index cachÃ©
db.users.hideIndex("email_1")
// ... test pendant 24h ...
db.users.unhideIndex("email_1")
// âš¡ RÃ©activation : ~10 millisecondes

// ScÃ©nario 2 : Index supprimÃ©
db.users.dropIndex("email_1")
// ... test pendant 24h ...
db.users.createIndex({ email: 1 })
// ğŸŒ RecrÃ©ation : ~15 minutes
```

**DiffÃ©rence** : 10ms vs 15 minutes = **90 000x plus rapide** !

---

## StratÃ©gie de Test RecommandÃ©e

### Processus Ã‰tape par Ã‰tape

```javascript
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 1 : PRÃ‰PARATION (Avant de cacher)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// 1.1 : Identifier les index candidats Ã  la suppression
db.users.aggregate([{ $indexStats: {} }]).sort({ "accesses.ops": 1 })

// 1.2 : Documenter l'index
let indexInfo = db.users.getIndexes().find(idx => idx.name === "suspect_1")
console.log("Index Ã  tester :", JSON.stringify(indexInfo, null, 2))

// 1.3 : Ã‰tablir baseline de performance
let baseline = db.users.find({ targetQuery }).explain("executionStats")
console.log("Baseline :", baseline.executionStats.executionTimeMillis, "ms")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 2 : TEST (Cacher et surveiller)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// 2.1 : Cacher l'index
db.users.hideIndex("suspect_1")
console.log("Index cachÃ© - Date:", new Date())

// 2.2 : Surveiller pendant 24-48h
// - MÃ©triques de performance (temps de rÃ©ponse)
// - Logs de requÃªtes lentes
// - Utilisation CPU/mÃ©moire
// - Retours utilisateurs

// 2.3 : Tester manuellement les requÃªtes critiques
db.users.find({ criticalQuery }).explain("executionStats")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Phase 3 : DÃ‰CISION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Option A : Performances OK â†’ Supprimer dÃ©finitivement
if (performancesOK) {
  db.users.dropIndex("suspect_1")
  console.log("Index supprimÃ© - espace libÃ©rÃ©")
}

// Option B : ProblÃ¨me dÃ©tectÃ© â†’ RÃ©activer
if (problemeDetecte) {
  db.users.unhideIndex("suspect_1")
  console.log("Index rÃ©activÃ© - analyse nÃ©cessaire")
}

// Option C : Incertain â†’ Prolonger le test
if (incertain) {
  console.log("Test prolongÃ© de 24h supplÃ©mentaires")
}
```

### Checklist de Surveillance

```javascript
// âœ… MÃ©triques Ã  surveiller pendant le test

// 1. Performance des requÃªtes
db.currentOp({
  "secs_running": { $gte: 5 }  // RequÃªtes > 5 secondes
})

// 2. Utilisation de l'index (doit Ãªtre 0 si cachÃ©)
db.users.aggregate([
  { $indexStats: {} },
  { $match: { name: "suspect_1" } }
])

// 3. Slow queries log
db.getProfilingStatus()
db.system.profile.find({
  millis: { $gte: 100 }
}).sort({ ts: -1 }).limit(10)

// 4. Statistiques serveur
db.serverStatus().opcounters
db.serverStatus().mem
```

---

## Limitations et Contraintes

### Index _id Non Cachable

```javascript
// âŒ Impossible
db.users.hideIndex("_id_")
// MongoServerError: cannot hide _id index
```

L'index sur `_id` est essentiel et ne peut jamais Ãªtre cachÃ©.

### Index TTL

Les index TTL **continuent de fonctionner** mÃªme cachÃ©s :

```javascript
// Index TTL cachÃ©
db.sessions.createIndex(
  { createdAt: 1 },
  { expireAfterSeconds: 3600, hidden: true }
)

// âœ… Les documents sont toujours supprimÃ©s automatiquement
// MÃªme si l'index est cachÃ© pour les requÃªtes
```

**Raison** : Le thread TTL utilise l'index indÃ©pendamment du query planner.

### Contraintes d'UnicitÃ©

Les index uniques **maintiennent la contrainte** mÃªme cachÃ©s :

```javascript
// Index unique cachÃ©
db.users.createIndex({ email: 1 }, { unique: true, hidden: true })

// âœ… La contrainte d'unicitÃ© est toujours appliquÃ©e
db.users.insertOne({ email: "alice@example.com" })
db.users.insertOne({ email: "alice@example.com" })
// ERREUR : Duplicate key (mÃªme si index cachÃ©)
```

### Performances d'Ã‰criture

Un index cachÃ© a **toujours un impact** sur les Ã©critures :

```javascript
// Index cachÃ©
db.products.hideIndex("category_1")

// âŒ L'impact sur les insertions reste
db.products.insertOne({ name: "Product", category: "Electronics" })
// L'index est mis Ã  jour (mÃªme si cachÃ©)
```

**Si vous voulez vraiment supprimer l'impact sur les Ã©critures** â†’ Supprimez l'index complÃ¨tement.

### Espace Disque

Un index cachÃ© **consomme toujours de l'espace** :

```javascript
// Statistiques
db.users.stats().indexSizes
// {
//   "_id_": 10485760,
//   "email_1": 5242880  // â† Index cachÃ© (5 MB utilisÃ©s)
// }
```

**Pour libÃ©rer l'espace** â†’ Supprimez l'index.

---

## Quand Utiliser un Index CachÃ©

### âœ… Utilisez un Index CachÃ© Quand

1. **Test de suppression d'index**
   - Vous voulez vÃ©rifier qu'un index est inutile
   - Avant de supprimer dÃ©finitivement
   - Besoin de rollback rapide

2. **Migration d'index**
   - Remplacement d'un ancien index par un nouveau
   - Transition progressive
   - Validation du nouveau avant suppression de l'ancien

3. **Debug de performances**
   - Identifier quel index cause un problÃ¨me
   - Test d'isolation
   - Analyse comparative

4. **Validation prudente**
   - Index crÃ©Ã© par erreur ou test
   - Pas sÃ»r de l'utilitÃ©
   - Environnement de production critique

5. **ExpÃ©rimentation**
   - A/B testing de stratÃ©gies d'index
   - Mesure d'impact
   - DÃ©cision data-driven

### âŒ N'utilisez PAS un Index CachÃ© Quand

1. **Suppression dÃ©finitive prÃ©vue**
   - Vous Ãªtes sÃ»r que l'index est inutile
   - Pas besoin de test
   - â†’ Supprimez directement pour libÃ©rer espace

2. **Optimisation des Ã©critures nÃ©cessaire**
   - Index cachÃ© a toujours impact sur Ã©critures
   - Pour accÃ©lÃ©rer les insertions massives
   - â†’ Supprimez puis recrÃ©ez aprÃ¨s

3. **LibÃ©ration d'espace disque urgente**
   - Index cachÃ© consomme toujours de l'espace
   - Besoin immÃ©diat d'espace
   - â†’ Supprimez directement

4. **Index jamais utilisÃ© Ã©vident**
   - CrÃ©Ã© par erreur claire
   - Aucun doute sur l'inutilitÃ©
   - â†’ Supprimez sans test

5. **Environnement de dÃ©veloppement**
   - Pas de risque de production
   - Iterations rapides
   - â†’ Supprimer/recrÃ©er directement

---

## Bonnes Pratiques

### âœ… Ã€ Faire

1. **Documenter les tests**
   ```javascript
   // CrÃ©er un fichier de log
   let testLog = {
     indexName: "suspect_1",
     hiddenAt: new Date(),
     reason: "Index utilisÃ© seulement 5 fois en 6 mois",
     baseline: { avgResponseTime: 50 },
     testDuration: "48 heures"
   }

   db.index_tests.insertOne(testLog)
   ```

2. **DÃ©finir une durÃ©e de test claire**
   ```javascript
   // Exemple : 48 heures
   let testEndDate = new Date(Date.now() + 48 * 60 * 60 * 1000)
   console.log(`Test jusqu'Ã  : ${testEndDate}`)

   // CrÃ©er un rappel
   db.reminders.insertOne({
     type: "index_test",
     indexName: "suspect_1",
     checkAt: testEndDate
   })
   ```

3. **Surveiller activement**
   ```javascript
   // Script de surveillance
   function monitorIndexTest(indexName) {
     // VÃ©rifier slow queries
     let slowQueries = db.system.profile.countDocuments({
       millis: { $gte: 100 },
       ts: { $gte: testStartDate }
     })

     console.log(`Slow queries depuis le test : ${slowQueries}`)

     // VÃ©rifier mÃ©triques
     let metrics = db.serverStatus().opcounters
     console.log(`OpÃ©rations :\n`, metrics)
   }

   // ExÃ©cuter toutes les heures
   ```

4. **Tester en heures creuses d'abord**
   ```javascript
   // Cacher l'index Ã  2h du matin (trafic minimal)
   // Surveiller pendant 6 heures
   // Si OK â†’ Continuer le test en heures pleines
   ```

5. **Avoir un plan de rollback**
   ```javascript
   // ProcÃ©dure d'urgence documentÃ©e
   // En cas de problÃ¨me :
   // 1. db.users.unhideIndex("suspect_1")
   // 2. VÃ©rifier que les performances reviennent
   // 3. Analyser les logs
   ```

6. **Communiquer avec l'Ã©quipe**
   ```javascript
   // Informer l'Ã©quipe
   console.log(`
   âš ï¸  TEST D'INDEX EN COURS
   Index : suspect_1 sur collection users
   DÃ©but : ${new Date()}
   Fin prÃ©vue : ${testEndDate}
   Contact : votre-nom
   Rollback : db.users.unhideIndex("suspect_1")
   `)
   ```

### âŒ Ã€ Ã‰viter

1. **Ne pas laisser un index cachÃ© indÃ©finiment**
   ```javascript
   // âŒ Oublier un index cachÃ© pendant des mois
   // Consomme espace et impacte Ã©critures pour rien

   // âœ… DÃ©finir une deadline de dÃ©cision
   let deadline = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
   ```

2. **Ne pas cacher plusieurs index simultanÃ©ment**
   ```javascript
   // âŒ Cacher 5 index en mÃªme temps
   // Impossible d'isoler quel index cause quel problÃ¨me

   // âœ… Tester un index Ã  la fois
   db.users.hideIndex("index1")
   // Tester 48h
   // DÃ©cision
   // Puis tester index2 si nÃ©cessaire
   ```

3. **Ne pas ignorer les alertes**
   ```javascript
   // âŒ Voir des slow queries et continuer le test

   // âœ… RÃ©agir immÃ©diatement
   if (slowQueriesDetected) {
     db.users.unhideIndex("suspect_1")
     console.log("Rollback effectuÃ© - index nÃ©cessaire")
   }
   ```

4. **Ne pas oublier les heures de pointe**
   ```javascript
   // âŒ Tester seulement la nuit

   // âœ… Inclure au moins une pÃ©riode de forte charge
   // Pour voir l'impact rÃ©el
   ```

5. **Ne pas cacher l'index _id**
   ```javascript
   // âŒ Impossible de toute faÃ§on
   db.users.hideIndex("_id_")
   // ERREUR
   ```

---

## VÃ©rification et Monitoring

### Lister les Index CachÃ©s

```javascript
// Tous les index
db.users.getIndexes()

// Filtrer seulement les cachÃ©s
db.users.getIndexes().filter(idx => idx.hidden === true)
```

**RÃ©sultat** :
```json
[
  {
    "v": 2,
    "key": { "lastLoginDate": 1 },
    "name": "lastLoginDate_1",
    "hidden": true  // â† Index cachÃ©
  }
]
```

### VÃ©rifier qu'un Index N'est Plus UtilisÃ©

```javascript
// Statistiques d'utilisation
db.users.aggregate([
  { $indexStats: {} },
  { $match: { name: "lastLoginDate_1" } }
])
```

**RÃ©sultat pour index cachÃ©** :
```json
{
  "name": "lastLoginDate_1",
  "key": { "lastLoginDate": 1 },
  "accesses": {
    "ops": 0,  // â† 0 utilisations (cachÃ©)
    "since": ISODate("2024-01-20T10:00:00Z")
  }
}
```

### Tester avec explain()

```javascript
// Index cachÃ©
db.users.hideIndex("email_1")

// Tester requÃªte
let result = db.users.find({ email: "alice@example.com" })
  .explain("executionStats")

// VÃ©rifier le plan
console.log("Stage :", result.executionStats.executionStage)
// "COLLSCAN" â†’ Index non utilisÃ© (cachÃ©)

// RÃ©activer
db.users.unhideIndex("email_1")

// Re-tester
result = db.users.find({ email: "alice@example.com" })
  .explain("executionStats")

console.log("Stage :", result.executionStats.executionStage)
// "IXSCAN" â†’ Index utilisÃ© (visible)
```

### Script de Monitoring Complet

```javascript
function monitorHiddenIndexTest(collection, indexName, testStartTime) {
  console.log(`\n=== Monitoring Index Test ===`)
  console.log(`Collection: ${collection}`)
  console.log(`Index: ${indexName}`)
  console.log(`Test started: ${testStartTime}`)

  // 1. VÃ©rifier que l'index est bien cachÃ©
  let index = db[collection].getIndexes().find(idx => idx.name === indexName)
  console.log(`\nIndex hidden: ${index.hidden}`)

  // 2. Utilisation de l'index (doit Ãªtre 0)
  let usage = db[collection].aggregate([
    { $indexStats: {} },
    { $match: { name: indexName } }
  ]).toArray()[0]
  console.log(`Index accesses: ${usage.accesses.ops}`)

  // 3. Slow queries depuis le dÃ©but du test
  let slowQueries = db.system.profile.countDocuments({
    millis: { $gte: 100 },
    ts: { $gte: testStartTime }
  })
  console.log(`Slow queries (>100ms): ${slowQueries}`)

  // 4. Performance gÃ©nÃ©rale
  let serverStatus = db.serverStatus()
  console.log(`\nServer Status:`)
  console.log(`- Query operations: ${serverStatus.opcounters.query}`)
  console.log(`- Memory usage: ${serverStatus.mem.resident} MB`)

  // 5. Recommandation
  let testDuration = (Date.now() - testStartTime) / (1000 * 60 * 60)
  console.log(`\nTest duration: ${testDuration.toFixed(1)} hours`)

  if (slowQueries === 0 && testDuration >= 48) {
    console.log(`âœ… RECOMMANDATION: Safe to drop index`)
  } else if (slowQueries > 10) {
    console.log(`âš ï¸  RECOMMANDATION: Unhide index immediately`)
  } else {
    console.log(`â³ RECOMMANDATION: Continue monitoring`)
  }
}

// Utilisation
monitorHiddenIndexTest("users", "lastLoginDate_1", ISODate("2024-01-20T10:00:00Z"))
```

---

## Exemple Complet : Workflow RÃ©el

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXEMPLE COMPLET : Nettoyage d'Index en Production
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰TAPE 1 : AUDIT DES INDEX (Vendredi 14h)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

console.log("=== Audit des index ===")

// Lister tous les index avec statistiques d'utilisation
let indexStats = db.products.aggregate([
  { $indexStats: {} }
]).toArray()

// Trier par utilisation
indexStats.sort((a, b) => a.accesses.ops - b.accesses.ops)

console.log("Index peu utilisÃ©s :")
indexStats.slice(0, 3).forEach(idx => {
  console.log(`- ${idx.name}: ${idx.accesses.ops} utilisations depuis ${idx.accesses.since}`)
})

// RÃ©sultat :
// - oldCategory_1: 12 utilisations depuis 2023-06-01
// - tempField_1: 0 utilisations depuis 2023-12-01
// - legacyStatus_1: 45 utilisations depuis 2023-03-01

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰TAPE 2 : PRÃ‰PARATION (Vendredi 15h)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Documenter le test
db.index_tests.insertOne({
  indexName: "oldCategory_1",
  collection: "products",
  testStartDate: new Date(),
  testEndDate: new Date(Date.now() + 72 * 60 * 60 * 1000),  // 72h (weekend)
  reason: "Seulement 12 utilisations en 8 mois",
  status: "testing",
  baseline: {
    totalDocuments: db.products.countDocuments(),
    avgQueryTime: 45,  // ms
    indexSize: db.products.stats().indexSizes.oldCategory_1
  }
})

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰TAPE 3 : CACHER L'INDEX (Vendredi 16h)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

console.log("=== DÃ©but du test ===")
db.products.hideIndex("oldCategory_1")
console.log("Index cachÃ© Ã ", new Date())

// Notifier l'Ã©quipe
console.log(`
âš ï¸  TEST D'INDEX EN COURS - Ã€ SURVEILLER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Collection : products
Index : oldCategory_1
DÃ©but : ${new Date()}
Fin prÃ©vue : ${new Date(Date.now() + 72 * 60 * 60 * 1000)}
Rollback : db.products.unhideIndex("oldCategory_1")
Contact : admin@company.com
`)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰TAPE 4 : SURVEILLANCE (Samedi & Dimanche)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Script Ã  exÃ©cuter toutes les 6 heures
function checkIndexTest() {
  console.log("\n=== Check @", new Date(), "===")

  // Slow queries
  let slowQueries = db.system.profile.countDocuments({
    millis: { $gte: 100 },
    ts: { $gte: ISODate("2024-01-19T16:00:00Z") }
  })
  console.log("Slow queries:", slowQueries)

  // Si problÃ¨me â†’ Rollback immÃ©diat
  if (slowQueries > 50) {
    console.log("âš ï¸  TROP DE SLOW QUERIES - ROLLBACK")
    db.products.unhideIndex("oldCategory_1")

    // Mettre Ã  jour le test
    db.index_tests.updateOne(
      { indexName: "oldCategory_1", status: "testing" },
      {
        $set: {
          status: "failed",
          endDate: new Date(),
          reason: "Slow queries detected"
        }
      }
    )
    return
  }

  console.log("âœ“ Performances OK")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰TAPE 5 : DÃ‰CISION (Lundi 10h)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// VÃ©rifier les rÃ©sultats du weekend
let testResult = db.index_tests.findOne({
  indexName: "oldCategory_1",
  status: "testing"
})

console.log("=== RÃ©sultats du test ===")
console.log("Slow queries totales:", /* nombre */)
console.log("Plaintes utilisateurs:", 0)
console.log("Performances:", "Stables")

// DÃ©cision : Supprimer l'index
console.log("\nâœ“ DÃ‰CISION: Supprimer l'index")

db.products.dropIndex("oldCategory_1")

// Mettre Ã  jour le test
db.index_tests.updateOne(
  { indexName: "oldCategory_1", status: "testing" },
  {
    $set: {
      status: "success",
      endDate: new Date(),
      decision: "dropped",
      spaceFreed: testResult.baseline.indexSize
    }
  }
)

console.log("Index supprimÃ© dÃ©finitivement")
console.log("Espace libÃ©rÃ©:", testResult.baseline.indexSize, "bytes")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIN DU WORKFLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Conclusion

Les **index cachÃ©s** sont un outil de sÃ©curitÃ© essentiel pour tester la suppression d'index en production sans risque. Ils permettent un rollback instantanÃ© en cas de problÃ¨me, Ã©vitant ainsi des interruptions de service coÃ»teuses.

### Points ClÃ©s Ã  Retenir

- âœ… Index cachÃ© = Index invisible pour query planner
- âœ… Syntaxe : `hideIndex()` / `unhideIndex()`
- âœ… Index maintenu Ã  jour (impact Ã©critures)
- âœ… Consomme toujours de l'espace disque
- âœ… Rollback instantanÃ© (millisecondes)
- âœ… Parfait pour tester avant suppression
- âœ… Index _id ne peut pas Ãªtre cachÃ©
- âœ… Contraintes (unique, TTL) restent actives
- âœ… Tester 24-48h minimum
- âœ… Un index Ã  la fois pour isolation

### Workflow Type

1. ğŸ” **Identifier** index suspect (faible utilisation)
2. ğŸ“‹ **Documenter** le test (raison, durÃ©e, baseline)
3. ğŸ™ˆ **Cacher** l'index (`hideIndex`)
4. ğŸ‘€ **Surveiller** 24-48h (mÃ©triques, slow queries)
5. âœ… **DÃ©cider** : Supprimer si OK, RÃ©activer si problÃ¨me

### Cas d'Usage Typiques

- ğŸ§ª Test suppression index
- ğŸ”„ Migration d'index
- ğŸ› Debug performances
- âš¡ A/B testing
- ğŸš€ Validation prudente en prod
- ğŸ” Identification index problÃ©matiques

### Prochaines Ã‰tapes

Maintenant que vous maÃ®trisez les index cachÃ©s, explorez :
- **[CrÃ©ation et suppression d'index](./05-creation-suppression-index.md)** : Gestion complÃ¨te
- **[Analyse avec explain()](./06-analyse-explain.md)** : Diagnostic approfondi
- **[StratÃ©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avancÃ©es
- **[Gestion des index en production](./10-gestion-index-production.md)** : Best practices opÃ©rationnelles

---

**ğŸ“š Ressources ComplÃ©mentaires**
- [Documentation officielle - Hidden Indexes](https://docs.mongodb.com/manual/core/index-hidden/)
- [Index Management](https://docs.mongodb.com/manual/indexes/)
- [Query Plans](https://docs.mongodb.com/manual/core/query-plans/)
- [Index Maintenance](https://docs.mongodb.com/manual/tutorial/manage-indexes/)

â­ï¸ [Combinaison d'options](/05-index-et-optimisation/04.5-combinaison-options.md)
