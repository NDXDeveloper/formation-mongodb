üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.4.1 Index Unique

## Introduction

Un **index unique** (ou **Unique Index**) est un index qui garantit qu'**aucune valeur dupliqu√©e** ne peut exister pour le champ index√©. C'est l'√©quivalent d'une contrainte d'unicit√© dans les bases de donn√©es relationnelles.

Les index uniques sont essentiels pour :
- **Garantir l'unicit√©** : Emp√™cher les doublons (emails, usernames, SKU...)
- **Int√©grit√© des donn√©es** : Valider automatiquement les donn√©es √† l'insertion
- **Cl√©s m√©tier** : Impl√©menter des identifiants uniques naturels
- **Performance** : Optimiser les recherches tout en garantissant l'unicit√©

L'index unique combine deux fonctions :
1. ‚úÖ **Optimisation** : Acc√©l√®re les recherches (comme un index classique)
2. ‚úÖ **Contrainte** : Emp√™che les doublons (protection des donn√©es)

---

## Le Probl√®me : Doublons Ind√©sirables

### Sans Index Unique

Imaginons une collection d'utilisateurs :

```javascript
// Collection users
db.users.insertOne({
  username: "alice",
  email: "alice@example.com",
  createdAt: new Date()
})

db.users.insertOne({
  username: "bob",
  email: "bob@example.com",
  createdAt: new Date()
})

// ‚ùå Probl√®me : Rien n'emp√™che les doublons !
db.users.insertOne({
  username: "alice",  // ‚Üê Doublon !
  email: "alice2@example.com",
  createdAt: new Date()
})
// Insertion r√©ussie ‚Üí Deux utilisateurs avec le m√™me username !
```

**Cons√©quences** :
- ‚ùå Donn√©es incoh√©rentes
- ‚ùå Bugs dans l'application (authentification, recherche...)
- ‚ùå Confusion pour les utilisateurs
- ‚ùå Difficile √† d√©tecter et corriger a posteriori

### Approche Manuelle (Inad√©quate)

```javascript
// ‚ùå V√©rification manuelle avant insertion
function createUser(username, email) {
  // V√©rifier si le username existe d√©j√†
  let existing = db.users.findOne({ username: username });

  if (existing) {
    throw new Error("Username d√©j√† utilis√©");
  }

  // Ins√©rer
  db.users.insertOne({ username, email });
}
```

**Probl√®mes** :
- ‚ùå **Race condition** : Entre la v√©rification et l'insertion, un autre processus peut ins√©rer le m√™me username
- ‚ùå **Complexit√©** : Code r√©p√©titif dans toute l'application
- ‚ùå **Performance** : Deux op√©rations au lieu d'une
- ‚ùå **Pas fiable** : Peut √©chouer en environnement concurrent

### Avec Index Unique ‚úÖ

```javascript
// Cr√©er un index unique sur username
db.users.createIndex({ username: 1 }, { unique: true })

// Tentative d'insertion d'un doublon
db.users.insertOne({
  username: "alice",  // ‚Üê D√©j√† existant
  email: "alice3@example.com"
})

// ‚úÖ R√©sultat : ERREUR automatique !
// MongoServerError: E11000 duplicate key error
```

**Avantages** :
- ‚úÖ Protection automatique garantie
- ‚úÖ Atomique (pas de race condition)
- ‚úÖ Simple √† impl√©menter
- ‚úÖ Performant (un seul appel DB)
- ‚úÖ Fiable en environnement concurrent

---

## Syntaxe de Cr√©ation

### Index Unique Simple

```javascript
db.collection.createIndex(
  { champ: 1 },
  { unique: true }
)
```

**Exemple** :
```javascript
// Index unique sur email
db.users.createIndex({ email: 1 }, { unique: true })

// Index unique sur SKU produit
db.products.createIndex({ sku: 1 }, { unique: true })

// Index unique sur num√©ro de commande
db.orders.createIndex({ orderNumber: 1 }, { unique: true })
```

### Index Unique Compos√©

Un index unique compos√© garantit que la **combinaison** des valeurs est unique :

```javascript
db.collection.createIndex(
  { champ1: 1, champ2: 1 },
  { unique: true }
)
```

**Exemple** : Inscription √† un √©v√©nement

```javascript
// Collection event_registrations
{
  eventId: "EVENT-2024-001",
  userId: 12345,
  registeredAt: ISODate("2024-01-15T10:00:00Z")
}

// Index unique compos√© : un utilisateur ne peut s'inscrire qu'une fois par √©v√©nement
db.event_registrations.createIndex(
  { eventId: 1, userId: 1 },
  { unique: true }
)

// ‚úÖ Permis : Utilisateurs diff√©rents pour m√™me √©v√©nement
db.event_registrations.insertOne({ eventId: "EVENT-2024-001", userId: 12345 })
db.event_registrations.insertOne({ eventId: "EVENT-2024-001", userId: 67890 })

// ‚úÖ Permis : M√™me utilisateur pour √©v√©nements diff√©rents
db.event_registrations.insertOne({ eventId: "EVENT-2024-001", userId: 12345 })
db.event_registrations.insertOne({ eventId: "EVENT-2024-002", userId: 12345 })

// ‚ùå Interdit : M√™me combinaison (eventId + userId)
db.event_registrations.insertOne({ eventId: "EVENT-2024-001", userId: 12345 })
db.event_registrations.insertOne({ eventId: "EVENT-2024-001", userId: 12345 })
// ERREUR : Doublon !
```

---

## L'Index Unique sur _id

MongoDB cr√©e **automatiquement** un index unique sur le champ `_id` pour toutes les collections :

```javascript
// Automatique √† la cr√©ation de la collection
{
  "v": 2,
  "key": { "_id": 1 },
  "name": "_id_",
  "unique": true  // ‚Üê Unique par d√©faut !
}
```

**Caract√©ristiques** :
- ‚úÖ Cr√©√© automatiquement
- ‚úÖ Toujours unique
- ‚úÖ Ne peut pas √™tre supprim√©
- ‚úÖ Garantit unicit√© absolue des documents

---

## Comportement avec les Valeurs NULL

### R√®gle Importante : NULL est une Valeur

MongoDB consid√®re `null` comme une **valeur**, donc un index unique n'autorise qu'**un seul document** avec une valeur `null` pour le champ index√©.

```javascript
// Index unique sur email
db.users.createIndex({ email: 1 }, { unique: true })

// ‚úÖ Premier document sans email
db.users.insertOne({ username: "alice" })
// email est implicitement null

// ‚ùå Deuxi√®me document sans email
db.users.insertOne({ username: "bob" })
// ERREUR : Duplicate key (null)
```

**Explication** :
```
Document 1 : email = null
Document 2 : email = null
‚Üí Doublon sur la valeur null ‚Üí ERREUR !
```

### Champ Absent vs null

Un champ **absent** est trait√© comme `null` pour l'indexation :

```javascript
// Ces trois documents sont √©quivalents pour l'index unique :
{ username: "alice" }                    // email absent
{ username: "bob", email: null }         // email = null explicite
{ username: "charlie", email: undefined } // email = undefined
// Tous ont email = null pour l'index ‚Üí Conflits !
```

---

## Index Unique + Sparse

Pour permettre plusieurs documents sans le champ index√©, combinez `unique` et `sparse` :

### Index Sparse : Ignore les Documents sans le Champ

```javascript
db.users.createIndex(
  { email: 1 },
  { unique: true, sparse: true }
)
```

**Comportement** :
- ‚úÖ L'index ignore les documents o√π le champ est absent ou `null`
- ‚úÖ Unicit√© garantie uniquement pour les documents **avec** une valeur
- ‚úÖ Plusieurs documents peuvent ne pas avoir le champ

**Exemple** :
```javascript
// Index unique + sparse sur email
db.users.createIndex({ email: 1 }, { unique: true, sparse: true })

// ‚úÖ Permis : Plusieurs documents sans email
db.users.insertOne({ username: "alice" })          // email absent
db.users.insertOne({ username: "bob" })            // email absent
db.users.insertOne({ username: "charlie" })        // email absent
// Tous accept√©s car sparse ignore les valeurs null

// ‚úÖ Permis : Emails uniques
db.users.insertOne({ username: "dave", email: "dave@example.com" })
db.users.insertOne({ username: "eve", email: "eve@example.com" })

// ‚ùå Interdit : Email dupliqu√©
db.users.insertOne({ username: "frank", email: "dave@example.com" })
// ERREUR : dave@example.com existe d√©j√†
```

### Cas d'Usage : Champs Optionnels Uniques

**Sc√©nario** : Site avec connexion sociale optionnelle

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  googleId: "google-123456789",  // Optionnel
  facebookId: null                // Optionnel
}

// Index unique sparse sur googleId
db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })

// Index unique sparse sur facebookId
db.users.createIndex({ facebookId: 1 }, { unique: true, sparse: true })
```

**R√©sultat** :
- ‚úÖ Utilisateurs sans googleId/facebookId : OK (plusieurs)
- ‚úÖ googleId unique si pr√©sent : Garanti
- ‚úÖ facebookId unique si pr√©sent : Garanti

---

## Comparaison : Unique vs Unique + Sparse

| Crit√®re | `{ unique: true }` | `{ unique: true, sparse: true }` |
|---------|-------------------|----------------------------------|
| **Valeurs non-null** | Doivent √™tre uniques | Doivent √™tre uniques |
| **Valeur null** | **1 seul** document autoris√© | **Plusieurs** documents autoris√©s |
| **Champ absent** | **1 seul** document autoris√© | **Plusieurs** documents autoris√©s |
| **Index inclut** | Tous les documents | Seulement documents avec valeur |
| **Cas d'usage** | Champ obligatoire unique | Champ optionnel unique |

**Exemple Visuel** :

```javascript
// Documents
{ username: "alice", email: "alice@example.com" }
{ username: "bob", email: "bob@example.com" }
{ username: "charlie" }  // Pas d'email
{ username: "dave" }     // Pas d'email

// Index unique standard
db.users.createIndex({ email: 1 }, { unique: true })
// ‚ùå ERREUR : charlie et dave ont tous deux email = null (doublon)

// Index unique sparse
db.users.createIndex({ email: 1 }, { unique: true, sparse: true })
// ‚úÖ OK : charlie et dave sont ignor√©s par l'index
```

---

## Gestion des Erreurs de Duplicit√©

### Erreur E11000

Quand une insertion ou mise √† jour viole la contrainte d'unicit√©, MongoDB retourne une erreur **E11000** :

```javascript
db.users.createIndex({ email: 1 }, { unique: true })

db.users.insertOne({ username: "alice", email: "alice@example.com" })
db.users.insertOne({ username: "bob", email: "alice@example.com" })

// Erreur retourn√©e :
MongoServerError: E11000 duplicate key error collection: mydb.users
index: email_1 dup key: { email: "alice@example.com" }
```

### Attraper l'Erreur en Code

**JavaScript/Node.js** :
```javascript
try {
  await db.users.insertOne({
    username: "alice",
    email: "alice@example.com"
  });
} catch (error) {
  if (error.code === 11000) {
    // Erreur de duplicit√©
    console.error("Email d√©j√† utilis√© :", error.keyValue.email);
    // Afficher message √† l'utilisateur
  } else {
    // Autre erreur
    throw error;
  }
}
```

**Python/PyMongo** :
```python
from pymongo.errors import DuplicateKeyError

try:
    db.users.insert_one({
        "username": "alice",
        "email": "alice@example.com"
    })
except DuplicateKeyError as e:
    print(f"Email d√©j√† utilis√© : {e.details['keyValue']['email']}")
```

### Messages Utilisateur Conviviaux

```javascript
async function createUser(username, email) {
  try {
    await db.users.insertOne({ username, email });
    return { success: true, message: "Compte cr√©√© !" };

  } catch (error) {
    if (error.code === 11000) {
      // D√©terminer quel champ est en doublon
      let field = Object.keys(error.keyValue)[0];
      let value = error.keyValue[field];

      return {
        success: false,
        message: `Le ${field} "${value}" est d√©j√† utilis√©.`
      };
    }

    // Autre erreur
    throw error;
  }
}
```

---

## Cas d'Usage Pratiques

### 1. Emails Uniques (Utilisateurs)

```javascript
// Collection users
{
  _id: ObjectId("..."),
  username: "alice",
  email: "alice@example.com",
  password: "hashed_password",
  createdAt: ISODate("2024-01-15")
}

// Index unique sur email
db.users.createIndex({ email: 1 }, { unique: true })

// Cas d'usage :
// - Inscription : Email doit √™tre unique
// - Connexion : Recherche rapide par email
// - R√©cup√©ration mot de passe : Email comme identifiant
```

**Avantage** : Garantit qu'un email = un seul compte.

### 2. Usernames Uniques

```javascript
// Index unique sur username (insensible √† la casse)
db.users.createIndex({ username: 1 }, { unique: true })

// Meilleure approche : Normaliser en minuscules
db.users.createIndex({ usernameLower: 1 }, { unique: true })

// Application :
db.users.insertOne({
  username: "Alice",
  usernameLower: "alice",  // Normalis√© pour unicit√©
  email: "alice@example.com"
})

// Recherche :
db.users.findOne({ usernameLower: username.toLowerCase() })
```

### 3. SKU Produits (E-commerce)

```javascript
// Collection products
{
  _id: ObjectId("..."),
  name: "Laptop Dell XPS 15",
  sku: "LAPTOP-DELL-XPS15-2024",  // Stock Keeping Unit
  price: 1299.99,
  category: "Electronics"
}

// Index unique sur SKU
db.products.createIndex({ sku: 1 }, { unique: true })
```

**Avantage** : Un SKU identifie un seul produit (gestion de stock, commandes).

### 4. Num√©ros de Commande

```javascript
// Collection orders
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2024-001234",
  customerId: 12345,
  items: [ /* ... */ ],
  total: 299.99,
  status: "pending"
}

// Index unique sur orderNumber
db.orders.createIndex({ orderNumber: 1 }, { unique: true })

// G√©n√©ration de num√©ro unique :
function generateOrderNumber() {
  let year = new Date().getFullYear();
  let timestamp = Date.now();
  let random = Math.floor(Math.random() * 10000);
  return `ORD-${year}-${timestamp}${random}`;
}
```

### 5. Codes de V√©rification

```javascript
// Collection verification_codes
{
  _id: ObjectId("..."),
  code: "VERIFY-ABC123XYZ789",
  userId: 12345,
  type: "email_verification",
  createdAt: ISODate("2024-01-15"),
  expiresAt: ISODate("2024-01-16")
}

// Index unique sur code
db.verification_codes.createIndex({ code: 1 }, { unique: true })

// Index TTL pour expiration
db.verification_codes.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 })
```

### 6. Inscriptions √† des √âv√©nements (Index Compos√©)

```javascript
// Collection event_registrations
{
  _id: ObjectId("..."),
  eventId: "EVENT-2024-CONF",
  userId: 12345,
  ticketType: "VIP",
  registeredAt: ISODate("2024-01-15")
}

// Index unique compos√© : un utilisateur par √©v√©nement
db.event_registrations.createIndex(
  { eventId: 1, userId: 1 },
  { unique: true }
)
```

**Avantage** : Emp√™che les inscriptions doubles au m√™me √©v√©nement.

### 7. Likes (R√©seaux Sociaux)

```javascript
// Collection post_likes
{
  _id: ObjectId("..."),
  postId: ObjectId("..."),
  userId: 12345,
  likedAt: ISODate("2024-01-15")
}

// Index unique compos√© : un like par utilisateur par post
db.post_likes.createIndex(
  { postId: 1, userId: 1 },
  { unique: true }
)
```

**Avantage** : Un utilisateur ne peut liker un post qu'une seule fois.

### 8. Connexions Sociales Optionnelles

```javascript
// Collection users avec connexions sociales optionnelles
{
  _id: ObjectId("..."),
  email: "alice@example.com",
  googleId: "google-123456789",    // Optionnel
  facebookId: null,                 // Optionnel
  githubId: null                    // Optionnel
}

// Index uniques sparse pour chaque provider
db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ facebookId: 1 }, { unique: true, sparse: true })
db.users.createIndex({ githubId: 1 }, { unique: true, sparse: true })
```

**Avantage** : IDs sociaux uniques si pr√©sents, plusieurs utilisateurs peuvent ne pas en avoir.

---

## Cr√©er un Index Unique sur une Collection Existante

### V√©rifier les Doublons Existants

Avant de cr√©er un index unique, assurez-vous qu'il n'y a pas de doublons :

```javascript
// Trouver les doublons sur email
db.users.aggregate([
  {
    $group: {
      _id: "$email",
      count: { $sum: 1 },
      ids: { $push: "$_id" }
    }
  },
  {
    $match: {
      count: { $gt: 1 }
    }
  }
])
```

**R√©sultat** :
```json
[
  {
    "_id": "alice@example.com",
    "count": 3,
    "ids": [
      ObjectId("..."),
      ObjectId("..."),
      ObjectId("...")
    ]
  }
]
```

### Nettoyer les Doublons

```javascript
// Strat√©gie : Garder le plus ancien, supprimer les autres
function cleanupDuplicates(email) {
  let docs = db.users.find({ email: email }).sort({ createdAt: 1 }).toArray();

  // Garder le premier (plus ancien)
  let toKeep = docs[0]._id;

  // Supprimer les autres
  for (let i = 1; i < docs.length; i++) {
    db.users.deleteOne({ _id: docs[i]._id });
  }
}
```

### Cr√©er l'Index Unique

```javascript
// Une fois les doublons nettoy√©s
db.users.createIndex({ email: 1 }, { unique: true })
```

**Si des doublons existent** :
```javascript
// Tentative de cr√©ation
db.users.createIndex({ email: 1 }, { unique: true })

// Erreur si doublons :
MongoServerError: Index build failed: 11000 duplicate key error
// ‚Üí Nettoyer d'abord les doublons !
```

---

## Index Unique et Mises √† Jour

### Mise √† Jour Violant l'Unicit√©

```javascript
db.users.createIndex({ email: 1 }, { unique: true })

// Documents existants :
{ _id: 1, username: "alice", email: "alice@example.com" }
{ _id: 2, username: "bob", email: "bob@example.com" }

// ‚ùå Tentative de mise √† jour violant l'unicit√©
db.users.updateOne(
  { _id: 2 },
  { $set: { email: "alice@example.com" } }
)
// ERREUR : E11000 duplicate key error
```

### Mise √† Jour S√©curis√©e

```javascript
async function updateEmail(userId, newEmail) {
  try {
    await db.users.updateOne(
      { _id: userId },
      { $set: { email: newEmail } }
    );
    return { success: true };

  } catch (error) {
    if (error.code === 11000) {
      return {
        success: false,
        message: "Cet email est d√©j√† utilis√© par un autre compte."
      };
    }
    throw error;
  }
}
```

### Upsert avec Index Unique

```javascript
// Index unique sur email
db.users.createIndex({ email: 1 }, { unique: true })

// Upsert : ins√©rer si n'existe pas, mettre √† jour sinon
db.users.updateOne(
  { email: "alice@example.com" },
  {
    $set: {
      username: "alice",
      lastLogin: new Date()
    },
    $setOnInsert: {
      createdAt: new Date()
    }
  },
  { upsert: true }
)
```

**Comportement** :
- Si email n'existe pas ‚Üí Insertion
- Si email existe ‚Üí Mise √† jour
- L'unicit√© est toujours garantie

---

## Index Unique Partiel (Partial)

Vous pouvez combiner `unique` avec un filtre `partialFilterExpression` pour appliquer l'unicit√© uniquement √† un sous-ensemble de documents :

```javascript
// Index unique uniquement pour les utilisateurs actifs
db.users.createIndex(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: { status: "active" }
  }
)
```

**Comportement** :
- Email unique seulement pour `status: "active"`
- Utilisateurs avec `status: "inactive"` peuvent avoir des emails dupliqu√©s

**Cas d'usage** :
```javascript
// Utilisateurs actifs : emails uniques
{ email: "alice@example.com", status: "active" }
{ email: "bob@example.com", status: "active" }

// Utilisateurs inactifs/supprim√©s : emails peuvent √™tre r√©utilis√©s
{ email: "charlie@example.com", status: "deleted" }
{ email: "charlie@example.com", status: "deleted" }  // ‚úÖ OK
```

---

## Limitations et Contraintes

### Taille Maximale de la Cl√©

MongoDB limite la taille totale des valeurs index√©es √† **1024 bytes** :

```javascript
db.users.createIndex({ username: 1 }, { unique: true })

// ‚ùå Username trop long (> 1024 bytes)
db.users.insertOne({
  username: "a".repeat(2000),  // 2000 caract√®res
  email: "user@example.com"
})
// ERREUR : Index key too large
```

**Solution** : Limiter la longueur des champs uniques dans votre application.

### Index Unique et Sharding

Dans un cluster shard√©, l'index unique doit :
- Soit √™tre sur la **shard key**
- Soit **contenir** la shard key comme pr√©fixe

```javascript
// Shard key : { userId: 1 }

// ‚úÖ Index unique sur shard key
db.collection.createIndex({ userId: 1 }, { unique: true })

// ‚úÖ Index unique contenant shard key
db.collection.createIndex({ userId: 1, email: 1 }, { unique: true })

// ‚ùå Index unique ne contenant PAS shard key
db.collection.createIndex({ email: 1 }, { unique: true })
// ERREUR en environnement shard√©
```

### Performances

Index unique = Index classique + V√©rification d'unicit√© :

- ‚úÖ Lectures : M√™me performance qu'un index classique
- ‚ö†Ô∏è √âcritures : L√©g√®rement plus lent (v√©rification unicit√©)
- ‚ö†Ô∏è Insertions massives : Impact plus notable

**Recommandation** : L'impact est g√©n√©ralement n√©gligeable par rapport au b√©n√©fice.

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **Utiliser pour les identifiants naturels**
   ```javascript
   // Champs qui doivent √™tre uniques par nature
   db.users.createIndex({ email: 1 }, { unique: true })
   db.products.createIndex({ sku: 1 }, { unique: true })
   db.orders.createIndex({ orderNumber: 1 }, { unique: true })
   ```

2. **Combiner avec sparse pour champs optionnels**
   ```javascript
   // Champs optionnels mais uniques si pr√©sents
   db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })
   db.users.createIndex({ googleId: 1 }, { unique: true, sparse: true })
   ```

3. **Normaliser les donn√©es avant indexation**
   ```javascript
   // Emails en minuscules
   db.users.insertOne({
     email: "Alice@Example.COM",
     emailLower: "alice@example.com"  // Normalis√©
   })
   db.users.createIndex({ emailLower: 1 }, { unique: true })
   ```

4. **G√©rer les erreurs E11000 gracieusement**
   ```javascript
   try {
     await db.users.insertOne(userData);
   } catch (error) {
     if (error.code === 11000) {
       // Message convivial pour l'utilisateur
       return "Cette adresse email est d√©j√† utilis√©e.";
     }
     throw error;
   }
   ```

5. **V√©rifier les doublons avant cr√©ation**
   ```javascript
   // Sur collection existante, v√©rifier d'abord
   db.users.aggregate([
     { $group: { _id: "$email", count: { $sum: 1 } } },
     { $match: { count: { $gt: 1 } } }
   ])
   // Nettoyer puis cr√©er l'index
   ```

6. **Documenter les contraintes**
   ```javascript
   // Commentaire dans le code
   // Index unique sur email : un email = un compte utilisateur
   // Garantit l'int√©grit√© pour connexion et r√©cup√©ration mot de passe
   db.users.createIndex({ email: 1 }, { unique: true })
   ```

### ‚ùå √Ä √âviter

1. **Ne pas cr√©er d'index unique inutile**
   ```javascript
   // ‚ùå Nom de produit unique ? Probablement non
   db.products.createIndex({ name: 1 }, { unique: true })
   // Deux produits diff√©rents peuvent avoir le m√™me nom

   // ‚úÖ SKU unique ? Oui !
   db.products.createIndex({ sku: 1 }, { unique: true })
   ```

2. **Ne pas oublier sparse pour optionnel**
   ```javascript
   // ‚ùå Sans sparse : un seul document sans phoneNumber
   db.users.createIndex({ phoneNumber: 1 }, { unique: true })

   // ‚úÖ Avec sparse : plusieurs documents sans phoneNumber
   db.users.createIndex({ phoneNumber: 1 }, { unique: true, sparse: true })
   ```

3. **Ne pas cr√©er d'index unique sur champs avec cardinalit√© faible**
   ```javascript
   // ‚ùå Mauvais choix : bool√©en
   db.users.createIndex({ isActive: 1 }, { unique: true })
   // Seulement 2 valeurs possibles !

   // ‚ùå Mauvais choix : statut avec peu de valeurs
   db.orders.createIndex({ status: 1 }, { unique: true })
   // "pending", "completed", "cancelled" ‚Üí 3 valeurs
   ```

4. **Ne pas ignorer les erreurs de duplicit√©**
   ```javascript
   // ‚ùå Ignorer silencieusement
   try {
     db.users.insertOne(userData);
   } catch (error) {
     console.log("Erreur ignor√©e");  // ‚ùå Mauvais !
   }

   // ‚úÖ G√©rer explicitement
   try {
     db.users.insertOne(userData);
   } catch (error) {
     if (error.code === 11000) {
       throw new Error("Email d√©j√† utilis√©");
     }
     throw error;
   }
   ```

5. **Ne pas cr√©er sur champs trop longs**
   ```javascript
   // ‚ùå Description compl√®te (peut d√©passer 1024 bytes)
   db.products.createIndex({ description: 1 }, { unique: true })

   // ‚úÖ Champs de longueur contr√¥l√©e
   db.products.createIndex({ sku: 1 }, { unique: true })  // Max 50 chars
   ```

---

## Analyse et V√©rification

### Lister les Index Uniques

```javascript
// Tous les index de la collection
db.users.getIndexes()

// Filtrer les index uniques
db.users.getIndexes().filter(idx => idx.unique === true)
```

**R√©sultat** :
```json
[
  {
    "v": 2,
    "key": { "_id": 1 },
    "name": "_id_",
    "unique": true
  },
  {
    "v": 2,
    "key": { "email": 1 },
    "name": "email_1",
    "unique": true
  }
]
```

### V√©rifier une Contrainte d'Unicit√©

```javascript
// V√©rifier si un index unique existe
function hasUniqueIndex(collection, field) {
  let indexes = db[collection].getIndexes();
  return indexes.some(idx =>
    idx.unique === true &&
    idx.key[field] !== undefined
  );
}

// Utilisation
hasUniqueIndex("users", "email")  // true
hasUniqueIndex("users", "age")    // false
```

### Tester l'Unicit√©

```javascript
// Tester l'unicit√© en environnement de dev
db.test_users.createIndex({ email: 1 }, { unique: true })

// Test 1 : Insertion normale
db.test_users.insertOne({ email: "test@example.com" })  // ‚úÖ

// Test 2 : Doublon
try {
  db.test_users.insertOne({ email: "test@example.com" })  // ‚ùå
} catch (e) {
  print("Erreur attendue : " + e.code);  // 11000
}

// Nettoyer
db.test_users.drop()
```

---

## Conclusion

Les **index uniques** sont un outil essentiel pour garantir l'int√©grit√© des donn√©es dans MongoDB. Ils combinent optimisation des performances et validation automatique des contraintes d'unicit√©.

### Points Cl√©s √† Retenir

- ‚úÖ Index unique = Index + Contrainte d'unicit√©
- ‚úÖ Syntaxe : `createIndex({ field: 1 }, { unique: true })`
- ‚úÖ Emp√™che automatiquement les doublons
- ‚úÖ Erreur E11000 en cas de violation
- ‚úÖ `_id` est unique par d√©faut (automatique)
- ‚úÖ NULL = valeur ‚Üí 1 seul document avec null (sauf sparse)
- ‚úÖ `sparse: true` ‚Üí Permet plusieurs documents sans le champ
- ‚úÖ Index compos√© unique ‚Üí Combinaison unique
- ‚úÖ Essentiel pour emails, SKU, codes, num√©ros
- ‚úÖ V√©rifier doublons existants avant cr√©ation

### Cas d'Usage Typiques

- üîê Emails utilisateurs
- üë§ Usernames
- üè∑Ô∏è SKU produits
- üìã Num√©ros de commande
- üé´ Codes de v√©rification
- üì± Num√©ros de t√©l√©phone (optionnel avec sparse)
- üåê IDs de connexions sociales (optionnel avec sparse)
- üë• Inscriptions √©v√©nements (compos√©)
- ‚ù§Ô∏è Likes/votes (compos√©)

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les index uniques, explorez :
- **[Index partiel (Partial)](./04.2-index-partiel.md)** : Indexer un sous-ensemble de documents
- **[Index sparse](./04.3-index-sparse.md)** : G√©rer les valeurs manquantes
- **[Index cach√© (Hidden)](./04.4-index-cache.md)** : Tester sans supprimer
- **[Strat√©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avanc√©es

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - Unique Indexes](https://docs.mongodb.com/manual/core/index-unique/)
- [Unique Index Restrictions](https://docs.mongodb.com/manual/core/index-unique/#restrictions)
- [Index Properties](https://docs.mongodb.com/manual/core/index-properties/)
- [Error Handling Best Practices](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/embedded-documents/)

‚è≠Ô∏è [Index partiel (Partial)](/05-index-et-optimisation/04.2-index-partiel.md)
