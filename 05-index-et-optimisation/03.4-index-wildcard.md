üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.3.4 Index Wildcard

## Introduction

Un **index wildcard** (ou **Wildcard Index**) est un type d'index sp√©cialis√© dans MongoDB con√ßu pour indexer automatiquement **tous les champs** d'un document ou **tous les sous-champs** d'un objet imbriqu√©, y compris les champs dont les noms ne sont pas connus √† l'avance.

Les index wildcard sont particuli√®rement utiles pour :
- **Sch√©mas flexibles** avec des noms de champs dynamiques
- **Documents h√©t√©rog√®nes** avec des structures variables
- **Attributs personnalis√©s** d√©finis par les utilisateurs
- **Donn√©es imbriqu√©es complexes** avec de nombreux niveaux

Contrairement aux index traditionnels qui n√©cessitent de sp√©cifier chaque champ √† indexer, un index wildcard s'adapte automatiquement √† la structure des documents.

---

## Le Probl√®me : Sch√©mas Flexibles

### Documents avec Champs Dynamiques

MongoDB permet des sch√©mas tr√®s flexibles, ce qui peut poser des d√©fis pour l'indexation :

**Exemple 1 : Attributs Produits E-commerce**

```javascript
// Produit 1 : Laptop
{
  _id: 1,
  name: "Laptop Dell XPS",
  category: "Electronics",
  attributes: {
    brand: "Dell",
    processor: "Intel i7",
    ram: "16GB",
    storage: "512GB SSD",
    screenSize: "15.6 inches"
  }
}

// Produit 2 : T-shirt
{
  _id: 2,
  name: "T-shirt Nike",
  category: "Clothing",
  attributes: {
    brand: "Nike",
    size: "M",
    color: "Blue",
    material: "Cotton",
    fitType: "Regular"
  }
}

// Produit 3 : Livre
{
  _id: 3,
  name: "MongoDB Guide",
  category: "Books",
  attributes: {
    author: "John Doe",
    publisher: "Tech Press",
    isbn: "978-1234567890",
    pages: 450,
    language: "English"
  }
}
```

**Probl√®me** : Chaque type de produit a des attributs diff√©rents. Comment indexer efficacement `attributes` ?

**Solutions classiques** (inadapt√©es) :

```javascript
// ‚ùå Option 1 : Index sur l'objet complet
db.products.createIndex({ attributes: 1 })
// Probl√®me : Ne permet pas de chercher par attribut sp√©cifique

// ‚ùå Option 2 : Cr√©er un index pour chaque attribut possible
db.products.createIndex({ "attributes.brand": 1 })
db.products.createIndex({ "attributes.size": 1 })
db.products.createIndex({ "attributes.color": 1 })
db.products.createIndex({ "attributes.author": 1 })
// ... 50+ index !
// Probl√®me : Explosion du nombre d'index, maintenance impossible

// ‚ùå Option 3 : Index compos√© massif
db.products.createIndex({
  "attributes.brand": 1,
  "attributes.size": 1,
  "attributes.color": 1
  // ... tous les attributs
})
// Probl√®me : Limit√© √† 32 champs, ne couvre pas tous les cas
```

### La Solution : Index Wildcard

```javascript
// ‚úÖ Index wildcard sur attributes
db.products.createIndex({ "attributes.$**": 1 })

// Indexe automatiquement TOUS les sous-champs :
// - attributes.brand
// - attributes.size
// - attributes.color
// - attributes.author
// - attributes.processor
// ... et tous les futurs attributs !
```

**Avantage** : Un seul index qui s'adapte automatiquement √† tous les attributs, pr√©sents et futurs ! ‚úÖ

---

## Qu'est-ce qu'un Index Wildcard ?

### Analogie : Le Biblioth√©caire Intelligent

Imaginez une biblioth√®que avec des fiches de catalogage :

**Index classique** = Fiches pr√©-imprim√©es avec champs fixes
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Titre: _______  ‚îÇ
‚îÇ Auteur: ______  ‚îÇ
‚îÇ ISBN: ________  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
‚ùå Probl√®me : Que faire si un livre a aussi "Illustrateur", "Traducteur", "√âdition" ?

**Index wildcard** = Syst√®me flexible qui catalogue tout
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Tout champ pr√©sent est  ‚îÇ
‚îÇ automatiquement index√©  ‚îÇ
‚îÇ quel que soit son nom   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
‚úÖ S'adapte √† n'importe quelle structure !

### Fonctionnement Interne

Un index wildcard cr√©e en r√©alit√© **plusieurs index simples**, un pour chaque chemin de champ trouv√© dans les documents :

```javascript
// Documents
{ attributes: { brand: "Dell", ram: "16GB" } }
{ attributes: { brand: "Nike", size: "M" } }

// Index wildcard cr√©e internement :
// - Index sur attributes.brand
// - Index sur attributes.ram
// - Index sur attributes.size
```

MongoDB d√©couvre et indexe automatiquement tous les chemins au fur et √† mesure de l'insertion des documents.

---

## Syntaxe de Cr√©ation

### Index Wildcard sur Tous les Champs d'un Document

```javascript
// Indexer TOUS les champs du document
db.collection.createIndex({ "$**": 1 })
```

**Utilisation** : Documents avec structure compl√®tement variable.

### Index Wildcard sur un Sous-Objet

```javascript
// Indexer tous les sous-champs d'un objet sp√©cifique
db.collection.createIndex({ "champ.$**": 1 })
```

**Exemple** :
```javascript
// Indexer tous les attributs
db.products.createIndex({ "attributes.$**": 1 })

// Indexer toutes les m√©tadonn√©es
db.documents.createIndex({ "metadata.$**": 1 })
```

### Index Wildcard avec Projection

Vous pouvez inclure ou exclure certains chemins :

#### Inclusion de Chemins Sp√©cifiques

```javascript
db.collection.createIndex(
  { "$**": 1 },
  {
    wildcardProjection: {
      "champ1": 1,
      "champ2.sousChamp": 1
    }
  }
)
```

**Exemple** :
```javascript
// Indexer uniquement les champs sp√©cifi√©s
db.products.createIndex(
  { "$**": 1 },
  {
    wildcardProjection: {
      "attributes.brand": 1,
      "attributes.color": 1,
      "price": 1
    }
  }
)
```

#### Exclusion de Chemins Sp√©cifiques

```javascript
db.collection.createIndex(
  { "$**": 1 },
  {
    wildcardProjection: {
      "champAExclure": 0
    }
  }
)
```

**Exemple** :
```javascript
// Indexer tous les champs SAUF les m√©tadonn√©es internes
db.products.createIndex(
  { "$**": 1 },
  {
    wildcardProjection: {
      "_internalMetadata": 0,
      "tempData": 0
    }
  }
)
```

‚ö†Ô∏è **Important** : Vous ne pouvez pas m√©langer inclusion et exclusion (sauf pour `_id`).

---

## Requ√™tes Support√©es

### Recherches d'√âgalit√© ‚úÖ

```javascript
// Index wildcard
db.products.createIndex({ "attributes.$**": 1 })

// ‚úÖ Recherche d'√©galit√©
db.products.find({ "attributes.brand": "Dell" })

// ‚úÖ Recherche d'√©galit√© sur autre attribut
db.products.find({ "attributes.size": "M" })

// ‚úÖ Recherche avec $eq
db.products.find({ "attributes.color": { $eq: "Blue" } })
```

### Recherches par Plage ‚úÖ

```javascript
// ‚úÖ Recherche par plage
db.products.find({ "attributes.price": { $gte: 100, $lte: 500 } })

// ‚úÖ Comparaisons
db.products.find({ "attributes.rating": { $gt: 4.0 } })
```

### Op√©rateur $in ‚úÖ

```javascript
// ‚úÖ Recherche avec $in
db.products.find({
  "attributes.brand": { $in: ["Dell", "HP", "Lenovo"] }
})
```

### Op√©rateurs d'Existence ‚úÖ

```javascript
// ‚úÖ V√©rifier l'existence d'un champ
db.products.find({ "attributes.warranty": { $exists: true } })
```

### Requ√™tes sur Tableaux ‚úÖ

```javascript
// Documents
{
  tags: {
    technical: ["database", "nosql", "mongodb"],
    business: ["ecommerce", "retail"]
  }
}

// Index wildcard
db.articles.createIndex({ "tags.$**": 1 })

// ‚úÖ Recherche dans tableau
db.articles.find({ "tags.technical": "mongodb" })
```

### Limitations ‚ùå

#### Requ√™tes Multi-Champs

```javascript
// ‚ùå Ne peut pas utiliser l'index wildcard pour plusieurs champs simultan√©ment
db.products.find({
  "attributes.brand": "Dell",
  "attributes.ram": "16GB"
})
// Utilisera l'index pour UN SEUL champ, pas les deux
```

#### Tri

```javascript
// ‚ö†Ô∏è Le tri peut utiliser l'index wildcard, mais avec limitations
db.products.find({ "attributes.brand": "Dell" })
  .sort({ "attributes.price": 1 })
// Peut ne pas √™tre optimal
```

#### Index Compos√© avec Wildcard

```javascript
// ‚ùå Impossible de combiner wildcard avec d'autres champs dans un index compos√©
db.products.createIndex({
  category: 1,
  "attributes.$**": 1  // ERREUR !
})
```

---

## Cas d'Usage Pratiques

### 1. E-commerce : Attributs Produits Variables

**Contexte** : Catalogue avec des cat√©gories tr√®s diff√©rentes

```javascript
// Collection products
{
  _id: 1,
  name: "Laptop",
  category: "Electronics",
  specs: {
    brand: "Dell",
    model: "XPS 15",
    processor: "Intel i7-11800H",
    ram: "32GB",
    storage: "1TB SSD",
    gpu: "NVIDIA RTX 3050",
    screenSize: "15.6 inches",
    weight: "2.0 kg"
  }
}

{
  _id: 2,
  name: "Running Shoes",
  category: "Sports",
  specs: {
    brand: "Nike",
    model: "Air Zoom Pegasus",
    size: "42",
    color: "Blue/White",
    gender: "Unisex",
    sport: "Running",
    cushioning: "High"
  }
}

// Index wildcard sur specs
db.products.createIndex({ "specs.$**": 1 })

// Recherches optimis√©es sur n'importe quelle spec
db.products.find({ "specs.brand": "Nike" })
db.products.find({ "specs.processor": /Intel/ })
db.products.find({ "specs.size": "42" })
db.products.find({ "specs.sport": "Running" })
```

**Avantage** : Un seul index pour tous les types de produits, quelle que soit leur cat√©gorie.

### 2. Donn√©es Utilisateur Personnalis√©es

**Contexte** : Profils utilisateurs avec champs personnalisables

```javascript
// Collection users
{
  _id: 1,
  username: "alice",
  email: "alice@example.com",
  customFields: {
    favoriteColor: "Blue",
    hometown: "Paris",
    hobby: "Photography",
    yearJoined: 2020
  }
}

{
  _id: 2,
  username: "bob",
  email: "bob@example.com",
  customFields: {
    company: "Tech Corp",
    jobTitle: "Developer",
    programmingLanguages: ["JavaScript", "Python"],
    experienceYears: 5
  }
}

// Index wildcard
db.users.createIndex({ "customFields.$**": 1 })

// Recherches sur n'importe quel champ personnalis√©
db.users.find({ "customFields.hobby": "Photography" })
db.users.find({ "customFields.company": "Tech Corp" })
db.users.find({ "customFields.experienceYears": { $gte: 3 } })
```

### 3. Syst√®me de Configuration Multi-Tenant

**Contexte** : Application SaaS avec configurations par client

```javascript
// Collection tenants
{
  _id: "tenant-123",
  name: "Company A",
  config: {
    emailNotifications: true,
    maxUsers: 100,
    features: {
      advancedReporting: true,
      apiAccess: true,
      ssoEnabled: true
    },
    branding: {
      primaryColor: "#FF5733",
      logo: "https://..."
    },
    integrations: {
      slack: { enabled: true, webhookUrl: "..." },
      zapier: { enabled: false }
    }
  }
}

// Index wildcard sur config
db.tenants.createIndex({ "config.$**": 1 })

// Requ√™tes sur diff√©rentes configurations
db.tenants.find({ "config.features.apiAccess": true })
db.tenants.find({ "config.maxUsers": { $gte: 50 } })
db.tenants.find({ "config.integrations.slack.enabled": true })
```

### 4. M√©tadonn√©es de Fichiers

**Contexte** : Syst√®me de gestion documentaire avec m√©tadonn√©es vari√©es

```javascript
// Collection files
{
  _id: ObjectId("..."),
  filename: "report.pdf",
  uploadedAt: ISODate("2024-01-15"),
  metadata: {
    // M√©tadonn√©es communes
    author: "John Doe",
    department: "Sales",

    // M√©tadonn√©es sp√©cifiques PDF
    pageCount: 25,
    pdfVersion: "1.7",
    hasAnnotations: true
  }
}

{
  _id: ObjectId("..."),
  filename: "photo.jpg",
  uploadedAt: ISODate("2024-01-15"),
  metadata: {
    // M√©tadonn√©es communes
    author: "Jane Smith",
    department: "Marketing",

    // M√©tadonn√©es sp√©cifiques image
    width: 3840,
    height: 2160,
    format: "JPEG",
    camera: "Canon EOS R5",
    iso: 400,
    aperture: "f/2.8",
    shutterSpeed: "1/250"
  }
}

// Index wildcard sur metadata
db.files.createIndex({ "metadata.$**": 1 })

// Recherches vari√©es
db.files.find({ "metadata.department": "Marketing" })
db.files.find({ "metadata.camera": "Canon EOS R5" })
db.files.find({ "metadata.pageCount": { $gt: 20 } })
```

### 5. Logs avec Donn√©es Contextuelles Variables

**Contexte** : Syst√®me de logging avec contexte variable

```javascript
// Collection logs
{
  _id: ObjectId("..."),
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  level: "error",
  message: "Database connection failed",
  context: {
    service: "api-server",
    environment: "production",
    errorCode: "CONN_TIMEOUT",
    database: "mongodb",
    host: "db.example.com",
    port: 27017,
    attemptNumber: 3
  }
}

{
  _id: ObjectId("..."),
  timestamp: ISODate("2024-01-15T10:31:00Z"),
  level: "info",
  message: "User logged in",
  context: {
    service: "auth-service",
    userId: 12345,
    username: "alice",
    ipAddress: "192.168.1.100",
    userAgent: "Mozilla/5.0...",
    sessionId: "abc123xyz"
  }
}

// Index wildcard sur context
db.logs.createIndex({ "context.$**": 1 })

// Recherches dans contexte variable
db.logs.find({ "context.service": "api-server" })
db.logs.find({ "context.userId": 12345 })
db.logs.find({ "context.errorCode": "CONN_TIMEOUT" })
```

### 6. Donn√©es IoT avec Capteurs H√©t√©rog√®nes

**Contexte** : Plateforme IoT avec diff√©rents types de capteurs

```javascript
// Collection sensor_readings
{
  _id: ObjectId("..."),
  sensorId: "TEMP-001",
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  readings: {
    temperature: 22.5,
    humidity: 65.2,
    pressure: 1013.25
  }
}

{
  _id: ObjectId("..."),
  sensorId: "GPS-001",
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  readings: {
    latitude: 48.8566,
    longitude: 2.3522,
    altitude: 35.0,
    speed: 0,
    satellites: 12,
    accuracy: 5.0
  }
}

{
  _id: ObjectId("..."),
  sensorId: "MOTION-001",
  timestamp: ISODate("2024-01-15T10:30:00Z"),
  readings: {
    motionDetected: true,
    intensity: 7,
    direction: "north",
    duration: 3.5
  }
}

// Index wildcard sur readings
db.sensor_readings.createIndex({ "readings.$**": 1 })

// Requ√™tes sur diff√©rents types de mesures
db.sensor_readings.find({ "readings.temperature": { $gt: 25 } })
db.sensor_readings.find({ "readings.motionDetected": true })
db.sensor_readings.find({ "readings.latitude": { $exists: true } })
```

---

## Performance et Consid√©rations

### Avantages

‚úÖ **Flexibilit√© maximale**
- Un seul index pour de nombreux champs
- S'adapte automatiquement aux nouveaux champs
- Parfait pour sch√©mas √©volutifs

‚úÖ **Simplicit√© de maintenance**
- Pas besoin de cr√©er/supprimer des index √† chaque nouveau champ
- Gestion automatique

‚úÖ **Requ√™tes sur champs inconnus**
- Permet de rechercher sur des champs ajout√©s apr√®s la cr√©ation de l'index

‚úÖ **√âvite l'explosion d'index**
- Un seul index wildcard plut√¥t que des dizaines d'index simples

### Limitations et Inconv√©nients

‚ùå **Taille de l'index**
```
Index wildcard peut √™tre TR√àS volumineux
- Indexe potentiellement des centaines de chemins
- Chaque chemin = entr√©e d'index suppl√©mentaire
- Peut atteindre plusieurs fois la taille des donn√©es
```

‚ùå **Performance d'√©criture**
```
Impact sur les insertions/mises √† jour :
- MongoDB doit analyser la structure du document
- Cr√©er/mettre √† jour des entr√©es pour chaque chemin
- Plus le document est complexe, plus l'impact est grand
```

‚ùå **Requ√™tes multi-champs moins efficaces**
```javascript
// Moins optimal qu'un index compos√© d√©di√©
db.products.find({
  "attributes.brand": "Dell",
  "attributes.ram": "16GB"
})
```

‚ùå **Pas d'index compos√© avec wildcard**
```javascript
// ‚ùå Impossible
db.products.createIndex({
  category: 1,
  "attributes.$**": 1
})
```

‚ùå **Limite de chemins index√©s**
- MongoDB limite le nombre total de chemins index√©s
- Pour documents tr√®s complexes, peut atteindre la limite

### Comparaison de Taille d'Index

**Exemple** : 1 million de documents

```javascript
// Document type
{
  category: "Electronics",
  attributes: {
    brand: "Dell",
    model: "XPS 15",
    processor: "Intel i7",
    ram: "16GB",
    storage: "512GB"
  }
}

// Index classique (1 champ)
db.products.createIndex({ "attributes.brand": 1 })
// Taille : ~20 MB

// Index wildcard (tous les sous-champs)
db.products.createIndex({ "attributes.$**": 1 })
// Taille : ~100 MB (5 chemins index√©s)
// Plus volumineux mais plus flexible
```

---

## Quand Utiliser un Index Wildcard

### ‚úÖ Utilisez un Index Wildcard Quand

1. **Sch√©mas tr√®s flexibles**
   - Noms de champs non connus √† l'avance
   - Structure de document variable par type

2. **Attributs personnalis√©s**
   - Champs d√©finis par les utilisateurs
   - Configuration multi-tenant
   - M√©tadonn√©es extensibles

3. **Requ√™tes sur champs vari√©s**
   - Vous interrogez diff√©rents champs selon le contexte
   - Pas de pattern de requ√™te fixe

4. **Documents h√©t√©rog√®nes**
   - Diff√©rents types de documents dans la m√™me collection
   - Chaque type a ses propres champs sp√©cifiques

5. **√âvolution rapide du sch√©ma**
   - Application en d√©veloppement actif
   - Nouveaux champs ajout√©s fr√©quemment

### ‚ùå N'utilisez PAS un Index Wildcard Quand

1. **Sch√©ma stable et bien d√©fini**
   ```javascript
   // Si votre sch√©ma est fixe, utilisez des index classiques
   db.users.createIndex({ email: 1 })
   db.users.createIndex({ username: 1 })
   ```

2. **Requ√™tes sur un ensemble fixe de champs**
   ```javascript
   // Si vous savez que vous cherchez toujours sur brand et price
   // Utilisez un index compos√© sp√©cifique
   db.products.createIndex({ brand: 1, price: 1 })
   ```

3. **Performance critique**
   - Index wildcard peut √™tre plus lent qu'un index d√©di√©
   - Pour applications haute performance, pr√©f√©rez des index sp√©cifiques

4. **Peu de champs variables**
   ```javascript
   // Si seulement 3-4 champs variables, cr√©ez des index simples
   db.products.createIndex({ "attributes.color": 1 })
   db.products.createIndex({ "attributes.size": 1 })
   db.products.createIndex({ "attributes.material": 1 })
   ```

5. **Contraintes de stockage**
   - Index wildcard consomme beaucoup d'espace
   - Si l'espace disque est limit√©, soyez s√©lectif

---

## Comparaison avec Alternatives

### Index Wildcard vs Index Multiples

**Sc√©nario** : 20 attributs diff√©rents possibles

#### Option 1 : Index Wildcard

```javascript
// ‚úÖ Un seul index
db.products.createIndex({ "attributes.$**": 1 })

// Avantages :
// - Simple √† g√©rer
// - S'adapte aux nouveaux attributs
// - Espace : ~100 MB

// Inconv√©nients :
// - Performance moyenne
// - Volumineux
```

#### Option 2 : 20 Index Simples

```javascript
// ‚ùå 20 index distincts
db.products.createIndex({ "attributes.brand": 1 })
db.products.createIndex({ "attributes.color": 1 })
// ... 18 autres index

// Avantages :
// - Performance optimale par champ
// - Espace : ~20 MB par index = 400 MB

// Inconv√©nients :
// - Complexe √† g√©rer
// - Ne couvre pas les futurs attributs
// - Impact √©norme sur les √©critures
```

### Index Wildcard vs Index Compos√©

**Sc√©nario** : Requ√™tes fr√©quentes sur brand + price

#### Option 1 : Index Wildcard

```javascript
db.products.createIndex({ "attributes.$**": 1 })

// Requ√™te
db.products.find({
  "attributes.brand": "Dell",
  "attributes.price": { $lte: 1000 }
})

// ‚ö†Ô∏è Utilise l'index pour UN seul champ
```

#### Option 2 : Index Compos√© D√©di√©

```javascript
db.products.createIndex({
  "attributes.brand": 1,
  "attributes.price": 1
})

// Requ√™te
db.products.find({
  "attributes.brand": "Dell",
  "attributes.price": { $lte: 1000 }
})

// ‚úÖ Utilise l'index pour LES DEUX champs = optimal
```

**Conclusion** : Pour des requ√™tes multi-champs fr√©quentes et connues, un index compos√© est sup√©rieur.

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **Limiter le scope avec wildcardProjection**
   ```javascript
   // Indexer seulement les champs utiles
   db.products.createIndex(
     { "attributes.$**": 1 },
     {
       wildcardProjection: {
         "attributes.brand": 1,
         "attributes.category": 1,
         "attributes.price": 1
       }
     }
   )
   ```

2. **Surveiller la taille de l'index**
   ```javascript
   // V√©rifier r√©guli√®rement
   db.products.stats()
   ```

3. **Combiner avec index sp√©cifiques**
   ```javascript
   // Index wildcard pour flexibilit√©
   db.products.createIndex({ "attributes.$**": 1 })

   // Index d√©di√©s pour requ√™tes fr√©quentes
   db.products.createIndex({ category: 1, price: -1 })
   ```

4. **Utiliser explain() pour v√©rifier**
   ```javascript
   db.products.find({ "attributes.brand": "Dell" })
     .explain("executionStats")
   ```

5. **Documenter le choix**
   ```javascript
   // Commentaire dans le code
   // Index wildcard sur attributes car :
   // - 50+ attributs diff√©rents possibles
   // - Structure variable par cat√©gorie
   // - Nouveaux attributs ajout√©s r√©guli√®rement
   db.products.createIndex({ "attributes.$**": 1 })
   ```

6. **Tester l'impact sur les performances**
   ```javascript
   // Mesurer avant/apr√®s
   // - Temps de requ√™te
   // - Temps d'insertion
   // - Taille de l'index
   ```

### ‚ùå √Ä √âviter

1. **Ne pas utiliser sur TOUS les champs sans raison**
   ```javascript
   // ‚ùå Trop large si pas n√©cessaire
   db.collection.createIndex({ "$**": 1 })

   // ‚úÖ Limiter au sous-objet concern√©
   db.collection.createIndex({ "dynamicFields.$**": 1 })
   ```

2. **Ne pas oublier les index sp√©cifiques pour requ√™tes fr√©quentes**
   ```javascript
   // ‚ùå Seulement wildcard
   db.products.createIndex({ "attributes.$**": 1 })

   // ‚úÖ Wildcard + index d√©di√©
   db.products.createIndex({ "attributes.$**": 1 })
   db.products.createIndex({ category: 1, price: -1 })
   ```

3. **Ne pas utiliser pour sch√©mas stables**
   ```javascript
   // ‚ùå Sch√©ma fixe ne n√©cessite pas wildcard
   {
     name: "...",
     email: "...",
     age: 30
   }

   // ‚úÖ Utilisez des index classiques
   db.users.createIndex({ email: 1 })
   ```

4. **Ne pas ignorer l'impact sur les √©critures**
   ```javascript
   // Mesurer l'impact sur INSERT/UPDATE
   // avant de d√©ployer en production
   ```

5. **Ne pas cr√©er plusieurs index wildcard redondants**
   ```javascript
   // ‚ùå Redondant
   db.products.createIndex({ "attributes.$**": 1 })
   db.products.createIndex({ "attributes.specs.$**": 1 })

   // ‚úÖ Un seul index couvre les deux
   db.products.createIndex({ "attributes.$**": 1 })
   ```

---

## Analyse et V√©rification

### V√©rifier l'Index Wildcard

```javascript
db.products.getIndexes()
```

**R√©sultat** :
```json
[
  {
    "v": 2,
    "key": { "$**": 1 },
    "name": "$**_1",
    "wildcardProjection": {
      "attributes": 1
    }
  }
]
```

### Analyser une Requ√™te

```javascript
db.products.find({ "attributes.brand": "Dell" })
  .explain("executionStats")
```

**Points cl√©s** :
```javascript
{
  "winningPlan": {
    "stage": "FETCH",
    "inputStage": {
      "stage": "IXSCAN",
      "indexName": "$**_1",  // ‚úÖ Utilise l'index wildcard
      "keyPattern": { "$_path": 1, "attributes.brand": 1 },
      "isMultiKey": false
    }
  },
  "executionStats": {
    "totalDocsExamined": 150,
    "executionTimeMillis": 5
  }
}
```

### Statistiques d'Index

```javascript
db.products.aggregate([{ $indexStats: {} }])
```

**R√©sultat** :
```json
[
  {
    "name": "$**_1",
    "key": { "$**": 1 },
    "host": "...",
    "accesses": {
      "ops": 5432,
      "since": ISODate("2024-01-01T00:00:00Z")
    },
    "spec": {
      "wildcardProjection": { "attributes": 1 }
    }
  }
]
```

---

## Migration et Gestion

### Ajouter un Index Wildcard √† une Collection Existante

```javascript
// 1. Analyser les requ√™tes actuelles
db.products.aggregate([
  { $currentOp: {} },
  { $match: { op: "query" } }
])

// 2. Cr√©er l'index wildcard
db.products.createIndex({ "attributes.$**": 1 })

// 3. Surveiller la taille
db.products.stats().indexSizes

// 4. Tester les performances
db.products.find({ "attributes.brand": "Dell" })
  .explain("executionStats")
```

### Optimiser un Index Wildcard Existant

Si l'index wildcard est trop volumineux, ajoutez une projection :

```javascript
// 1. Analyser les champs r√©ellement utilis√©s
db.products.find({}).limit(1000).forEach(function(doc) {
  print(Object.keys(doc.attributes))
})

// 2. Supprimer l'ancien index
db.products.dropIndex("$**_1")

// 3. Cr√©er un index wildcard avec projection
db.products.createIndex(
  { "attributes.$**": 1 },
  {
    wildcardProjection: {
      "attributes.brand": 1,
      "attributes.category": 1,
      "attributes.price": 1,
      "attributes.inStock": 1
    }
  }
)
```

### Supprimer un Index Wildcard

```javascript
// Par nom
db.products.dropIndex("$**_1")

// Ou recr√©er tous les index
db.products.dropIndexes()
db.products.createIndex({ /* nouveaux index */ })
```

---

## Conclusion

Les **index wildcard** sont un outil puissant pour g√©rer des sch√©mas flexibles et des donn√©es h√©t√©rog√®nes dans MongoDB. Ils offrent une grande flexibilit√© au prix d'une taille d'index plus importante et de performances parfois inf√©rieures √† des index sp√©cialis√©s.

### Points Cl√©s √† Retenir

- ‚úÖ Index wildcard = Flexibilit√© maximale pour sch√©mas variables
- ‚úÖ Syntaxe : `db.collection.createIndex({ "champ.$**": 1 })`
- ‚úÖ Indexe automatiquement tous les sous-chemins
- ‚úÖ Parfait pour attributs personnalis√©s, m√©tadonn√©es, configurations
- ‚úÖ Utiliser `wildcardProjection` pour limiter le scope
- ‚úÖ Plus volumineux que des index classiques
- ‚úÖ Impact sur les performances d'√©criture
- ‚úÖ Ne remplace pas les index compos√©s pour requ√™tes fr√©quentes
- ‚úÖ Un seul champ wildcard par index

### Quand Utiliser

‚úÖ **Utilisez pour** :
- Sch√©mas flexibles et √©volutifs
- Attributs personnalis√©s par utilisateur
- Documents h√©t√©rog√®nes
- M√©tadonn√©es extensibles
- Configurations multi-tenant
- Noms de champs non connus √† l'avance

‚ùå **N'utilisez PAS pour** :
- Sch√©mas stables et bien d√©finis
- Requ√™tes sur ensemble fixe de champs
- Applications haute performance critique
- Contraintes de stockage strictes
- Peu de champs variables (<5)

### Prochaines √âtapes

Maintenant que vous ma√Ætrisez les index wildcard, explorez :
- **[Index TTL](./03.5-index-ttl.md)** : Expiration automatique des documents
- **[Index partiel](./04.2-index-partiel.md)** : Indexer un sous-ensemble de documents
- **[Strat√©gies d'optimisation](./08-strategies-optimisation.md)** : Techniques avanc√©es
- **[Gestion des index en production](./10-gestion-index-production.md)** : Best practices op√©rationnelles

---

**üìö Ressources Compl√©mentaires**
- [Documentation officielle - Wildcard Indexes](https://docs.mongodb.com/manual/core/index-wildcard/)
- [Wildcard Index Restrictions](https://docs.mongodb.com/manual/core/index-wildcard/#restrictions)
- [Wildcard Projection](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#wildcard-projection)
- [Schema Design Patterns](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)

‚è≠Ô∏è [Index TTL (Time-To-Live)](/05-index-et-optimisation/03.5-index-ttl.md)
