üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.3 $group - Regrouper et Agr√©ger les Donn√©es

## Introduction

L'√©tape `$group` est l'une des op√©rations les plus puissantes du framework d'agr√©gation MongoDB. Elle permet de **regrouper des documents** selon un ou plusieurs crit√®res et d'effectuer des **calculs d'agr√©gation** sur ces groupes (somme, moyenne, comptage, etc.).

Pensez √† `$group` comme un **organisateur** qui trie vos documents en cat√©gories et calcule des statistiques pour chaque cat√©gorie. C'est l'√©quivalent de la clause `GROUP BY` en SQL.

## √Ä Quoi Sert $group ?

### 1. **Regrouper par Crit√®re**
Organiser vos documents en groupes selon une ou plusieurs valeurs communes.

### 2. **Calculer des Statistiques**
Effectuer des calculs sur chaque groupe : somme, moyenne, minimum, maximum, comptage...

### 3. **Cr√©er des Agr√©gations**
Transformer plusieurs documents en un seul document r√©sum√© par groupe.

### 4. **Analyser les Donn√©es**
Extraire des insights et tendances de vos collections.

## Syntaxe de Base

```javascript
{
  $group: {
    _id: <expression>,              // Crit√®re de regroupement (obligatoire)
    <champ1>: { <accumulateur1>: <expression1> },
    <champ2>: { <accumulateur2>: <expression2> }
  }
}
```

**√âl√©ments cl√©s** :
- **`_id`** : D√©finit le crit√®re de regroupement (obligatoire, peut √™tre `null` pour tout regrouper)
- **Accumulateurs** : Op√©rations d'agr√©gation ($sum, $avg, $max, etc.)
- **Nouveaux champs** : Les r√©sultats sont stock√©s dans de nouveaux champs

## Le Champ _id : La Cl√© du Regroupement

‚ö†Ô∏è **Le champ `_id` est OBLIGATOIRE** dans `$group`. Il d√©finit comment les documents seront regroup√©s.

### Exemples de _id

```javascript
// Grouper par une valeur unique
{ _id: "$categorie" }

// Grouper par plusieurs champs
{ _id: { categorie: "$categorie", statut: "$statut" } }

// Regrouper tous les documents ensemble
{ _id: null }

// Grouper par une expression calcul√©e
{ _id: { $year: "$date" } }
```

## Les Accumulateurs : Calculer sur les Groupes

Les accumulateurs effectuent des calculs sur les documents de chaque groupe :

| Accumulateur | Description | Exemple |
|--------------|-------------|---------|
| `$sum` | Somme des valeurs | `{ total: { $sum: "$montant" } }` |
| `$avg` | Moyenne des valeurs | `{ moyenne: { $avg: "$note" } }` |
| `$min` | Valeur minimale | `{ minimum: { $min: "$prix" } }` |
| `$max` | Valeur maximale | `{ maximum: { $max: "$prix" } }` |
| `$count` | Compte les documents | `{ nombre: { $count: {} } }` |
| `$first` | Premier document du groupe | `{ premier: { $first: "$nom" } }` |
| `$last` | Dernier document du groupe | `{ dernier: { $last: "$nom" } }` |
| `$push` | Cr√©e un tableau avec toutes les valeurs | `{ liste: { $push: "$item" } }` |
| `$addToSet` | Tableau de valeurs uniques | `{ unique: { $addToSet: "$tag" } }` |

## Exemples Progressifs

### Exemple 1 : Compter les Documents par Cat√©gorie

Imaginons une collection `produits` :

```javascript
// Collection: produits
{ "_id": 1, "nom": "Laptop", "categorie": "√âlectronique", "prix": 1200 }
{ "_id": 2, "nom": "Souris", "categorie": "√âlectronique", "prix": 25 }
{ "_id": 3, "nom": "Chaise", "categorie": "Meuble", "prix": 150 }
{ "_id": 4, "nom": "Bureau", "categorie": "Meuble", "prix": 300 }
{ "_id": 5, "nom": "T√©l√©phone", "categorie": "√âlectronique", "prix": 800 }
```

Compter le nombre de produits par cat√©gorie :

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",              // Grouper par cat√©gorie
      nombreProduits: { $sum: 1 }     // Compter : ajouter 1 pour chaque document
    }
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": "√âlectronique", "nombreProduits": 3 },
  { "_id": "Meuble", "nombreProduits": 2 }
]
```

**Explication** :
- `_id: "$categorie"` cr√©e un groupe pour chaque cat√©gorie unique
- `$sum: 1` ajoute 1 pour chaque document dans le groupe = comptage

### Exemple 2 : Calculer la Somme par Groupe

Calculer le prix total des produits par cat√©gorie :

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",
      prixTotal: { $sum: "$prix" }    // Additionner les prix
    }
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": "√âlectronique", "prixTotal": 2025 },  // 1200 + 25 + 800
  { "_id": "Meuble", "prixTotal": 450 }          // 150 + 300
]
```

### Exemple 3 : Calculer Plusieurs Statistiques

Obtenir plusieurs agr√©gations en m√™me temps :

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",
      nombreProduits: { $sum: 1 },
      prixTotal: { $sum: "$prix" },
      prixMoyen: { $avg: "$prix" },
      prixMin: { $min: "$prix" },
      prixMax: { $max: "$prix" }
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": "√âlectronique",
    "nombreProduits": 3,
    "prixTotal": 2025,
    "prixMoyen": 675,        // (1200 + 25 + 800) / 3
    "prixMin": 25,
    "prixMax": 1200
  },
  {
    "_id": "Meuble",
    "nombreProduits": 2,
    "prixTotal": 450,
    "prixMoyen": 225,        // (150 + 300) / 2
    "prixMin": 150,
    "prixMax": 300
  }
]
```

### Exemple 4 : Grouper Tous les Documents (_id: null)

Calculer des statistiques globales sans regroupement :

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: null,                      // Pas de regroupement, tout ensemble
      totalProduits: { $sum: 1 },
      prixTotalGeneral: { $sum: "$prix" },
      prixMoyenGeneral: { $avg: "$prix" }
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": null,
    "totalProduits": 5,
    "prixTotalGeneral": 2475,
    "prixMoyenGeneral": 495
  }
]
```

**Note** : `_id: null` signifie "mettre tous les documents dans un seul groupe".

### Exemple 5 : Grouper par Plusieurs Champs

Grouper par cat√©gorie ET par gamme de prix :

```javascript
// Ajoutons un champ "gamme"
db.produits.aggregate([
  {
    $project: {
      categorie: 1,
      prix: 1,
      gamme: {
        $cond: {
          if: { $gte: ["$prix", 500] },
          then: "Premium",
          else: "Standard"
        }
      }
    }
  },
  {
    $group: {
      _id: {
        categorie: "$categorie",
        gamme: "$gamme"
      },
      nombre: { $sum: 1 },
      prixMoyen: { $avg: "$prix" }
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": { "categorie": "√âlectronique", "gamme": "Premium" },
    "nombre": 2,
    "prixMoyen": 1000
  },
  {
    "_id": { "categorie": "√âlectronique", "gamme": "Standard" },
    "nombre": 1,
    "prixMoyen": 25
  },
  {
    "_id": { "categorie": "Meuble", "gamme": "Standard" },
    "nombre": 2,
    "prixMoyen": 225
  }
]
```

### Exemple 6 : Cr√©er des Tableaux avec $push

Collecter tous les noms de produits par cat√©gorie :

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",
      listeProduits: { $push: "$nom" }    // Cr√©e un tableau avec tous les noms
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": "√âlectronique",
    "listeProduits": ["Laptop", "Souris", "T√©l√©phone"]
  },
  {
    "_id": "Meuble",
    "listeProduits": ["Chaise", "Bureau"]
  }
]
```

### Exemple 7 : Valeurs Uniques avec $addToSet

Supposons une collection `commandes` avec des tags :

```javascript
// Collection: commandes
{ "_id": 1, "client": "Alice", "tags": ["urgent", "prioritaire"] }
{ "_id": 2, "client": "Alice", "tags": ["urgent"] }
{ "_id": 3, "client": "Bob", "tags": ["standard"] }
{ "_id": 4, "client": "Alice", "tags": ["prioritaire", "export"] }
```

Obtenir tous les tags uniques par client :

```javascript
db.commandes.aggregate([
  {
    $unwind: "$tags"    // D√©plier le tableau de tags
  },
  {
    $group: {
      _id: "$client",
      tagsUniques: { $addToSet: "$tags" }    // Valeurs uniques seulement
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": "Alice",
    "tagsUniques": ["urgent", "prioritaire", "export"]    // Pas de doublons
  },
  {
    "_id": "Bob",
    "tagsUniques": ["standard"]
  }
]
```

**Diff√©rence $push vs $addToSet** :
- `$push` : Ajoute **toutes** les valeurs (doublons possibles)
- `$addToSet` : Ajoute uniquement les valeurs **uniques**

### Exemple 8 : Premier et Dernier Document ($first et $last)

Pour une collection de transactions tri√©es par date :

```javascript
// Collection: transactions
{ "_id": 1, "client": "Alice", "montant": 100, "date": ISODate("2024-01-15") }
{ "_id": 2, "client": "Alice", "montant": 150, "date": ISODate("2024-02-20") }
{ "_id": 3, "client": "Alice", "montant": 80, "date": ISODate("2024-03-10") }
{ "_id": 4, "client": "Bob", "montant": 200, "date": ISODate("2024-01-05") }
```

Obtenir la premi√®re et derni√®re transaction de chaque client :

```javascript
db.transactions.aggregate([
  {
    $sort: { date: 1 }    // Important : trier d'abord par date
  },
  {
    $group: {
      _id: "$client",
      premiereTransaction: { $first: "$montant" },
      derniereTransaction: { $last: "$montant" },
      premiereDate: { $first: "$date" },
      derniereDate: { $last: "$date" }
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": "Alice",
    "premiereTransaction": 100,
    "derniereTransaction": 80,
    "premiereDate": ISODate("2024-01-15"),
    "derniereDate": ISODate("2024-03-10")
  },
  {
    "_id": "Bob",
    "premiereTransaction": 200,
    "derniereTransaction": 200,
    "premiereDate": ISODate("2024-01-05"),
    "derniereDate": ISODate("2024-01-05")
  }
]
```

‚ö†Ô∏è **Important** : `$first` et `$last` d√©pendent de l'ordre des documents. Utilisez toujours `$sort` avant si l'ordre est important.

### Exemple 9 : Grouper par Expression Calcul√©e

Grouper les commandes par ann√©e :

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: { $year: "$date" },              // Extraire l'ann√©e de la date
      nombreCommandes: { $sum: 1 },
      chiffreAffaires: { $sum: "$montant" }
    }
  },
  {
    $sort: { _id: 1 }    // Trier par ann√©e
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 2023, "nombreCommandes": 145, "chiffreAffaires": 52300 },
  { "_id": 2024, "nombreCommandes": 289, "chiffreAffaires": 98750 }
]
```

### Exemple 10 : Grouper par Ann√©e et Mois

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: {
        annee: { $year: "$date" },
        mois: { $month: "$date" }
      },
      nombreCommandes: { $sum: 1 },
      montantTotal: { $sum: "$montant" }
    }
  },
  {
    $sort: {
      "_id.annee": 1,
      "_id.mois": 1
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "_id": { "annee": 2024, "mois": 1 },
    "nombreCommandes": 23,
    "montantTotal": 8560
  },
  {
    "_id": { "annee": 2024, "mois": 2 },
    "nombreCommandes": 31,
    "montantTotal": 11200
  }
]
```

## Accumulateurs D√©taill√©s

### $sum : Additionner

```javascript
// Compter des documents
{ nombreTotal: { $sum: 1 } }

// Additionner un champ
{ montantTotal: { $sum: "$montant" } }

// Somme conditionnelle
{
  montantPaye: {
    $sum: {
      $cond: [{ $eq: ["$statut", "pay√©"] }, "$montant", 0]
    }
  }
}
```

### $avg : Calculer la Moyenne

```javascript
// Moyenne simple
{ prixMoyen: { $avg: "$prix" } }

// Note : $avg ignore les valeurs null et manquantes
```

### $min et $max : Minimum et Maximum

```javascript
{
  $group: {
    _id: "$categorie",
    prixPlusBas: { $min: "$prix" },
    prixPlusHaut: { $max: "$prix" },
    datePlusRecente: { $max: "$date" },
    datePlusAncienne: { $min: "$date" }
  }
}
```

### $count : Compter (MongoDB 5.0+)

```javascript
// Alternative moderne √† { $sum: 1 }
{
  $group: {
    _id: "$categorie",
    total: { $count: {} }
  }
}
```

### $push : Cr√©er un Tableau

```javascript
{
  $group: {
    _id: "$client",
    toutesCommandes: { $push: "$numeroCommande" },

    // Pousser un objet complet
    historique: {
      $push: {
        date: "$date",
        montant: "$montant"
      }
    }
  }
}
```

### $addToSet : Valeurs Uniques

```javascript
{
  $group: {
    _id: "$ville",
    clientsUniques: { $addToSet: "$client" },
    categoriesVendues: { $addToSet: "$categorie" }
  }
}
```

## Cas d'Usage Pratiques

### 1. Analyse des Ventes par Mois

```javascript
db.ventes.aggregate([
  {
    $match: {
      date: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      }
    }
  },
  {
    $group: {
      _id: {
        mois: { $month: "$date" },
        annee: { $year: "$date" }
      },
      chiffreAffaires: { $sum: "$montant" },
      nombreVentes: { $sum: 1 },
      panierMoyen: { $avg: "$montant" },
      ventesMax: { $max: "$montant" }
    }
  },
  {
    $sort: {
      "_id.annee": 1,
      "_id.mois": 1
    }
  },
  {
    $project: {
      _id: 0,
      periode: {
        $concat: [
          { $toString: "$_id.mois" },
          "/",
          { $toString: "$_id.annee" }
        ]
      },
      chiffreAffaires: 1,
      nombreVentes: 1,
      panierMoyen: { $round: ["$panierMoyen", 2] }
    }
  }
])
```

### 2. Top Clients par Chiffre d'Affaires

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      totalDepense: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 },
      derniereCommande: { $max: "$date" }
    }
  },
  {
    $sort: { totalDepense: -1 }
  },
  {
    $limit: 10
  },
  {
    $project: {
      _id: 0,
      client: "$_id",
      totalDepense: 1,
      nombreCommandes: 1,
      panierMoyen: {
        $divide: ["$totalDepense", "$nombreCommandes"]
      },
      derniereCommande: 1
    }
  }
])
```

### 3. Statistiques de Stock par Entrep√¥t

```javascript
db.inventaire.aggregate([
  {
    $group: {
      _id: "$entrepot",
      produitsTotal: { $sum: 1 },
      quantiteTotal: { $sum: "$quantite" },
      valeurStock: { $sum: { $multiply: ["$quantite", "$prixUnitaire"] } },
      produitsEnRupture: {
        $sum: {
          $cond: [{ $lte: ["$quantite", 0] }, 1, 0]
        }
      },
      produitsStockFaible: {
        $sum: {
          $cond: [
            { $and: [
              { $gt: ["$quantite", 0] },
              { $lt: ["$quantite", 10] }
            ]},
            1,
            0
          ]
        }
      }
    }
  }
])
```

### 4. Analyse de Performance des Produits

```javascript
db.ventes.aggregate([
  {
    $group: {
      _id: "$produit",
      quantiteVendue: { $sum: "$quantite" },
      revenuTotal: { $sum: { $multiply: ["$quantite", "$prixUnitaire"] } },
      nombreTransactions: { $sum: 1 },
      clientsUniques: { $addToSet: "$client" }
    }
  },
  {
    $project: {
      produit: "$_id",
      quantiteVendue: 1,
      revenuTotal: 1,
      nombreTransactions: 1,
      nombreClientsUniques: { $size: "$clientsUniques" },
      revenuMoyenParTransaction: {
        $divide: ["$revenuTotal", "$nombreTransactions"]
      }
    }
  },
  {
    $sort: { revenuTotal: -1 }
  }
])
```

### 5. Segmentation de Client√®le

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      totalDepense: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 }
    }
  },
  {
    $project: {
      client: "$_id",
      totalDepense: 1,
      nombreCommandes: 1,
      segment: {
        $switch: {
          branches: [
            {
              case: {
                $and: [
                  { $gte: ["$totalDepense", 1000] },
                  { $gte: ["$nombreCommandes", 5] }
                ]
              },
              then: "VIP"
            },
            {
              case: {
                $and: [
                  { $gte: ["$totalDepense", 500] },
                  { $gte: ["$nombreCommandes", 3] }
                ]
              },
              then: "Fid√®le"
            },
            {
              case: { $gte: ["$nombreCommandes", 2] },
              then: "R√©gulier"
            }
          ],
          default: "Occasionnel"
        }
      }
    }
  },
  {
    $group: {
      _id: "$segment",
      nombreClients: { $sum: 1 },
      revenuMoyen: { $avg: "$totalDepense" }
    }
  }
])
```

## Performances et Optimisations

### 1. Filtrer Avant de Grouper

Toujours utiliser `$match` avant `$group` pour r√©duire les donn√©es :

```javascript
// ‚úÖ BON : Filtrer d'abord
db.commandes.aggregate([
  {
    $match: {
      date: { $gte: ISODate("2024-01-01") },
      statut: "valid√©e"
    }
  },
  {
    $group: {
      _id: "$client",
      total: { $sum: "$montant" }
    }
  }
])

// ‚ùå MOINS EFFICACE : Grouper toutes les donn√©es puis filtrer
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      total: { $sum: "$montant" }
    }
  },
  {
    $match: { total: { $gt: 1000 } }
  }
])
```

### 2. Utiliser des Index

Cr√©ez des index sur les champs utilis√©s dans `_id` :

```javascript
// Si vous groupez souvent par categorie
db.produits.createIndex({ categorie: 1 })

// Si vous groupez par date
db.commandes.createIndex({ date: 1 })
```

### 3. Projeter Avant de Grouper

R√©duisez la taille des documents avant `$group` :

```javascript
db.ventes.aggregate([
  {
    $match: { date: { $gte: ISODate("2024-01-01") } }
  },
  {
    // Garder uniquement les champs n√©cessaires
    $project: {
      client: 1,
      montant: 1
    }
  },
  {
    $group: {
      _id: "$client",
      total: { $sum: "$montant" }
    }
  }
])
```

### 4. Limite de M√©moire

Par d√©faut, une √©tape de pipeline est limit√©e √† 100 Mo de RAM. Pour les grosses agr√©gations :

```javascript
// Activer allowDiskUse pour utiliser le disque si n√©cessaire
db.collection.aggregate(
  [ /* pipeline */ ],
  { allowDiskUse: true }
)
```

‚ö†Ô∏è **Note** : `allowDiskUse` ralentit les performances mais permet de traiter plus de donn√©es.

## $group vs SQL GROUP BY

Pour ceux qui connaissent SQL, voici les √©quivalences :

### SQL
```sql
SELECT categorie, COUNT(*), SUM(prix), AVG(prix)
FROM produits
GROUP BY categorie
HAVING SUM(prix) > 1000;
```

### MongoDB
```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",
      count: { $sum: 1 },
      total: { $sum: "$prix" },
      moyenne: { $avg: "$prix" }
    }
  },
  {
    $match: { total: { $gt: 1000 } }    // HAVING en SQL
  }
])
```

## Pi√®ges Courants √† √âviter

### 1. Oublier que _id est Obligatoire

```javascript
// ‚ùå ERREUR : Pas de _id
{
  $group: {
    total: { $sum: "$montant" }
  }
}

// ‚úÖ CORRECT
{
  $group: {
    _id: null,    // M√™me si on ne regroupe pas, _id est n√©cessaire
    total: { $sum: "$montant" }
  }
}
```

### 2. Ordre des Documents dans $first/$last

```javascript
// ‚ùå DANGEREUX : Ordre non d√©fini
db.collection.aggregate([
  {
    $group: {
      _id: "$client",
      dernierAchat: { $last: "$date" }    // Ordre al√©atoire !
    }
  }
])

// ‚úÖ CORRECT : Trier d'abord
db.collection.aggregate([
  { $sort: { date: 1 } },    // Trier par date
  {
    $group: {
      _id: "$client",
      dernierAchat: { $last: "$date" }
    }
  }
])
```

### 3. Utiliser $push sur de Gros Tableaux

```javascript
// ‚ö†Ô∏è ATTENTION : Peut cr√©er des documents > 16 Mo
{
  $group: {
    _id: "$client",
    toutesLesCommandes: { $push: "$$ROOT" }    // Danger si beaucoup de commandes
  }
}

// ‚úÖ MIEUX : Limiter ou utiliser $addToSet
{
  $group: {
    _id: "$client",
    dernieres10Commandes: { $push: "$numeroCommande" }
  }
}
// Puis limiter avec $slice dans $project
```

## Points Cl√©s √† Retenir

1. ‚úÖ **$group regroupe et agr√®ge** les documents
2. ‚úÖ **_id est obligatoire** et d√©finit le crit√®re de regroupement
3. ‚úÖ **Accumulateurs** : $sum, $avg, $min, $max, $count, $first, $last, $push, $addToSet
4. ‚úÖ **$push** cr√©e des tableaux, **$addToSet** cr√©e des tableaux sans doublons
5. ‚úÖ **Filtrer avant** de grouper pour meilleures performances
6. ‚úÖ **Trier avant** d'utiliser $first/$last
7. ‚úÖ **Utiliser des index** sur les champs de regroupement
8. ‚úÖ **allowDiskUse** pour les grosses agr√©gations

## Exemple Complet : Tableau de Bord Commercial

```javascript
// Cr√©er un tableau de bord complet des ventes
db.ventes.aggregate([
  {
    // 1. Filtrer l'ann√©e en cours
    $match: {
      date: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      }
    }
  },
  {
    // 2. Grouper par mois
    $group: {
      _id: {
        mois: { $month: "$date" },
        annee: { $year: "$date" }
      },

      // M√©triques de volume
      nombreVentes: { $sum: 1 },
      quantiteTotale: { $sum: "$quantite" },

      // M√©triques financi√®res
      chiffreAffaires: { $sum: "$montant" },
      panierMoyen: { $avg: "$montant" },
      venteMini: { $min: "$montant" },
      venteMaxi: { $max: "$montant" },

      // Clients
      clientsUniques: { $addToSet: "$client" },

      // Produits
      produitsVendus: { $addToSet: "$produit" }
    }
  },
  {
    // 3. Enrichir avec des calculs
    $project: {
      _id: 0,
      periode: {
        $concat: [
          { $toString: "$_id.mois" },
          "/",
          { $toString: "$_id.annee" }
        ]
      },
      nombreVentes: 1,
      quantiteTotale: 1,
      chiffreAffaires: { $round: ["$chiffreAffaires", 2] },
      panierMoyen: { $round: ["$panierMoyen", 2] },
      venteMini: 1,
      venteMaxi: 1,
      nombreClientsUniques: { $size: "$clientsUniques" },
      nombreProduitsUniques: { $size: "$produitsVendus" },
      caParClient: {
        $round: [
          { $divide: ["$chiffreAffaires", { $size: "$clientsUniques" }] },
          2
        ]
      }
    }
  },
  {
    // 4. Trier chronologiquement
    $sort: { periode: 1 }
  }
])
```

## Conclusion

L'√©tape `$group` est **essentielle** pour l'analyse de donn√©es dans MongoDB. Elle vous permet de :

- üìä **Agr√©ger** vos donn√©es en groupes significatifs
- üìà **Calculer** des statistiques (sommes, moyennes, min/max)
- üîç **Analyser** les tendances et patterns
- üìã **Cr√©er** des rapports et tableaux de bord
- üéØ **Extraire** des insights de vos collections

Ma√Ætriser `$group` et ses accumulateurs est fondamental pour exploiter pleinement la puissance du framework d'agr√©gation MongoDB.

---


‚è≠Ô∏è [$sort](/06-framework-agregation/03.4-sort.md)
