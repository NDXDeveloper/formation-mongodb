üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.4 $sort - Trier les Documents

## Introduction

L'√©tape `$sort` permet de **trier les documents** dans un pipeline d'agr√©gation selon un ou plusieurs crit√®res. C'est l'une des op√©rations les plus courantes et essentielles pour pr√©senter vos donn√©es dans l'ordre souhait√©.

Pensez √† `$sort` comme un **organisateur m√©ticuleux** qui range vos documents dans l'ordre que vous lui demandez : du plus petit au plus grand, du plus r√©cent au plus ancien, alphab√©tiquement, etc.

## √Ä Quoi Sert $sort ?

### 1. **Ordonner les R√©sultats**
Pr√©senter vos donn√©es dans un ordre logique et lisible.

### 2. **Pr√©parer pour $limit**
Trier avant de limiter pour obtenir les "top N" ou "bottom N".

### 3. **Organiser pour $group**
Ordonner avant un groupement pour utiliser correctement `$first` et `$last`.

### 4. **Am√©liorer la Lisibilit√©**
Faciliter l'analyse des r√©sultats en les pr√©sentant de mani√®re ordonn√©e.

## Syntaxe de Base

```javascript
{
  $sort: {
    <champ1>: <ordre>,
    <champ2>: <ordre>
  }
}
```

**Valeurs d'ordre** :
- `1` : Ordre **croissant** (ascendant) ‚Üí A √† Z, 0 √† 9, dates anciennes vers r√©centes
- `-1` : Ordre **d√©croissant** (descendant) ‚Üí Z √† A, 9 √† 0, dates r√©centes vers anciennes

## Exemples Progressifs

### Exemple 1 : Tri Simple Croissant

Imaginons une collection `produits` :

```javascript
// Collection: produits
{ "_id": 1, "nom": "Clavier", "prix": 45 }
{ "_id": 2, "nom": "Souris", "prix": 25 }
{ "_id": 3, "nom": "√âcran", "prix": 250 }
{ "_id": 4, "nom": "Webcam", "prix": 80 }
```

Trier par prix croissant (du moins cher au plus cher) :

```javascript
db.produits.aggregate([
  {
    $sort: { prix: 1 }    // 1 = croissant
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 2, "nom": "Souris", "prix": 25 },
  { "_id": 1, "nom": "Clavier", "prix": 45 },
  { "_id": 4, "nom": "Webcam", "prix": 80 },
  { "_id": 3, "nom": "√âcran", "prix": 250 }
]
```

### Exemple 2 : Tri Simple D√©croissant

Trier par prix d√©croissant (du plus cher au moins cher) :

```javascript
db.produits.aggregate([
  {
    $sort: { prix: -1 }    // -1 = d√©croissant
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 3, "nom": "√âcran", "prix": 250 },
  { "_id": 4, "nom": "Webcam", "prix": 80 },
  { "_id": 1, "nom": "Clavier", "prix": 45 },
  { "_id": 2, "nom": "Souris", "prix": 25 }
]
```

### Exemple 3 : Tri Alphab√©tique

Trier par nom alphab√©tiquement :

```javascript
db.produits.aggregate([
  {
    $sort: { nom: 1 }    // A ‚Üí Z
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 1, "nom": "Clavier", "prix": 45 },
  { "_id": 3, "nom": "√âcran", "prix": 250 },
  { "_id": 2, "nom": "Souris", "prix": 25 },
  { "_id": 4, "nom": "Webcam", "prix": 80 }
]
```

**Note** : Le tri alphab√©tique respecte l'ordre lexicographique. Les accents et la casse peuvent influencer l'ordre selon la configuration de la locale.

### Exemple 4 : Tri par Date

Pour une collection avec des dates :

```javascript
// Collection: commandes
{ "_id": 1, "client": "Alice", "date": ISODate("2024-03-15"), "montant": 150 }
{ "_id": 2, "client": "Bob", "date": ISODate("2024-01-10"), "montant": 200 }
{ "_id": 3, "client": "Charlie", "date": ISODate("2024-02-20"), "montant": 75 }
```

Trier de la date la plus r√©cente √† la plus ancienne :

```javascript
db.commandes.aggregate([
  {
    $sort: { date: -1 }    // Plus r√©cent en premier
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 1, "client": "Alice", "date": ISODate("2024-03-15"), "montant": 150 },
  { "_id": 3, "client": "Charlie", "date": ISODate("2024-02-20"), "montant": 75 },
  { "_id": 2, "client": "Bob", "date": ISODate("2024-01-10"), "montant": 200 }
]
```

### Exemple 5 : Tri sur Plusieurs Champs

Vous pouvez trier sur plusieurs champs. L'ordre est important : MongoDB trie d'abord par le premier champ, puis par le deuxi√®me en cas d'√©galit√©, etc.

```javascript
// Collection: etudiants
{ "nom": "Dupont", "prenom": "Marie", "note": 15 }
{ "nom": "Martin", "prenom": "Jean", "note": 18 }
{ "nom": "Dupont", "prenom": "Pierre", "note": 12 }
{ "nom": "Martin", "prenom": "Alice", "note": 18 }
{ "nom": "Dupont", "prenom": "Alice", "note": 15 }
```

Trier par nom (alphab√©tique), puis par pr√©nom si le nom est identique :

```javascript
db.etudiants.aggregate([
  {
    $sort: {
      nom: 1,       // D'abord par nom (A ‚Üí Z)
      prenom: 1     // Puis par pr√©nom (A ‚Üí Z)
    }
  }
])
```

**R√©sultat** :
```javascript
[
  { "nom": "Dupont", "prenom": "Alice", "note": 15 },
  { "nom": "Dupont", "prenom": "Marie", "note": 15 },
  { "nom": "Dupont", "prenom": "Pierre", "note": 12 },
  { "nom": "Martin", "prenom": "Alice", "note": 18 },
  { "nom": "Martin", "prenom": "Jean", "note": 18 }
]
```

### Exemple 6 : Tri avec Ordre Mixte

Trier par note d√©croissante, puis par nom croissant :

```javascript
db.etudiants.aggregate([
  {
    $sort: {
      note: -1,     // D'abord par note (meilleure note en premier)
      nom: 1        // Puis par nom alphab√©tique
    }
  }
])
```

**R√©sultat** :
```javascript
[
  { "nom": "Martin", "prenom": "Alice", "note": 18 },
  { "nom": "Martin", "prenom": "Jean", "note": 18 },
  { "nom": "Dupont", "prenom": "Alice", "note": 15 },
  { "nom": "Dupont", "prenom": "Marie", "note": 15 },
  { "nom": "Dupont", "prenom": "Pierre", "note": 12 }
]
```

### Exemple 7 : Top N avec $sort et $limit

Obtenir les 3 produits les plus chers :

```javascript
db.produits.aggregate([
  {
    $sort: { prix: -1 }    // Trier du plus cher au moins cher
  },
  {
    $limit: 3              // Garder les 3 premiers
  }
])
```

**Important** : L'ordre est crucial ! Toujours `$sort` AVANT `$limit` pour obtenir les "top N".

```javascript
// ‚úÖ CORRECT : Sort puis Limit
[
  { $sort: { prix: -1 } },
  { $limit: 3 }
]

// ‚ùå INCORRECT : Limit puis Sort (ne donne pas le top 3 !)
[
  { $limit: 3 },
  { $sort: { prix: -1 } }
]
```

### Exemple 8 : Tri sur Champ Imbriqu√©

Pour trier sur un champ dans un objet imbriqu√©, utilisez la notation point√©e :

```javascript
// Collection: utilisateurs
{
  "nom": "Dupont",
  "adresse": {
    "ville": "Paris",
    "codePostal": "75001"
  }
}
{
  "nom": "Martin",
  "adresse": {
    "ville": "Lyon",
    "codePostal": "69001"
  }
}
```

Trier par ville :

```javascript
db.utilisateurs.aggregate([
  {
    $sort: { "adresse.ville": 1 }    // Notation point√©e
  }
])
```

### Exemple 9 : Tri Apr√®s un $group

Trier les r√©sultats d'une agr√©gation :

```javascript
db.commandes.aggregate([
  {
    // 1. Grouper par client
    $group: {
      _id: "$client",
      totalDepense: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 }
    }
  },
  {
    // 2. Trier par total d√©pens√© (d√©croissant)
    $sort: { totalDepense: -1 }
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": "Alice", "totalDepense": 1250, "nombreCommandes": 8 },
  { "_id": "Bob", "totalDepense": 890, "nombreCommandes": 5 },
  { "_id": "Charlie", "totalDepense": 450, "nombreCommandes": 3 }
]
```

### Exemple 10 : Tri Avant $group pour $first/$last

Le tri est crucial avant d'utiliser `$first` et `$last` dans un `$group` :

```javascript
db.transactions.aggregate([
  {
    // 1. Trier par date (important !)
    $sort: { date: 1 }    // Du plus ancien au plus r√©cent
  },
  {
    // 2. Grouper par client
    $group: {
      _id: "$client",
      premiereTransaction: { $first: "$montant" },
      derniereTransaction: { $last: "$montant" },
      premiereDate: { $first: "$date" },
      derniereDate: { $last: "$date" }
    }
  }
])
```

Sans le `$sort` initial, `$first` et `$last` donneraient des r√©sultats al√©atoires !

## Comportement avec les Valeurs Sp√©ciales

### Valeurs null et Manquantes

Les valeurs `null` et les champs manquants sont plac√©s en premier lors d'un tri croissant :

```javascript
// Collection: produits
{ "_id": 1, "nom": "A", "stock": 10 }
{ "_id": 2, "nom": "B", "stock": null }
{ "_id": 3, "nom": "C" }              // stock manquant
{ "_id": 4, "nom": "D", "stock": 5 }
```

Tri croissant sur stock :

```javascript
db.produits.aggregate([
  { $sort: { stock: 1 } }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 3, "nom": "C" },                  // manquant (en premier)
  { "_id": 2, "nom": "B", "stock": null },   // null (ensuite)
  { "_id": 4, "nom": "D", "stock": 5 },
  { "_id": 1, "nom": "A", "stock": 10 }
]
```

**Ordre** : `champ manquant < null < valeurs r√©elles`

### Diff√©rents Types de Donn√©es

Lors du tri sur un champ contenant diff√©rents types, MongoDB suit cet ordre (du plus petit au plus grand) :

1. MinKey (valeur interne)
2. null
3. Nombres (int, long, double, decimal)
4. Symboles, Cha√Ænes
5. Objets
6. Tableaux
7. Donn√©es binaires
8. ObjectId
9. Bool√©ens
10. Dates
11. Timestamps
12. Expressions r√©guli√®res
13. MaxKey (valeur interne)

En pratique, il est recommand√© d'avoir des types coh√©rents dans un m√™me champ.

## Cas d'Usage Pratiques

### 1. Classement des Meilleurs Vendeurs

```javascript
db.ventes.aggregate([
  {
    $group: {
      _id: "$vendeur",
      chiffreAffaires: { $sum: "$montant" },
      nombreVentes: { $sum: 1 }
    }
  },
  {
    $sort: { chiffreAffaires: -1 }    // Meilleur vendeur en premier
  },
  {
    $limit: 10    // Top 10
  },
  {
    $project: {
      _id: 0,
      vendeur: "$_id",
      chiffreAffaires: 1,
      nombreVentes: 1,
      venteMoyenne: {
        $divide: ["$chiffreAffaires", "$nombreVentes"]
      }
    }
  }
])
```

### 2. Articles de Blog par Date de Publication

```javascript
db.articles.aggregate([
  {
    $match: { statut: "publi√©" }
  },
  {
    $sort: { datePublication: -1 }    // Plus r√©cent en premier
  },
  {
    $limit: 20    // 20 derniers articles
  },
  {
    $project: {
      titre: 1,
      auteur: 1,
      datePublication: 1,
      extrait: { $substr: ["$contenu", 0, 200] }
    }
  }
])
```

### 3. Classement des √âtudiants

```javascript
db.resultats.aggregate([
  {
    $group: {
      _id: "$etudiant",
      moyenneGenerale: { $avg: "$note" },
      nombreExamens: { $sum: 1 }
    }
  },
  {
    $sort: {
      moyenneGenerale: -1,    // Meilleure moyenne en premier
      nombreExamens: -1       // En cas d'√©galit√©, plus d'examens en premier
    }
  },
  {
    $project: {
      _id: 0,
      etudiant: "$_id",
      moyenneGenerale: { $round: ["$moyenneGenerale", 2] },
      nombreExamens: 1,
      classement: { $add: [{ $indexOfArray: [[], 0] }, 1] }
    }
  }
])
```

### 4. Produits par Popularit√© et Prix

```javascript
db.produits.aggregate([
  {
    $match: { stock: { $gt: 0 } }    // En stock seulement
  },
  {
    $sort: {
      nombreVentes: -1,    // Plus vendu en premier
      prix: 1              // En cas d'√©galit√©, moins cher en premier
    }
  },
  {
    $limit: 50
  }
])
```

### 5. Historique des Transactions

```javascript
db.transactions.aggregate([
  {
    $match: {
      client: "Alice",
      date: { $gte: ISODate("2024-01-01") }
    }
  },
  {
    $sort: { date: -1 }    // Plus r√©cente en premier
  },
  {
    $project: {
      _id: 0,
      date: {
        $dateToString: {
          format: "%d/%m/%Y %H:%M",
          date: "$date"
        }
      },
      type: 1,
      montant: 1,
      solde: 1
    }
  }
])
```

## Performances et Optimisations

### 1. Utiliser des Index

Le `$sort` peut utiliser un index si :
- Le tri est sur des champs index√©s
- Le tri respecte l'ordre de l'index (ou son inverse)
- Le tri est la premi√®re √©tape (ou apr√®s un `$match` qui utilise un index)

```javascript
// Cr√©er un index pour optimiser le tri
db.produits.createIndex({ prix: 1 })

// Ce tri utilisera l'index
db.produits.aggregate([
  { $sort: { prix: 1 } }
])

// Index compos√© pour tri multiple
db.produits.createIndex({ categorie: 1, prix: -1 })

// Utilisera l'index
db.produits.aggregate([
  { $match: { categorie: "√âlectronique" } },
  { $sort: { categorie: 1, prix: -1 } }
])
```

**V√©rifier l'utilisation d'index** :

```javascript
db.produits.aggregate([
  { $sort: { prix: 1 } }
], { explain: true })
```

Cherchez `"IXSCAN"` dans la sortie pour confirmer l'utilisation d'un index.

### 2. Limite de M√©moire

Par d√©faut, l'op√©ration `$sort` est limit√©e √† **100 Mo de RAM**. Si vos donn√©es d√©passent cette limite :

#### Option 1 : Utiliser un Index (Recommand√©)

Si le tri utilise un index, la limite de m√©moire ne s'applique pas.

#### Option 2 : allowDiskUse

Permettre l'utilisation du disque pour les tris volumineux :

```javascript
db.collection.aggregate(
  [
    { $sort: { champ: 1 } }
  ],
  { allowDiskUse: true }    // Utilise le disque si n√©cessaire
)
```

‚ö†Ô∏è **Note** : `allowDiskUse` ralentit consid√©rablement les performances. Privil√©giez les index.

### 3. Position Optimale du $sort

#### Trier T√¥t pour R√©duire les Donn√©es

Si vous devez trier puis limiter, faites-le t√¥t :

```javascript
// ‚úÖ BON : Sort et limit t√¥t
db.produits.aggregate([
  { $match: { categorie: "√âlectronique" } },
  { $sort: { prix: -1 } },
  { $limit: 10 },
  // Maintenant seulement 10 documents dans les √©tapes suivantes
  { $project: { nom: 1, prix: 1 } }
])
```

#### Trier Tard pour Moins de Donn√©es √† Trier

Si le pipeline r√©duit significativement le nombre de documents, triez √† la fin :

```javascript
// Groupement qui r√©duit √† 5 cat√©gories
db.produits.aggregate([
  { $group: {
      _id: "$categorie",
      total: { $sum: "$prix" }
    }
  },
  // Seulement 5 documents √† trier
  { $sort: { total: -1 } }
])
```

### 4. √âviter les Tris Multiples Inutiles

```javascript
// ‚ùå INEFFICACE : Trier deux fois
db.collection.aggregate([
  { $sort: { date: 1 } },
  { $group: { /* ... */ } },
  { $sort: { total: -1 } }    // Nouveau tri n√©cessaire
])

// ‚úÖ MIEUX : Un seul tri si possible
db.collection.aggregate([
  { $group: { /* ... */ } },
  { $sort: { total: -1 } }    // Un seul tri
])
```

## $sort dans le Pipeline vs sort() sur Cursor

### M√©thode sort() sur Cursor

```javascript
// Avec find()
db.produits.find().sort({ prix: -1 }).limit(10)
```

### √âtape $sort dans Aggregate

```javascript
// Avec aggregate()
db.produits.aggregate([
  { $sort: { prix: -1 } },
  { $limit: 10 }
])
```

### Diff√©rences

| Aspect | sort() | $sort |
|--------|--------|-------|
| **Contexte** | Requ√™te find() | Pipeline d'agr√©gation |
| **Syntaxe** | `.sort({ champ: 1 })` | `{ $sort: { champ: 1 } }` |
| **Position** | Apr√®s find() | N'importe o√π dans le pipeline |
| **Utilisation** | Requ√™tes simples | Agr√©gations complexes |
| **Multiple** | Un seul tri | Peut trier plusieurs fois |

## Tri Complexe avec Expression

Parfois, vous voulez trier selon un calcul. Utilisez `$project` avant `$sort` :

```javascript
db.employes.aggregate([
  {
    // 1. Calculer un score
    $project: {
      nom: 1,
      prenom: 1,
      salaire: 1,
      anciennete: 1,
      score: {
        $add: [
          { $multiply: ["$salaire", 0.6] },
          { $multiply: ["$anciennete", 1000] }
        ]
      }
    }
  },
  {
    // 2. Trier par le score calcul√©
    $sort: { score: -1 }
  },
  {
    // 3. Nettoyer la sortie
    $project: { score: 0 }
  }
])
```

## Tri avec Collation (Sensibilit√© √† la Casse et Accents)

Pour un tri plus fin selon les r√®gles linguistiques :

```javascript
db.noms.aggregate(
  [
    { $sort: { nom: 1 } }
  ],
  {
    collation: {
      locale: "fr",              // Fran√ßais
      strength: 1,               // Insensible √† la casse et aux accents
      numericOrdering: true      // "2" avant "10"
    }
  }
)
```

**Param√®tres de collation** :
- `locale` : Langue ("en", "fr", "de", etc.)
- `strength` :
  - `1` : Insensible casse et accents
  - `2` : Sensible aux accents, pas √† la casse
  - `3` : Sensible aux accents et √† la casse
- `numericOrdering` : Tri num√©rique des cha√Ænes contenant des nombres

## Pi√®ges Courants √† √âviter

### 1. Oublier le $sort Avant $first/$last

```javascript
// ‚ùå INCORRECT : R√©sultats al√©atoires
db.transactions.aggregate([
  {
    $group: {
      _id: "$client",
      derniere: { $last: "$date" }    // Date al√©atoire !
    }
  }
])

// ‚úÖ CORRECT : Trier d'abord
db.transactions.aggregate([
  { $sort: { date: 1 } },              // Trier d'abord
  {
    $group: {
      _id: "$client",
      derniere: { $last: "$date" }    // Vraiment la derni√®re
    }
  }
])
```

### 2. $limit Avant $sort

```javascript
// ‚ùå INCORRECT : N'obtient PAS les top 10
db.produits.aggregate([
  { $limit: 10 },           // Prend 10 documents au hasard
  { $sort: { prix: -1 } }   // Puis les trie
])

// ‚úÖ CORRECT : Les vraies 10 plus chers
db.produits.aggregate([
  { $sort: { prix: -1 } },  // Trier d'abord
  { $limit: 10 }            // Puis prendre les 10 premiers
])
```

### 3. Tri sans Index sur Gros Volume

```javascript
// ‚ö†Ô∏è ATTENTION : Peut d√©passer 100 Mo
db.bigCollection.aggregate([
  { $sort: { date: 1 } }    // Million de documents, pas d'index
])

// ‚úÖ SOLUTION 1 : Cr√©er un index
db.bigCollection.createIndex({ date: 1 })

// ‚úÖ SOLUTION 2 : allowDiskUse (mais lent)
db.bigCollection.aggregate(
  [{ $sort: { date: 1 } }],
  { allowDiskUse: true }
)

// ‚úÖ SOLUTION 3 : Filtrer d'abord
db.bigCollection.aggregate([
  { $match: { date: { $gte: recentDate } } },  // R√©duire le volume
  { $sort: { date: 1 } }
])
```

## Points Cl√©s √† Retenir

1. ‚úÖ **1 = croissant**, **-1 = d√©croissant**
2. ‚úÖ **Ordre important** dans le tri multi-champs
3. ‚úÖ **$sort AVANT $limit** pour obtenir les "top N"
4. ‚úÖ **$sort AVANT $group** si vous utilisez $first/$last
5. ‚úÖ **Utiliser des index** pour de meilleures performances
6. ‚úÖ **Limite de 100 Mo** sans index (utiliser `allowDiskUse` si n√©cessaire)
7. ‚úÖ **null et manquants** viennent en premier dans l'ordre croissant
8. ‚úÖ **V√©rifier avec explain()** si un index est utilis√©

## Exemple Complet : Top Produits par Cat√©gorie

```javascript
// Obtenir les 3 produits les plus vendus de chaque cat√©gorie
db.ventes.aggregate([
  {
    // 1. Grouper par produit
    $group: {
      _id: {
        produit: "$produit",
        categorie: "$categorie"
      },
      quantiteVendue: { $sum: "$quantite" },
      revenu: { $sum: { $multiply: ["$quantite", "$prixUnitaire"] } }
    }
  },
  {
    // 2. Trier par cat√©gorie puis par quantit√©
    $sort: {
      "_id.categorie": 1,
      quantiteVendue: -1
    }
  },
  {
    // 3. Regrouper par cat√©gorie pour cr√©er un top 3
    $group: {
      _id: "$_id.categorie",
      topProduits: {
        $push: {
          produit: "$_id.produit",
          quantite: "$quantiteVendue",
          revenu: "$revenu"
        }
      }
    }
  },
  {
    // 4. Limiter √† 3 produits par cat√©gorie
    $project: {
      _id: 0,
      categorie: "$_id",
      top3: { $slice: ["$topProduits", 3] }
    }
  },
  {
    // 5. Trier les cat√©gories alphab√©tiquement
    $sort: { categorie: 1 }
  }
])
```

## Conclusion

L'√©tape `$sort` est **fondamentale** pour organiser vos donn√©es. Elle vous permet de :

- üìä **Ordonner** vos r√©sultats de mani√®re logique
- üèÜ **Cr√©er des classements** et top N
- üìÖ **Organiser chronologiquement** vos donn√©es
- üéØ **Pr√©parer** pour d'autres op√©rations ($limit, $group)
- üìà **Am√©liorer** la lisibilit√© de vos analyses

Associ√© aux index, `$sort` offre des performances excellentes m√™me sur de gros volumes de donn√©es. La cl√© est de comprendre quand et o√π placer le tri dans votre pipeline pour optimiser les performances.

---


‚è≠Ô∏è [$limit et $skip](/06-framework-agregation/03.5-limit-skip.md)
