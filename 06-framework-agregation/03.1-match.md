ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.1 $match - Filtrer les Documents dans le Pipeline d'AgrÃ©gation

## Introduction

L'Ã©tape `$match` est l'une des opÃ©rations les plus fondamentales et les plus importantes du framework d'agrÃ©gation MongoDB. Elle permet de **filtrer les documents** qui entrent dans le pipeline d'agrÃ©gation, exactement comme la mÃ©thode `find()` filtre les documents lors d'une requÃªte simple.

Pensez Ã  `$match` comme un **portier** qui dÃ©cide quels documents peuvent passer Ã  l'Ã©tape suivante du pipeline. Seuls les documents qui correspondent aux critÃ¨res spÃ©cifiÃ©s sont transmis aux Ã©tapes suivantes.

## Pourquoi Utiliser $match ?

### 1. **RÃ©duire le Volume de DonnÃ©es**
En filtrant les documents dÃ¨s le dÃ©but du pipeline, vous rÃ©duisez la quantitÃ© de donnÃ©es Ã  traiter dans les Ã©tapes suivantes, ce qui amÃ©liore considÃ©rablement les performances.

### 2. **PrÃ©cision des RÃ©sultats**
`$match` vous permet de cibler exactement les documents dont vous avez besoin pour votre analyse ou transformation.

### 3. **Optimisation des Performances**
Lorsque `$match` est placÃ© en premiÃ¨re position du pipeline et utilise un index, MongoDB peut exploiter cet index pour accÃ©lÃ©rer la requÃªte.

## Syntaxe de Base

La syntaxe de `$match` est trÃ¨s simple et utilise les mÃªmes opÃ©rateurs que les requÃªtes `find()` classiques :

```javascript
{
  $match: {
    <champ>: <valeur>,
    <champ2>: <condition>
  }
}
```

**Important** : La syntaxe de filtrage dans `$match` est identique Ã  celle utilisÃ©e dans les requÃªtes `find()`. Si vous savez Ã©crire une requÃªte `find()`, vous savez Ã©crire un `$match` !

## Exemples Progressifs

### Exemple 1 : Filtre Simple sur une Valeur

Imaginons une collection `commandes` contenant des informations sur des achats :

```javascript
// Collection: commandes
{
  "_id": 1,
  "client": "Alice",
  "montant": 150,
  "statut": "livrÃ©e"
}
{
  "_id": 2,
  "client": "Bob",
  "montant": 75,
  "statut": "en cours"
}
{
  "_id": 3,
  "client": "Charlie",
  "montant": 200,
  "statut": "livrÃ©e"
}
```

Pour obtenir uniquement les commandes livrÃ©es :

```javascript
db.commandes.aggregate([
  {
    $match: {
      statut: "livrÃ©e"
    }
  }
])
```

**RÃ©sultat** :
```javascript
[
  { "_id": 1, "client": "Alice", "montant": 150, "statut": "livrÃ©e" },
  { "_id": 3, "client": "Charlie", "montant": 200, "statut": "livrÃ©e" }
]
```

### Exemple 2 : Filtre avec OpÃ©rateur de Comparaison

Pour trouver les commandes dont le montant est supÃ©rieur Ã  100â‚¬ :

```javascript
db.commandes.aggregate([
  {
    $match: {
      montant: { $gt: 100 }
    }
  }
])
```

**RÃ©sultat** :
```javascript
[
  { "_id": 1, "client": "Alice", "montant": 150, "statut": "livrÃ©e" },
  { "_id": 3, "client": "Charlie", "montant": 200, "statut": "livrÃ©e" }
]
```

### Exemple 3 : Filtres Multiples (ET logique)

Pour trouver les commandes livrÃ©es ET dont le montant dÃ©passe 100â‚¬ :

```javascript
db.commandes.aggregate([
  {
    $match: {
      statut: "livrÃ©e",
      montant: { $gt: 100 }
    }
  }
])
```

**RÃ©sultat** :
```javascript
[
  { "_id": 1, "client": "Alice", "montant": 150, "statut": "livrÃ©e" },
  { "_id": 3, "client": "Charlie", "montant": 200, "statut": "livrÃ©e" }
]
```

### Exemple 4 : Filtre avec OU Logique

Pour trouver les commandes dont le statut est "livrÃ©e" OU dont le montant dÃ©passe 180â‚¬ :

```javascript
db.commandes.aggregate([
  {
    $match: {
      $or: [
        { statut: "livrÃ©e" },
        { montant: { $gt: 180 } }
      ]
    }
  }
])
```

### Exemple 5 : Filtre sur un Tableau

Supposons une collection `produits` avec des tags :

```javascript
// Collection: produits
{
  "_id": 1,
  "nom": "Ordinateur",
  "tags": ["Ã©lectronique", "informatique", "bureautique"]
}
{
  "_id": 2,
  "nom": "Chaise",
  "tags": ["meuble", "bureautique"]
}
```

Pour trouver tous les produits ayant le tag "Ã©lectronique" :

```javascript
db.produits.aggregate([
  {
    $match: {
      tags: "Ã©lectronique"
    }
  }
])
```

**RÃ©sultat** :
```javascript
[
  {
    "_id": 1,
    "nom": "Ordinateur",
    "tags": ["Ã©lectronique", "informatique", "bureautique"]
  }
]
```

### Exemple 6 : Filtre sur des Plages de Valeurs

Pour trouver les commandes dont le montant est entre 80â‚¬ et 180â‚¬ :

```javascript
db.commandes.aggregate([
  {
    $match: {
      montant: {
        $gte: 80,   // supÃ©rieur ou Ã©gal Ã  80
        $lte: 180   // infÃ©rieur ou Ã©gal Ã  180
      }
    }
  }
])
```

## OpÃ©rateurs Couramment UtilisÃ©s avec $match

Voici les principaux opÃ©rateurs que vous pouvez utiliser dans `$match` :

### OpÃ©rateurs de Comparaison

| OpÃ©rateur | Description | Exemple |
|-----------|-------------|---------|
| `$eq` | Ã‰gal Ã  | `{ prix: { $eq: 50 } }` |
| `$ne` | DiffÃ©rent de | `{ statut: { $ne: "annulÃ©" } }` |
| `$gt` | SupÃ©rieur Ã  | `{ age: { $gt: 18 } }` |
| `$gte` | SupÃ©rieur ou Ã©gal Ã  | `{ score: { $gte: 80 } }` |
| `$lt` | InfÃ©rieur Ã  | `{ stock: { $lt: 10 } }` |
| `$lte` | InfÃ©rieur ou Ã©gal Ã  | `{ prix: { $lte: 100 } }` |
| `$in` | Dans une liste | `{ categorie: { $in: ["A", "B"] } }` |
| `$nin` | Pas dans une liste | `{ statut: { $nin: ["annulÃ©", "retournÃ©"] } }` |

### OpÃ©rateurs Logiques

| OpÃ©rateur | Description | Exemple |
|-----------|-------------|---------|
| `$and` | ET logique | `{ $and: [{ a: 1 }, { b: 2 }] }` |
| `$or` | OU logique | `{ $or: [{ a: 1 }, { b: 2 }] }` |
| `$not` | NÃ©gation | `{ prix: { $not: { $gt: 100 } } }` |
| `$nor` | NI...NI | `{ $nor: [{ a: 1 }, { b: 2 }] }` |

### OpÃ©rateurs d'Ã‰lÃ©ments

| OpÃ©rateur | Description | Exemple |
|-----------|-------------|---------|
| `$exists` | Le champ existe | `{ email: { $exists: true } }` |
| `$type` | Type de donnÃ©e | `{ age: { $type: "number" } }` |

## Positionnement de $match dans le Pipeline

### RÃ¨gle d'Or : Placer $match le Plus TÃ´t Possible

Il est **fortement recommandÃ©** de placer `$match` en **premiÃ¨re position** du pipeline pour plusieurs raisons :

1. **RÃ©duction ImmÃ©diate des DonnÃ©es** : Moins de documents Ã  traiter dans les Ã©tapes suivantes
2. **Utilisation des Index** : MongoDB peut exploiter les index existants
3. **Meilleures Performances** : Moins de mÃ©moire et de CPU utilisÃ©s

#### âŒ Mauvaise Pratique

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      total: { $sum: "$montant" }
    }
  },
  {
    $match: {
      total: { $gt: 1000 }  // Filtrage APRÃˆS le groupement
    }
  }
])
```

#### âœ… Bonne Pratique (quand possible)

```javascript
db.commandes.aggregate([
  {
    $match: {
      montant: { $gt: 100 }  // Filtrage AVANT le groupement
    }
  },
  {
    $group: {
      _id: "$client",
      total: { $sum: "$montant" }
    }
  }
])
```

**Note** : Dans l'exemple "mauvaise pratique", le `$match` sur le champ calculÃ© `total` doit nÃ©cessairement venir aprÃ¨s le `$group`. Ce n'est pas une erreur, c'est une nÃ©cessitÃ© logique. L'idÃ©e est de filtrer d'abord sur les champs originaux quand c'est possible.

## $match vs find() : Quelle DiffÃ©rence ?

### Similitudes

- **MÃªme syntaxe** de filtrage
- **MÃªmes opÃ©rateurs** disponibles
- **MÃªme logique** de filtrage

### DiffÃ©rences

| Aspect | find() | $match |
|--------|--------|--------|
| **Contexte** | RequÃªte simple | Ã‰tape dans un pipeline |
| **ChaÃ®nage** | LimitÃ© (sort, limit, skip) | Peut Ãªtre combinÃ© avec de nombreuses autres Ã©tapes |
| **Utilisation** | RÃ©cupÃ©ration simple | Partie d'une analyse complexe |
| **Position** | Toujours au dÃ©but | Peut Ãªtre utilisÃ© plusieurs fois dans un pipeline |

## Utilisation Multiple de $match

Vous pouvez utiliser `$match` **plusieurs fois** dans un mÃªme pipeline :

```javascript
db.commandes.aggregate([
  {
    // Premier filtre : sÃ©lectionner les commandes de 2024
    $match: {
      date: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      }
    }
  },
  {
    // Groupement par client
    $group: {
      _id: "$client",
      totalDepense: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 }
    }
  },
  {
    // Second filtre : ne garder que les gros clients
    $match: {
      totalDepense: { $gt: 1000 }
    }
  }
])
```

Dans cet exemple :
1. Le **premier `$match`** filtre les documents originaux (annÃ©e 2024)
2. Le **second `$match`** filtre les rÃ©sultats aprÃ¨s le groupement (clients ayant dÃ©pensÃ© plus de 1000â‚¬)

## Cas d'Usage Pratiques

### 1. Filtrer par Date

```javascript
db.articles.aggregate([
  {
    $match: {
      datePublication: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2024-12-31")
      }
    }
  }
])
```

### 2. Filtrer par Expression RÃ©guliÃ¨re

```javascript
db.clients.aggregate([
  {
    $match: {
      email: { $regex: /@gmail\.com$/, $options: "i" }
    }
  }
])
```

### 3. Filtrer les Valeurs Nulles ou Manquantes

```javascript
db.utilisateurs.aggregate([
  {
    $match: {
      telephone: { $exists: true, $ne: null }
    }
  }
])
```

### 4. Filtrer sur Plusieurs Valeurs

```javascript
db.produits.aggregate([
  {
    $match: {
      categorie: { $in: ["Ã‰lectronique", "Informatique", "TÃ©lÃ©phonie"] }
    }
  }
])
```

## Performances et Optimisations

### 1. Utiliser des Index

Si vous filtrez frÃ©quemment sur un champ, crÃ©ez un index :

```javascript
db.commandes.createIndex({ statut: 1 })
db.commandes.createIndex({ montant: 1 })
```

Ensuite, votre `$match` bÃ©nÃ©ficiera automatiquement de ces index s'il est en premiÃ¨re position.

### 2. Ã‰viter les Regex Complexes

Les expressions rÃ©guliÃ¨res sans ancrage au dÃ©but (`^`) ne peuvent pas utiliser les index efficacement :

```javascript
// âŒ Lent
{ nom: { $regex: /martin/ } }

// âœ… Plus rapide (peut utiliser un index)
{ nom: { $regex: /^Martin/ } }
```

### 3. Filtrer Avant de Transformer

Toujours filtrer les donnÃ©es avant de les transformer ou de les grouper.

## Points ClÃ©s Ã  Retenir

1. âœ… **$match filtre les documents** dans le pipeline d'agrÃ©gation
2. âœ… **Syntaxe identique** Ã  `find()` - si vous connaissez l'un, vous connaissez l'autre
3. âœ… **Placer $match tÃ´t** dans le pipeline pour de meilleures performances
4. âœ… **Peut Ãªtre utilisÃ© plusieurs fois** dans le mÃªme pipeline
5. âœ… **Exploite les index** quand il est en premiÃ¨re position
6. âœ… **Tous les opÃ©rateurs de requÃªte** sont disponibles ($gt, $lt, $in, $regex, etc.)

## Exemple Complet : Pipeline avec $match

Voici un exemple rÃ©aliste combinant plusieurs concepts :

```javascript
// Analyser les ventes de produits Ã©lectroniques en 2024
// pour les commandes supÃ©rieures Ã  50â‚¬

db.commandes.aggregate([
  {
    // Filtrer : annÃ©e 2024 et montant > 50â‚¬
    $match: {
      date: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      },
      montant: { $gt: 50 },
      categorie: "Ã‰lectronique"
    }
  },
  {
    // Grouper par produit
    $group: {
      _id: "$produit",
      totalVentes: { $sum: "$montant" },
      nombreVentes: { $sum: 1 },
      montantMoyen: { $avg: "$montant" }
    }
  },
  {
    // Filtrer : garder seulement les produits avec plus de 10 ventes
    $match: {
      nombreVentes: { $gt: 10 }
    }
  },
  {
    // Trier par total des ventes dÃ©croissant
    $sort: { totalVentes: -1 }
  },
  {
    // Limiter aux 5 meilleurs produits
    $limit: 5
  }
])
```

Ce pipeline :
1. Filtre les commandes de 2024, > 50â‚¬, catÃ©gorie Ã‰lectronique
2. Groupe par produit et calcule des statistiques
3. Filtre pour ne garder que les produits populaires (>10 ventes)
4. Trie et limite aux 5 meilleurs

## Conclusion

L'Ã©tape `$match` est la **fondation** de tout pipeline d'agrÃ©gation efficace. MaÃ®triser `$match`, c'est savoir :

- ğŸ¯ Cibler prÃ©cisÃ©ment les donnÃ©es dont vous avez besoin
- âš¡ Optimiser les performances de vos agrÃ©gations
- ğŸ”§ Utiliser tous les opÃ©rateurs de requÃªte MongoDB

Dans les prochaines sections, nous verrons comment combiner `$match` avec d'autres Ã©tapes comme `$project`, `$group`, et `$sort` pour crÃ©er des analyses de donnÃ©es puissantes et performantes.

---


â­ï¸ [$project](/06-framework-agregation/03.2-project.md)
