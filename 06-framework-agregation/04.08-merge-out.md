üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.4.8 $merge et $out

## Introduction

Les √©tapes `$merge` et `$out` sont des op√©rateurs du framework d'agr√©gation MongoDB qui permettent d'**√©crire les r√©sultats** d'un pipeline d'agr√©gation dans une **collection**. Contrairement aux autres op√©rateurs qui retournent simplement les r√©sultats, ces deux op√©rateurs **persistent les donn√©es** dans la base de donn√©es.

### L'Essentiel

- **`$out`** : Remplace compl√®tement une collection avec les r√©sultats du pipeline
- **`$merge`** : Fusionne les r√©sultats avec une collection existante (plus flexible)
- **Position** : Doivent √™tre la **derni√®re √©tape** du pipeline
- **Usage** : Mat√©rialiser des vues, cr√©er des rapports, pr√©-calculer des agr√©gations

### Analogie Simple

Imaginez que vous faites des **calculs sur Excel** :
- **Sans $out/$merge** : Vous calculez des totaux et les **regardez √† l'√©cran** (r√©sultats temporaires)
- **Avec $out** : Vous cr√©ez une **nouvelle feuille** et y copiez tous les r√©sultats (√©crase si elle existe d√©j√†)
- **Avec $merge** : Vous **mettez √† jour** une feuille existante, en ajoutant ou modifiant seulement certaines lignes

---

## Pourquoi Utiliser $merge / $out ?

Ces op√©rateurs sont essentiels pour :

1. **Mat√©rialiser des vues** : Cr√©er des snapshots de donn√©es agr√©g√©es
2. **Pr√©-calculer des statistiques** : √âviter de recalculer √† chaque requ√™te
3. **Cr√©er des rapports** : G√©n√©rer des donn√©es pour le reporting
4. **ETL (Extract, Transform, Load)** : Transformer et charger des donn√©es
5. **Donn√©es d√©normalis√©es** : Cr√©er des collections optimis√©es pour la lecture
6. **Snapshots temporels** : Sauvegarder l'√©tat des donn√©es √† un instant T

---

## $out : Remplacement Complet

`$out` est l'op√©rateur le plus **simple** mais aussi le plus **radical** : il **remplace enti√®rement** la collection cible.

### Syntaxe

```javascript
{
  $out: "<nom_de_la_collection>"
}

// OU (pour √©crire dans une autre base de donn√©es)

{
  $out: {
    db: "<nom_base_de_donnees>",
    coll: "<nom_collection>"
  }
}
```

### Comportement

1. Si la collection **n'existe pas** ‚Üí Elle est **cr√©√©e**
2. Si la collection **existe** ‚Üí Elle est **supprim√©e** puis recr√©√©e
3. Les **index** de l'ancienne collection sont **perdus** (sauf _id)
4. L'op√©ration est **atomique** au niveau de la collection

‚ö†Ô∏è **ATTENTION** : `$out` **supprime compl√®tement** la collection cible avant d'√©crire !

---

## Exemple Simple avec $out

### Donn√©es de D√©part

```javascript
db.ventes.insertMany([
  { _id: 1, produit: "Laptop", categorie: "Informatique", montant: 899, date: ISODate("2024-01-15") },
  { _id: 2, produit: "Souris", categorie: "Informatique", montant: 29, date: ISODate("2024-01-16") },
  { _id: 3, produit: "Bureau", categorie: "Mobilier", montant: 299, date: ISODate("2024-01-17") },
  { _id: 4, produit: "Chaise", categorie: "Mobilier", montant: 159, date: ISODate("2024-01-18") },
  { _id: 5, produit: "√âcran", categorie: "Informatique", montant: 349, date: ISODate("2024-01-19") }
])
```

### Cr√©er un Rapport de Ventes par Cat√©gorie

```javascript
db.ventes.aggregate([
  {
    $group: {
      _id: "$categorie",
      nombre_ventes: { $sum: 1 },
      chiffre_affaires: { $sum: "$montant" },
      vente_moyenne: { $avg: "$montant" }
    }
  },
  {
    $project: {
      _id: 0,
      categorie: "$_id",
      nombre_ventes: 1,
      chiffre_affaires: 1,
      vente_moyenne: { $round: ["$vente_moyenne", 2] }
    }
  },
  // √âcrire dans une nouvelle collection
  {
    $out: "rapport_ventes_par_categorie"
  }
])
```

### V√©rification

```javascript
db.rapport_ventes_par_categorie.find()
```

**R√©sultat** :
```json
[
  {
    "categorie": "Informatique",
    "nombre_ventes": 3,
    "chiffre_affaires": 1277,
    "vente_moyenne": 425.67
  },
  {
    "categorie": "Mobilier",
    "nombre_ventes": 2,
    "chiffre_affaires": 458,
    "vente_moyenne": 229
  }
]
```

**Observations** :
- Une nouvelle collection `rapport_ventes_par_categorie` a √©t√© cr√©√©e
- Elle contient **uniquement** les r√©sultats de l'agr√©gation
- Si on r√©-ex√©cute le pipeline, la collection sera **remplac√©e**

---

## Limitations de $out

### 1. Doit √ätre la Derni√®re √âtape

```javascript
// ‚ùå ERREUR : $out n'est pas la derni√®re √©tape
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $out: "rapport" },
  { $sort: { total: -1 } }  // Interdit apr√®s $out
])

// ‚úÖ CORRECT : $out est la derni√®re √©tape
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $sort: { total: -1 } },
  { $out: "rapport" }  // En dernier
])
```

### 2. Remplace Tout

```javascript
// Collection existante
db.rapport.find()
// ‚Üí 100 documents

// Ex√©cution du pipeline
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $out: "rapport" }
])

// Collection apr√®s
db.rapport.find()
// ‚Üí Seulement 2 documents (les r√©sultats de l'agr√©gation)
// Les 100 anciens documents sont PERDUS
```

### 3. Perte des Index

```javascript
// Avant : collection avec index
db.rapport.getIndexes()
// ‚Üí [{ _id: 1 }, { categorie: 1 }, { date: 1 }]

// Apr√®s $out
db.ventes.aggregate([
  /* ... */
  { $out: "rapport" }
])

db.rapport.getIndexes()
// ‚Üí [{ _id: 1 }]  // Seulement l'index _id reste
```

### 4. Impossible avec des Collections Shard√©es

`$out` ne peut pas √©crire dans une collection **shard√©e** (partitionn√©e).

---

## $merge : Fusion Intelligente

`$merge` est beaucoup plus **flexible** que `$out`. Il permet de **fusionner** les r√©sultats avec une collection existante au lieu de la remplacer compl√®tement.

### Syntaxe Simple

```javascript
{
  $merge: "<nom_collection>"
}
```

### Syntaxe Compl√®te

```javascript
{
  $merge: {
    into: "<nom_collection>",           // Ou { db: "...", coll: "..." }
    on: "<champ_ou_tableau_champs>",    // Champ(s) de correspondance (d√©faut: _id)
    whenMatched: "<action>",            // Action si document existe
    whenNotMatched: "<action>",         // Action si document n'existe pas
    let: { <variables> },               // Variables pour le pipeline
    pipeline: [ <etapes> ]              // Pipeline personnalis√©
  }
}
```

### Param√®tres Principaux

| Param√®tre | Description | D√©faut |
|-----------|-------------|--------|
| `into` | Collection cible | Requis |
| `on` | Champ(s) pour identifier les documents | `"_id"` |
| `whenMatched` | Action si le document existe d√©j√† | `"merge"` |
| `whenNotMatched` | Action si le document n'existe pas | `"insert"` |

---

## Options whenMatched

D√©termine ce qui se passe quand un document du r√©sultat **correspond** √† un document existant.

### 1. "replace" : Remplacement Complet

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenMatched: "replace"  // Remplace le document entier
  }
}
```

**Comportement** : Le document existant est **enti√®rement remplac√©** par le nouveau.

### 2. "merge" : Fusion des Champs (D√©faut)

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenMatched: "merge"  // Fusionne les champs
  }
}
```

**Comportement** : Les champs du nouveau document sont **ajout√©s ou mis √† jour**, les autres champs existants sont **conserv√©s**.

#### Exemple

**Document existant** :
```json
{ "_id": 1, "nom": "Laptop", "prix": 899, "stock": 10 }
```

**R√©sultat du pipeline** :
```json
{ "_id": 1, "prix": 850, "promotion": true }
```

**Apr√®s merge** :
```json
{ "_id": 1, "nom": "Laptop", "prix": 850, "stock": 10, "promotion": true }
// "nom" et "stock" conserv√©s, "prix" mis √† jour, "promotion" ajout√©
```

### 3. "keepExisting" : Conserver l'Existant

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenMatched: "keepExisting"  // Ne rien faire si existe
  }
}
```

**Comportement** : Si le document existe d√©j√†, il n'est **pas modifi√©**.

### 4. "fail" : √âchouer si Existe

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenMatched: "fail"  // Erreur si le document existe
  }
}
```

**Comportement** : L'op√©ration **√©choue** avec une erreur si un document correspondant existe d√©j√†.

### 5. Pipeline Personnalis√©

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenMatched: [
      {
        $set: {
          derniere_maj: "$$NOW",
          prix_precedent: "$prix",
          prix: "$$new.prix"
        }
      }
    ]
  }
}
```

**Comportement** : Ex√©cute un **pipeline d'agr√©gation personnalis√©** pour mettre √† jour le document.

**Variables disponibles** :
- `$$new` : Le document du r√©sultat du pipeline
- `$$ROOT` : Le document existant dans la collection

---

## Options whenNotMatched

D√©termine ce qui se passe quand un document du r√©sultat **ne correspond √† aucun** document existant.

### 1. "insert" : Ins√©rer (D√©faut)

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenNotMatched: "insert"  // Ins√®re les nouveaux documents
  }
}
```

**Comportement** : Les nouveaux documents sont **ins√©r√©s** dans la collection.

### 2. "discard" : Ignorer

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenNotMatched: "discard"  // Ne pas ins√©rer
  }
}
```

**Comportement** : Les documents qui n'existent pas sont **ignor√©s** (non ins√©r√©s).

### 3. "fail" : √âchouer

```javascript
{
  $merge: {
    into: "produits_enrichis",
    on: "_id",
    whenNotMatched: "fail"  // Erreur si nouveau
  }
}
```

**Comportement** : L'op√©ration **√©choue** si un document n'a pas de correspondance.

---

## Exemples Pratiques avec $merge

### Exemple 1 : Mise √† Jour Incr√©mentale de Statistiques

```javascript
// Collection existante avec des statistiques
db.stats_produits.insertMany([
  { _id: "Laptop", ventes_totales: 50, ca_total: 44950 },
  { _id: "Souris", ventes_totales: 120, ca_total: 3480 }
])

// Nouvelles ventes
db.ventes.insertMany([
  { produit: "Laptop", montant: 899 },
  { produit: "Laptop", montant: 899 },
  { produit: "Souris", montant: 29 },
  { produit: "√âcran", montant: 349 }  // Nouveau produit
])

// Mettre √† jour les statistiques
db.ventes.aggregate([
  {
    $group: {
      _id: "$produit",
      nouvelles_ventes: { $sum: 1 },
      nouveau_ca: { $sum: "$montant" }
    }
  },
  {
    $merge: {
      into: "stats_produits",
      on: "_id",
      whenMatched: [
        {
          $set: {
            ventes_totales: { $add: ["$ventes_totales", "$$new.nouvelles_ventes"] },
            ca_total: { $add: ["$ca_total", "$$new.nouveau_ca"] },
            derniere_maj: "$$NOW"
          }
        }
      ],
      whenNotMatched: "insert"
    }
  }
])

// V√©rification
db.stats_produits.find()
```

**R√©sultat** :
```json
[
  {
    "_id": "Laptop",
    "ventes_totales": 52,      // 50 + 2
    "ca_total": 46748,         // 44950 + 1798
    "derniere_maj": ISODate("2024-03-20T10:30:00Z")
  },
  {
    "_id": "Souris",
    "ventes_totales": 121,     // 120 + 1
    "ca_total": 3509,          // 3480 + 29
    "derniere_maj": ISODate("2024-03-20T10:30:00Z")
  },
  {
    "_id": "√âcran",
    "nouvelles_ventes": 1,     // Nouveau produit ins√©r√©
    "nouveau_ca": 349
  }
]
```

### Exemple 2 : Upsert (Update or Insert)

```javascript
// Mettre √† jour les prix, cr√©er si n'existe pas
db.nouveaux_prix.aggregate([
  {
    $project: {
      _id: "$produit_id",
      prix: "$nouveau_prix",
      date_maj: "$$NOW"
    }
  },
  {
    $merge: {
      into: "catalogue",
      on: "_id",
      whenMatched: "merge",      // Mettre √† jour le prix
      whenNotMatched: "insert"   // Cr√©er si nouveau
    }
  }
])
```

### Exemple 3 : Snapshots Quotidiens

```javascript
// Cr√©er un snapshot des statistiques journali√®res
db.ventes.aggregate([
  {
    $match: {
      date: {
        $gte: ISODate("2024-03-20T00:00:00Z"),
        $lt: ISODate("2024-03-21T00:00:00Z")
      }
    }
  },
  {
    $group: {
      _id: {
        date: { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
        categorie: "$categorie"
      },
      ventes: { $sum: 1 },
      ca: { $sum: "$montant" }
    }
  },
  {
    $project: {
      _id: 0,
      date: "$_id.date",
      categorie: "$_id.categorie",
      ventes: 1,
      ca: 1
    }
  },
  {
    $merge: {
      into: "snapshots_quotidiens",
      on: ["date", "categorie"],  // Cl√© composite
      whenMatched: "replace",
      whenNotMatched: "insert"
    }
  }
])
```

### Exemple 4 : D√©normalisation pour Performance

```javascript
// Enrichir les commandes avec les infos clients (d√©normalisation)
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "client_info"
    }
  },
  { $unwind: "$client_info" },
  {
    $project: {
      _id: 1,
      date: 1,
      montant: 1,
      client_nom: "$client_info.nom",
      client_email: "$client_info.email",
      client_ville: "$client_info.ville"
    }
  },
  {
    $merge: {
      into: "commandes_enrichies",
      on: "_id",
      whenMatched: "replace",
      whenNotMatched: "insert"
    }
  }
])
```

---

## Option : on (Champs de Correspondance)

Le param√®tre `on` d√©termine comment identifier les documents correspondants.

### Un Seul Champ

```javascript
{
  $merge: {
    into: "produits",
    on: "_id"  // Correspondance par _id
  }
}
```

### Plusieurs Champs (Cl√© Composite)

```javascript
{
  $merge: {
    into: "ventes_journalieres",
    on: ["date", "categorie", "region"]  // Cl√© composite
  }
}
```

**Comportement** : Un document correspond si **tous les champs** sp√©cifi√©s sont √©gaux.

### Sans Champ _id

Si vos documents n'ont pas de champ `_id`, sp√©cifiez explicitement les champs :

```javascript
{
  $merge: {
    into: "stats",
    on: ["annee", "mois", "produit"]
  }
}
```

---

## Comparaison $out vs $merge

| Aspect | $out | $merge |
|--------|------|--------|
| **Remplacement** | ‚úÖ Total (supprime tout) | ‚ö†Ô∏è S√©lectif (fusion) |
| **Flexibilit√©** | ‚ùå Limit√©e | ‚úÖ Tr√®s flexible |
| **Index** | ‚ùå Perdus (sauf _id) | ‚úÖ Conserv√©s |
| **Mise √† jour partielle** | ‚ùå Non | ‚úÖ Oui |
| **Complexit√©** | ‚úÖ Simple | ‚ö†Ô∏è Plus complexe |
| **Collection shard√©e** | ‚ùå Non support√© | ‚úÖ Support√© |
| **Base diff√©rente** | ‚úÖ Oui | ‚úÖ Oui |
| **Performance** | ‚úÖ Rapide (remplace tout) | ‚ö†Ô∏è Plus lent (v√©rifie chaque doc) |

### Quand Utiliser Chacun ?

**Utilisez `$out`** quand :
- ‚úÖ Vous voulez **remplacer compl√®tement** la collection
- ‚úÖ C'est un **rapport en lecture seule**
- ‚úÖ La **simplicit√©** est importante
- ‚úÖ La collection cible n'est **pas shard√©e**

**Utilisez `$merge`** quand :
- ‚úÖ Vous voulez **mettre √† jour s√©lectivement**
- ‚úÖ Vous devez **conserver les index**
- ‚úÖ Vous travaillez avec des collections **shard√©es**
- ‚úÖ Vous faites des **mises √† jour incr√©mentales**
- ‚úÖ Vous avez besoin de **logique conditionnelle**

---

## Cas d'Usage Courants

### 1. Rapports Pr√©-calcul√©s

```javascript
// Calculer un rapport mensuel
db.ventes.aggregate([
  {
    $match: {
      date: {
        $gte: ISODate("2024-03-01"),
        $lt: ISODate("2024-04-01")
      }
    }
  },
  {
    $group: {
      _id: {
        jour: { $dayOfMonth: "$date" },
        categorie: "$categorie"
      },
      ventes: { $sum: 1 },
      ca: { $sum: "$montant" }
    }
  },
  {
    $out: "rapport_mars_2024"
  }
])

// Utilisation rapide du rapport pr√©-calcul√©
db.rapport_mars_2024.find()  // Tr√®s rapide !
```

### 2. Cache de Requ√™tes Complexes

```javascript
// Pr√©-calculer des agr√©gations co√ªteuses
db.commandes.aggregate([
  {
    $lookup: { /* jointure complexe */ }
  },
  { $unwind: "$produits" },
  {
    $group: { /* agr√©gation complexe */ }
  },
  {
    $merge: {
      into: "cache_dashboard",
      on: "_id",
      whenMatched: "replace"
    }
  }
])

// Le dashboard lit directement le cache
db.cache_dashboard.find()  // Instantan√© !
```

### 3. Transformation ETL

```javascript
// Extract, Transform, Load
db.donnees_brutes.aggregate([
  // Extract
  {
    $match: { statut: "valide" }
  },
  // Transform
  {
    $project: {
      // Nettoyage et transformation
      client_id: { $toInt: "$id_client" },
      montant: { $toDouble: "$montant_str" },
      date: { $dateFromString: { dateString: "$date_str" } }
    }
  },
  // Load
  {
    $out: "donnees_propres"
  }
])
```

### 4. Vues Mat√©rialis√©es

```javascript
// Cr√©er une "vue mat√©rialis√©e" (snapshot statique)
db.createView(
  "vue_ventes_categorie",
  "ventes",
  [
    {
      $group: {
        _id: "$categorie",
        total: { $sum: "$montant" }
      }
    }
  ]
)

// Mat√©rialiser la vue pour de meilleures performances
db.vue_ventes_categorie.aggregate([
  { $out: "ventes_categorie_materialisee" }
])
```

### 5. Historisation de Donn√©es

```javascript
// Sauvegarder un snapshot historique
db.produits.aggregate([
  {
    $addFields: {
      snapshot_date: new Date(),
      snapshot_id: ObjectId()
    }
  },
  {
    $merge: {
      into: "historique_produits",
      whenMatched: "fail",        // Ne jamais √©craser
      whenNotMatched: "insert"
    }
  }
])
```

---

## Bonnes Pratiques

### 1. Utiliser des Index sur les Champs de Correspondance

```javascript
// Cr√©er un index sur le champ "on"
db.stats_produits.createIndex({ _id: 1 })

// Ou pour une cl√© composite
db.ventes_journalieres.createIndex({ date: 1, categorie: 1, region: 1 })

// Puis utiliser $merge
db.ventes.aggregate([
  /* ... */
  {
    $merge: {
      into: "ventes_journalieres",
      on: ["date", "categorie", "region"]
    }
  }
])
```

### 2. Tester d'Abord sans $out/$merge

```javascript
// ‚úÖ Bon : Tester le pipeline d'abord
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $sort: { total: -1 } }
  // Pas encore de $out/$merge
])

// V√©rifier les r√©sultats
// ...

// Puis ajouter $out/$merge une fois satisfait
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $sort: { total: -1 } },
  { $out: "rapport_categories" }
])
```

### 3. Utiliser des Collections Temporaires pour $out

```javascript
// ‚úÖ √âcrire d'abord dans une collection temporaire
db.ventes.aggregate([
  /* ... */
  { $out: "rapport_temp" }
])

// V√©rifier
db.rapport_temp.find()

// Si OK, renommer
db.rapport_temp.renameCollection("rapport_final", { dropTarget: true })
```

### 4. Planifier les Mises √† Jour avec $merge

```javascript
// Utiliser un scheduler (cron, etc.) pour les mises √† jour r√©guli√®res
// Exemple : Toutes les heures
db.ventes.aggregate([
  {
    $match: {
      date: {
        $gte: new Date(Date.now() - 3600000)  // Derni√®re heure
      }
    }
  },
  {
    $group: { /* ... */ }
  },
  {
    $merge: {
      into: "stats_horaires",
      on: "heure",
      whenMatched: "replace",
      whenNotMatched: "insert"
    }
  }
])
```

### 5. Documenter les Transformations

```javascript
// Ajouter des m√©tadonn√©es
db.ventes.aggregate([
  {
    $group: {
      _id: "$categorie",
      total: { $sum: "$montant" }
    }
  },
  {
    $addFields: {
      _metadata: {
        generation_date: "$$NOW",
        source: "ventes",
        pipeline: "rapport_mensuel"
      }
    }
  },
  {
    $out: "rapport_categories"
  }
])
```

---

## Permissions et S√©curit√©

### Permissions Requises

Pour utiliser `$out` ou `$merge`, l'utilisateur doit avoir :

| Action | Permission Requise |
|--------|-------------------|
| `$out` (nouvelle collection) | `insert` et `remove` sur la collection cible |
| `$out` (collection existante) | `insert`, `remove`, et `dropCollection` |
| `$merge` | `insert` et `update` sur la collection cible |

### Exemple de R√¥le

```javascript
db.createRole({
  role: "agregationWriter",
  privileges: [
    {
      resource: { db: "analytics", collection: "rapports" },
      actions: ["insert", "update", "remove", "dropCollection"]
    }
  ],
  roles: []
})
```

---

## Limitations et Consid√©rations

### 1. Position dans le Pipeline

```javascript
// ‚ùå ERREUR : $out/$merge n'est pas la derni√®re √©tape
db.ventes.aggregate([
  { $group: { _id: "$categorie", total: { $sum: "$montant" } } },
  { $out: "rapport" },
  { $sort: { total: -1 } }  // Interdit !
])
```

### 2. Transactions

`$out` et `$merge` peuvent √™tre utilis√©s dans des **transactions multi-documents**.

```javascript
const session = db.getMongo().startSession()
session.startTransaction()

try {
  db.ventes.aggregate([
    /* ... */
    { $merge: { into: "stats" } }
  ], { session })

  session.commitTransaction()
} catch (error) {
  session.abortTransaction()
  throw error
} finally {
  session.endSession()
}
```

### 3. Performance

- **$out** : Rapide (remplace en bloc)
- **$merge** : Plus lent (v√©rifie chaque document pour correspondance)

Pour de **grandes collections**, `$merge` peut prendre du temps.

### 4. M√©moire

Les op√©rations respectent la **limite de 100 Mo** par d√©faut. Utilisez `allowDiskUse: true` si n√©cessaire.

```javascript
db.ventes.aggregate(
  [
    /* pipeline complexe */
    { $merge: { into: "resultats" } }
  ],
  { allowDiskUse: true }
)
```

---

## Exemple Complet : Syst√®me de Reporting

```javascript
// 1. Donn√©es de ventes brutes
db.ventes_brutes.insertMany([
  {
    date: ISODate("2024-03-15T10:30:00Z"),
    produit: "Laptop",
    categorie: "Informatique",
    montant: 899,
    quantite: 1,
    vendeur: "Alice",
    region: "Nord"
  },
  {
    date: ISODate("2024-03-15T14:20:00Z"),
    produit: "Souris",
    categorie: "Informatique",
    montant: 29,
    quantite: 2,
    vendeur: "Bob",
    region: "Sud"
  },
  // ... plus de ventes
])

// 2. Pipeline de transformation et agr√©gation
db.ventes_brutes.aggregate([
  // Nettoyer et transformer
  {
    $project: {
      date: 1,
      annee: { $year: "$date" },
      mois: { $month: "$date" },
      jour: { $dayOfMonth: "$date" },
      categorie: 1,
      region: 1,
      vendeur: 1,
      ca_ligne: { $multiply: ["$montant", "$quantite"] }
    }
  },

  // Agr√©ger par jour, cat√©gorie et r√©gion
  {
    $group: {
      _id: {
        annee: "$annee",
        mois: "$mois",
        jour: "$jour",
        categorie: "$categorie",
        region: "$region"
      },
      nombre_ventes: { $sum: 1 },
      ca_total: { $sum: "$ca_ligne" },
      vendeurs: { $addToSet: "$vendeur" }
    }
  },

  // Restructurer
  {
    $project: {
      _id: 0,
      date: {
        $dateFromParts: {
          year: "$_id.annee",
          month: "$_id.mois",
          day: "$_id.jour"
        }
      },
      categorie: "$_id.categorie",
      region: "$_id.region",
      nombre_ventes: 1,
      ca_total: { $round: ["$ca_total", 2] },
      ca_moyen: {
        $round: [{ $divide: ["$ca_total", "$nombre_ventes"] }, 2]
      },
      nombre_vendeurs: { $size: "$vendeurs" }
    }
  },

  // Fusionner dans la collection de reporting
  {
    $merge: {
      into: "rapport_ventes_quotidien",
      on: ["date", "categorie", "region"],
      whenMatched: [
        {
          $set: {
            nombre_ventes: "$$new.nombre_ventes",
            ca_total: "$$new.ca_total",
            ca_moyen: "$$new.ca_moyen",
            nombre_vendeurs: "$$new.nombre_vendeurs",
            derniere_mise_a_jour: "$$NOW"
          }
        }
      ],
      whenNotMatched: "insert"
    }
  }
])

// 3. Cr√©er un r√©sum√© mensuel √† partir du quotidien
db.rapport_ventes_quotidien.aggregate([
  {
    $group: {
      _id: {
        annee: { $year: "$date" },
        mois: { $month: "$date" },
        categorie: "$categorie",
        region: "$region"
      },
      jours_actifs: { $sum: 1 },
      total_ventes: { $sum: "$nombre_ventes" },
      ca_total: { $sum: "$ca_total" }
    }
  },
  {
    $project: {
      _id: 0,
      periode: {
        $concat: [
          { $toString: "$_id.annee" },
          "-",
          { $toString: "$_id.mois" }
        ]
      },
      categorie: "$_id.categorie",
      region: "$_id.region",
      jours_actifs: 1,
      total_ventes: 1,
      ca_total: { $round: ["$ca_total", 2] },
      ventes_par_jour: {
        $round: [{ $divide: ["$total_ventes", "$jours_actifs"] }, 2]
      }
    }
  },
  {
    $out: "rapport_ventes_mensuel"
  }
])

// 4. Consultation des rapports (tr√®s rapide)
db.rapport_ventes_quotidien.find({ date: ISODate("2024-03-15") })
db.rapport_ventes_mensuel.find({ periode: "2024-3" })
```

---

## R√©sum√©

### Points Cl√©s

| Aspect | $out | $merge |
|--------|------|--------|
| **Fonction** | Remplace compl√®tement la collection | Fusionne avec la collection existante |
| **Simplicit√©** | ‚úÖ Tr√®s simple | ‚ö†Ô∏è Plus complexe |
| **Flexibilit√©** | ‚ùå Limit√©e | ‚úÖ Tr√®s flexible |
| **Index** | ‚ùå Perdus | ‚úÖ Conserv√©s |
| **Mise √† jour** | ‚ùå Non (tout remplac√©) | ‚úÖ Oui (s√©lective) |
| **Collections shard√©es** | ‚ùå Non | ‚úÖ Oui |
| **Position** | Derni√®re √©tape | Derni√®re √©tape |

### Quand Utiliser $out vs $merge

**Utilisez `$out`** pour :
- ‚úÖ Rapports en **lecture seule**
- ‚úÖ **Remplacement total** souhait√©
- ‚úÖ **Simplicit√©** prioritaire
- ‚úÖ Snapshots **ponctuels**

**Utilisez `$merge`** pour :
- ‚úÖ **Mises √† jour incr√©mentales**
- ‚úÖ **Conservation des index**
- ‚úÖ Collections **shard√©es**
- ‚úÖ Logique **conditionnelle** (whenMatched/whenNotMatched)
- ‚úÖ **Upserts** (update or insert)

### Applications Principales

1. **Rapports pr√©-calcul√©s** : √âviter de recalculer √† chaque requ√™te
2. **Vues mat√©rialis√©es** : Snapshots statiques de donn√©es agr√©g√©es
3. **ETL** : Transformation et chargement de donn√©es
4. **Cache** : Stocker des r√©sultats de requ√™tes complexes
5. **D√©normalisation** : Cr√©er des collections optimis√©es pour la lecture

---

## Conclusion

`$out` et `$merge` sont des outils **essentiels** pour persister les r√©sultats d'agr√©gations dans MongoDB. Ils permettent de cr√©er des rapports, des vues mat√©rialis√©es, et d'optimiser les performances en pr√©-calculant des donn√©es complexes.

### √Ä Retenir

1. **$out** remplace **compl√®tement** la collection (simple mais radical)
2. **$merge** **fusionne** intelligemment (flexible et puissant)
3. Doivent √™tre la **derni√®re √©tape** du pipeline
4. Utilisez `$out` pour des **rapports en lecture seule**
5. Utilisez `$merge` pour des **mises √† jour incr√©mentales**
6. **Indexez** les champs de correspondance pour `$merge`
7. **Testez** le pipeline avant d'ajouter $out/$merge
8. Pensez aux **permissions** n√©cessaires

### Prochaines √âtapes

Dans les sections suivantes, nous explorerons :
- **$redact** : Filtrage au niveau document et sous-document
- **$sample** : √âchantillonnage al√©atoire de documents
- **Optimisation des pipelines** : Techniques avanc√©es de performance

---

**üìö R√©f√©rences**

- [Documentation officielle $out](https://www.mongodb.com/docs/manual/reference/operator/aggregation/out/)
- [Documentation officielle $merge](https://www.mongodb.com/docs/manual/reference/operator/aggregation/merge/)
- [Materialized Views Pattern](https://www.mongodb.com/docs/manual/core/materialized-views/)
- [Aggregation Pipeline Optimization](https://www.mongodb.com/docs/manual/core/aggregation-pipeline-optimization/)

‚è≠Ô∏è [$redact](/06-framework-agregation/04.09-redact.md)
