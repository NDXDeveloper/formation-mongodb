üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.4.6 $bucket et $bucketAuto

## Introduction

Les √©tapes `$bucket` et `$bucketAuto` sont des op√©rateurs du framework d'agr√©gation MongoDB qui permettent de **regrouper des documents en tranches** (ou "buckets" en anglais) bas√©es sur des intervalles de valeurs. Ils sont particuli√®rement utiles pour cr√©er des histogrammes, des distributions et des analyses par cat√©gories num√©riques.

### L'Essentiel

- **`$bucket`** : Regroupe les documents dans des tranches avec **limites d√©finies manuellement**
- **`$bucketAuto`** : Regroupe les documents dans des tranches **calcul√©es automatiquement**
- **Objectif** : Cr√©er des distributions, histogrammes, et cat√©gorisations num√©riques
- **R√©sultat** : Documents regroup√©s par intervalle avec statistiques associ√©es

### Analogie Simple

Imaginez que vous classez des √©tudiants par **tranches de notes** :
- **0-10** : Insuffisant (3 √©tudiants)
- **10-14** : Passable (12 √©tudiants)
- **14-16** : Bien (8 √©tudiants)
- **16-20** : Tr√®s bien (5 √©tudiants)

`$bucket` et `$bucketAuto` font exactement cela : ils **cr√©ent des cat√©gories** et **comptent combien d'√©l√©ments** tombent dans chaque cat√©gorie.

---

## Pourquoi Utiliser $bucket / $bucketAuto ?

Ces op√©rateurs sont essentiels pour :

1. **Cr√©er des histogrammes** : Visualiser la distribution des donn√©es
2. **Analyser des tranches de prix** : Produits par gamme tarifaire
3. **Segmenter des clients** : Par √¢ge, revenu, comportement
4. **Cr√©er des cat√©gories** : Automatiquement ou manuellement
5. **Faciliter les filtres** : Proposer des options de filtrage par tranche
6. **Analyses statistiques** : Distribution, quartiles, percentiles

---

## $bucket : Tranches Manuelles

### Syntaxe

```javascript
{
  $bucket: {
    groupBy: <expression>,           // Champ utilis√© pour cat√©goriser
    boundaries: [<limite1>, <limite2>, ...],  // Limites des tranches
    default: <valeur_par_defaut>,    // Cat√©gorie pour valeurs hors limites (optionnel)
    output: {                        // Calculs √† effectuer (optionnel)
      <champ_sortie1>: { <accumulateur1> },
      <champ_sortie2>: { <accumulateur2> }
    }
  }
}
```

### Param√®tres

| Param√®tre | Description | Obligatoire |
|-----------|-------------|-------------|
| `groupBy` | Expression d√©terminant la valeur √† cat√©goriser | ‚úÖ Oui |
| `boundaries` | Tableau des limites des tranches (croissant) | ‚úÖ Oui |
| `default` | Cat√©gorie pour les valeurs hors limites | ‚ùå Non |
| `output` | Statistiques √† calculer pour chaque tranche | ‚ùå Non |

### Fonctionnement des Limites

Les `boundaries` d√©finissent les **bornes des intervalles** :
- `[0, 50, 100, 150]` cr√©e **3 tranches** :
  - Tranche 1 : `[0, 50)` ‚Üí 0 inclus, 50 exclu
  - Tranche 2 : `[50, 100)` ‚Üí 50 inclus, 100 exclu
  - Tranche 3 : `[100, 150)` ‚Üí 100 inclus, 150 exclu

‚ö†Ô∏è **Important** : La derni√®re valeur (150) est la **borne sup√©rieure** qui n'est **jamais incluse**.

---

## Exemple Simple avec $bucket

### Pr√©paration des Donn√©es

```javascript
db.produits.insertMany([
  { _id: 1, nom: "Stylo", prix: 2, categorie: "Fournitures" },
  { _id: 2, nom: "Cahier", prix: 5, categorie: "Fournitures" },
  { _id: 3, nom: "Calculatrice", prix: 25, categorie: "√âlectronique" },
  { _id: 4, nom: "Sac √† dos", prix: 45, categorie: "Maroquinerie" },
  { _id: 5, nom: "Livre", prix: 15, categorie: "Librairie" },
  { _id: 6, nom: "Montre", prix: 120, categorie: "Accessoires" },
  { _id: 7, nom: "Souris", prix: 29, categorie: "√âlectronique" },
  { _id: 8, nom: "Clavier", prix: 79, categorie: "√âlectronique" },
  { _id: 9, nom: "√âcran", prix: 299, categorie: "√âlectronique" },
  { _id: 10, nom: "Lampe", prix: 35, categorie: "Mobilier" }
])
```

### Application de $bucket

Regroupons les produits par **tranches de prix** :

```javascript
db.produits.aggregate([
  {
    $bucket: {
      groupBy: "$prix",                    // Champ √† cat√©goriser
      boundaries: [0, 20, 50, 100, 300],   // 4 tranches
      default: "Autre",                    // Pour valeurs hors limites
      output: {
        "nombre": { $sum: 1 },             // Compter les produits
        "produits": { $push: "$nom" }      // Liste des noms
      }
    }
  }
])
```

### R√©sultat

```json
[
  {
    "_id": 0,                              // Tranche [0, 20)
    "nombre": 3,
    "produits": ["Stylo", "Cahier", "Livre"]
  },
  {
    "_id": 20,                             // Tranche [20, 50)
    "nombre": 4,
    "produits": ["Calculatrice", "Sac √† dos", "Souris", "Lampe"]
  },
  {
    "_id": 50,                             // Tranche [50, 100)
    "nombre": 1,
    "produits": ["Clavier"]
  },
  {
    "_id": 100,                            // Tranche [100, 300)
    "nombre": 2,
    "produits": ["Montre", "√âcran"]
  }
]
```

### Observations

1. Le champ `_id` contient la **limite inf√©rieure** de chaque tranche
2. Chaque tranche compte le nombre de produits et liste leurs noms
3. Les valeurs sont **incluses √† gauche, exclues √† droite** : `[min, max)`

---

## Output Personnalis√©

Vous pouvez calculer diverses **statistiques** pour chaque tranche.

### Exemple : Statistiques D√©taill√©es

```javascript
db.produits.aggregate([
  {
    $bucket: {
      groupBy: "$prix",
      boundaries: [0, 20, 50, 100, 300],
      default: "Hors gamme",
      output: {
        "nombre_produits": { $sum: 1 },
        "prix_moyen": { $avg: "$prix" },
        "prix_min": { $min: "$prix" },
        "prix_max": { $max: "$prix" },
        "total": { $sum: "$prix" },
        "produits": { $push: "$nom" },
        "categories": { $addToSet: "$categorie" }  // Cat√©gories uniques
      }
    }
  }
])
```

### R√©sultat

```json
[
  {
    "_id": 0,
    "nombre_produits": 3,
    "prix_moyen": 7.33,
    "prix_min": 2,
    "prix_max": 15,
    "total": 22,
    "produits": ["Stylo", "Cahier", "Livre"],
    "categories": ["Fournitures", "Librairie"]
  },
  {
    "_id": 20,
    "nombre_produits": 4,
    "prix_moyen": 33.5,
    "prix_min": 25,
    "prix_max": 45,
    "total": 134,
    "produits": ["Calculatrice", "Sac √† dos", "Souris", "Lampe"],
    "categories": ["√âlectronique", "Maroquinerie", "Mobilier"]
  },
  // ...
]
```

---

## Gestion des Valeurs Hors Limites

### Sans `default`

Si une valeur est **en dehors des limites** et qu'aucun `default` n'est sp√©cifi√©, le document est **ignor√©**.

```javascript
// Produit avec prix = 500 (hors limites [0, 20, 50, 100, 300])
db.produits.insertOne({ _id: 11, nom: "Ordinateur", prix: 500 })

db.produits.aggregate([
  {
    $bucket: {
      groupBy: "$prix",
      boundaries: [0, 20, 50, 100, 300]
      // Pas de "default"
    }
  }
])
// L'ordinateur (500‚Ç¨) ne sera PAS dans le r√©sultat
```

### Avec `default`

```javascript
db.produits.aggregate([
  {
    $bucket: {
      groupBy: "$prix",
      boundaries: [0, 20, 50, 100, 300],
      default: "Premium",           // Cat√©gorie pour valeurs >= 300
      output: {
        "nombre": { $sum: 1 },
        "produits": { $push: "$nom" }
      }
    }
  }
])
```

**R√©sultat** (extrait) :
```json
[
  // ... autres tranches ...
  {
    "_id": "Premium",                // Cat√©gorie par d√©faut
    "nombre": 1,
    "produits": ["Ordinateur"]
  }
]
```

---

## $bucketAuto : Tranches Automatiques

`$bucketAuto` **calcule automatiquement** les limites des tranches pour r√©partir √©quitablement les documents.

### Syntaxe

```javascript
{
  $bucketAuto: {
    groupBy: <expression>,           // Champ utilis√© pour cat√©goriser
    buckets: <nombre_de_tranches>,   // Nombre de tranches √† cr√©er
    output: {                        // Calculs √† effectuer (optionnel)
      <champ_sortie1>: { <accumulateur1> }
    },
    granularity: <granularit√©>       // Arrondi des limites (optionnel)
  }
}
```

### Param√®tres

| Param√®tre | Description | Obligatoire |
|-----------|-------------|-------------|
| `groupBy` | Expression d√©terminant la valeur √† cat√©goriser | ‚úÖ Oui |
| `buckets` | Nombre de tranches √† cr√©er | ‚úÖ Oui |
| `output` | Statistiques √† calculer pour chaque tranche | ‚ùå Non |
| `granularity` | Arrondi des limites (R5, R10, R20, etc.) | ‚ùå Non |

---

## Exemple Simple avec $bucketAuto

```javascript
db.produits.aggregate([
  {
    $bucketAuto: {
      groupBy: "$prix",
      buckets: 4,                    // Cr√©er 4 tranches automatiquement
      output: {
        "nombre": { $sum: 1 },
        "prix_moyen": { $avg: "$prix" },
        "produits": { $push: "$nom" }
      }
    }
  }
])
```

### R√©sultat

```json
[
  {
    "_id": {
      "min": 2,                      // Limite inf√©rieure (incluse)
      "max": 15                      // Limite sup√©rieure (exclue)
    },
    "nombre": 3,
    "prix_moyen": 7.33,
    "produits": ["Stylo", "Cahier", "Livre"]
  },
  {
    "_id": {
      "min": 15,
      "max": 35
    },
    "nombre": 3,
    "prix_moyen": 23,
    "produits": ["Calculatrice", "Souris", "Lampe"]
  },
  {
    "_id": {
      "min": 35,
      "max": 79
    },
    "nombre": 2,
    "prix_moyen": 62,
    "produits": ["Sac √† dos", "Clavier"]
  },
  {
    "_id": {
      "min": 79,
      "max": 299
    },
    "nombre": 2,
    "prix_moyen": 209.5,
    "produits": ["Montre", "√âcran"]
  }
]
```

### Observations

1. MongoDB a **automatiquement calcul√©** les limites
2. Le champ `_id` est un **objet** avec `min` et `max`
3. Les tranches sont **relativement √©quilibr√©es** en nombre de documents
4. Parfait quand vous **ne connaissez pas** la distribution des donn√©es

---

## Comparaison $bucket vs $bucketAuto

| Aspect | $bucket | $bucketAuto |
|--------|---------|-------------|
| **Limites** | ‚úÖ D√©finies manuellement | ‚úÖ Calcul√©es automatiquement |
| **Contr√¥le** | ‚úÖ Total sur les tranches | ‚ùå Limit√© |
| **Simplicit√©** | ‚ùå N√©cessite connaissance des donn√©es | ‚úÖ Simple √† utiliser |
| **Pr√©visibilit√©** | ‚úÖ R√©sultats pr√©visibles | ‚ö†Ô∏è D√©pend des donn√©es |
| **Format _id** | Valeur simple (min de tranche) | Objet `{min, max}` |
| **R√©partition** | Peut √™tre d√©s√©quilibr√©e | Tente d'√©quilibrer |

### Quand Utiliser Chacun ?

**Utilisez `$bucket`** quand :
- ‚úÖ Vous connaissez la **distribution** des donn√©es
- ‚úÖ Vous avez des **cat√©gories m√©tier** pr√©d√©finies (ex: tranches de prix standard)
- ‚úÖ Vous voulez des **limites pr√©cises** (ex: 0-18 ans, 18-25 ans, etc.)
- ‚úÖ Vous voulez **comparer** avec des p√©riodes pr√©c√©dentes (m√™mes tranches)

**Utilisez `$bucketAuto`** quand :
- ‚úÖ Vous **ne connaissez pas** la distribution des donn√©es
- ‚úÖ Vous voulez une **r√©partition √©quilibr√©e**
- ‚úÖ Vous explorez les donn√©es (**analyse exploratoire**)
- ‚úÖ La distribution change fr√©quemment

---

## Option granularity

`granularity` permet d'**arrondir les limites** selon des s√©ries standard (s√©rie de Renard).

### Valeurs Possibles

- **R5** : 1, 2, 5, 10, 20, 50, 100...
- **R10** : 1, 2, 3, 5, 10, 20, 30, 50, 100...
- **R20** : 1, 1.5, 2, 3, 5, 6, 10, 15, 20...
- **R40**, **R80** : Plus de pr√©cision
- **1-2-5** : 1, 2, 5, 10, 20, 50...
- **E6**, **E12**, **E24**, etc. : S√©ries √©lectroniques

### Exemple

```javascript
db.produits.aggregate([
  {
    $bucketAuto: {
      groupBy: "$prix",
      buckets: 4,
      granularity: "R20",          // Arrondir selon R20
      output: {
        "nombre": { $sum: 1 },
        "produits": { $push: "$nom" }
      }
    }
  }
])
```

**R√©sultat** :
```json
[
  {
    "_id": { "min": 2, "max": 15 },  // Arrondies selon R20
    "nombre": 3,
    "produits": ["Stylo", "Cahier", "Livre"]
  },
  // Les limites sont des valeurs "rondes" de la s√©rie R20
]
```

### Avantage

Les limites sont plus **lisibles** et **pr√©sentables** (ex: 10, 50, 100 plut√¥t que 9.7, 47.3, 98.6).

---

## Cas d'Usage Courants

### 1. Analyse des Ages

```javascript
db.utilisateurs.insertMany([
  { _id: 1, nom: "Alice", age: 25, ville: "Paris" },
  { _id: 2, nom: "Bob", age: 17, ville: "Lyon" },
  { _id: 3, nom: "Charlie", age: 42, ville: "Paris" },
  { _id: 4, nom: "Diana", age: 31, ville: "Marseille" },
  { _id: 5, nom: "Eve", age: 19, ville: "Paris" },
  { _id: 6, nom: "Frank", age: 67, ville: "Lyon" },
  { _id: 7, nom: "Grace", age: 28, ville: "Paris" },
  { _id: 8, nom: "Henry", age: 55, ville: "Marseille" }
])

// R√©partition par tranches d'√¢ge
db.utilisateurs.aggregate([
  {
    $bucket: {
      groupBy: "$age",
      boundaries: [0, 18, 25, 35, 50, 65, 100],  // Tranches d'√¢ge
      default: "Non sp√©cifi√©",
      output: {
        "nombre_personnes": { $sum: 1 },
        "age_moyen": { $avg: "$age" },
        "noms": { $push: "$nom" }
      }
    }
  }
])
```

**R√©sultat** :
```json
[
  {
    "_id": 0,                        // 0-18 ans (Mineurs)
    "nombre_personnes": 1,
    "age_moyen": 17,
    "noms": ["Bob"]
  },
  {
    "_id": 18,                       // 18-25 ans (Jeunes adultes)
    "nombre_personnes": 2,
    "age_moyen": 22,
    "noms": ["Alice", "Eve"]
  },
  {
    "_id": 25,                       // 25-35 ans (Adultes)
    "nombre_personnes": 2,
    "age_moyen": 29.5,
    "noms": ["Charlie", "Grace"]
  },
  {
    "_id": 35,                       // 35-50 ans
    "nombre_personnes": 1,
    "age_moyen": 42,
    "noms": ["Diana"]
  },
  {
    "_id": 50,                       // 50-65 ans
    "nombre_personnes": 1,
    "age_moyen": 55,
    "noms": ["Henry"]
  },
  {
    "_id": 65,                       // 65+ ans (Seniors)
    "nombre_personnes": 1,
    "age_moyen": 67,
    "noms": ["Frank"]
  }
]
```

### 2. Distribution des Notes

```javascript
db.examens.insertMany([
  { _id: 1, etudiant: "Alice", note: 18 },
  { _id: 2, etudiant: "Bob", note: 12 },
  { _id: 3, etudiant: "Charlie", note: 8 },
  { _id: 4, etudiant: "Diana", note: 15 },
  { _id: 5, etudiant: "Eve", note: 9 },
  { _id: 6, etudiant: "Frank", note: 17 },
  { _id: 7, etudiant: "Grace", note: 11 },
  { _id: 8, etudiant: "Henry", note: 14 }
])

// Histogramme des notes
db.examens.aggregate([
  {
    $bucket: {
      groupBy: "$note",
      boundaries: [0, 10, 12, 14, 16, 20],
      output: {
        "nombre_etudiants": { $sum: 1 },
        "note_moyenne": { $avg: "$note" },
        "etudiants": { $push: "$etudiant" }
      }
    }
  },
  {
    $addFields: {
      "mention": {
        $switch: {
          branches: [
            { case: { $eq: ["$_id", 0] }, then: "Insuffisant" },
            { case: { $eq: ["$_id", 10] }, then: "Passable" },
            { case: { $eq: ["$_id", 12] }, then: "Assez bien" },
            { case: { $eq: ["$_id", 14] }, then: "Bien" },
            { case: { $eq: ["$_id", 16] }, then: "Tr√®s bien" }
          ],
          default: "Inconnu"
        }
      }
    }
  }
])
```

### 3. Gammes de Prix E-commerce

```javascript
db.catalogue.aggregate([
  {
    $bucket: {
      groupBy: "$prix",
      boundaries: [0, 50, 100, 200, 500, 1000],
      default: "Luxe",
      output: {
        "nombre_produits": { $sum: 1 },
        "prix_moyen": { $avg: "$prix" },
        "total_stock": { $sum: "$stock" }
      }
    }
  },
  {
    $addFields: {
      "gamme": {
        $switch: {
          branches: [
            { case: { $eq: ["$_id", 0] }, then: "Entr√©e de gamme" },
            { case: { $eq: ["$_id", 50] }, then: "Accessible" },
            { case: { $eq: ["$_id", 100] }, then: "Milieu de gamme" },
            { case: { $eq: ["$_id", 200] }, then: "Premium" },
            { case: { $eq: ["$_id", 500] }, then: "Haut de gamme" }
          ],
          default: "Luxe"
        }
      }
    }
  },
  {
    $project: {
      _id: 0,
      gamme: 1,
      tranche_prix: {
        $concat: [
          { $toString: "$_id" },
          " - ",
          { $toString: { $add: ["$_id", 50] } },  // Exemple simplifi√©
          "‚Ç¨"
        ]
      },
      nombre_produits: 1,
      prix_moyen: { $round: ["$prix_moyen", 2] },
      total_stock: 1
    }
  }
])
```

### 4. Analyse des Temps de R√©ponse

```javascript
db.logs_api.aggregate([
  {
    $bucketAuto: {
      groupBy: "$temps_reponse_ms",
      buckets: 5,                    // 5 tranches automatiques
      granularity: "R10",            // Limites arrondies
      output: {
        "nombre_requetes": { $sum: 1 },
        "temps_moyen": { $avg: "$temps_reponse_ms" },
        "temps_max": { $max: "$temps_reponse_ms" },
        "endpoints": { $addToSet: "$endpoint" }
      }
    }
  },
  {
    $addFields: {
      "performance": {
        $cond: {
          if: { $lte: ["$temps_moyen", 100] },
          then: "Excellent",
          else: {
            $cond: {
              if: { $lte: ["$temps_moyen", 500] },
              then: "Bon",
              else: "√Ä am√©liorer"
            }
          }
        }
      }
    }
  }
])
```

---

## Combinaison avec $facet

Cr√©er plusieurs histogrammes en une seule requ√™te.

### Exemple : Analyse Multi-dimensionnelle

```javascript
db.ventes.aggregate([
  {
    $facet: {
      // Histogramme par montant
      "par_montant": [
        {
          $bucket: {
            groupBy: "$montant",
            boundaries: [0, 100, 250, 500, 1000],
            default: "Premium",
            output: {
              "nombre_ventes": { $sum: 1 },
              "ca_total": { $sum: "$montant" }
            }
          }
        }
      ],

      // Distribution par nombre de produits
      "par_produits": [
        {
          $bucketAuto: {
            groupBy: { $size: "$produits" },
            buckets: 4,
            output: {
              "nombre_commandes": { $sum: 1 },
              "panier_moyen": { $avg: "$montant" }
            }
          }
        }
      ],

      // R√©partition par heure de commande
      "par_heure": [
        {
          $bucket: {
            groupBy: { $hour: "$date" },
            boundaries: [0, 6, 12, 18, 24],
            output: {
              "nombre_commandes": { $sum: 1 },
              "ca": { $sum: "$montant" }
            }
          }
        },
        {
          $addFields: {
            "periode": {
              $switch: {
                branches: [
                  { case: { $eq: ["$_id", 0] }, then: "Nuit" },
                  { case: { $eq: ["$_id", 6] }, then: "Matin" },
                  { case: { $eq: ["$_id", 12] }, then: "Apr√®s-midi" },
                  { case: { $eq: ["$_id", 18] }, then: "Soir√©e" }
                ]
              }
            }
          }
        }
      ]
    }
  }
])
```

---

## Histogrammes pour Visualisation

### Cr√©er des Donn√©es pour un Graphique

```javascript
db.reponses_questionnaire.aggregate([
  {
    $bucket: {
      groupBy: "$score",
      boundaries: [0, 2, 4, 6, 8, 10],
      output: {
        "nombre": { $sum: 1 }
      }
    }
  },
  {
    $project: {
      _id: 0,
      "label": {
        $concat: [
          { $toString: "$_id" },
          "-",
          { $toString: { $add: ["$_id", 2] } }
        ]
      },
      "value": "$nombre"
    }
  }
])
```

**R√©sultat (pr√™t pour Chart.js, D3.js, etc.)** :
```json
[
  { "label": "0-2", "value": 5 },
  { "label": "2-4", "value": 12 },
  { "label": "4-6", "value": 18 },
  { "label": "6-8", "value": 15 },
  { "label": "8-10", "value": 8 }
]
```

---

## Bonnes Pratiques

### 1. Choisir le Bon Nombre de Tranches

```javascript
// ‚ùå Trop peu de tranches (perte d'information)
{ $bucketAuto: { groupBy: "$prix", buckets: 2 } }

// ‚ùå Trop de tranches (bruit, difficile √† lire)
{ $bucketAuto: { groupBy: "$prix", buckets: 50 } }

// ‚úÖ Juste milieu (selon le contexte)
{ $bucketAuto: { groupBy: "$prix", buckets: 5-10 } }
```

**R√®gle g√©n√©rale** :
- **5-10 tranches** : Bon pour la plupart des visualisations
- **3-5 tranches** : Cat√©gorisation simple (petit/moyen/grand)
- **10-20 tranches** : Analyses d√©taill√©es

### 2. D√©finir des Limites M√©tier Coh√©rentes

```javascript
// ‚úÖ Limites qui ont du sens m√©tier
{
  $bucket: {
    groupBy: "$age",
    boundaries: [0, 18, 25, 35, 50, 65, 100],  // Tranches d'√¢ge standard
  }
}

// ‚ùå Limites arbitraires
{
  $bucket: {
    groupBy: "$age",
    boundaries: [0, 17, 23, 39, 54, 68, 100],  // Difficiles √† interpr√©ter
  }
}
```

### 3. Toujours Sp√©cifier `default` pour $bucket

```javascript
// ‚úÖ Bon : G√®re les valeurs hors limites
{
  $bucket: {
    groupBy: "$prix",
    boundaries: [0, 50, 100, 200],
    default: "Hors cat√©gorie"  // Pour prix >= 200
  }
}

// ‚ùå Risqu√© : Les valeurs >= 200 sont perdues
{
  $bucket: {
    groupBy: "$prix",
    boundaries: [0, 50, 100, 200]
    // Pas de default
  }
}
```

### 4. Filtrer Avant de Bucketer

```javascript
// ‚úÖ Bon : Filtrer d'abord
db.produits.aggregate([
  {
    $match: {
      categorie: "√âlectronique",
      stock: { $gt: 0 }
    }
  },
  {
    $bucket: { /* ... */ }
  }
])

// ‚ùå Moins efficace : Bucketer puis filtrer
db.produits.aggregate([
  {
    $bucket: { /* ... */ }
  },
  {
    $match: { /* ... */ }  // Trop tard
  }
])
```

### 5. Utiliser granularity pour la Lisibilit√©

```javascript
// ‚úÖ Limites lisibles avec granularity
{
  $bucketAuto: {
    groupBy: "$prix",
    buckets: 5,
    granularity: "R10"  // Limites: 10, 20, 50, 100...
  }
}

// ‚ö†Ô∏è Sans granularity : limites moins lisibles
{
  $bucketAuto: {
    groupBy: "$prix",
    buckets: 5
    // Limites possibles: 9.73, 47.28, 98.45...
  }
}
```

---

## Comparaison avec $group

### $group : Regroupement Exact

```javascript
// Groupe par valeur exacte
{
  $group: {
    _id: "$categorie",  // "√âlectronique", "Mobilier", etc.
    nombre: { $sum: 1 }
  }
}
```

### $bucket : Regroupement par Intervalle

```javascript
// Groupe par tranche de valeurs
{
  $bucket: {
    groupBy: "$prix",
    boundaries: [0, 50, 100, 200],  // Tranches de prix
    output: { nombre: { $sum: 1 } }
  }
}
```

### Quand Utiliser Chacun ?

| Situation | Op√©rateur |
|-----------|-----------|
| Valeurs discr√®tes (cat√©gories, statuts) | ‚úÖ `$group` |
| Valeurs num√©riques continues (prix, √¢ge) | ‚úÖ `$bucket` / `$bucketAuto` |
| Distribution statistique, histogramme | ‚úÖ `$bucket` / `$bucketAuto` |
| Nombre exact de groupes souhait√© | ‚ö†Ô∏è `$bucketAuto` |
| Limites m√©tier pr√©d√©finies | ‚úÖ `$bucket` |

---

## Performances

### Impact

- `$bucket` et `$bucketAuto` sont **relativement efficaces**
- N√©cessitent un **scan complet** des documents filtr√©s
- `$bucketAuto` est l√©g√®rement plus co√ªteux (calcul des limites)

### Optimisations

1. **Indexer le champ groupBy** :
```javascript
db.produits.createIndex({ prix: 1 })
```

2. **Filtrer avant** avec `$match` :
```javascript
db.produits.aggregate([
  { $match: { stock: { $gt: 0 } } },  // R√©duire le volume
  { $bucket: { /* ... */ } }
])
```

3. **Projeter uniquement les champs n√©cessaires** :
```javascript
db.produits.aggregate([
  { $project: { prix: 1, nom: 1 } },  // Seulement ce qui est n√©cessaire
  { $bucket: { /* ... */ } }
])
```

---

## Exemple Complet : Dashboard Analytique

```javascript
// Insertion de donn√©es de ventes
db.ventes.insertMany([
  {
    _id: 1,
    date: ISODate("2024-01-15T10:30:00Z"),
    montant: 450,
    produits_count: 3,
    client_age: 28,
    region: "Europe"
  },
  {
    _id: 2,
    date: ISODate("2024-01-16T14:20:00Z"),
    montant: 120,
    produits_count: 1,
    client_age: 42,
    region: "Am√©rique"
  },
  {
    _id: 3,
    date: ISODate("2024-01-17T09:15:00Z"),
    montant: 890,
    produits_count: 5,
    client_age: 35,
    region: "Europe"
  },
  {
    _id: 4,
    date: ISODate("2024-01-18T16:45:00Z"),
    montant: 220,
    produits_count: 2,
    client_age: 19,
    region: "Asie"
  },
  {
    _id: 5,
    date: ISODate("2024-01-19T11:00:00Z"),
    montant: 75,
    produits_count: 1,
    client_age: 67,
    region: "Europe"
  }
])

// Dashboard complet avec analyses multiples
db.ventes.aggregate([
  {
    $facet: {
      // Analyse 1 : Distribution par montant
      "distribution_montants": [
        {
          $bucket: {
            groupBy: "$montant",
            boundaries: [0, 100, 250, 500, 1000],
            default: "Premium",
            output: {
              "nombre_ventes": { $sum: 1 },
              "ca_total": { $sum: "$montant" },
              "panier_moyen": { $avg: "$montant" }
            }
          }
        },
        {
          $project: {
            tranche: "$_id",
            nombre_ventes: 1,
            ca_total: { $round: ["$ca_total", 2] },
            panier_moyen: { $round: ["$panier_moyen", 2] },
            _id: 0
          }
        }
      ],

      // Analyse 2 : Segmentation par √¢ge des clients
      "segments_age": [
        {
          $bucket: {
            groupBy: "$client_age",
            boundaries: [0, 25, 35, 50, 100],
            output: {
              "nombre_clients": { $sum: 1 },
              "ca_total": { $sum: "$montant" },
              "age_moyen": { $avg: "$client_age" }
            }
          }
        },
        {
          $addFields: {
            "segment": {
              $switch: {
                branches: [
                  { case: { $eq: ["$_id", 0] }, then: "18-25 ans" },
                  { case: { $eq: ["$_id", 25] }, then: "25-35 ans" },
                  { case: { $eq: ["$_id", 35] }, then: "35-50 ans" },
                  { case: { $eq: ["$_id", 50] }, then: "50+ ans" }
                ]
              }
            }
          }
        }
      ],

      // Analyse 3 : Taille de panier automatique
      "taille_panier": [
        {
          $bucketAuto: {
            groupBy: "$produits_count",
            buckets: 3,
            output: {
              "nombre_commandes": { $sum: 1 },
              "ca_moyen": { $avg: "$montant" }
            }
          }
        }
      ],

      // Analyse 4 : Heures de pic
      "heures_achat": [
        {
          $bucket: {
            groupBy: { $hour: "$date" },
            boundaries: [0, 6, 12, 18, 24],
            output: {
              "nombre_ventes": { $sum: 1 },
              "ca": { $sum: "$montant" }
            }
          }
        },
        {
          $addFields: {
            "periode_journee": {
              $switch: {
                branches: [
                  { case: { $eq: ["$_id", 0] }, then: "Nuit (0h-6h)" },
                  { case: { $eq: ["$_id", 6] }, then: "Matin (6h-12h)" },
                  { case: { $eq: ["$_id", 12] }, then: "Apr√®s-midi (12h-18h)" },
                  { case: { $eq: ["$_id", 18] }, then: "Soir√©e (18h-24h)" }
                ]
              }
            }
          }
        }
      ]
    }
  }
])
```

**R√©sultat Structur√©** :
```json
{
  "distribution_montants": [
    { "tranche": 0, "nombre_ventes": 2, "ca_total": 195, "panier_moyen": 97.5 },
    { "tranche": 100, "nombre_ventes": 1, "ca_total": 120, "panier_moyen": 120 },
    { "tranche": 250, "nombre_ventes": 1, "ca_total": 450, "panier_moyen": 450 },
    { "tranche": 500, "nombre_ventes": 1, "ca_total": 890, "panier_moyen": 890 }
  ],
  "segments_age": [
    { "_id": 0, "segment": "18-25 ans", "nombre_clients": 1, "ca_total": 220, "age_moyen": 19 },
    { "_id": 25, "segment": "25-35 ans", "nombre_clients": 2, "ca_total": 1340, "age_moyen": 31.5 },
    { "_id": 35, "segment": "35-50 ans", "nombre_clients": 1, "ca_total": 120, "age_moyen": 42 },
    { "_id": 50, "segment": "50+ ans", "nombre_clients": 1, "ca_total": 75, "age_moyen": 67 }
  ],
  "taille_panier": [
    { "_id": { "min": 1, "max": 2 }, "nombre_commandes": 2, "ca_moyen": 97.5 },
    { "_id": { "min": 2, "max": 3 }, "nombre_commandes": 1, "ca_moyen": 220 },
    { "_id": { "min": 3, "max": 5 }, "nombre_commandes": 2, "ca_moyen": 670 }
  ],
  "heures_achat": [
    { "_id": 6, "periode_journee": "Matin (6h-12h)", "nombre_ventes": 2, "ca": 965 },
    { "_id": 12, "periode_journee": "Apr√®s-midi (12h-18h)", "nombre_ventes": 3, "ca": 790 }
  ]
}
```

---

## R√©sum√©

### Points Cl√©s

| Aspect | $bucket | $bucketAuto |
|--------|---------|-------------|
| **Fonction** | Regroupe en tranches avec limites d√©finies | Regroupe en tranches calcul√©es automatiquement |
| **Limites** | Manuelles (boundaries) | Automatiques (nombre de tranches) |
| **Format _id** | Valeur simple (limite inf) | Objet `{min, max}` |
| **Contr√¥le** | ‚úÖ Total | ‚ö†Ô∏è Limit√© |
| **Simplicit√©** | ‚ö†Ô∏è N√©cessite connaissance | ‚úÖ Facile |
| **Usage** | Cat√©gories m√©tier, comparaisons | Exploration, r√©partition √©quilibr√©e |

### Quand Utiliser $bucket / $bucketAuto

‚úÖ **Utilisez $bucket** pour :
- Cat√©gories m√©tier pr√©d√©finies (tranches d'√¢ge, prix)
- Comparaisons temporelles (m√™mes tranches)
- Limites pr√©cises et significatives
- Histogrammes avec axes fixes

‚úÖ **Utilisez $bucketAuto** pour :
- Exploration de donn√©es inconnues
- R√©partition √©quilibr√©e automatique
- Analyses ad-hoc
- Quand la distribution change souvent

### Applications Principales

1. **Histogrammes** et distributions statistiques
2. **Segmentation client** (√¢ge, revenu, comportement)
3. **Gammes de produits** (entr√©e/milieu/haut de gamme)
4. **Analyses de performance** (temps de r√©ponse, scores)
5. **Visualisations** (graphiques, charts)

---

## Conclusion

`$bucket` et `$bucketAuto` sont des outils **puissants** pour cr√©er des cat√©gories et analyser des distributions de valeurs num√©riques. Ils transforment des donn√©es continues en tranches discr√®tes, facilitant ainsi l'analyse, la visualisation et la compr√©hension des donn√©es.

### √Ä Retenir

1. **$bucket** n√©cessite des **limites manuelles** pr√©cises
2. **$bucketAuto** calcule les limites **automatiquement**
3. Les tranches sont **inclusives √† gauche, exclusives √† droite** : `[min, max)`
4. Utilisez `default` pour g√©rer les **valeurs hors limites**
5. `granularity` arrondit les limites pour plus de **lisibilit√©**
6. Parfait pour cr√©er des **histogrammes** et **segmentations**
7. Combinez avec **$facet** pour analyses multiples

### Prochaines √âtapes

Dans les sections suivantes, nous explorerons :
- **$graphLookup** : Requ√™tes r√©cursives pour structures hi√©rarchiques
- **$merge et $out** : √âcrire les r√©sultats dans des collections
- **Optimisation des pipelines** : Techniques avanc√©es de performance

---

**üìö R√©f√©rences**

- [Documentation officielle $bucket](https://www.mongodb.com/docs/manual/reference/operator/aggregation/bucket/)
- [Documentation officielle $bucketAuto](https://www.mongodb.com/docs/manual/reference/operator/aggregation/bucketAuto/)
- [S√©ries de Renard (granularity)](https://en.wikipedia.org/wiki/Renard_series)
- [Aggregation Pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/)

‚è≠Ô∏è [$graphLookup](/06-framework-agregation/04.07-graphlookup.md)
