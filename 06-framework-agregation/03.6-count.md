üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.6 $count - Compter les Documents

## Introduction

L'√©tape `$count` permet de **compter le nombre de documents** qui passent √† travers cette √©tape du pipeline d'agr√©gation. C'est l'√©quivalent d'un compteur qui vous dit "combien de documents sont arriv√©s jusqu'ici".

Pensez √† `$count` comme un **compteur automatique** qui note le nombre de documents qui franchissent ce point du pipeline et retourne ce nombre dans un champ que vous nommez.

## √Ä Quoi Sert $count ?

### 1. **Compter les R√©sultats**
Conna√Ætre le nombre exact de documents qui correspondent √† vos crit√®res.

### 2. **Statistiques Rapides**
Obtenir rapidement des m√©triques sur vos donn√©es.

### 3. **V√©rification**
Valider le volume de donn√©es avant un traitement co√ªteux.

### 4. **M√©tadonn√©es**
Fournir des informations de pagination (nombre total de pages).

## Syntaxe de Base

```javascript
{
  $count: "<nomDuChamp>"
}
```

**Param√®tre** :
- `nomDuChamp` : Le nom du champ qui contiendra le compte (sous forme de cha√Æne)

**R√©sultat** :
L'√©tape `$count` retourne **un seul document** avec le champ sp√©cifi√© contenant le nombre de documents compt√©s.

## Exemples Progressifs

### Exemple 1 : Compter Tous les Documents

```javascript
// Collection: produits
{ "_id": 1, "nom": "Laptop", "prix": 1200 }
{ "_id": 2, "nom": "Souris", "prix": 25 }
{ "_id": 3, "nom": "Clavier", "prix": 45 }
{ "_id": 4, "nom": "√âcran", "prix": 250 }
{ "_id": 5, "nom": "Webcam", "prix": 80 }
```

Compter tous les produits :

```javascript
db.produits.aggregate([
  {
    $count: "totalProduits"
  }
])
```

**R√©sultat** :
```javascript
[
  { "totalProduits": 5 }
]
```

**Note** : Le r√©sultat est toujours un tableau contenant un seul document avec le champ sp√©cifi√©.

### Exemple 2 : Compter Apr√®s un Filtrage

Compter uniquement les produits chers (> 100‚Ç¨) :

```javascript
db.produits.aggregate([
  {
    $match: {
      prix: { $gt: 100 }
    }
  },
  {
    $count: "produitsChers"
  }
])
```

**R√©sultat** :
```javascript
[
  { "produitsChers": 3 }
]
// Laptop (1200), √âcran (250), et un autre > 100
```

### Exemple 3 : Compter Apr√®s un Groupement

Compter le nombre de cat√©gories distinctes :

```javascript
// Collection: produits avec cat√©gories
{ "_id": 1, "nom": "Laptop", "categorie": "√âlectronique" }
{ "_id": 2, "nom": "Souris", "categorie": "√âlectronique" }
{ "_id": 3, "nom": "Chaise", "categorie": "Meuble" }
{ "_id": 4, "nom": "Bureau", "categorie": "Meuble" }
{ "_id": 5, "nom": "Lampe", "categorie": "√âclairage" }
```

```javascript
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie"    // Grouper par cat√©gorie
    }
  },
  {
    $count: "nombreCategories"    // Compter les groupes
  }
])
```

**R√©sultat** :
```javascript
[
  { "nombreCategories": 3 }
]
// 3 cat√©gories : √âlectronique, Meuble, √âclairage
```

### Exemple 4 : Compter les Commandes par Statut

```javascript
// Compter les commandes valid√©es
db.commandes.aggregate([
  {
    $match: {
      statut: "valid√©e",
      date: { $gte: ISODate("2024-01-01") }
    }
  },
  {
    $count: "commandesValidees2024"
  }
])
```

**R√©sultat** :
```javascript
[
  { "commandesValidees2024": 1247 }
]
```

### Exemple 5 : Compter les Documents Uniques

Compter le nombre de clients uniques ayant pass√© commande :

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client"    // Regrouper par client (d√©duplique)
    }
  },
  {
    $count: "clientsUniques"    // Compter les clients uniques
  }
])
```

**R√©sultat** :
```javascript
[
  { "clientsUniques": 342 }
]
```

### Exemple 6 : Compter Apr√®s Plusieurs Transformations

```javascript
db.ventes.aggregate([
  {
    // 1. Filtrer l'ann√©e 2024
    $match: {
      date: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      }
    }
  },
  {
    // 2. Grouper par produit
    $group: {
      _id: "$produit",
      quantiteTotale: { $sum: "$quantite" }
    }
  },
  {
    // 3. Ne garder que les produits avec > 100 ventes
    $match: {
      quantiteTotale: { $gt: 100 }
    }
  },
  {
    // 4. Compter combien de produits r√©pondent au crit√®re
    $count: "produitsBestSellers"
  }
])
```

**R√©sultat** :
```javascript
[
  { "produitsBestSellers": 23 }
]
// 23 produits ont √©t√© vendus plus de 100 fois en 2024
```

## $count vs countDocuments() vs estimatedDocumentCount()

MongoDB offre plusieurs fa√ßons de compter des documents. Comprendre leurs diff√©rences est important.

### 1. $count (dans aggregate)

```javascript
db.collection.aggregate([
  { $match: { statut: "actif" } },
  { $count: "total" }
])
```

**Caract√©ristiques** :
- ‚úÖ Partie d'un pipeline d'agr√©gation
- ‚úÖ Peut compter apr√®s des transformations
- ‚úÖ Compte pr√©cis
- ‚úÖ Respecte les filtres du pipeline
- ‚è±Ô∏è Performance : d√©pend du pipeline

### 2. countDocuments()

```javascript
db.collection.countDocuments({ statut: "actif" })
```

**Caract√©ristiques** :
- ‚úÖ Compte pr√©cis avec filtre
- ‚úÖ Utilise les index
- ‚úÖ Plus simple pour un simple comptage
- ‚è±Ô∏è Performance : bonne avec index
- ‚ùå Ne fait pas partie d'un pipeline

### 3. estimatedDocumentCount()

```javascript
db.collection.estimatedDocumentCount()
```

**Caract√©ristiques** :
- ‚ö° Tr√®s rapide (utilise les m√©tadonn√©es)
- ‚ùå Estimation, pas pr√©cis
- ‚ùå Compte TOUTE la collection (pas de filtre)
- ‚úÖ Utile pour des approximations
- ‚è±Ô∏è Performance : excellent (O(1))

### Comparaison

| M√©thode | Pr√©cision | Filtre | Vitesse | Cas d'usage |
|---------|-----------|--------|---------|-------------|
| `$count` | ‚úÖ Exacte | ‚úÖ Oui | ‚è±Ô∏è Moyenne | Dans un pipeline |
| `countDocuments()` | ‚úÖ Exacte | ‚úÖ Oui | ‚ö° Rapide | Comptage simple |
| `estimatedDocumentCount()` | ‚ö†Ô∏è Estimation | ‚ùå Non | ‚ö°‚ö° Tr√®s rapide | Approximation |

### Exemples Comparatifs

```javascript
// 1. Avec $count (dans un pipeline)
db.produits.aggregate([
  { $match: { prix: { $gt: 100 } } },
  { $count: "total" }
])
// R√©sultat : [{ "total": 156 }]

// 2. Avec countDocuments() (m√©thode simple)
db.produits.countDocuments({ prix: { $gt: 100 } })
// R√©sultat : 156

// 3. Avec estimatedDocumentCount() (approximation)
db.produits.estimatedDocumentCount()
// R√©sultat : ~1000 (approximatif, toute la collection)
```

### Quand Utiliser Quoi ?

```javascript
// ‚úÖ Utilisez $count quand :
// - Vous avez d√©j√† un pipeline d'agr√©gation
// - Vous comptez apr√®s des transformations ($group, $project, etc.)
db.ventes.aggregate([
  { $group: { _id: "$categorie" } },
  { $count: "nombreCategories" }
])

// ‚úÖ Utilisez countDocuments() quand :
// - Vous voulez juste compter avec un filtre simple
// - Pas besoin d'un pipeline complet
const count = await db.commandes.countDocuments({
  statut: "valid√©e",
  date: { $gte: startDate }
})

// ‚úÖ Utilisez estimatedDocumentCount() quand :
// - Vous avez besoin d'une estimation rapide
// - La pr√©cision n'est pas critique
// - Vous comptez toute la collection
const approx = await db.logs.estimatedDocumentCount()
```

## Cas d'Usage Pratiques

### 1. Nombre Total pour la Pagination

```javascript
// Obtenir le nombre total pour calculer les pages
db.produits.aggregate([
  {
    $match: { categorie: "√âlectronique", stock: { $gt: 0 } }
  },
  {
    $count: "totalProduits"
  }
])
// R√©sultat : [{ "totalProduits": 342 }]
// Calcul : totalPages = Math.ceil(342 / itemsParPage)
```

### 2. Statistiques par Cat√©gorie

```javascript
// Compter les produits dans chaque cat√©gorie
db.produits.aggregate([
  {
    $group: {
      _id: "$categorie",
      nombreProduits: { $sum: 1 }    // Compter dans chaque groupe
    }
  },
  {
    $sort: { nombreProduits: -1 }
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": "√âlectronique", "nombreProduits": 245 },
  { "_id": "Meuble", "nombreProduits": 123 },
  { "_id": "V√™tements", "nombreProduits": 98 }
]
```

**Note** : Ici on utilise `{ $sum: 1 }` dans `$group`, pas `$count`, car on compte par groupe.

### 3. Dashboard - Compteurs Multiples avec $facet

Obtenir plusieurs compteurs en une seule requ√™te :

```javascript
db.commandes.aggregate([
  {
    $facet: {
      // Compteur 1 : Total des commandes
      total: [
        { $count: "nombre" }
      ],

      // Compteur 2 : Commandes valid√©es
      validees: [
        { $match: { statut: "valid√©e" } },
        { $count: "nombre" }
      ],

      // Compteur 3 : Commandes en attente
      enAttente: [
        { $match: { statut: "en attente" } },
        { $count: "nombre" }
      ],

      // Compteur 4 : Commandes du jour
      aujourdHui: [
        {
          $match: {
            date: {
              $gte: new Date(new Date().setHours(0, 0, 0, 0))
            }
          }
        },
        { $count: "nombre" }
      ]
    }
  },
  {
    $project: {
      total: { $arrayElemAt: ["$total.nombre", 0] },
      validees: { $arrayElemAt: ["$validees.nombre", 0] },
      enAttente: { $arrayElemAt: ["$enAttente.nombre", 0] },
      aujourdHui: { $arrayElemAt: ["$aujourdHui.nombre", 0] }
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "total": 5634,
    "validees": 4521,
    "enAttente": 892,
    "aujourdHui": 47
  }
]
```

### 4. V√©rification de Volume Avant Traitement

```javascript
// V√©rifier le volume avant un traitement co√ªteux
const volumeCheck = await db.transactions.aggregate([
  {
    $match: {
      date: { $gte: startDate, $lt: endDate },
      statut: "√† traiter"
    }
  },
  {
    $count: "volumeATraiter"
  }
]).toArray();

const volume = volumeCheck[0]?.volumeATraiter || 0;

if (volume > 10000) {
  console.log(`Volume important : ${volume} documents. Utiliser le traitement par lots.`);
} else {
  console.log(`Volume acceptable : ${volume} documents. Traitement direct.`);
}
```

### 5. Compter les R√©sultats de Recherche

```javascript
// Recherche de produits avec comptage
db.produits.aggregate([
  {
    $match: {
      $text: { $search: "ordinateur portable" }
    }
  },
  {
    $count: "resultatsRecherche"
  }
])
```

**R√©sultat** :
```javascript
[
  { "resultatsRecherche": 47 }
]
```

### 6. Alertes Bas√©es sur des Seuils

```javascript
// V√©rifier si le stock est bas pour beaucoup de produits
const alerteStock = await db.produits.aggregate([
  {
    $match: {
      stock: { $lt: 10, $gt: 0 }    // Stock faible mais pas z√©ro
    }
  },
  {
    $count: "produitsStockFaible"
  }
]).toArray();

const nombre = alerteStock[0]?.produitsStockFaible || 0;

if (nombre > 50) {
  console.log(`‚ö†Ô∏è ALERTE : ${nombre} produits ont un stock faible !`);
}
```

## Performances et Optimisations

### 1. $count Utilise les Index

Si votre pipeline utilise `$match` avec des champs index√©s, `$count` b√©n√©ficie de ces index :

```javascript
// Cr√©er un index
db.commandes.createIndex({ statut: 1, date: -1 })

// Ce count utilisera l'index
db.commandes.aggregate([
  {
    $match: {
      statut: "valid√©e",
      date: { $gte: ISODate("2024-01-01") }
    }
  },
  {
    $count: "total"
  }
])
```

V√©rifiez avec `explain()` :

```javascript
db.commandes.aggregate([
  { $match: { statut: "valid√©e" } },
  { $count: "total" }
], { explain: true })
```

Cherchez `"IXSCAN"` dans la sortie pour confirmer l'utilisation d'index.

### 2. Position de $count dans le Pipeline

`$count` doit √™tre plac√© **apr√®s** toutes les transformations et filtres :

```javascript
// ‚úÖ CORRECT : Count √† la fin
db.collection.aggregate([
  { $match: { /* filtre */ } },
  { $group: { /* groupement */ } },
  { $match: { /* filtre post-group */ } },
  { $count: "total" }    // √Ä la fin
])
```

**Logique** : `$count` compte les documents qui arrivent √† cette √©tape, donc il doit √™tre apr√®s tous les filtres et transformations.

### 3. √âviter $count sur √ânormes Collections Sans Filtre

```javascript
// ‚ö†Ô∏è LENT : Compter toute une √©norme collection
db.hugeCollection.aggregate([
  { $count: "total" }
])

// ‚úÖ MIEUX : Utiliser estimatedDocumentCount()
db.hugeCollection.estimatedDocumentCount()

// ‚úÖ OU : Ajouter des filtres
db.hugeCollection.aggregate([
  { $match: { date: { $gte: recentDate } } },
  { $count: "total" }
])
```

### 4. Compter vs Retourner Tous les Documents

Si vous avez besoin du compte ET des documents, ne faites pas deux requ√™tes :

```javascript
// ‚ùå INEFFICACE : Deux requ√™tes
const count = await db.produits.countDocuments({ categorie: "√âlectronique" });
const products = await db.produits.find({ categorie: "√âlectronique" }).toArray();

// ‚úÖ EFFICACE : Une seule requ√™te avec $facet
db.produits.aggregate([
  { $match: { categorie: "√âlectronique" } },
  {
    $facet: {
      data: [
        { $sort: { prix: 1 } },
        { $skip: 0 },
        { $limit: 20 }
      ],
      count: [
        { $count: "total" }
      ]
    }
  }
])
```

## Utilisation de $count avec d'Autres √âtapes

### Avec $match (Filtrage)

```javascript
db.utilisateurs.aggregate([
  {
    $match: {
      actif: true,
      dernierLogin: { $gte: ISODate("2024-01-01") }
    }
  },
  {
    $count: "utilisateursActifs2024"
  }
])
```

### Avec $group (Comptage par Groupe)

```javascript
// Attention : avec $group, on utilise $sum: 1, pas $count
db.ventes.aggregate([
  {
    $group: {
      _id: "$vendeur",
      nombreVentes: { $sum: 1 }    // Compter dans chaque groupe
    }
  }
])

// Si vous voulez compter le nombre de vendeurs :
db.ventes.aggregate([
  {
    $group: {
      _id: "$vendeur",
      nombreVentes: { $sum: 1 }
    }
  },
  {
    $count: "nombreVendeurs"    // Compter les groupes
  }
])
```

### Avec $unwind (D√©pliage de Tableaux)

```javascript
// Collection avec tableaux
{ "_id": 1, "tags": ["A", "B", "C"] }
{ "_id": 2, "tags": ["A", "D"] }
{ "_id": 3, "tags": ["B", "C", "E"] }

// Compter le nombre total de tags (avec doublons)
db.articles.aggregate([
  { $unwind: "$tags" },
  { $count: "totalTags" }
])
// R√©sultat : [{ "totalTags": 8 }]  // 3 + 2 + 3 = 8

// Compter les tags uniques
db.articles.aggregate([
  { $unwind: "$tags" },
  { $group: { _id: "$tags" } },
  { $count: "tagsUniques" }
])
// R√©sultat : [{ "tagsUniques": 5 }]  // A, B, C, D, E
```

### Avec $lookup (Jointures)

```javascript
// Compter les commandes avec au moins un produit en rupture
db.commandes.aggregate([
  {
    $lookup: {
      from: "produits",
      localField: "produitId",
      foreignField: "_id",
      as: "produitInfo"
    }
  },
  {
    $unwind: "$produitInfo"
  },
  {
    $match: {
      "produitInfo.stock": 0
    }
  },
  {
    $count: "commandesAvecRupture"
  }
])
```

## Pi√®ges Courants √† √âviter

### 1. Confusion entre $count et $sum

```javascript
// ‚ùå ERREUR : Utiliser $count dans $group
db.collection.aggregate([
  {
    $group: {
      _id: "$categorie",
      nombre: { $count: {} }    // $count n'existe pas comme accumulateur !
    }
  }
])

// ‚úÖ CORRECT : Utiliser $sum: 1 dans $group
db.collection.aggregate([
  {
    $group: {
      _id: "$categorie",
      nombre: { $sum: 1 }    // Compteur dans $group
    }
  }
])

// ‚úÖ OU : Utiliser $count apr√®s $group
db.collection.aggregate([
  {
    $group: {
      _id: "$categorie"
    }
  },
  {
    $count: "nombreCategories"    // Compter les groupes
  }
])
```

### 2. Oublier que $count Retourne un Tableau

```javascript
// Le r√©sultat est toujours un tableau avec un document
const result = await db.collection.aggregate([
  { $match: { statut: "actif" } },
  { $count: "total" }
]).toArray();

// ‚ùå ERREUR : Acc√®s direct
console.log(result.total);    // undefined !

// ‚úÖ CORRECT : Acc√©der au premier √©l√©ment
console.log(result[0]?.total || 0);    // 0 si aucun r√©sultat
```

### 3. $count sur Collection Vide

```javascript
// Si aucun document ne correspond
db.produits.aggregate([
  { $match: { prix: { $gt: 1000000 } } },
  { $count: "total" }
])

// R√©sultat : []  (tableau vide, pas [{ total: 0 }])
```

**Solution** : Toujours g√©rer le cas du tableau vide :

```javascript
const result = await db.produits.aggregate([
  { $match: { prix: { $gt: 1000000 } } },
  { $count: "total" }
]).toArray();

const count = result[0]?.total || 0;    // 0 si aucun r√©sultat
```

### 4. Nommer le Champ avec un Mot R√©serv√©

```javascript
// ‚ö†Ô∏è ATTENTION : √âvitez les noms comme "count", "result", etc.
{ $count: "count" }    // Fonctionne mais peut cr√©er des confusions

// ‚úÖ MIEUX : Nom descriptif
{ $count: "totalDocuments" }
{ $count: "nombreProduits" }
```

## $count vs $sum: 1 dans $group

C'est une source fr√©quente de confusion. Voici la diff√©rence :

### $sum: 1 dans $group (Compteur par Groupe)

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      nombreCommandes: { $sum: 1 }    // Compte par groupe
    }
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": "Alice", "nombreCommandes": 12 },
  { "_id": "Bob", "nombreCommandes": 8 },
  { "_id": "Charlie", "nombreCommandes": 5 }
]
// Un document par groupe, chacun avec son compte
```

### $count (Compte Total)

```javascript
db.commandes.aggregate([
  {
    $group: {
      _id: "$client"
    }
  },
  {
    $count: "nombreClients"    // Compte les groupes
  }
])
```

**R√©sultat** :
```javascript
[
  { "nombreClients": 3 }
]
// Un seul document avec le nombre total de groupes
```

### R√©sum√©

| Op√©rateur | Usage | Sortie | Contexte |
|-----------|-------|--------|----------|
| `$sum: 1` | Compte par groupe | Multiple documents | Dans `$group` |
| `$count` | Compte total | Un document | √âtape du pipeline |

## Points Cl√©s √† Retenir

1. ‚úÖ **$count** retourne un **seul document** avec le compte
2. ‚úÖ Le r√©sultat est un **tableau** `[{ nomChamp: nombre }]`
3. ‚úÖ Utilisez **$sum: 1** dans `$group`, **$count** comme √©tape
4. ‚úÖ **$count** doit venir **apr√®s** les transformations
5. ‚úÖ B√©n√©ficie des **index** si utilis√© avec $match
6. ‚ö†Ô∏è Sur collection vide : retourne `[]` (pas `[{ total: 0 }]`)
7. ‚úÖ Pour plusieurs compteurs : utilisez **$facet**
8. üöÄ Pour estimation rapide : **estimatedDocumentCount()**

## Exemple Complet : Dashboard de Monitoring

```javascript
// Cr√©er un dashboard complet avec plusieurs m√©triques
db.transactions.aggregate([
  {
    // Filtrer les transactions du mois en cours
    $match: {
      date: {
        $gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
        $lt: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1)
      }
    }
  },
  {
    // Utiliser $facet pour obtenir plusieurs statistiques
    $facet: {
      // Statistique 1 : Nombre total de transactions
      totalTransactions: [
        { $count: "nombre" }
      ],

      // Statistique 2 : Transactions par type
      parType: [
        { $group: { _id: "$type", nombre: { $sum: 1 } } },
        { $sort: { nombre: -1 } }
      ],

      // Statistique 3 : Nombre de transactions r√©ussies
      reussies: [
        { $match: { statut: "r√©ussie" } },
        { $count: "nombre" }
      ],

      // Statistique 4 : Nombre de transactions √©chou√©es
      echouees: [
        { $match: { statut: "√©chou√©e" } },
        { $count: "nombre" }
      ],

      // Statistique 5 : Nombre de clients uniques
      clientsUniques: [
        { $group: { _id: "$client" } },
        { $count: "nombre" }
      ],

      // Statistique 6 : Volume moyen et total
      montants: [
        {
          $group: {
            _id: null,
            total: { $sum: "$montant" },
            moyenne: { $avg: "$montant" },
            max: { $max: "$montant" }
          }
        }
      ]
    }
  },
  {
    // Formater la sortie
    $project: {
      totalTransactions: { $arrayElemAt: ["$totalTransactions.nombre", 0] },
      transactionsReussies: { $arrayElemAt: ["$reussies.nombre", 0] },
      transactionsEchouees: { $arrayElemAt: ["$echouees.nombre", 0] },
      clientsUniques: { $arrayElemAt: ["$clientsUniques.nombre", 0] },
      tauxReussite: {
        $multiply: [
          {
            $divide: [
              { $arrayElemAt: ["$reussies.nombre", 0] },
              { $arrayElemAt: ["$totalTransactions.nombre", 0] }
            ]
          },
          100
        ]
      },
      montantTotal: { $arrayElemAt: ["$montants.total", 0] },
      montantMoyen: { $arrayElemAt: ["$montants.moyenne", 0] },
      montantMax: { $arrayElemAt: ["$montants.max", 0] },
      parType: "$parType"
    }
  }
])
```

**R√©sultat** :
```javascript
[
  {
    "totalTransactions": 15683,
    "transactionsReussies": 14892,
    "transactionsEchouees": 791,
    "clientsUniques": 3421,
    "tauxReussite": 94.96,
    "montantTotal": 2847569.50,
    "montantMoyen": 181.54,
    "montantMax": 9850.00,
    "parType": [
      { "_id": "paiement", "nombre": 12456 },
      { "_id": "remboursement", "nombre": 2134 },
      { "_id": "transfert", "nombre": 1093 }
    ]
  }
]
```

## Conclusion

L'op√©rateur `$count` est un outil **simple mais puissant** pour :

- üî¢ **Compter** les documents dans un pipeline
- üìä **Cr√©er** des statistiques et m√©triques
- üìÑ **Calculer** des m√©tadonn√©es de pagination
- ‚úÖ **V√©rifier** des volumes de donn√©es
- üìà **Construire** des dashboards

Bien que simple en apparence, `$count` est essentiel pour obtenir des insights quantitatifs sur vos donn√©es. Utilis√© avec `$facet`, il permet de cr√©er des dashboards complets en une seule requ√™te.

---


‚è≠Ô∏è [√âtapes avanc√©es](/06-framework-agregation/04-etapes-avancees.md)
