üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.4.1 $lookup (Jointures)

## Introduction

L'√©tape `$lookup` est l'une des fonctionnalit√©s les plus puissantes du framework d'agr√©gation MongoDB. Elle permet de r√©aliser des **jointures** entre collections, similaires aux `JOIN` en SQL, tout en respectant la philosophie orient√©e document de MongoDB.

### Pourquoi $lookup ?

Bien que MongoDB favorise l'**imbrication de documents** pour repr√©senter les relations, il existe des cas o√π la s√©paration des donn√©es en collections distinctes est pr√©f√©rable :

- **√âviter la duplication** : Donn√©es partag√©es par plusieurs entit√©s
- **Limiter la taille des documents** : Respecter la limite de 16 Mo
- **Faciliter les mises √† jour** : Modification d'une donn√©e √† un seul endroit
- **Normalisation s√©lective** : √âquilibre entre performance et maintenance

---

## Concept de Jointure dans MongoDB

Dans une base de donn√©es relationnelle, on utilise des `JOIN` pour combiner des lignes de plusieurs tables. Dans MongoDB, `$lookup` permet de combiner des documents de plusieurs collections.

### Exemple Conceptuel

Imaginons deux collections :

**Collection `commandes`** :
```json
{
  "_id": 1,
  "client_id": 101,
  "date": "2024-01-15",
  "total": 250.00
}
```

**Collection `clients`** :
```json
{
  "_id": 101,
  "nom": "Dupont",
  "email": "dupont@email.com"
}
```

Avec `$lookup`, nous pouvons **enrichir** chaque commande avec les informations du client correspondant.

---

## Syntaxe de Base

### Forme Simple (√âgalit√©)

La forme la plus courante de `$lookup` effectue une jointure bas√©e sur l'**√©galit√©** entre deux champs :

```javascript
{
  $lookup: {
    from: "<collection_√†_joindre>",
    localField: "<champ_local>",
    foreignField: "<champ_distant>",
    as: "<nom_du_tableau_r√©sultat>"
  }
}
```

#### Param√®tres

| Param√®tre | Description |
|-----------|-------------|
| `from` | Nom de la collection √† joindre (celle d'o√π proviennent les donn√©es √† ajouter) |
| `localField` | Champ de la collection courante utilis√© pour la jointure |
| `foreignField` | Champ de la collection distante utilis√© pour la jointure |
| `as` | Nom du nouveau champ (tableau) qui contiendra les documents joints |

### Comportement Important

- Le r√©sultat est **toujours un tableau**, m√™me s'il n'y a qu'un seul document correspondant
- Si aucun document ne correspond, le tableau est **vide** `[]`
- Les documents de la collection courante sont **pr√©serv√©s** (√©quivalent d'un LEFT JOIN)

---

## Exemple Pratique D√©taill√©

### Pr√©paration des Donn√©es

Cr√©ons deux collections pour illustrer `$lookup` :

```javascript
// Collection "clients"
db.clients.insertMany([
  {
    _id: 101,
    nom: "Dupont",
    prenom: "Jean",
    ville: "Paris"
  },
  {
    _id: 102,
    nom: "Martin",
    prenom: "Marie",
    ville: "Lyon"
  },
  {
    _id: 103,
    nom: "Durand",
    prenom: "Pierre",
    ville: "Marseille"
  }
])

// Collection "commandes"
db.commandes.insertMany([
  {
    _id: 1,
    client_id: 101,
    date: ISODate("2024-01-15"),
    montant: 250.00,
    statut: "livr√©e"
  },
  {
    _id: 2,
    client_id: 101,
    date: ISODate("2024-02-20"),
    montant: 180.00,
    statut: "en cours"
  },
  {
    _id: 3,
    client_id: 102,
    date: ISODate("2024-01-28"),
    montant: 420.00,
    statut: "livr√©e"
  },
  {
    _id: 4,
    client_id: 103,
    date: ISODate("2024-03-05"),
    montant: 95.00,
    statut: "livr√©e"
  }
])
```

### Application de $lookup

Enrichissons chaque commande avec les informations du client :

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",           // Collection √† joindre
      localField: "client_id",   // Champ dans "commandes"
      foreignField: "_id",       // Champ dans "clients"
      as: "infos_client"         // Nom du nouveau champ
    }
  }
])
```

### R√©sultat

```json
[
  {
    "_id": 1,
    "client_id": 101,
    "date": ISODate("2024-01-15"),
    "montant": 250.00,
    "statut": "livr√©e",
    "infos_client": [
      {
        "_id": 101,
        "nom": "Dupont",
        "prenom": "Jean",
        "ville": "Paris"
      }
    ]
  },
  {
    "_id": 2,
    "client_id": 101,
    "date": ISODate("2024-02-20"),
    "montant": 180.00,
    "statut": "en cours",
    "infos_client": [
      {
        "_id": 101,
        "nom": "Dupont",
        "prenom": "Jean",
        "ville": "Paris"
      }
    ]
  },
  // ... autres commandes
]
```

### Observations

1. **Tableau** : `infos_client` est un tableau contenant un document
2. **Document complet** : Toutes les informations du client sont incluses
3. **Pr√©servation** : Toutes les commandes sont pr√©sentes, m√™me sans correspondance

---

## D√©plier le R√©sultat avec $unwind

Souvent, apr√®s un `$lookup`, on souhaite "aplatir" le tableau r√©sultant, surtout quand on sait qu'il n'y a qu'un seul √©l√©ment.

### Exemple avec $unwind

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "infos_client"
    }
  },
  {
    $unwind: "$infos_client"  // D√©plier le tableau
  }
])
```

### R√©sultat Aplati

```json
{
  "_id": 1,
  "client_id": 101,
  "date": ISODate("2024-01-15"),
  "montant": 250.00,
  "statut": "livr√©e",
  "infos_client": {
    "_id": 101,
    "nom": "Dupont",
    "prenom": "Jean",
    "ville": "Paris"
  }
}
```

Maintenant, `infos_client` est un **objet** et non plus un tableau.

---

## Projeter des Champs Sp√©cifiques

Pour ne r√©cup√©rer que certains champs de la collection jointe et nettoyer le r√©sultat :

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "infos_client"
    }
  },
  {
    $unwind: "$infos_client"
  },
  {
    $project: {
      _id: 1,
      date: 1,
      montant: 1,
      statut: 1,
      "client_nom": "$infos_client.nom",
      "client_prenom": "$infos_client.prenom",
      "client_ville": "$infos_client.ville"
    }
  }
])
```

### R√©sultat

```json
{
  "_id": 1,
  "date": ISODate("2024-01-15"),
  "montant": 250.00,
  "statut": "livr√©e",
  "client_nom": "Dupont",
  "client_prenom": "Jean",
  "client_ville": "Paris"
}
```

---

## $lookup avec Pipeline (Forme Avanc√©e)

MongoDB permet une forme plus flexible de `$lookup` utilisant un **pipeline d'agr√©gation complet**.

### Syntaxe

```javascript
{
  $lookup: {
    from: "<collection>",
    let: { <variables_locales> },
    pipeline: [
      // √âtapes d'agr√©gation
    ],
    as: "<nom_du_r√©sultat>"
  }
}
```

### Avantages

- **Filtres complexes** : Conditions multiples, op√©rateurs avanc√©s
- **Transformations** : Manipulation des donn√©es jointes
- **Performance** : R√©duction des donn√©es transf√©r√©es

### Exemple : Jointure avec Condition Multiple

Imaginons que nous voulons joindre les commandes avec les clients, mais seulement pour les clients d'une ville sp√©cifique :

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      let: { commandeClientId: "$client_id" },  // Variable locale
      pipeline: [
        {
          $match: {
            $expr: {
              $and: [
                { $eq: ["$_id", "$$commandeClientId"] },  // Condition de jointure
                { $eq: ["$ville", "Paris"] }              // Condition suppl√©mentaire
              ]
            }
          }
        },
        {
          $project: {  // Projection dans le pipeline
            nom: 1,
            prenom: 1,
            ville: 1
          }
        }
      ],
      as: "infos_client"
    }
  }
])
```

#### Explications

- **`let`** : D√©finit des variables accessibles dans le pipeline (pr√©fix√©es par `$$`)
- **`$expr`** : Permet d'utiliser des expressions d'agr√©gation dans `$match`
- **`$$commandeClientId`** : Variable d√©finie dans `let`
- **Filtrage suppl√©mentaire** : Seuls les clients de Paris sont joints

---

## Cas d'Usage Courants

### 1. Relation One-to-One

**Exemple** : Un utilisateur a un profil

```javascript
db.utilisateurs.aggregate([
  {
    $lookup: {
      from: "profils",
      localField: "_id",
      foreignField: "utilisateur_id",
      as: "profil"
    }
  },
  {
    $unwind: {
      path: "$profil",
      preserveNullAndEmptyArrays: true  // Garder les utilisateurs sans profil
    }
  }
])
```

### 2. Relation One-to-Many

**Exemple** : Un client a plusieurs commandes

```javascript
db.clients.aggregate([
  {
    $lookup: {
      from: "commandes",
      localField: "_id",
      foreignField: "client_id",
      as: "historique_commandes"
    }
  }
])
```

Le r√©sultat contiendra un tableau de toutes les commandes pour chaque client.

### 3. Relation Many-to-Many

**Exemple** : √âtudiants et cours (via une table de liaison)

```javascript
db.etudiants.aggregate([
  {
    $lookup: {
      from: "inscriptions",
      localField: "_id",
      foreignField: "etudiant_id",
      as: "inscriptions"
    }
  },
  {
    $unwind: "$inscriptions"
  },
  {
    $lookup: {
      from: "cours",
      localField: "inscriptions.cours_id",
      foreignField: "_id",
      as: "cours_details"
    }
  }
])
```

---

## $lookup Multiple (Jointures en Cascade)

On peut effectuer plusieurs `$lookup` dans un m√™me pipeline :

```javascript
db.commandes.aggregate([
  // Premi√®re jointure : r√©cup√©rer le client
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "client"
    }
  },
  { $unwind: "$client" },

  // Deuxi√®me jointure : r√©cup√©rer les produits de la commande
  {
    $lookup: {
      from: "produits",
      localField: "produit_ids",
      foreignField: "_id",
      as: "produits"
    }
  },

  // Projection finale
  {
    $project: {
      date: 1,
      montant: 1,
      "client_nom": "$client.nom",
      "produits.nom": 1,
      "produits.prix": 1
    }
  }
])
```

---

## Performances et Bonnes Pratiques

### 1. Indexation

**Crucial** : Cr√©ez des index sur les champs utilis√©s dans la jointure.

```javascript
// Index sur le champ foreign
db.clients.createIndex({ _id: 1 })  // G√©n√©ralement d√©j√† index√©

// Index sur le champ local
db.commandes.createIndex({ client_id: 1 })
```

### 2. Filtrer Avant de Joindre

R√©duisez le volume de donn√©es **avant** le `$lookup` :

```javascript
db.commandes.aggregate([
  {
    $match: {
      date: { $gte: ISODate("2024-01-01") }  // Filtrer d'abord
    }
  },
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "client"
    }
  }
])
```

### 3. Projeter Uniquement les Champs N√©cessaires

Dans un pipeline `$lookup`, limitez les champs r√©cup√©r√©s :

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      let: { clientId: "$client_id" },
      pipeline: [
        {
          $match: {
            $expr: { $eq: ["$_id", "$$clientId"] }
          }
        },
        {
          $project: { nom: 1, email: 1 }  // Seulement les champs n√©cessaires
        }
      ],
      as: "client"
    }
  }
])
```

### 4. Limiter les Jointures en Cascade

Chaque `$lookup` suppl√©mentaire augmente la complexit√© et le temps d'ex√©cution. √âvaluez si une d√©normalisation partielle ne serait pas plus efficace.

### 5. Attention √† la Taille des R√©sultats

Rappelez-vous la **limite de 16 Mo par document**. Un `$lookup` qui retourne beaucoup de donn√©es peut d√©passer cette limite.

---

## $lookup vs Imbrication

### Quand Utiliser $lookup

‚úÖ **Bonne id√©e** :
- Donn√©es partag√©es par plusieurs collections
- Relation Many-to-Many
- Donn√©es volumineuses ou rarement consult√©es
- Mises √† jour fr√©quentes d'une entit√©

### Quand Imbriquer

‚úÖ **Pr√©f√©rable** :
- Donn√©es toujours consult√©es ensemble
- Relation One-to-One ou One-to-Few
- Performance critique en lecture
- Donn√©es rarement modifi√©es

---

## Limitations

### 1. Collection Shard√©e

- `$lookup` peut √™tre utilis√© sur des collections shard√©es (depuis MongoDB 5.1+)
- Performances peuvent √™tre impact√©es selon la configuration

### 2. Vues

- On ne peut pas faire de `$lookup` **vers** une collection qui n'existe pas
- On peut faire un `$lookup` **depuis** une vue

### 3. Transactions

- `$lookup` est support√© dans les transactions multi-documents

---

## Comparaison avec SQL

### SQL JOIN

```sql
SELECT c.*, cl.nom, cl.prenom
FROM commandes c
LEFT JOIN clients cl ON c.client_id = cl.id;
```

### MongoDB $lookup √âquivalent

```javascript
db.commandes.aggregate([
  {
    $lookup: {
      from: "clients",
      localField: "client_id",
      foreignField: "_id",
      as: "client"
    }
  },
  {
    $unwind: {
      path: "$client",
      preserveNullAndEmptyArrays: true  // LEFT JOIN
    }
  },
  {
    $project: {
      date: 1,
      montant: 1,
      statut: 1,
      "nom_client": "$client.nom",
      "prenom_client": "$client.prenom"
    }
  }
])
```

---

## R√©sum√©

### Points Cl√©s

| Aspect | Description |
|--------|-------------|
| **Objectif** | Combiner des documents de plusieurs collections |
| **R√©sultat** | Toujours un tableau dans le champ `as` |
| **Type de jointure** | LEFT JOIN par d√©faut (tous les documents de gauche sont pr√©serv√©s) |
| **Performance** | N√©cessite des index sur les champs de jointure |
| **Formes** | Simple (√©galit√©) ou pipeline (conditions complexes) |

### Sch√©ma de D√©cision

```
Ai-je besoin de joindre des collections ?
‚îú‚îÄ Non ‚Üí Utilisez l'imbrication
‚îî‚îÄ Oui
   ‚îú‚îÄ Relation simple (√©galit√©) ‚Üí $lookup simple
   ‚îú‚îÄ Conditions complexes ‚Üí $lookup avec pipeline
   ‚îú‚îÄ R√©sultat unique attendu ‚Üí Ajoutez $unwind
   ‚îî‚îÄ Performance critique ‚Üí √âvaluez la d√©normalisation
```

---

## Exemple Complet : Syst√®me de Blog

Cr√©ons un exemple complet avec des articles, auteurs et commentaires :

```javascript
// Donn√©es
db.auteurs.insertMany([
  { _id: 1, nom: "Alice", email: "alice@blog.com" },
  { _id: 2, nom: "Bob", email: "bob@blog.com" }
])

db.articles.insertMany([
  {
    _id: 101,
    titre: "Introduction √† MongoDB",
    auteur_id: 1,
    date: ISODate("2024-01-15"),
    contenu: "MongoDB est une base de donn√©es..."
  },
  {
    _id: 102,
    titre: "Les agr√©gations avanc√©es",
    auteur_id: 2,
    date: ISODate("2024-02-20"),
    contenu: "Le framework d'agr√©gation permet..."
  }
])

db.commentaires.insertMany([
  {
    _id: 201,
    article_id: 101,
    auteur: "Charlie",
    texte: "Excellent article !",
    date: ISODate("2024-01-16")
  },
  {
    _id: 202,
    article_id: 101,
    auteur: "Diana",
    texte: "Tr√®s instructif, merci !",
    date: ISODate("2024-01-17")
  },
  {
    _id: 203,
    article_id: 102,
    auteur: "Eve",
    texte: "Pourriez-vous approfondir $lookup ?",
    date: ISODate("2024-02-21")
  }
])

// Requ√™te : Articles avec auteur et commentaires
db.articles.aggregate([
  // Jointure avec les auteurs
  {
    $lookup: {
      from: "auteurs",
      localField: "auteur_id",
      foreignField: "_id",
      as: "auteur"
    }
  },
  { $unwind: "$auteur" },

  // Jointure avec les commentaires
  {
    $lookup: {
      from: "commentaires",
      localField: "_id",
      foreignField: "article_id",
      as: "commentaires"
    }
  },

  // Ajout du nombre de commentaires
  {
    $addFields: {
      nb_commentaires: { $size: "$commentaires" }
    }
  },

  // Projection finale
  {
    $project: {
      titre: 1,
      date: 1,
      "auteur.nom": 1,
      "auteur.email": 1,
      nb_commentaires: 1,
      "commentaires.auteur": 1,
      "commentaires.texte": 1,
      "commentaires.date": 1
    }
  },

  // Tri par date d√©croissante
  { $sort: { date: -1 } }
])
```

---

## Conclusion

L'op√©rateur `$lookup` est un outil essentiel du framework d'agr√©gation MongoDB. Il permet de r√©concilier la **flexibilit√© du mod√®le document** avec les **besoins de jointure** des applications complexes.

### √Ä Retenir

1. **$lookup** effectue des jointures entre collections (√©quivalent LEFT JOIN)
2. Le r√©sultat est toujours un **tableau** (utilisez `$unwind` pour l'aplatir)
3. **Indexez** les champs de jointure pour des performances optimales
4. Utilisez la forme **pipeline** pour des conditions complexes
5. **Filtrez avant** de joindre pour r√©duire le volume de donn√©es
6. Pr√©f√©rez l'**imbrication** quand possible pour de meilleures performances

### Prochaines √âtapes

Dans les sections suivantes, nous explorerons :
- **$unwind** : D√©plier les tableaux en d√©tail
- **$graphLookup** : Jointures r√©cursives pour les structures hi√©rarchiques
- **Optimisation des pipelines** : Techniques avanc√©es de performance

---

**üìö R√©f√©rences**

- [Documentation officielle $lookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/)
- [Pipeline Optimization](https://www.mongodb.com/docs/manual/core/aggregation-pipeline-optimization/)
- [Indexing Strategies](https://www.mongodb.com/docs/manual/applications/indexes/)

‚è≠Ô∏è [$unwind](/06-framework-agregation/04.02-unwind.md)
