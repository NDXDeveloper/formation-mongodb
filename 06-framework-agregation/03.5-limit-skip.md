üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.5 $limit et $skip - Contr√¥ler le Nombre de Documents

## Introduction

Les √©tapes `$limit` et `$skip` permettent de **contr√¥ler le nombre de documents** qui passent dans le pipeline d'agr√©gation. Ces op√©rateurs sont essentiels pour la pagination, l'affichage de r√©sultats limit√©s, et l'optimisation des performances.

Pensez √† `$limit` comme un **filtre quantitatif** qui dit "je ne veux que les N premiers", et √† `$skip` comme un **sauteur** qui dit "ignore les N premiers et commence apr√®s".

## √Ä Quoi Servent $limit et $skip ?

### $limit
- **Limiter** le nombre de r√©sultats
- Obtenir les **"top N"** (avec $sort)
- **Optimiser** les performances
- Cr√©er des **aper√ßus** de donn√©es

### $skip
- **Sauter** les premiers documents
- Impl√©menter la **pagination**
- Exclure des r√©sultats d√©j√† vus
- Naviguer dans de **grands ensembles de donn√©es**

### Ensemble ($skip + $limit)
- **Pagination compl√®te** (page 1, page 2, etc.)
- Navigation dans les r√©sultats
- Affichage par lots

## L'Op√©rateur $limit

### Syntaxe

```javascript
{
  $limit: <nombre_positif>
}
```

Le nombre doit √™tre un **entier positif**. `$limit` garde les N premiers documents et ignore tous les autres.

### Exemple 1 : Limiter √† 3 Documents

```javascript
// Collection: produits
{ "_id": 1, "nom": "Laptop", "prix": 1200 }
{ "_id": 2, "nom": "Souris", "prix": 25 }
{ "_id": 3, "nom": "Clavier", "prix": 45 }
{ "_id": 4, "nom": "√âcran", "prix": 250 }
{ "_id": 5, "nom": "Webcam", "prix": 80 }
```

Ne garder que les 3 premiers produits :

```javascript
db.produits.aggregate([
  {
    $limit: 3
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 1, "nom": "Laptop", "prix": 1200 },
  { "_id": 2, "nom": "Souris", "prix": 25 },
  { "_id": 3, "nom": "Clavier", "prix": 45 }
]
```

### Exemple 2 : Top 5 avec $sort et $limit

Obtenir les 5 produits les plus chers :

```javascript
db.produits.aggregate([
  {
    $sort: { prix: -1 }    // Trier par prix d√©croissant
  },
  {
    $limit: 5              // Garder les 5 premiers
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 1, "nom": "Laptop", "prix": 1200 },
  { "_id": 4, "nom": "√âcran", "prix": 250 },
  { "_id": 5, "nom": "Webcam", "prix": 80 },
  { "_id": 3, "nom": "Clavier", "prix": 45 },
  { "_id": 2, "nom": "Souris", "prix": 25 }
]
```

‚ö†Ô∏è **Important** : L'ordre **$sort puis $limit** est crucial pour obtenir les "top N".

### Exemple 3 : Limiter Apr√®s un Filtrage

```javascript
db.commandes.aggregate([
  {
    $match: {
      statut: "valid√©e",
      date: { $gte: ISODate("2024-01-01") }
    }
  },
  {
    $sort: { montant: -1 }
  },
  {
    $limit: 10    // Les 10 plus grosses commandes valid√©es de 2024
  }
])
```

### Exemple 4 : Limiter Apr√®s un Groupement

```javascript
db.ventes.aggregate([
  {
    $group: {
      _id: "$produit",
      totalVendu: { $sum: "$quantite" }
    }
  },
  {
    $sort: { totalVendu: -1 }
  },
  {
    $limit: 3    // Top 3 des produits les plus vendus
  }
])
```

## L'Op√©rateur $skip

### Syntaxe

```javascript
{
  $skip: <nombre_positif>
}
```

Le nombre doit √™tre un **entier positif ou z√©ro**. `$skip` ignore les N premiers documents et passe tous les suivants.

### Exemple 5 : Sauter les 2 Premiers Documents

```javascript
db.produits.aggregate([
  {
    $skip: 2    // Ignorer les 2 premiers
  }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 3, "nom": "Clavier", "prix": 45 },
  { "_id": 4, "nom": "√âcran", "prix": 250 },
  { "_id": 5, "nom": "Webcam", "prix": 80 }
]
// Les produits 1 et 2 sont ignor√©s
```

### Exemple 6 : Skip Apr√®s un Tri

```javascript
db.produits.aggregate([
  {
    $sort: { prix: -1 }    // Du plus cher au moins cher
  },
  {
    $skip: 2               // Ignorer les 2 plus chers
  }
])
```

**R√©sultat** : Tous les produits sauf les 2 plus chers.

### Exemple 7 : Skip Seul pour Exclure des R√©sultats

```javascript
// Obtenir tous les produits sauf les 5 premiers
db.produits.aggregate([
  {
    $skip: 5
  }
])
```

## Utilisation Combin√©e : $skip et $limit

La vraie puissance appara√Æt quand on combine `$skip` et `$limit` pour la **pagination**.

### Syntaxe de Pagination

```javascript
[
  { $sort: { <champ>: <ordre> } },    // Optionnel mais recommand√©
  { $skip: <nombre_a_sauter> },       // Page * TailleParPage
  { $limit: <taille_par_page> }       // Nombre par page
]
```

### Exemple 8 : Pagination Simple

Afficher les produits par pages de 2 :

**Page 1** (produits 1-2) :
```javascript
db.produits.aggregate([
  { $sort: { _id: 1 } },    // Ordre coh√©rent
  { $skip: 0 },             // (Page 1 - 1) * 2 = 0
  { $limit: 2 }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 1, "nom": "Laptop", "prix": 1200 },
  { "_id": 2, "nom": "Souris", "prix": 25 }
]
```

**Page 2** (produits 3-4) :
```javascript
db.produits.aggregate([
  { $sort: { _id: 1 } },
  { $skip: 2 },             // (Page 2 - 1) * 2 = 2
  { $limit: 2 }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 3, "nom": "Clavier", "prix": 45 },
  { "_id": 4, "nom": "√âcran", "prix": 250 }
]
```

**Page 3** (produits 5+) :
```javascript
db.produits.aggregate([
  { $sort: { _id: 1 } },
  { $skip: 4 },             // (Page 3 - 1) * 2 = 4
  { $limit: 2 }
])
```

**R√©sultat** :
```javascript
[
  { "_id": 5, "nom": "Webcam", "prix": 80 }
]
```

### Formule de Pagination

```javascript
const page = 2;              // Num√©ro de la page (commence √† 1)
const itemsParPage = 10;     // Nombre d'√©l√©ments par page

const skip = (page - 1) * itemsParPage;
const limit = itemsParPage;

db.collection.aggregate([
  { $skip: skip },
  { $limit: limit }
])
```

### Exemple 9 : Pagination avec Tri et Filtre

```javascript
function obtenirCommandes(page, tailleParPage, statut) {
  return db.commandes.aggregate([
    {
      // 1. Filtrer par statut
      $match: { statut: statut }
    },
    {
      // 2. Trier par date (plus r√©cent en premier)
      $sort: { date: -1 }
    },
    {
      // 3. Sauter les pages pr√©c√©dentes
      $skip: (page - 1) * tailleParPage
    },
    {
      // 4. Limiter √† la taille de la page
      $limit: tailleParPage
    },
    {
      // 5. Formater la sortie
      $project: {
        numeroCommande: 1,
        client: 1,
        montant: 1,
        date: {
          $dateToString: {
            format: "%d/%m/%Y",
            date: "$date"
          }
        }
      }
    }
  ]);
}

// Utilisation
obtenirCommandes(1, 20, "valid√©e");  // Page 1, 20 par page, statut valid√©e
obtenirCommandes(2, 20, "valid√©e");  // Page 2
```

## Ordre Important : $skip puis $limit

L'ordre entre `$skip` et `$limit` est important pour le comportement, mais MongoDB les optimise automatiquement.

### Ordre Logique

```javascript
// ‚úÖ RECOMMAND√â : Skip puis Limit (logique)
[
  { $skip: 10 },
  { $limit: 5 }
]
// R√©sultat : Documents 11 √† 15
```

### Ordre Invers√© (Fonctionne aussi)

```javascript
// ‚ö†Ô∏è Fonctionne mais moins intuitif
[
  { $limit: 15 },
  { $skip: 10 }
]
// R√©sultat : Documents 11 √† 15 (MongoDB optimise)
```

**Recommandation** : Utilisez toujours `$skip` puis `$limit` pour plus de clart√©.

## Cas d'Usage Pratiques

### 1. Liste de Produits Pagin√©e

```javascript
// API REST endpoint : /api/produits?page=2&limit=20
function getProducts(page = 1, limit = 20, categorie = null) {
  const pipeline = [];

  // Filtre optionnel
  if (categorie) {
    pipeline.push({
      $match: { categorie: categorie }
    });
  }

  // Tri
  pipeline.push({ $sort: { nom: 1 } });

  // Pagination
  pipeline.push({ $skip: (page - 1) * limit });
  pipeline.push({ $limit: limit });

  return db.produits.aggregate(pipeline);
}
```

### 2. Top 10 avec Donn√©es Compl√®tes

```javascript
// Top 10 des clients par chiffre d'affaires
db.commandes.aggregate([
  {
    $group: {
      _id: "$client",
      totalDepense: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 },
      derniereCommande: { $max: "$date" }
    }
  },
  {
    $sort: { totalDepense: -1 }
  },
  {
    $limit: 10    // Seulement les 10 premiers
  },
  {
    $lookup: {
      from: "clients",
      localField: "_id",
      foreignField: "_id",
      as: "infoClient"
    }
  },
  {
    $unwind: "$infoClient"
  },
  {
    $project: {
      _id: 0,
      client: "$infoClient.nom",
      email: "$infoClient.email",
      totalDepense: 1,
      nombreCommandes: 1,
      derniereCommande: 1
    }
  }
])
```

### 3. Fil d'Actualit√© (Feed)

```javascript
// Afficher les 20 derniers posts d'un utilisateur
function getFeed(userId, page = 1, postsPerPage = 20) {
  return db.posts.aggregate([
    {
      $match: {
        $or: [
          { auteur: userId },
          { abonnes: userId }
        ]
      }
    },
    {
      $sort: { datePublication: -1 }
    },
    {
      $skip: (page - 1) * postsPerPage
    },
    {
      $limit: postsPerPage
    },
    {
      $lookup: {
        from: "utilisateurs",
        localField: "auteur",
        foreignField: "_id",
        as: "auteurInfo"
      }
    }
  ]);
}
```

### 4. Aper√ßu de R√©sultats de Recherche

```javascript
// Recherche avec aper√ßu limit√©
db.articles.aggregate([
  {
    $match: {
      $text: { $search: "MongoDB agr√©gation" }
    }
  },
  {
    $sort: { score: { $meta: "textScore" } }
  },
  {
    $limit: 5    // Seulement les 5 meilleurs r√©sultats
  },
  {
    $project: {
      titre: 1,
      extrait: { $substr: ["$contenu", 0, 200] },
      score: { $meta: "textScore" }
    }
  }
])
```

### 5. Classement avec Position

```javascript
// Top 100 avec num√©ro de position
db.joueurs.aggregate([
  {
    $match: { saison: "2024" }
  },
  {
    $sort: { score: -1 }
  },
  {
    $limit: 100
  },
  {
    $group: {
      _id: null,
      joueurs: { $push: "$$ROOT" }
    }
  },
  {
    $unwind: { path: "$joueurs", includeArrayIndex: "position" }
  },
  {
    $project: {
      _id: 0,
      position: { $add: ["$position", 1] },    // Position commence √† 1
      joueur: "$joueurs.nom",
      score: "$joueurs.score"
    }
  }
])
```

## Calcul du Nombre Total de Pages

Pour une pagination compl√®te, il faut souvent conna√Ætre le nombre total de pages :

```javascript
// M√©thode 1 : Compter s√©par√©ment (2 requ√™tes)
const total = await db.produits.countDocuments({ categorie: "√âlectronique" });
const totalPages = Math.ceil(total / itemsParPage);

const resultats = await db.produits.aggregate([
  { $match: { categorie: "√âlectronique" } },
  { $sort: { prix: 1 } },
  { $skip: (page - 1) * itemsParPage },
  { $limit: itemsParPage }
]);

// Retourner les m√©tadonn√©es
return {
  data: resultats,
  pagination: {
    page: page,
    itemsParPage: itemsParPage,
    totalItems: total,
    totalPages: totalPages
  }
};
```

```javascript
// M√©thode 2 : Utiliser $facet (1 requ√™te)
db.produits.aggregate([
  {
    $match: { categorie: "√âlectronique" }
  },
  {
    $facet: {
      // Branche 1 : Les donn√©es pagin√©es
      data: [
        { $sort: { prix: 1 } },
        { $skip: (page - 1) * itemsParPage },
        { $limit: itemsParPage }
      ],
      // Branche 2 : Le compte total
      metadata: [
        { $count: "total" }
      ]
    }
  },
  {
    $project: {
      data: 1,
      total: { $arrayElemAt: ["$metadata.total", 0] },
      page: { $literal: page },
      itemsParPage: { $literal: itemsParPage },
      totalPages: {
        $ceil: {
          $divide: [
            { $arrayElemAt: ["$metadata.total", 0] },
            itemsParPage
          ]
        }
      }
    }
  }
])
```

**R√©sultat** :
```javascript
{
  "data": [
    { "_id": 1, "nom": "Produit 1", "prix": 25 },
    { "_id": 2, "nom": "Produit 2", "prix": 30 }
    // ... 20 produits
  ],
  "total": 156,
  "page": 2,
  "itemsParPage": 20,
  "totalPages": 8
}
```

## Performances et Optimisations

### 1. $limit Optimise Automatiquement

MongoDB optimise automatiquement `$limit` en remontant dans le pipeline :

```javascript
// Ce pipeline
[
  { $match: { statut: "actif" } },
  { $project: { nom: 1, prix: 1 } },
  { $limit: 10 }
]

// Est optimis√© en interne comme :
[
  { $match: { statut: "actif" } },
  { $limit: 10 },              // Remont√©
  { $project: { nom: 1, prix: 1 } }
]
```

Cette optimisation r√©duit le nombre de documents trait√©s.

### 2. Probl√®me de Performance avec $skip sur Grandes Valeurs

‚ö†Ô∏è **Attention** : `$skip` devient **lent** avec de grandes valeurs car MongoDB doit parcourir tous les documents ignor√©s.

```javascript
// ‚ùå LENT : Skip 1,000,000 de documents
db.collection.aggregate([
  { $skip: 1000000 },
  { $limit: 20 }
])
```

### 3. Alternative : Pagination par Curseur (Range-based)

Pour de meilleures performances sur de gros ensembles, utilisez la **pagination par curseur** :

```javascript
// Au lieu de $skip, utilisez un filtre sur la derni√®re valeur vue
// Page 1
db.produits.aggregate([
  { $sort: { _id: 1 } },
  { $limit: 20 }
])
// Sauvegarder le dernier _id : lastId = 20

// Page 2 (en utilisant lastId au lieu de $skip)
db.produits.aggregate([
  { $match: { _id: { $gt: lastId } } },    // Commence apr√®s le dernier ID
  { $sort: { _id: 1 } },
  { $limit: 20 }
])
```

**Avantages** :
- ‚úÖ Performance constante quelle que soit la page
- ‚úÖ Utilise les index efficacement
- ‚ùå Ne permet pas d'aller directement √† la page N
- ‚ùå Compliqu√© avec des tris complexes

### 4. Utiliser des Index

Pour une pagination efficace, cr√©ez des index sur les champs de tri :

```javascript
// Index pour tri par date
db.commandes.createIndex({ date: -1 })

// Index compos√© pour filtre + tri
db.produits.createIndex({ categorie: 1, prix: -1 })

// Ces pipelines utiliseront les index
db.commandes.aggregate([
  { $sort: { date: -1 } },
  { $skip: 100 },
  { $limit: 20 }
])

db.produits.aggregate([
  { $match: { categorie: "√âlectronique" } },
  { $sort: { prix: -1 } },
  { $skip: 40 },
  { $limit: 20 }
])
```

### 5. Limiter T√¥t dans le Pipeline

Si vous savez que vous ne voulez que quelques r√©sultats, limitez t√¥t :

```javascript
// ‚úÖ BON : Limit t√¥t
db.collection.aggregate([
  { $match: { statut: "actif" } },
  { $sort: { date: -1 } },
  { $limit: 10 },
  // Seulement 10 documents dans les √©tapes suivantes
  { $lookup: { /* jointure co√ªteuse */ } },
  { $project: { /* transformations */ } }
])

// ‚ùå MOINS EFFICACE : Limit tard
db.collection.aggregate([
  { $match: { statut: "actif" } },
  { $sort: { date: -1 } },
  { $lookup: { /* jointure sur beaucoup de docs */ } },
  { $project: { /* transformations */ } },
  { $limit: 10 }    // Trop tard !
])
```

## Pi√®ges Courants √† √âviter

### 1. Oublier le $sort pour la Pagination

```javascript
// ‚ùå DANGEREUX : Pagination sans tri
db.collection.aggregate([
  { $skip: 20 },
  { $limit: 10 }
])
// L'ordre n'est pas garanti ! Les m√™mes documents peuvent appara√Ætre sur diff√©rentes pages
```

```javascript
// ‚úÖ CORRECT : Toujours trier
db.collection.aggregate([
  { $sort: { _id: 1 } },    // Ordre coh√©rent et reproductible
  { $skip: 20 },
  { $limit: 10 }
])
```

### 2. $skip avec Valeurs N√©gatives

```javascript
// ‚ùå ERREUR : Valeur n√©gative
{ $skip: -5 }    // Provoque une erreur
```

`$skip` et `$limit` n√©cessitent des valeurs **positives ou z√©ro**.

### 3. $limit: 0

```javascript
// ‚ö†Ô∏è Attention : 0 retourne aucun document
{ $limit: 0 }    // R√©sultat vide
```

Si vous calculez dynamiquement la limite, assurez-vous qu'elle est >= 1.

### 4. $skip sur Collection Enti√®re sans Filtre

```javascript
// ‚ùå INEFFICACE : Skip beaucoup sur toute la collection
db.hugeCollection.aggregate([
  { $skip: 500000 },
  { $limit: 20 }
])
// MongoDB doit parcourir 500,000 documents
```

**Solution** : Ajouter des filtres ou utiliser la pagination par curseur.

### 5. Ne pas G√©rer les Pages Vides

```javascript
// Page qui d√©passe le nombre total de documents
db.produits.aggregate([
  { $sort: { _id: 1 } },
  { $skip: 10000 },    // Plus que le nombre total
  { $limit: 20 }
])
// R√©sultat : tableau vide []
```

**Solution** : V√©rifier le nombre total avant, ou g√©rer les tableaux vides c√¥t√© application.

## $limit/$skip vs limit()/skip() sur Cursor

### Avec find()

```javascript
db.collection.find().sort({ date: -1 }).skip(20).limit(10)
```

### Avec aggregate()

```javascript
db.collection.aggregate([
  { $sort: { date: -1 } },
  { $skip: 20 },
  { $limit: 10 }
])
```

### Diff√©rences

| Aspect | find() | aggregate() |
|--------|--------|-------------|
| **Syntaxe** | M√©thodes cha√Æn√©es | √âtapes de pipeline |
| **Flexibilit√©** | Limit√©e | Tr√®s flexible |
| **Combinaison** | Avec d'autres m√©thodes | Avec toutes les √©tapes |
| **Performance** | Similaire | Similaire |

## Points Cl√©s √† Retenir

1. ‚úÖ **$limit** : Garde les N premiers documents
2. ‚úÖ **$skip** : Ignore les N premiers documents
3. ‚úÖ **Pagination** : $sort ‚Üí $skip ‚Üí $limit (dans cet ordre)
4. ‚úÖ **Formule** : `skip = (page - 1) √ó itemsParPage`
5. ‚úÖ **Toujours trier** avant pagination pour un ordre coh√©rent
6. ‚úÖ **Utiliser des index** sur les champs de tri
7. ‚ö†Ô∏è **$skip est lent** avec de grandes valeurs (consid√©rer pagination par curseur)
8. ‚úÖ **$facet** pour obtenir donn√©es + m√©tadonn√©es en une requ√™te

## Exemple Complet : API de Pagination

```javascript
// Fonction compl√®te pour une API RESTful
async function getPaginatedResults(collection, filter, sortBy, page, limit) {
  // Validation
  page = Math.max(1, parseInt(page) || 1);
  limit = Math.max(1, Math.min(100, parseInt(limit) || 20));  // Max 100

  const pipeline = [
    // √âtape 1 : Filtrage
    { $match: filter },

    // √âtape 2 : Tri
    { $sort: sortBy },

    // √âtape 3 : Facet pour donn√©es + compte
    {
      $facet: {
        // Donn√©es pagin√©es
        documents: [
          { $skip: (page - 1) * limit },
          { $limit: limit }
        ],
        // M√©tadonn√©es
        pageInfo: [
          { $count: "totalDocuments" }
        ]
      }
    },

    // √âtape 4 : Formater la r√©ponse
    {
      $project: {
        documents: 1,
        pageInfo: {
          currentPage: { $literal: page },
          itemsPerPage: { $literal: limit },
          totalDocuments: {
            $ifNull: [
              { $arrayElemAt: ["$pageInfo.totalDocuments", 0] },
              0
            ]
          },
          totalPages: {
            $ceil: {
              $divide: [
                { $ifNull: [
                  { $arrayElemAt: ["$pageInfo.totalDocuments", 0] },
                  0
                ]},
                limit
              ]
            }
          },
          hasNextPage: {
            $gt: [
              { $ifNull: [
                { $arrayElemAt: ["$pageInfo.totalDocuments", 0] },
                0
              ]},
              { $multiply: [page, limit] }
            ]
          },
          hasPreviousPage: { $gt: [page, 1] }
        }
      }
    }
  ];

  const result = await db[collection].aggregate(pipeline).toArray();

  return result[0] || {
    documents: [],
    pageInfo: {
      currentPage: page,
      itemsPerPage: limit,
      totalDocuments: 0,
      totalPages: 0,
      hasNextPage: false,
      hasPreviousPage: false
    }
  };
}

// Utilisation
const result = await getPaginatedResults(
  "produits",
  { categorie: "√âlectronique", stock: { $gt: 0 } },
  { prix: -1 },
  2,
  20
);

console.log(result);
/*
{
  documents: [ ... 20 produits ... ],
  pageInfo: {
    currentPage: 2,
    itemsPerPage: 20,
    totalDocuments: 156,
    totalPages: 8,
    hasNextPage: true,
    hasPreviousPage: true
  }
}
*/
```

## Conclusion

Les op√©rateurs `$limit` et `$skip` sont **essentiels** pour :

- üìÑ **Paginer** vos r√©sultats efficacement
- üéØ **Limiter** le volume de donn√©es retourn√©
- ‚ö° **Optimiser** les performances (avec $limit t√¥t)
- üîù **Cr√©er** des classements "Top N"
- üì± **Impl√©menter** des interfaces utilisateur (load more, pagination)

Utilis√©s correctement avec `$sort` et des index appropri√©s, ils permettent de naviguer efficacement dans de grandes collections tout en maintenant de bonnes performances.

---


‚è≠Ô∏è [$count](/06-framework-agregation/03.6-count.md)
