ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.2 ACID dans le Contexte NoSQL

## Introduction

L'Ã©mergence des bases de donnÃ©es NoSQL au dÃ©but des annÃ©es 2000 a Ã©tÃ© motivÃ©e par un rejet dÃ©libÃ©rÃ© du modÃ¨le ACID strict des bases relationnelles. Ce n'Ã©tait pas une limitation technique, mais un choix architectural conscient : sacrifier certaines garanties ACID pour obtenir une scalabilitÃ© horizontale massive et des performances exceptionnelles. Comprendre ACID dans le contexte NoSQL nÃ©cessite d'examiner ce changement de paradigme, ses motivations, et comment MongoDB reprÃ©sente aujourd'hui une convergence fascinante entre ces deux mondes.

## Le Grand Schisme : SQL vs NoSQL

### Les Fondations Philosophiques

**Monde SQL (1970-2000)**
```
Philosophie : "CohÃ©rence d'abord, scalabilitÃ© ensuite"

Principes :
1. Normalisation des donnÃ©es (formes normales)
2. ACID strict par dÃ©faut
3. SchÃ©ma rigide
4. Relations via clÃ©s Ã©trangÃ¨res
5. Scaling vertical (machines plus puissantes)

Architecture type :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Base de DonnÃ©es Centrale       â”‚
â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Transaction Manager             â”‚  â”‚
â”‚  â”‚  - Lock Manager                  â”‚  â”‚
â”‚  â”‚  - 2-Phase Commit                â”‚  â”‚
â”‚  â”‚  - Write-Ahead Log               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                        â”‚
â”‚  Tables relationnelles normalisÃ©es     â”‚
â”‚  Contraintes d'intÃ©gritÃ© strictes      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Scaling vertical
         â–¼
    Serveur unique
    (trÃ¨s puissant)
```

**Monde NoSQL (2000-prÃ©sent)**
```
Philosophie : "DisponibilitÃ© d'abord, cohÃ©rence Ã©ventuelle acceptable"

Principes :
1. DÃ©normalisation encouragÃ©e
2. CohÃ©rence configurable (souvent Ã©ventuelle)
3. SchÃ©ma flexible
4. Relations minimales ou absentes
5. Scaling horizontal (machines commodity)

Architecture type :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   NÅ“ud 1     â”‚  â”‚   NÅ“ud 2     â”‚  â”‚   NÅ“ud N     â”‚
â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
â”‚  DonnÃ©es A-F â”‚  â”‚  DonnÃ©es G-M â”‚  â”‚  DonnÃ©es N-Z â”‚
â”‚  RÃ©plicas    â”‚  â”‚  RÃ©plicas    â”‚  â”‚  RÃ©plicas    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
              Coordination faible
           (eventual consistency)
```

### Le ThÃ©orÃ¨me CAP : La Contrainte Fondamentale

Le thÃ©orÃ¨me CAP (Eric Brewer, 2000) Ã©nonce qu'un systÃ¨me distribuÃ© ne peut garantir simultanÃ©ment que deux des trois propriÃ©tÃ©s suivantes :

```
        Consistency (CohÃ©rence)
               â–²
              /â”‚\
             / â”‚ \
            /  â”‚  \
           /   â”‚   \
          /    â”‚    \
Availability  â”‚  Partition Tolerance
(DisponibilitÃ©) â”‚  (TolÃ©rance aux pannes)
```

**Preuve intuitive** :

```javascript
// ScÃ©nario : Cluster avec 2 nÅ“uds sÃ©parÃ©s par une partition rÃ©seau

NÅ“ud A (Paris)                    NÅ“ud B (New York)
     â”‚                                  â”‚
     â”‚  âš  PARTITION RÃ‰SEAU             â”‚
     â”‚  (cÃ¢ble sous-marin coupÃ©)        â”‚
     â•³â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•³
     â”‚                                  â”‚
     â–¼                                  â–¼

// Client 1 Ã©crit sur A              // Client 2 lit depuis B
await nodeA.update(                  const data = await nodeB.find(
    { userId: "U001" },                  { userId: "U001" }
    { $set: { balance: 500 } }       );
);

// CHOIX IMPOSSIBLE :

// Option 1 : CONSISTENCY + PARTITION TOLERANCE (CP)
// â†’ nodeB refuse de servir les lectures (service indisponible)
// â†’ Sacrifie Availability
if (!canReachOtherNode) {
    throw new Error("Service temporarily unavailable");
}

// Option 2 : AVAILABILITY + PARTITION TOLERANCE (AP)
// â†’ nodeB sert des donnÃ©es potentiellement stale
// â†’ Sacrifie Consistency (cohÃ©rence immÃ©diate)
const data = await nodeB.find({ userId: "U001" });
// Peut retourner balance: 1000 (ancienne valeur)
// CohÃ©rence Ã©ventuelle

// Option 3 : CONSISTENCY + AVAILABILITY (CA)
// â†’ Impossible de garantir en prÃ©sence de partition
// â†’ Viole le thÃ©orÃ¨me CAP
```

**Positionnement des systÃ¨mes** :

```
SystÃ¨mes CP (Consistency + Partition tolerance) :
- MongoDB avec readConcern: "linearizable"
- HBase
- Redis Sentinel
CaractÃ©ristique : Refusent les opÃ©rations si cohÃ©rence non garantie

SystÃ¨mes AP (Availability + Partition tolerance) :
- Cassandra (dÃ©faut)
- DynamoDB
- Riak
CaractÃ©ristique : Toujours disponibles, cohÃ©rence Ã©ventuelle

SystÃ¨mes CA (Consistency + Availability) :
- SGBD relationnels classiques (serveur unique)
- PostgreSQL, MySQL (sans rÃ©plication)
CaractÃ©ristique : Ne tolÃ¨rent pas les partitions rÃ©seau
```

## BASE : L'Alternative NoSQL Ã  ACID

Face aux contraintes CAP, le NoSQL a dÃ©veloppÃ© un modÃ¨le alternatif : **BASE**

### DÃ©finition BASE

**B**asically **A**vailable, **S**oft state, **E**ventual consistency

```javascript
// ACID : Tout ou rien, immÃ©diat
async function transferMoneyACID(fromId, toId, amount) {
    const session = client.startSession();
    session.startTransaction();

    try {
        await accounts.updateOne(
            { accountId: fromId },
            { $inc: { balance: -amount } },
            { session }
        );

        await accounts.updateOne(
            { accountId: toId },
            { $inc: { balance: amount } },
            { session }
        );

        await session.commitTransaction();
        // âœ“ Ã€ ce point : garantie absolue de cohÃ©rence
        // âœ“ Les deux comptes sont modifiÃ©s
        // âœ— Latence : 50-200ms
        // âœ— Peut Ã©chouer si majoritÃ© indisponible

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}

// BASE : Disponible, Ã©ventuellement cohÃ©rent
async function transferMoneyBASE(fromId, toId, amount) {
    // Pas de transaction globale

    // Ã‰tape 1 : CrÃ©er un Ã©vÃ©nement de transfert
    const transferId = generateId();
    await transfers.insertOne({
        transferId: transferId,
        fromAccountId: fromId,
        toAccountId: toId,
        amount: amount,
        status: "pending",
        createdAt: new Date()
    }, {
        writeConcern: { w: 1 }  // Ã‰criture rapide
    });

    // âœ“ Latence : 2-5ms
    // âœ“ Toujours disponible

    // Ã‰tape 2 : Processus asynchrone (worker sÃ©parÃ©)
    processTransferAsync(transferId);

    return {
        transferId,
        status: "processing",
        message: "Le transfert sera traitÃ© sous peu"
    };
}

async function processTransferAsync(transferId) {
    // RÃ©cupÃ©ration idempotente avec retry
    const transfer = await transfers.findOne({ transferId });

    if (transfer.status !== "pending") {
        return; // DÃ©jÃ  traitÃ©
    }

    try {
        // DÃ©biter (opÃ©ration idempotente)
        await accounts.updateOne(
            {
                accountId: transfer.fromAccountId,
                balance: { $gte: transfer.amount }
            },
            {
                $inc: { balance: -transfer.amount },
                $push: {
                    transactions: {
                        id: transferId,
                        type: "debit",
                        amount: transfer.amount
                    }
                }
            }
        );

        // CrÃ©diter (opÃ©ration idempotente)
        await accounts.updateOne(
            { accountId: transfer.toAccountId },
            {
                $inc: { balance: transfer.amount },
                $push: {
                    transactions: {
                        id: transferId,
                        type: "credit",
                        amount: transfer.amount
                    }
                }
            }
        );

        // Marquer comme complÃ©tÃ©
        await transfers.updateOne(
            { transferId },
            {
                $set: {
                    status: "completed",
                    completedAt: new Date()
                }
            }
        );

        // CohÃ©rence Ã©ventuelle atteinte

    } catch (error) {
        // Retry avec backoff exponentiel
        await transfers.updateOne(
            { transferId },
            {
                $set: { status: "failed" },
                $push: { errors: { error: error.message, at: new Date() } }
            }
        );

        // Job de compensation ou alerte manuelle
    }
}

// Comparaison :
// ACID : CohÃ©rence immÃ©diate, latence Ã©levÃ©e, disponibilitÃ© conditionnelle
// BASE : CohÃ©rence Ã©ventuelle, latence faible, haute disponibilitÃ©
```

### CaractÃ©ristiques de BASE en DÃ©tail

#### 1. Basically Available (DisponibilitÃ© Fondamentale)

```javascript
// Le systÃ¨me rÃ©pond toujours, mÃªme avec des donnÃ©es partielles

// ScÃ©nario : Catalogue produits e-commerce avec rÃ©plication

// NÅ“ud Principal : Paris (primary)
// NÅ“ud Secondaire 1 : Londres (secondary, lag: 50ms)
// NÅ“ud Secondaire 2 : New York (secondary, lag: 150ms)

async function searchProducts(query) {
    try {
        // Tentative de lecture optimale (primary)
        return await products.find(
            { $text: { $search: query } },
            {
                readPreference: "primary",
                maxTimeMS: 100  // Timeout court
            }
        ).toArray();

    } catch (primaryError) {
        // Primary indisponible ou lent
        console.warn("Primary unavailable, falling back to secondary");

        try {
            // Fallback : lecture secondaire (donnÃ©es potentiellement stale)
            return await products.find(
                { $text: { $search: query } },
                {
                    readPreference: "secondaryPreferred",
                    maxTimeMS: 200
                }
            ).toArray();

        } catch (secondaryError) {
            // MÃªme les secondaires sont indisponibles
            console.error("All nodes unavailable");

            // DerniÃ¨re tentative : cache applicatif
            return await cacheService.get(`search:${query}`) || [];
        }
    }
}

// Garantie BASE :
// âœ“ Le systÃ¨me rÃ©pond toujours (mÃªme avec cache vide)
// âœ“ DÃ©gradation gracieuse
// âš  Les donnÃ©es peuvent Ãªtre lÃ©gÃ¨rement obsolÃ¨tes
```

#### 2. Soft State (Ã‰tat Transitoire)

```javascript
// L'Ã©tat du systÃ¨me peut changer sans input externe
// en raison de la propagation Ã©ventuelle

// ScÃ©nario : SystÃ¨me de likes sur les rÃ©seaux sociaux

// Architecture distribuÃ©e :
// - Shard US-EAST : utilisateurs A-M
// - Shard US-WEST : utilisateurs N-Z
// - Shard EU : utilisateurs internationaux

async function likePost(postId, userId) {
    // IncrÃ©menter le compteur localement (soft state)
    await posts.updateOne(
        { postId: postId },
        {
            $inc: { likes: 1 },
            $addToSet: { likers: userId }
        },
        {
            writeConcern: { w: 1 }  // Juste le nÅ“ud local
        }
    );

    // Ã‰tat "soft" : le compteur va Ã©voluer au fil de la rÃ©plication

    // Timeline observable :
    // T=0ms  : Utilisateur US-EAST like â†’ likes: 100 (sur shard US-EAST)
    // T=50ms : RÃ©plication US-WEST â†’ likes: 100 (sur shard US-WEST)
    // T=100ms: RÃ©plication EU â†’ likes: 100 (sur shard EU)
    // T=200ms: Utilisateur EU lit â†’ voit likes: 100

    // Pendant ce temps, d'autres utilisateurs ont likÃ© :
    // T=10ms : Utilisateur US-WEST like â†’ likes: 1 (local)
    // T=60ms : AprÃ¨s rÃ©plication complÃ¨te â†’ likes: 101 (partout)

    // L'Ã©tat "soft" converge vers la valeur finale
}

// Observation du soft state
async function observeSoftState(postId) {
    // Lecture depuis diffÃ©rents nÅ“uds
    const readFromUSEast = await posts.findOne(
        { postId },
        { readPreference: { mode: "nearest", tags: [{ region: "us-east" }] } }
    );

    const readFromEU = await posts.findOne(
        { postId },
        { readPreference: { mode: "nearest", tags: [{ region: "eu" }] } }
    );

    console.log(`US-EAST voit : ${readFromUSEast.likes} likes`);
    console.log(`EU voit : ${readFromEU.likes} likes`);
    // Valeurs potentiellement diffÃ©rentes (soft state)

    // AprÃ¨s un dÃ©lai (eventual consistency) :
    await sleep(5000);

    const finalUSEast = await posts.findOne({ postId }, {
        readPreference: { mode: "nearest", tags: [{ region: "us-east" }] }
    });
    const finalEU = await posts.findOne({ postId }, {
        readPreference: { mode: "nearest", tags: [{ region: "eu" }] }
    });

    console.log(`AprÃ¨s convergence :`);
    console.log(`US-EAST : ${finalUSEast.likes}`);
    console.log(`EU : ${finalEU.likes}`);
    // Maintenant identiques (Ã©tat stable atteint)
}
```

#### 3. Eventual Consistency (CohÃ©rence Ã‰ventuelle)

```javascript
// Le systÃ¨me finira par converger vers un Ã©tat cohÃ©rent
// si on arrÃªte de le modifier

// ScÃ©nario : Inventaire distribuÃ© sur plusieurs entrepÃ´ts

// ModÃ¨le eventual consistency
class DistributedInventory {
    async updateStock(warehouseId, productId, delta) {
        // Mise Ã  jour locale immÃ©diate
        await inventory.updateOne(
            { warehouseId, productId },
            {
                $inc: { quantity: delta },
                $push: {
                    updates: {
                        delta: delta,
                        timestamp: new Date(),
                        version: generateVersion()
                    }
                }
            },
            {
                writeConcern: { w: 1 }
            }
        );

        // Propagation asynchrone vers les autres entrepÃ´ts
        this.propagateUpdate(warehouseId, productId, delta);

        // âš  Ã€ ce stade :
        // - L'entrepÃ´t local a la bonne valeur
        // - Les autres entrepÃ´ts ont encore l'ancienne valeur
        // - CohÃ©rence Ã©ventuelle en cours de propagation
    }

    async propagateUpdate(sourceWarehouse, productId, delta) {
        // Trouver tous les autres entrepÃ´ts
        const otherWarehouses = await warehouses.find({
            warehouseId: { $ne: sourceWarehouse }
        }).toArray();

        // Propager en parallÃ¨le (sans attendre)
        otherWarehouses.forEach(warehouse => {
            this.replicateDelta(warehouse.warehouseId, productId, delta)
                .catch(error => {
                    console.error(`Propagation failed to ${warehouse.warehouseId}:`, error);
                    // Retry plus tard via un job de rÃ©conciliation
                });
        });
    }

    async getGlobalStock(productId) {
        // AgrÃ©ger le stock de tous les entrepÃ´ts
        const stocks = await inventory.aggregate([
            { $match: { productId: productId } },
            { $group: {
                _id: null,
                totalQuantity: { $sum: "$quantity" }
            }}
        ]).toArray();

        // âš  Cette valeur peut Ãªtre temporairement incohÃ©rente
        // pendant la propagation des mises Ã  jour

        return stocks[0]?.totalQuantity || 0;
    }

    async reconcile() {
        // Job pÃ©riodique pour garantir la convergence
        // En cas de pannes ou de messages perdus

        const products = await inventory.distinct("productId");

        for (const productId of products) {
            // Collecter toutes les mises Ã  jour de tous les entrepÃ´ts
            const allUpdates = await inventory.aggregate([
                { $match: { productId: productId } },
                { $unwind: "$updates" },
                { $sort: { "updates.timestamp": 1 } }
            ]).toArray();

            // Rejouer les mises Ã  jour dans l'ordre pour chaque entrepÃ´t
            // (idempotence garantie par version)

            // RÃ©sultat : CohÃ©rence Ã©ventuelle atteinte
        }
    }
}

// DÃ©monstration de convergence
async function demonstrateEventualConsistency() {
    const inventory = new DistributedInventory();

    // Ã‰tat initial : 100 unitÃ©s dans chaque entrepÃ´t
    // Paris: 100, Londres: 100, New York: 100
    // Total global: 300

    // T=0 : Vente Ã  Paris (-5 unitÃ©s)
    await inventory.updateStock("PARIS", "PRODUCT-001", -5);
    // Paris: 95 (immÃ©diat)
    // Londres: 100 (stale)
    // New York: 100 (stale)
    // Total observable: 295 ou 300 (selon le timing de lecture)

    // T=50ms : Propagation vers Londres
    // Paris: 95
    // Londres: 95
    // New York: 100 (encore stale)
    // Total: 290 ou 295 (incohÃ©rence transitoire)

    // T=150ms : Propagation complÃ¨te
    // Paris: 95
    // Londres: 95
    // New York: 95
    // Total: 285 (cohÃ©rence Ã©ventuelle atteinte)

    // âœ“ Sans nouvelles modifications, le systÃ¨me est maintenant cohÃ©rent
}
```

## MongoDB : Le Pont entre ACID et BASE

### L'Ã‰volution Historique

MongoDB reprÃ©sente une convergence fascinante entre les paradigmes ACID et BASE :

```
MongoDB 1.0-3.6 (2009-2018)
â”‚
â”œâ”€ Philosophie : BASE principalement
â”œâ”€ AtomicitÃ© : Document unique seulement
â”œâ”€ CohÃ©rence : Ã‰ventuelle par dÃ©faut
â”œâ”€ Isolation : Document-level
â””â”€ DurabilitÃ© : Configurable (w:1 dÃ©faut)

         â”‚
         â”‚ Transition
         â–¼

MongoDB 4.0-4.2 (2018-2019)
â”‚
â”œâ”€ RÃ©volution : Support transactions multi-documents
â”œâ”€ ACID : Complet sur Replica Sets puis Sharded Clusters
â”œâ”€ BASE : Toujours disponible comme option
â””â”€ Choix : L'architecte dÃ©cide pour chaque opÃ©ration

         â”‚
         â”‚ Maturation
         â–¼

MongoDB 5.0+ (2021-prÃ©sent)
â”‚
â”œâ”€ ACID : Performances amÃ©liorÃ©es
â”œâ”€ BASE : Toujours optimal pour la scalabilitÃ©
â”œâ”€ Spectre : Du fully ACID au fully BASE
â””â”€ Pragmatisme : Utiliser le bon outil pour chaque besoin
```

### Spectre de Garanties MongoDB

```javascript
// MongoDB offre un spectre complet de ACID Ã  BASE

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXTRÃŠME ACID : Garanties maximales
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function extremeACID(orderId, items) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "linearizable" },      // ğŸ”’ CohÃ©rence linÃ©aire
            writeConcern: { w: "majority", j: true },    // ğŸ”’ DurabilitÃ© maximale
            readPreference: "primary"                     // ğŸ”’ Primary seulement
        });

        // Toutes les garanties ACID strictes
        const order = await orders.insertOne({
            orderId: orderId,
            items: items,
            status: "confirmed",
            timestamp: new Date()
        }, { session });

        for (const item of items) {
            await inventory.updateOne(
                { productId: item.productId },
                { $inc: { stock: -item.quantity } },
                { session }
            );
        }

        await session.commitTransaction();

        // CaractÃ©ristiques :
        // âœ“ AtomicitÃ© : Transaction multi-documents
        // âœ“ CohÃ©rence : Linearizable (la plus forte)
        // âœ“ Isolation : Snapshot isolation
        // âœ“ DurabilitÃ© : RÃ©pliquÃ© + journalisÃ©
        //
        // CoÃ»t :
        // âœ— Latence : 100-300ms
        // âœ— DisponibilitÃ© : Requiert majoritÃ© accessible
        // âœ— Throughput : 100-500 ops/sec

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MILIEU : Compromis Ã©quilibrÃ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function balancedApproach(orderId, items) {
    // Pas de transaction globale
    // Mais garanties raisonnables

    const order = await orders.insertOne({
        orderId: orderId,
        items: items,
        status: "confirmed",
        timestamp: new Date()
    }, {
        writeConcern: { w: "majority" }  // DurabilitÃ© rÃ©pliquÃ©e
    });

    // Mise Ã  jour inventaire asynchrone (eventual consistency)
    updateInventoryAsync(items);

    // CaractÃ©ristiques :
    // âœ“ AtomicitÃ© : Document unique (ordre)
    // âš  CohÃ©rence : Ã‰ventuelle (inventaire)
    // âš  Isolation : Document-level
    // âœ“ DurabilitÃ© : RÃ©pliquÃ©e (ordre)
    //
    // CoÃ»t :
    // âœ“ Latence : 20-50ms
    // âœ“ DisponibilitÃ© : Haute
    // âœ“ Throughput : 5,000-10,000 ops/sec
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXTRÃŠME BASE : Performance maximale
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function extremeBASE(orderId, items) {
    // Fire and forget
    await orders.insertOne({
        orderId: orderId,
        items: items,
        status: "pending",
        timestamp: new Date()
    }, {
        writeConcern: { w: 0 }  // Aucune attente
    });

    // Tout le traitement en asynchrone
    processOrderAsync(orderId);

    // CaractÃ©ristiques :
    // âš  AtomicitÃ© : Best effort
    // âš  CohÃ©rence : Ã‰ventuelle
    // âš  Isolation : Minimale
    // âš  DurabilitÃ© : DiffÃ©rÃ©e
    //
    // CoÃ»t :
    // âœ“ Latence : <1ms
    // âœ“ DisponibilitÃ© : Toujours
    // âœ“ Throughput : 50,000+ ops/sec

    return { orderId, status: "processing" };
}
```

### Patterns NoSQL pour Compenser l'Absence d'ACID

#### Pattern 1 : Idempotence

```javascript
// Permettre le rejouer safe d'opÃ©rations

// ProblÃ¨me : Sans ACID, une opÃ©ration peut Ãªtre exÃ©cutÃ©e plusieurs fois
// Solution : Concevoir des opÃ©rations idempotentes

// âŒ NON IDEMPOTENT
async function incrementViewsBAD(articleId) {
    const article = await articles.findOne({ articleId });
    await articles.updateOne(
        { articleId },
        { $set: { views: article.views + 1 } }
    );

    // Si exÃ©cutÃ© 2 fois : views augmente de 2 (incorrect)
}

// âœ… IDEMPOTENT
async function incrementViewsGOOD(articleId, viewId) {
    await articles.updateOne(
        { articleId: articleId },
        {
            $inc: { views: 1 },
            $addToSet: { viewIds: viewId }  // DÃ©duplication
        }
    );

    // MÃªme si exÃ©cutÃ© plusieurs fois avec le mÃªme viewId :
    // - views augmente de 1 seulement
    // - viewIds contient viewId une seule fois
}

// Application : Traitement de messages distribuÃ©e
async function processMessageIdempotent(messageId, payload) {
    // VÃ©rifier si dÃ©jÃ  traitÃ©
    const result = await processedMessages.updateOne(
        {
            messageId: messageId,
            status: { $ne: "processed" }
        },
        {
            $set: {
                status: "processing",
                startedAt: new Date()
            }
        }
    );

    if (result.matchedCount === 0) {
        // DÃ©jÃ  traitÃ© ou en cours
        return { alreadyProcessed: true };
    }

    try {
        // Traitement mÃ©tier
        await businessLogic(payload);

        // Marquer comme complÃ©tÃ©
        await processedMessages.updateOne(
            { messageId },
            {
                $set: {
                    status: "processed",
                    completedAt: new Date()
                }
            }
        );

    } catch (error) {
        // Ã‰chec : permettre retry
        await processedMessages.updateOne(
            { messageId },
            {
                $set: {
                    status: "failed",
                    error: error.message
                }
            }
        );
        throw error;
    }
}
```

#### Pattern 2 : Compensation (Saga)

```javascript
// Remplacer les transactions par des compensations

// ScÃ©nario : RÃ©servation de voyage (vols + hÃ´tel + voiture)

class TravelBookingSaga {
    async bookTravel(travelData) {
        const sagaId = generateId();
        const compensations = [];

        try {
            // Ã‰tape 1 : RÃ©server le vol
            console.log("RÃ©servation vol...");
            const flight = await this.bookFlight(travelData.flight);
            compensations.push(() => this.cancelFlight(flight.id));

            await this.recordSagaStep(sagaId, "flight_booked", flight);

            // Ã‰tape 2 : RÃ©server l'hÃ´tel
            console.log("RÃ©servation hÃ´tel...");
            const hotel = await this.bookHotel(travelData.hotel);
            compensations.push(() => this.cancelHotel(hotel.id));

            await this.recordSagaStep(sagaId, "hotel_booked", hotel);

            // Ã‰tape 3 : RÃ©server la voiture
            console.log("RÃ©servation voiture...");
            const car = await this.bookCar(travelData.car);
            compensations.push(() => this.cancelCar(car.id));

            await this.recordSagaStep(sagaId, "car_booked", car);

            // Ã‰tape 4 : Paiement
            console.log("Paiement...");
            await this.processPayment(travelData.payment);

            await this.recordSagaStep(sagaId, "completed", { sagaId });

            return {
                success: true,
                sagaId,
                bookings: { flight, hotel, car }
            };

        } catch (error) {
            console.error(`Saga ${sagaId} failed:`, error.message);

            // ExÃ©cuter les compensations dans l'ordre inverse
            console.log("ExÃ©cution des compensations...");

            for (const compensate of compensations.reverse()) {
                try {
                    await compensate();
                } catch (compensationError) {
                    // Logger pour investigation manuelle
                    await this.recordCompensationFailure(
                        sagaId,
                        compensationError
                    );
                }
            }

            await this.recordSagaStep(sagaId, "failed", { error: error.message });

            throw error;
        }
    }

    async recordSagaStep(sagaId, step, data) {
        await sagas.updateOne(
            { sagaId },
            {
                $push: {
                    steps: {
                        step,
                        data,
                        timestamp: new Date()
                    }
                }
            },
            { upsert: true }
        );
    }

    async bookFlight(flightData) {
        // Simulation d'API externe
        return { id: generateId(), ...flightData };
    }

    async cancelFlight(flightId) {
        console.log(`Annulation vol ${flightId}`);
        // Compensation
    }

    // ... autres mÃ©thodes similaires
}

// Avantages :
// âœ“ Pas besoin de transactions distribuÃ©es
// âœ“ Chaque service peut utiliser sa propre base
// âœ“ ScalabilitÃ© horizontale
// âœ“ RÃ©silience aux pannes
//
// InconvÃ©nients :
// âš  ComplexitÃ© accrue (logique de compensation)
// âš  Ã‰tats intermÃ©diaires visibles
// âš  Compensation peut Ã©chouer (nÃ©cessite alertes)
```

#### Pattern 3 : Versioning Optimiste

```javascript
// DÃ©tecter les conflits sans verrouillage pessimiste

// ScÃ©nario : Ã‰dition collaborative de documents

async function updateDocumentOptimistic(docId, userId, changes) {
    // Lecture avec version actuelle
    const doc = await documents.findOne({ docId });

    if (!doc) {
        throw new Error("Document not found");
    }

    const currentVersion = doc.version;

    // Appliquer les modifications localement
    const updatedContent = applyChanges(doc.content, changes);

    // Tentative de mise Ã  jour conditionnelle
    const result = await documents.updateOne(
        {
            docId: docId,
            version: currentVersion  // ğŸ”‘ Condition sur la version
        },
        {
            $set: {
                content: updatedContent,
                lastModifiedBy: userId,
                lastModifiedAt: new Date()
            },
            $inc: { version: 1 }
        }
    );

    if (result.matchedCount === 0) {
        // Conflit dÃ©tectÃ© : quelqu'un d'autre a modifiÃ© entre temps
        throw new OptimisticLockError(
            "Document modifiÃ© par un autre utilisateur. Veuillez rafraÃ®chir."
        );
    }

    return { success: true, newVersion: currentVersion + 1 };
}

// Gestion cÃ´tÃ© client
async function saveDocumentWithRetry(docId, userId, changes, maxRetries = 3) {
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            return await updateDocumentOptimistic(docId, userId, changes);

        } catch (error) {
            if (error instanceof OptimisticLockError && attempt < maxRetries - 1) {
                attempt++;
                console.log(`Conflit dÃ©tectÃ©, tentative ${attempt}...`);

                // Recharger le document et fusionner les changements
                const latestDoc = await documents.findOne({ docId });
                changes = mergeChanges(latestDoc.content, changes);

                continue;
            }

            throw error;
        }
    }
}

// Avantages :
// âœ“ Pas de verrous (haute concurrence)
// âœ“ Performance optimale en cas de faible contention
// âœ“ DÃ©tection de conflits garantie
//
// InconvÃ©nients :
// âš  NÃ©cessite retry cÃ´tÃ© client
// âš  Peut Ãªtre inefficace avec haute contention
```

#### Pattern 4 : CQRS (Command Query Responsibility Segregation)

```javascript
// SÃ©parer les Ã©critures (commands) des lectures (queries)

// Architecture CQRS avec MongoDB

// WRITE MODEL : OptimisÃ© pour les Ã©critures (ACID strict)
class OrderWriteModel {
    async createOrder(orderData) {
        const session = client.startSession();

        try {
            session.startTransaction({
                writeConcern: { w: "majority" }
            });

            // ModÃ¨le d'Ã©criture normalisÃ©
            const order = await orders.insertOne({
                orderId: generateId(),
                customerId: orderData.customerId,
                status: "pending",
                createdAt: new Date()
            }, { session });

            for (const item of orderData.items) {
                await orderItems.insertOne({
                    orderItemId: generateId(),
                    orderId: order.insertedId,
                    productId: item.productId,
                    quantity: item.quantity,
                    price: item.price
                }, { session });
            }

            await session.commitTransaction();

            // Publier Ã©vÃ©nement pour mise Ã  jour du modÃ¨le de lecture
            await this.publishEvent({
                type: "OrderCreated",
                orderId: order.insertedId,
                data: orderData
            });

            return order;

        } catch (error) {
            await session.abortTransaction();
            throw error;
        } finally {
            await session.endSession();
        }
    }

    async publishEvent(event) {
        await events.insertOne({
            eventId: generateId(),
            ...event,
            publishedAt: new Date()
        });
    }
}

// READ MODEL : OptimisÃ© pour les lectures (dÃ©normalisÃ©, eventual consistency)
class OrderReadModel {
    async projectOrder(event) {
        // Mettre Ã  jour la vue matÃ©rialisÃ©e dÃ©normalisÃ©e
        if (event.type === "OrderCreated") {
            await ordersView.insertOne({
                orderId: event.orderId,
                customerId: event.data.customerId,
                customerName: await this.getCustomerName(event.data.customerId),
                items: event.data.items.map(item => ({
                    productId: item.productId,
                    productName: this.getProductName(item.productId),
                    quantity: item.quantity,
                    price: item.price
                })),
                total: event.data.items.reduce(
                    (sum, item) => sum + (item.price * item.quantity),
                    0
                ),
                status: "pending",
                createdAt: event.data.createdAt
            });
        }
    }

    async getOrderDetails(orderId) {
        // Lecture ultra-rapide depuis la vue dÃ©normalisÃ©e
        return await ordersView.findOne(
            { orderId },
            {
                readPreference: "secondaryPreferred",  // Distribuer la charge
                readConcern: { level: "local" }        // Performance max
            }
        );
    }
}

// Event processor (asynchrone)
class OrderEventProcessor {
    async process() {
        const cursor = events.find({
            processed: { $ne: true }
        }).sort({ publishedAt: 1 });

        for await (const event of cursor) {
            try {
                // Mettre Ã  jour le read model
                await readModel.projectOrder(event);

                // Marquer comme traitÃ©
                await events.updateOne(
                    { eventId: event.eventId },
                    { $set: { processed: true, processedAt: new Date() } }
                );

            } catch (error) {
                console.error(`Failed to process event ${event.eventId}:`, error);
                // Retry plus tard
            }
        }
    }
}

// Utilisation
const writeModel = new OrderWriteModel();
const readModel = new OrderReadModel();

// Ã‰criture : ACID strict
await writeModel.createOrder({
    customerId: "C001",
    items: [
        { productId: "P001", quantity: 2, price: 50 },
        { productId: "P002", quantity: 1, price: 100 }
    ]
});

// Lecture : Eventual consistency, ultra-rapide
const orderDetails = await readModel.getOrderDetails("ORD123");

// Avantages :
// âœ“ Ã‰critures : ACID strict pour intÃ©gritÃ©
// âœ“ Lectures : Performance maximale, scalabilitÃ© infinie
// âœ“ ModÃ¨les indÃ©pendants optimisÃ©s pour leur usage
//
// InconvÃ©nients :
// âš  ComplexitÃ© architecturale accrue
// âš  CohÃ©rence Ã©ventuelle entre modÃ¨les
// âš  Infrastructure supplÃ©mentaire (event store, processors)
```

## Quand Choisir ACID vs BASE dans MongoDB

### Matrice de DÃ©cision

```javascript
// Fonction d'aide Ã  la dÃ©cision

function shouldUseACID(scenario) {
    const factors = {
        // Facteurs favorisant ACID (transactions strictes)
        financialData: scenario.involvesFinancial,           // 10 points
        legalCompliance: scenario.requiresCompliance,        // 9 points
        criticalIntegrity: scenario.dataIntegrityCritical,   // 8 points
        crossDocumentConsistency: scenario.multipleEntities, // 7 points

        // Facteurs favorisant BASE (eventual consistency)
        highThroughput: scenario.requestsPerSecond > 5000,   // -8 points
        globalDistribution: scenario.multiRegion,            // -7 points
        readHeavy: scenario.readWriteRatio > 10,            // -6 points
        toleratesStale: scenario.acceptsStaleData            // -5 points
    };

    const score = Object.entries(factors).reduce((sum, [key, value]) => {
        if (typeof value === 'boolean') {
            return sum + (value ? factors[key + 'Weight'] || 5 : 0);
        }
        return sum + (value ? -8 : 0); // Facteurs nÃ©gatifs
    }, 0);

    if (score > 15) return "ACID_STRICT";
    if (score > 5) return "ACID_MODERATE";
    if (score > -5) return "HYBRID";
    if (score > -15) return "BASE_MODERATE";
    return "BASE_FULL";
}

// Exemples d'application

// CAS 1 : Transfert bancaire
const bankTransfer = {
    involvesFinancial: true,           // +10
    requiresCompliance: true,          // +9
    dataIntegrityCritical: true,       // +8
    multipleEntities: true,            // +7
    requestsPerSecond: 100,            // 0
    multiRegion: false,                // 0
    readWriteRatio: 1,                 // 0
    acceptsStaleData: false            // 0
};
// Score : 34 â†’ ACID_STRICT âœ“

const strategy = `
writeConcern: { w: "majority", j: true },
readConcern: { level: "linearizable" },
transaction: required
`;

// CAS 2 : Feed rÃ©seaux sociaux
const socialFeed = {
    involvesFinancial: false,          // 0
    requiresCompliance: false,         // 0
    dataIntegrityCritical: false,      // 0
    multipleEntities: false,           // 0
    requestsPerSecond: 50000,          // -8
    multiRegion: true,                 // -7
    readWriteRatio: 100,               // -6
    acceptsStaleData: true             // -5
};
// Score : -26 â†’ BASE_FULL âœ“

const strategyBase = `
writeConcern: { w: 1 },
readPreference: "nearest",
readConcern: { level: "local" },
transaction: not needed
`;

// CAS 3 : E-commerce checkout
const ecommerceCheckout = {
    involvesFinancial: true,           // +10
    requiresCompliance: false,         // 0
    dataIntegrityCritical: true,       // +8
    multipleEntities: true,            // +7
    requestsPerSecond: 2000,           // 0
    multiRegion: true,                 // -7
    readWriteRatio: 3,                 // 0
    acceptsStaleData: false            // 0
};
// Score : 18 â†’ ACID_STRICT âœ“ (mais avec optimisations)

const strategyHybrid = `
// Commande : ACID strict
writeConcern: { w: "majority" },
transaction: required for order creation

// Analytics : BASE
writeConcern: { w: 1 },
eventual consistency acceptable
`;
```

## Conclusion : La Convergence Pragmatique

MongoDB incarne la convergence entre les paradigmes ACID et BASE, offrant aux architectes la flexibilitÃ© de choisir le niveau de garanties appropriÃ© pour chaque opÃ©ration. Cette flexibilitÃ© n'est pas une faiblesse mais une force : elle reconnaÃ®t que le monde rÃ©el n'est pas binaire.

### Principes Directeurs

1. **ACID par dÃ©faut pour les opÃ©rations critiques** : Transactions financiÃ¨res, modifications d'Ã©tat important, donnÃ©es lÃ©gales

2. **BASE pour la scalabilitÃ©** : Analytics, feeds temps rÃ©el, mÃ©triques, logs

3. **Hybrid pour la majoritÃ©** : Combiner ACID strict pour l'Ã©criture critique avec BASE pour les lectures et les opÃ©rations secondaires

4. **Mesurer, pas supposer** : Benchmarker les compromis rÃ©els dans votre contexte spÃ©cifique

### L'Avenir

La tendance actuelle montre une convergence continue :
- Les bases NoSQL ajoutent plus de garanties ACID
- Les bases SQL adoptent des fonctionnalitÃ©s NoSQL (JSON, scalabilitÃ© horizontale)
- Les architectures modernes utilisent les deux paradigmes de maniÃ¨re complÃ©mentaire

MongoDB, en offrant le spectre complet de ACID Ã  BASE, se positionne comme un outil pragmatique pour l'Ã¨re moderne des donnÃ©es distribuÃ©es.

---


â­ï¸ [Comparaison avec les bases relationnelles](/08-transactions/01.3-comparaison-bases-relationnelles.md)
