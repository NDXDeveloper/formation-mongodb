üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.4.1 Read Concern (local, available, majority, linearizable, snapshot)

## Introduction aux niveaux de Read Concern

Le Read Concern d√©finit le niveau de garantie sur les donn√©es qu'une op√©ration de lecture peut retourner. Il s'agit d'un m√©canisme fondamental qui permet de naviguer dans le spectre entre performance maximale et coh√©rence stricte. Contrairement aux niveaux d'isolation traditionnels des bases relationnelles (READ UNCOMMITTED, READ COMMITTED, etc.), les Read Concerns de MongoDB sont sp√©cifiquement con√ßus pour les syst√®mes distribu√©s avec r√©plication asynchrone.

Chaque niveau de Read Concern r√©pond √† trois questions critiques :

1. **Durabilit√©** : Les donn√©es lues ont-elles √©t√© r√©pliqu√©es ou peuvent-elles √™tre annul√©es (rollback) ?
2. **Fra√Æcheur** : √Ä quel point les donn√©es sont-elles √† jour par rapport aux derni√®res √©critures ?
3. **Visibilit√©** : Puis-je voir des donn√©es non encore committ√©es ou non encore durables ?

## Spectre des Read Concerns

Les cinq niveaux de Read Concern forment un continuum progressif :

```
Performance ‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Üí Coh√©rence
Disponibilit√©                                    Durabilit√©

available ‚Üí local ‚Üí majority ‚Üí linearizable
                                    ‚Üì
                                snapshot (contexte transactionnel)
```

## Read Concern: "local"

### D√©finition et comportement

`local` est le niveau de Read Concern par d√©faut pour les lectures hors transaction. Avec ce niveau, une op√©ration de lecture retourne les donn√©es les plus r√©centes disponibles sur le n≈ìud interrog√©, **sans aucune garantie de durabilit√©**.

**Caract√©ristiques techniques** :

- Lit depuis la vue locale du n≈ìud (Primary ou Secondary selon Read Preference)
- Aucune v√©rification de r√©plication
- Peut retourner des donn√©es qui seront ult√©rieurement annul√©es (rollback)
- Latence minimale : pas d'attente de confirmation de r√©plication

### Garanties et limites

**Ce que `local` garantit** :
- Lecture des donn√©es telles qu'elles existent sur le n≈ìud au moment de la requ√™te
- Coh√©rence de lecture (read-your-own-writes) sur un m√™me n≈ìud

**Ce que `local` ne garantit PAS** :
- Durabilit√© des donn√©es lues
- Protection contre les rollbacks
- Coh√©rence entre plusieurs lectures cons√©cutives sur des n≈ìuds diff√©rents

### Sc√©nario de rollback

Comprendre le risque de rollback est crucial pour utiliser `local` en connaissance de cause :

```
Timeline d'un rollback avec Read Concern: local

T0 : Primary A √©crit document { _id: 1, status: "confirmed" }
T1 : Lecture avec readConcern:local retourne status="confirmed"
T2 : Primary A perd la connexion avec la majorit√© du Replica Set
T3 : Primary B est √©lu (ne poss√®de pas cette √©criture)
T4 : Primary A revient en ligne, d√©tecte le conflit
T5 : ROLLBACK : Le document revient √† son √©tat ant√©rieur ou est supprim√©
T6 : Les donn√©es lues en T1 n'ont jamais "exist√©" du point de vue du cluster
```

### Cas d'usage appropri√©s

**1. Dashboards et m√©triques non critiques**

```javascript
// Tableau de bord d'administration : statistiques approximatives
db.orders.aggregate([
  { $match: { status: "completed", date: { $gte: today } } },
  { $group: { _id: null, total: { $sum: "$amount" }, count: { $sum: 1 } } }
], {
  readConcern: { level: "local" },
  readPreference: "secondaryPreferred" // D√©charge le Primary
});

// Rationale : Des chiffres l√©g√®rement obsol√®tes ou approximatifs sont acceptables
// Gain : Latence minimale, pas d'impact sur le Primary
```

**2. Recherches et filtres utilisateur**

```javascript
// Moteur de recherche de produits : catalogue e-commerce
db.products.find(
  {
    category: "electronics",
    price: { $lt: 500 },
    inStock: true
  },
  { readConcern: { level: "local" } }
).limit(20);

// Rationale : Si un produit appara√Æt disponible puis ne l'est plus, ce n'est pas grave
// L'utilisateur verra l'erreur au moment du panier
```

**3. Lectures haute fr√©quence depuis Secondaries**

```javascript
// API de contenu statique (articles de blog, documentation)
db.articles.findOne(
  { slug: "mongodb-replication-guide" },
  {
    readConcern: { level: "local" },
    readPreference: "nearest" // N≈ìud le plus proche g√©ographiquement
  }
);

// Rationale : Contenu rarement modifi√©, priorit√© √† la latence minimale
// Distribution g√©ographique optimale
```

### M√©triques de performance

Pour un Replica Set √† 3 n≈ìuds dans le m√™me datacenter :

```
Read Concern: local
- Latence P50 : 2-5ms
- Latence P99 : 8-15ms
- Throughput : ~50,000 ops/sec (lecture depuis Secondaries)
- Replication Lag impact : Aucun (lit la vue locale)
```

### Antipattern : Utiliser `local` pour des donn√©es financi√®res

```javascript
// ‚ùå DANGEREUX : Validation de solde avec readConcern:local
async function processPaiement(userId, montant) {
  const user = await db.users.findOne(
    { _id: userId },
    { readConcern: { level: "local" } }
  );

  if (user.balance >= montant) {
    // PROBL√àME : Si un rollback se produit, le solde lu peut √™tre incorrect
    // On pourrait autoriser un paiement avec un solde insuffisant
    await debitAccount(userId, montant);
  }
}

// ‚úÖ CORRECT : Utiliser au minimum "majority"
const user = await db.users.findOne(
  { _id: userId },
  { readConcern: { level: "majority" } }
);
```

## Read Concern: "available"

### D√©finition et comportement

`available` est similaire √† `local` mais est sp√©cifiquement con√ßu pour les **clusters shard√©s**. Il retourne les donn√©es disponibles sur le shard sans v√©rifier si les donn√©es ont √©t√© migr√©es vers un autre shard.

**Diff√©rence cl√© avec `local`** :

Dans un cluster shard√©, les chunks (partitions de donn√©es) peuvent √™tre migr√©s entre shards. Avec `available`, une lecture peut retourner des donn√©es qui sont en cours de migration et potentiellement pr√©sentes sur deux shards simultan√©ment (orphan documents).

### Probl√®me des "orphan documents"

```
Situation de migration de chunk :

Shard A (source) :          Shard B (destination) :
- docs 1-1000              - docs 1-1000 (copi√©s)
- Migration en cours       - Pas encore finalis√©

Avec readConcern:available sur Shard A et B :
- Une requ√™te scatter/gather peut voir le document 500 deux fois
- Un comptage peut √™tre incorrect

Avec readConcern:local (ou majority) :
- Les orphan documents sont filtr√©s
- R√©sultats coh√©rents
```

### Cas d'usage : Performances extr√™mes en sharding

`available` ne devrait √™tre utilis√© que lorsque :

1. Les lectures depuis un cluster shard√© doivent √™tre absolument les plus rapides possibles
2. Les duplications temporaires ou incoh√©rences sont tol√©rables
3. La logique applicative peut g√©rer les doublons

**Exemple : Logs d'analyse non critiques**

```javascript
// Analyse de logs agr√©g√©s : tol√©rance aux doublons
db.logs.aggregate([
  { $match: { timestamp: { $gte: lastHour } } },
  { $group: { _id: "$eventType", count: { $sum: 1 } } }
], {
  readConcern: { level: "available" },
  // Peut compter certains √©v√©nements deux fois pendant migrations
  // mais c'est acceptable pour des statistiques approximatives
});
```

### Recommandation

**Dans 99% des cas, pr√©f√©rez `local` √† `available`**. La diff√©rence de performance est n√©gligeable, et `local` √©vite les surprises li√©es aux migrations de chunks. `available` est un niveau d'optimisation avanc√© pour des cas tr√®s sp√©cifiques.

## Read Concern: "majority"

### D√©finition et comportement

`majority` est le niveau de Read Concern recommand√© pour les **donn√©es critiques**. Il garantit que les donn√©es lues ont √©t√© r√©pliqu√©es sur une majorit√© des membres du Replica Set et ne pourront pas √™tre annul√©es en cas de rollback.

**M√©canisme technique** :

MongoDB maintient une vue "majority committed" des donn√©es, repr√©sentant l'√©tat qui a √©t√© acquitt√© par la majorit√© des n≈ìuds. Une lecture avec `readConcern:majority` ne retourne que les donn√©es appartenant √† cette vue.

```
Replica Set √† 3 n≈ìuds (P = Primary, S = Secondary) :

T0 : P √©crit doc { _id: 1, value: "A" }
T1 : R√©plication vers S1 (2/3 = majorit√© atteinte)
     ‚Üí La vue "majority committed" inclut maintenant ce document
T2 : Lecture avec readConcern:majority ‚Üí Retourne value="A"
T3 : P √©crit doc { _id: 1, value: "B" }
T4 : Lecture avec readConcern:majority ‚Üí Retourne encore value="A"
     ‚Üí Car "B" n'est pas encore r√©pliqu√© sur la majorit√©
T5 : R√©plication de "B" vers S1
T6 : Lecture avec readConcern:majority ‚Üí Retourne value="B"
```

### Garanties fondamentales

**Ce que `majority` garantit** :

1. **Protection contre les rollbacks** : Les donn√©es lues ne seront jamais annul√©es
2. **Durabilit√©** : Les donn√©es ont √©t√© persist√©es sur plusieurs n≈ìuds
3. **Coh√©rence causale** : Avec les sessions causales, garantit l'ordre des op√©rations

**Ce que `majority` ne garantit PAS** :

- Donn√©es absolument les plus r√©centes (il peut y avoir un d√©lai de r√©plication)
- Isolation entre plusieurs lectures (sans snapshot)

### Cas d'usage essentiels

**1. Op√©rations financi√®res et transactionnelles**

```javascript
// Transfert bancaire : v√©rification du solde avant d√©bit
const session = client.startSession({
  causalConsistency: true
});

try {
  // Lecture du solde avec garantie anti-rollback
  const account = await db.accounts.findOne(
    { accountId: "ACC123" },
    {
      readConcern: { level: "majority" },
      session
    }
  );

  if (account.balance >= transferAmount) {
    // L'√©criture sera coh√©rente avec la lecture
    await db.accounts.updateOne(
      { accountId: "ACC123" },
      { $inc: { balance: -transferAmount } },
      {
        writeConcern: { w: "majority" },
        session
      }
    );
  }
} finally {
  await session.endSession();
}

// Rationale : Aucun risque de double d√©bit d√ª √† un rollback
```

**2. Syst√®mes de r√©servation et inventaire**

```javascript
// R√©servation de place : lecture critique du stock
async function reserverPlace(eventId, userId) {
  const event = await db.events.findOne(
    { _id: eventId },
    { readConcern: { level: "majority" } }
  );

  if (event.placesDisponibles > 0) {
    // Tentative de r√©servation atomique
    const result = await db.events.findOneAndUpdate(
      {
        _id: eventId,
        placesDisponibles: { $gt: 0 }
      },
      {
        $inc: { placesDisponibles: -1 },
        $push: { reservations: { userId, date: new Date() } }
      },
      {
        readConcern: { level: "majority" },
        writeConcern: { w: "majority" },
        returnDocument: "after"
      }
    );

    return result.value !== null;
  }
  return false;
}

// Rationale : √âvite les surr√©servations dues √† des lectures non durables
```

**3. Audit et conformit√©**

```javascript
// Consultation de logs d'audit : donn√©es r√©glementaires
db.auditLogs.find(
  {
    userId: "USER123",
    action: "data_access",
    timestamp: { $gte: startDate, $lte: endDate }
  },
  { readConcern: { level: "majority" } }
);

// Rationale : Les audits doivent refl√©ter l'√©tat durable du syst√®me
// Aucun √©v√©nement ne doit "dispara√Ætre" apr√®s consultation
```

### Impact sur les performances

```
Read Concern: majority vs local (Replica Set 3 n≈ìuds, m√™me DC)

Configuration :                      Latence P50    Latence P99
-----------------------------------------------------------------
readConcern: local                   2ms            8ms
readConcern: majority (lag=10ms)     12ms           25ms
readConcern: majority (lag=100ms)    105ms          180ms
readConcern: majority (lag=1s)       1.01s          1.5s
```

**Facteur cl√©** : Le Replication Lag a un impact direct et proportionnel sur les performances de `readConcern:majority`.

### Optimisation du Replication Lag

Pour maintenir les performances avec `majority`, il faut surveiller et optimiser :

**1. Latence r√©seau entre les n≈ìuds**
- D√©ployer les membres du Replica Set dans le m√™me datacenter ou region
- Utiliser des connexions r√©seau d√©di√©es et rapides

**2. Charge du syst√®me**
- Monitorer l'utilisation CPU/IO des Secondaries
- Redimensionner si les Secondaries ne suivent pas

**3. Configuration WiredTiger**
- Ajuster `secondaryDelaySecs` si n√©cessaire
- Optimiser la taille du cache

**Monitoring critique** :

```javascript
// V√©rifier le Replication Lag
db.getReplicationInfo()

// Alerter si lag > 5 secondes
db.serverStatus().repl.members.forEach(member => {
  if (member.lag > 5000) {
    console.error(`‚ö†Ô∏è  Member ${member.name} has lag: ${member.lag}ms`);
  }
});
```

## Read Concern: "linearizable"

### D√©finition et comportement

`linearizable` est le niveau de Read Concern le **plus strict** de MongoDB. Il garantit que les lectures refl√®tent toutes les √©critures confirm√©es avec `writeConcern:majority` qui ont √©t√© acquitt√©es avant le d√©but de la lecture, et que la lecture elle-m√™me est acquitt√©e par la majorit√©.

**En termes simples** : `linearizable` garantit une coh√©rence absolue et une s√©rialisation totale des op√©rations comme si elles s'ex√©cutaient s√©quentiellement sur un seul n≈ìud.

### M√©canisme technique : Read Your Own Writes garanti

```
Timeline avec readConcern:linearizable :

T0 : Client A √©crit doc { _id: 1, value: "X" } avec writeConcern:majority
T1 : √âcriture confirm√©e (r√©pliqu√©e sur majorit√©)
T2 : Client B lit { _id: 1 } avec readConcern:linearizable
     ‚Üí M√©canisme :
       1. V√©rifier que je suis toujours le Primary (heartbeat)
       2. Lire la donn√©e
       3. Confirmer aupr√®s de la majorit√© que je suis toujours Primary
T3 : Client B re√ßoit value="X" avec GARANTIE ABSOLUE

Si entre T2 et T3 une √©lection s'est produite ‚Üí La lecture √©choue (retry)
```

**Diff√©rence critique avec `majority`** :

- `majority` : Lit les donn√©es durables mais peut lire un √©tat l√©g√®rement obsol√®te
- `linearizable` : Lit l'√©tat le plus r√©cent ET garantit qu'aucune √©criture concurrente n'a eu lieu

### Restrictions importantes

`linearizable` a des limitations strictes :

1. **Uniquement disponible pour les lectures de documents simples** (`find()` et `findOne()`)
2. **Ne fonctionne PAS avec** : Agr√©gations, transactions multi-documents
3. **Doit lire depuis le Primary** : Ne peut pas utiliser Read Preference sur Secondaries
4. **Performance p√©nalis√©e** : Requiert des confirmations suppl√©mentaires

### Cas d'usage : Syst√®mes exigeant des garanties absolues

**1. Verrous distribu√©s (Distributed Locks)**

```javascript
// Impl√©mentation d'un verrou distribu√© avec linearizable
async function acquireLock(resourceId, clientId, ttlSeconds) {
  try {
    const result = await db.locks.findOneAndUpdate(
      {
        _id: resourceId,
        $or: [
          { locked: false },
          { expiresAt: { $lt: new Date() } }
        ]
      },
      {
        $set: {
          locked: true,
          ownerId: clientId,
          expiresAt: new Date(Date.now() + ttlSeconds * 1000)
        }
      },
      {
        readConcern: { level: "linearizable" },
        writeConcern: { w: "majority" },
        returnDocument: "after"
      }
    );

    return result.value !== null;
  } catch (error) {
    if (error.code === 112) { // WriteConflict
      // Retry avec backoff exponentiel
      return acquireLock(resourceId, clientId, ttlSeconds);
    }
    throw error;
  }
}

// Rationale : AUCUNE possibilit√© de double acquisition
// M√™me en cas d'√©lection de Primary pendant l'op√©ration
```

**2. Leader Election dans un syst√®me distribu√©**

```javascript
// √âlection de leader : un seul n≈ìud peut gagner
async function electLeader(nodeId) {
  const election = await db.elections.findOne(
    { _id: "current_term" },
    { readConcern: { level: "linearizable" } }
  );

  if (!election || !election.leader) {
    // Tenter de devenir le leader
    const result = await db.elections.updateOne(
      {
        _id: "current_term",
        leader: { $exists: false }
      },
      {
        $set: {
          leader: nodeId,
          term: election ? election.term + 1 : 1,
          electedAt: new Date()
        }
      },
      { writeConcern: { w: "majority" } }
    );

    return result.modifiedCount > 0;
  }

  return false;
}

// Rationale : Impossible que deux n≈ìuds se d√©clarent leaders simultan√©ment
```

**3. S√©quences strictement monotones**

```javascript
// G√©n√©ration de num√©ros de facture sans gap ni doublon
async function getNextInvoiceNumber() {
  const counter = await db.counters.findOneAndUpdate(
    { _id: "invoice_counter" },
    { $inc: { value: 1 } },
    {
      readConcern: { level: "linearizable" },
      writeConcern: { w: "majority" },
      returnDocument: "after",
      upsert: true
    }
  );

  return counter.value.value;
}

// Rationale : S√©quence garantie sans trou m√™me en cas de failover
```

### Co√ªt en performance

```
Read Concern: linearizable (Replica Set 3 n≈ìuds)

Latence P50 : 25-50ms
Latence P99 : 80-150ms
Throughput max : ~2,000-5,000 ops/sec

Facteurs d'impact :
- Double round-trip vers la majorit√© (v√©rification Primary)
- Contention si plusieurs clients tentent des op√©rations linearizable simultan√©es
- Augmente drastiquement avec la latence r√©seau
```

**Recommandation** : N'utilisez `linearizable` que pour les op√©rations v√©ritablement critiques n√©cessitant des garanties absolues. Pour la plupart des cas, `majority` avec des sessions causales suffit.

### Quand NE PAS utiliser linearizable

```javascript
// ‚ùå INUTILE : Lecture simple sans √©criture critique
const user = await db.users.findOne(
  { email: "user@example.com" },
  { readConcern: { level: "linearizable" } } // Surco√ªt inutile
);

// ‚úÖ SUFFISANT : majority convient parfaitement
const user = await db.users.findOne(
  { email: "user@example.com" },
  { readConcern: { level: "majority" } }
);
```

## Read Concern: "snapshot"

### D√©finition et comportement

`snapshot` est un niveau de Read Concern sp√©cifique au **contexte transactionnel**. Il garantit que toutes les lectures dans une transaction voient un snapshot coh√©rent de la base de donn√©es pris au d√©but de la transaction.

**Propri√©t√© d'isolation MVCC (Multi-Version Concurrency Control)** :

MongoDB utilise le moteur WiredTiger qui maintient plusieurs versions des documents. `snapshot` assure que la transaction voit toujours la m√™me version, m√™me si des √©critures concurrentes modifient les donn√©es.

### Isolation transactionnelle

```
Transaction avec readConcern:snapshot :

Transaction A commence √† T0
T0 : Snapshot cr√©√© ‚Üí Version des donn√©es √† T0
T1 : Transaction A lit doc1 ‚Üí Voit version T0
T2 : Transaction B √©crit doc1 (nouvelle valeur)
T3 : Transaction B commit
T4 : Transaction A lit doc1 ‚Üí Voit ENCORE version T0 (isolation)
T5 : Transaction A lit doc2 ‚Üí Voit version T0
T6 : Transaction A commit

Garantie : Toutes les lectures dans Transaction A voient l'√©tat √† T0
```

### Diff√©rence avec les autres Read Concerns en transaction

```javascript
// readConcern:snapshot (d√©faut pour transactions)
const session = client.startSession();
session.startTransaction({
  readConcern: { level: "snapshot" },
  writeConcern: { w: "majority" }
});

// Toutes les lectures voient le m√™me snapshot
const user = await db.users.findOne({ _id: userId }, { session });
const orders = await db.orders.find({ userId }, { session });
// ‚Üí Coh√©rence garantie entre user et orders

await session.commitTransaction();
```

**vs**

```javascript
// Sans snapshot (reads s√©par√©s)
const user = await db.users.findOne({ _id: userId });
// ‚ö†Ô∏è Ici, un autre thread peut modifier l'utilisateur
const orders = await db.orders.find({ userId });
// ‚Üí Risque d'incoh√©rence : orders peut r√©f√©rencer un √©tat diff√©rent de user
```

### Cas d'usage : Transactions multi-documents

**1. Transfert bancaire atomique**

```javascript
async function transfererArgent(fromAccountId, toAccountId, montant) {
  const session = client.startSession();

  try {
    await session.withTransaction(async () => {
      // Snapshot garantit que les deux comptes sont lus dans le m√™me √©tat
      const fromAccount = await db.accounts.findOne(
        { _id: fromAccountId },
        { session }
      );

      if (fromAccount.balance < montant) {
        throw new Error("Solde insuffisant");
      }

      // D√©bit et cr√©dit atomiques
      await db.accounts.updateOne(
        { _id: fromAccountId },
        { $inc: { balance: -montant } },
        { session }
      );

      await db.accounts.updateOne(
        { _id: toAccountId },
        { $inc: { balance: montant } },
        { session }
      );

      // Enregistrement de la transaction
      await db.transactions.insertOne({
        from: fromAccountId,
        to: toAccountId,
        amount: montant,
        timestamp: new Date()
      }, { session });

    }, {
      readConcern: { level: "snapshot" },
      writeConcern: { w: "majority" },
      readPreference: "primary"
    });

    console.log("Transfert r√©ussi");
  } catch (error) {
    console.error("√âchec du transfert:", error);
  } finally {
    await session.endSession();
  }
}
```

**2. Calcul de rapport multi-collections**

```javascript
async function genererRapportMensuel(mois, annee) {
  const session = client.startSession();

  try {
    await session.withTransaction(async () => {
      // Snapshot garantit la coh√©rence entre toutes les collections
      const ventes = await db.sales.aggregate([
        { $match: { mois, annee } },
        { $group: { _id: null, total: { $sum: "$montant" } } }
      ], { session }).toArray();

      const depenses = await db.expenses.aggregate([
        { $match: { mois, annee } },
        { $group: { _id: null, total: { $sum: "$montant" } } }
      ], { session }).toArray();

      const stock = await db.inventory.aggregate([
        { $group: { _id: null, valeurTotale: { $sum: "$valeur" } } }
      ], { session }).toArray();

      // Cr√©ation du rapport avec des donn√©es coh√©rentes
      await db.reports.insertOne({
        mois,
        annee,
        ventes: ventes[0]?.total || 0,
        depenses: depenses[0]?.total || 0,
        stockFinal: stock[0]?.valeurTotale || 0,
        profit: (ventes[0]?.total || 0) - (depenses[0]?.total || 0),
        genereLe: new Date()
      }, { session });

    }, {
      readConcern: { level: "snapshot" },
      writeConcern: { w: "majority" }
    });

  } finally {
    await session.endSession();
  }
}
```

### Snapshot et conflit d'√©criture (Write Conflicts)

Un aspect crucial de `snapshot` : les transactions peuvent √©chouer avec une erreur `WriteConflict` si deux transactions tentent de modifier les m√™mes documents.

```
Timeline de Write Conflict :

T0 : Transaction A d√©marre (snapshot √† T0)
T1 : Transaction B d√©marre (snapshot √† T1)
T2 : Transaction A modifie doc1
T3 : Transaction B modifie doc1
T4 : Transaction A commit ‚Üí Succ√®s
T5 : Transaction B commit ‚Üí √âCHEC (WriteConflict)
     ‚Üí doc1 a √©t√© modifi√© depuis le snapshot de B

R√©solution : Transaction B doit retry
```

**Gestion des Write Conflicts** :

```javascript
async function updateWithRetry(collection, filter, update, maxRetries = 3) {
  const session = client.startSession();

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      await session.withTransaction(async () => {
        await collection.updateOne(filter, update, { session });
      }, {
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" }
      });

      return; // Succ√®s

    } catch (error) {
      if (error.hasErrorLabel('TransientTransactionError') && attempt < maxRetries - 1) {
        console.log(`Retry attempt ${attempt + 1}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, attempt)));
        continue;
      }
      throw error;
    } finally {
      if (attempt === maxRetries - 1) {
        await session.endSession();
      }
    }
  }
}
```

### Performance des transactions snapshot

```
Transactions avec readConcern:snapshot

Latence transaction simple (2 ops) :    50-100ms
Latence transaction complexe (10 ops) : 150-300ms
Throughput maximal :                    ~1,000-3,000 tx/sec

Facteurs limitants :
- Contention sur les documents hot
- Dur√©e de la transaction (holding locks)
- Taille du journal transactionnel (oplog)
```

**Optimisation des transactions** :

1. **Minimiser la dur√©e** : Ne faire que le n√©cessaire dans la transaction
2. **√âviter les hot documents** : R√©partir les modifications
3. **Utiliser des index** : Acc√©l√©rer les lectures transactionnelles
4. **Limiter le nombre d'op√©rations** : < 1000 ops par transaction recommand√©

## Comparaison et aide au choix

### Tableau r√©capitulatif

| Read Concern | Durabilit√© | Fra√Æcheur | Latence | Cas d'usage principal |
|--------------|------------|-----------|---------|----------------------|
| **available** | ‚ùå Aucune | ‚úÖ Maximale | ‚ö° <5ms | Sharding avec tol√©rance aux doublons |
| **local** | ‚ùå Aucune | ‚úÖ Maximale | ‚ö° <5ms | Dashboards, recherches non critiques |
| **majority** | ‚úÖ Garantie | ‚ö†Ô∏è D√©pend du lag | üî∂ 10-50ms | Donn√©es financi√®res, inventaire |
| **linearizable** | ‚úÖ‚úÖ Absolue | ‚úÖ‚úÖ Absolue | üî¥ 50-150ms | Verrous distribu√©s, leader election |
| **snapshot** | ‚úÖ Garantie | ‚úÖ Coh√©rente | üî∂ 50-300ms | Transactions multi-documents |

### Arbre de d√©cision

```
Ai-je besoin de transactions multi-documents ?
‚îÇ
‚îú‚îÄ OUI ‚Üí snapshot (obligatoire en transaction)
‚îÇ
‚îî‚îÄ NON ‚Üí L'op√©ration est-elle critique pour le business ?
    ‚îÇ
    ‚îú‚îÄ NON ‚Üí Recherches, analytics, dashboards ?
    ‚îÇ   ‚îî‚îÄ OUI ‚Üí local (ou available en sharding si doublons OK)
    ‚îÇ
    ‚îî‚îÄ OUI ‚Üí Besoin de garanties de linearizability absolue ?
        ‚îÇ
        ‚îú‚îÄ OUI ‚Üí Verrous distribu√©s, leader election ?
        ‚îÇ   ‚îî‚îÄ OUI ‚Üí linearizable
        ‚îÇ
        ‚îî‚îÄ NON ‚Üí majority (recommand√© par d√©faut pour donn√©es critiques)
```

### Exemples de configuration par type d'application

**Application e-commerce :**

```javascript
// Configuration diff√©renci√©e
const readConcernConfig = {
  // Catalogue produits : performance
  productSearch: { level: "local" },

  // Stock disponible : coh√©rence importante
  inventoryCheck: { level: "majority" },

  // Paiement : transactions atomiques
  payment: { level: "snapshot" }, // Dans une transaction

  // Prix et promotions : donn√©es critiques
  pricing: { level: "majority" }
};
```

**Application bancaire :**

```javascript
// Configuration stricte
const readConcernConfig = {
  // Consultation de solde : durable
  balanceQuery: { level: "majority" },

  // Historique des transactions : audit
  transactionHistory: { level: "majority" },

  // Transfert d'argent : isolation compl√®te
  transfer: { level: "snapshot" }, // Transaction multi-doc

  // Acquisition de verrou pour gros virements
  largeFundsLock: { level: "linearizable" }
};
```

**Application de r√©seau social :**

```javascript
// Configuration orient√©e performance
const readConcernConfig = {
  // Fil d'actualit√© : tol√©rance √† la latence
  newsFeed: { level: "local" },

  // Publications r√©centes : local suffisant
  userPosts: { level: "local" },

  // Messages priv√©s : coh√©rence importante
  privateMessages: { level: "majority" },

  // Compteurs de followers : approximatif acceptable
  followerCount: { level: "local" }
};
```

## Interaction avec Write Concern

Le Read Concern n'est efficace que s'il est coordonn√© avec un Write Concern appropri√© :

```javascript
// ‚ùå INCOH√âRENT : √âcriture non durable + lecture durable
await db.collection.insertOne(
  { data: "important" },
  { writeConcern: { w: 1 } } // Pas de garantie de r√©plication
);

const doc = await db.collection.findOne(
  { data: "important" },
  { readConcern: { level: "majority" } } // Peut ne pas voir le document !
);

// ‚úÖ COH√âRENT : Garanties align√©es
await db.collection.insertOne(
  { data: "important" },
  { writeConcern: { w: "majority" } }
);

const doc = await db.collection.findOne(
  { data: "important" },
  { readConcern: { level: "majority" } }
);
```

## Conclusion

Les diff√©rents niveaux de Read Concern offrent une flexibilit√© essentielle pour optimiser le comportement de votre application MongoDB selon les besoins sp√©cifiques de chaque op√©ration. Le choix du bon niveau n√©cessite de comprendre :

1. **Les garanties de durabilit√© requises** : Vos donn√©es peuvent-elles √™tre perdues ?
2. **Les exigences de fra√Æcheur** : Tol√©rez-vous des donn√©es l√©g√®rement obsol√®tes ?
3. **Le budget de latence** : Quel d√©lai est acceptable ?
4. **Le contexte d'ex√©cution** : Standalone, replica set, ou transaction ?

Dans la section suivante, nous explorerons en d√©tail les niveaux de Write Concern et leur interaction avec les Read Concerns pour former une strat√©gie de coh√©rence compl√®te.

---

**Points cl√©s √† retenir** :

- `local` : Performance maximale, aucune garantie de durabilit√©
- `available` : Similaire √† local, sp√©cifique au sharding (utilisez local dans le doute)
- `majority` : √âquilibre recommand√© pour les donn√©es importantes
- `linearizable` : Garanties absolues pour les op√©rations critiques (co√ªt √©lev√©)
- `snapshot` : Isolation transactionnelle (obligatoire en transaction multi-documents)
- Alignez toujours Read Concern et Write Concern pour des garanties coh√©rentes
- Mesurez l'impact du Replication Lag sur les performances de `majority`

‚è≠Ô∏è [Write Concern (w, j, wtimeout)](/08-transactions/04.2-write-concern.md)
