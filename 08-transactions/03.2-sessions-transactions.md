üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.2 Sessions et Transactions

## Introduction

Les sessions sont le m√©canisme fondamental qui permet l'existence des transactions multi-documents dans MongoDB. Sans sessions, MongoDB ne pourrait pas maintenir l'√©tat transactionnel, garantir l'isolation snapshot, ou coordonner les op√©rations distribu√©es. Comprendre les sessions en profondeur est essentiel pour ma√Ætriser les transactions, d√©boguer les probl√®mes de performance, et √©viter les fuites de ressources critiques.

Cette section explore l'architecture des sessions, leur cycle de vie, leurs options de configuration, et les pi√®ges courants √† √©viter.

## Anatomie d'une Session MongoDB

### Qu'est-ce qu'une Session ?

Une **session** dans MongoDB est un objet c√¥t√© serveur qui maintient l'√©tat contextuel pour une s√©quence d'op√©rations li√©es. C'est l'√©quivalent d'une "connexion logique avec √©tat" au-dessus de la connexion physique au serveur.

```javascript
// Structure conceptuelle d'une session

{
    // Identifiant unique de la session
    id: {
        id: Binary(UUID, 4)  // UUID v4
    },

    // Timestamp logique (Lamport clock)
    clusterTime: Timestamp(1701963000, 1),
    operationTime: Timestamp(1701963000, 1),

    // √âtat transactionnel (si transaction active)
    txnNumber: NumberLong(1),           // Num√©ro de transaction
    txnState: "inProgress",             // √âtat : inProgress | committed | aborted
    txnRetryCounter: 0,

    // Configuration transactionnelle
    transactionOptions: {
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" },
        readPreference: { mode: "primary" }
    },

    // Snapshot pour isolation
    atClusterTime: Timestamp(1701963000, 1),

    // M√©tadonn√©es de gestion
    lastUse: ISODate("2024-12-07T10:30:00Z"),
    expiresAt: ISODate("2024-12-07T11:00:00Z"),  // 30 min par d√©faut

    // Causal consistency
    operationTime: Timestamp(1701963000, 1)
}
```

### Cr√©ation et Cycle de Vie

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 1 : CR√âATION DE SESSION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const session = client.startSession({
    // Options de causal consistency
    causalConsistency: true,  // D√©faut: true

    // Options par d√©faut pour les transactions
    defaultTransactionOptions: {
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority", j: true },
        readPreference: "primary",
        maxCommitTimeMS: 60000
    }
});

// Que se passe-t-il en interne ?
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// C√¥t√© Client (Driver) :
// 1. G√©n√©ration d'un UUID unique pour la session
// 2. Cr√©ation d'un objet Session local
// 3. Initialisation des compteurs (txnNumber = 0)
// 4. PAS encore de communication serveur
//
// C√¥t√© Serveur :
// - Rien pour l'instant (cr√©ation lazy)
// - Le serveur ne sait pas encore que la session existe

console.log(session.id);
// Output: { id: Binary(Buffer.from(...), 4) }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 2 : PREMI√àRE UTILISATION (Lazy Initialization)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

await collection.insertOne(
    { data: "first operation" },
    { session }  // ‚Üê Premi√®re utilisation de la session
);

// Que se passe-t-il en interne ?
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// T=0ms : Driver envoie la commande au serveur
// Command: {
//     insert: "collection",
//     documents: [{ data: "first operation" }],
//     lsid: { id: UUID("...") },  // ‚Üê Session ID inclus
//     $clusterTime: { ... },
//     $db: "mydb"
// }
//
// T=1ms : Serveur re√ßoit la commande
// 1. V√©rifie si session existe dans le cache
// 2. Si non, cr√©e une nouvelle entr√©e de session
// 3. Initialise les m√©tadonn√©es
// 4. Enregistre lastUse = now
// 5. Fixe expiresAt = now + 30 minutes
//
// T=2ms : Op√©ration ex√©cut√©e
// T=3ms : R√©ponse au client avec clusterTime mis √† jour

// Cache serveur des sessions (simplifi√©) :
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Session Cache (in-memory)                           ‚îÇ
// ‚îÇ                                                     ‚îÇ
// ‚îÇ UUID-1234 ‚Üí {                                       ‚îÇ
// ‚îÇ   lastUse: T0,                                      ‚îÇ
// ‚îÇ   expiresAt: T0 + 30min,                            ‚îÇ
// ‚îÇ   txnNumber: 0,                                     ‚îÇ
// ‚îÇ   clusterTime: Timestamp(...)                       ‚îÇ
// ‚îÇ }                                                   ‚îÇ
// ‚îÇ                                                     ‚îÇ
// ‚îÇ UUID-5678 ‚Üí { ... }                                 ‚îÇ
// ‚îÇ ...                                                 ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 3 : TRANSACTION ACTIVE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

session.startTransaction({
    readConcern: { level: "snapshot" },
    writeConcern: { w: "majority" }
});

// Que se passe-t-il en interne ?
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// C√¥t√© Client :
// 1. session.txnNumber++ (incr√©mentation)
// 2. session.txnState = "starting"
// 3. Capture de l'operation time comme read timestamp
//
// C√¥t√© Serveur (√† la premi√®re op√©ration transactionnelle) :
// 1. Cr√©ation d'un snapshot au timestamp actuel
// 2. txnState ‚Üí "inProgress"
// 3. Enregistrement dans config.transactions
// 4. D√©but du suivi des op√©rations de la transaction

await collection.updateOne(
    { _id: 1 },
    { $set: { value: 100 } },
    { session }
);

// Command envoy√©e :
// {
//     update: "collection",
//     updates: [...],
//     lsid: { id: UUID("...") },           // Session ID
//     txnNumber: NumberLong(1),            // Transaction number
//     startTransaction: true,               // Premi√®re op de la txn
//     autocommit: false,                   // Mode transactionnel
//     readConcern: { level: "snapshot", atClusterTime: Timestamp(...) }
// }

// √âtat serveur :
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Active Transaction                                  ‚îÇ
// ‚îÇ                                                     ‚îÇ
// ‚îÇ Session: UUID-1234                                  ‚îÇ
// ‚îÇ txnNumber: 1                                        ‚îÇ
// ‚îÇ State: inProgress                                   ‚îÇ
// ‚îÇ Snapshot: Timestamp(1701963000, 1)                  ‚îÇ
// ‚îÇ                                                     ‚îÇ
// ‚îÇ Operations:                                         ‚îÇ
// ‚îÇ   - updateOne(collection, { _id: 1 })               ‚îÇ
// ‚îÇ                                                     ‚îÇ
// ‚îÇ Locks acquired: document { _id: 1 }                 ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 4 : COMMIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

await session.commitTransaction();

// Que se passe-t-il en interne ?
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// T=0ms : Client envoie commitTransaction
// Command: {
//     commitTransaction: 1,
//     lsid: { id: UUID("...") },
//     txnNumber: NumberLong(1),
//     autocommit: false,
//     writeConcern: { w: "majority" }
// }
//
// T=1ms : Serveur commence le commit
// 1. Validation finale (pas de conflits)
// 2. Pr√©paration de l'entr√©e applyOps
// 3. √âcriture dans l'oplog
//
// T=5ms : Oplog entry √©crite
// {
//     ts: Timestamp(...),
//     op: "c",
//     ns: "admin.$cmd",
//     o: {
//         applyOps: [
//             { op: "u", ns: "db.collection", o: {...}, o2: {...} }
//         ],
//         lsid: { id: UUID("...") },
//         txnNumber: NumberLong(1)
//     }
// }
//
// T=10ms : R√©plication vers secondaries (w: "majority")
// T=50ms : Majorit√© atteinte
// T=51ms : R√©ponse au client (success)
//
// √âtat final :
// - txnState ‚Üí "committed"
// - Locks rel√¢ch√©s
// - Modifications visibles
// - Transaction termin√©e

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 5 : FIN DE SESSION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

await session.endSession();

// Que se passe-t-il en interne ?
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// C√¥t√© Client :
// 1. Envoi de endSessions au serveur (si possible)
// 2. Lib√©ration des ressources locales
// 3. Invalidation de l'objet session
//
// C√¥t√© Serveur :
// 1. Retrait de la session du cache actif
// 2. Nettoyage des m√©tadonn√©es transactionnelles
// 3. Lib√©ration de la m√©moire
//
// Si endSession() n'est pas appel√© :
// - La session expire apr√®s 30 minutes (d√©faut)
// - Nettoyage automatique par le reaper thread
// - ‚ö† Fuite de ressources si sessions accumul√©es
```

## Options de Configuration des Sessions

### Causal Consistency

La coh√©rence causale garantit que les lectures observent les √©critures dans l'ordre causal, m√™me sur des n≈ìuds diff√©rents.

```javascript
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Sans Causal Consistency
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const sessionNoCausal = client.startSession({
    causalConsistency: false
});

// √âcriture sur le Primary
await users.insertOne(
    { userId: "U001", name: "Alice" },
    { session: sessionNoCausal }
);

// Lecture imm√©diate (peut aller sur un Secondary)
const user = await users.findOne(
    { userId: "U001" },
    {
        session: sessionNoCausal,
        readPreference: "secondaryPreferred"
    }
);

// ‚ö† PROBL√àME : user peut √™tre null
// Raison : Le secondary n'a pas encore r√©pliqu√© l'√©criture
// D√©lai de r√©plication : 10-100ms typique

// Timeline :
// T=0ms  : Write sur Primary (U001 cr√©√©)
// T=5ms  : Response client (√©criture confirm√©e)
// T=10ms : Read depuis Secondary (lag de r√©plication)
// T=10ms : Secondary n'a pas encore U001 ‚Üí null
// T=50ms : R√©plication atteint le Secondary
// T=51ms : Maintenant U001 serait trouv√©

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Avec Causal Consistency (d√©faut)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const sessionCausal = client.startSession({
    causalConsistency: true  // D√©faut
});

// √âcriture sur le Primary
await users.insertOne(
    { userId: "U002", name: "Bob" },
    { session: sessionCausal }
);

// Capture de l'operationTime
// session.operationTime = Timestamp(1701963000, 5)

// Lecture imm√©diate
const user = await users.findOne(
    { userId: "U002" },
    {
        session: sessionCausal,
        readPreference: "secondaryPreferred"
    }
);

// Command envoy√©e au Secondary :
// {
//     find: "users",
//     filter: { userId: "U002" },
//     readConcern: {
//         level: "local",
//         afterClusterTime: Timestamp(1701963000, 5)  // ‚Üê Cl√©
//     }
// }

// Le Secondary attend d'avoir r√©pliqu√© jusqu'√† Timestamp(1701963000, 5)
// avant de r√©pondre

// Timeline :
// T=0ms  : Write sur Primary (U002 cr√©√©) @ Timestamp T5
// T=5ms  : Response client avec operationTime = T5
// T=10ms : Read depuis Secondary avec afterClusterTime = T5
// T=10ms : Secondary v√©rifie son oplog (derni√®re entr√©e : T3)
// T=10ms : Secondary ATTEND (pas encore √† T5)
// T=50ms : R√©plication atteint T5
// T=51ms : Secondary peut maintenant r√©pondre
// T=52ms : U002 trouv√© et retourn√©

// Garantie : ‚úì user n'est jamais null
// Co√ªt : Latence additionnelle (attente de r√©plication)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Causal Consistency : Cas d'usage typique
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function updateUserProfile(userId, updates) {
    const session = client.startSession({
        causalConsistency: true
    });

    try {
        // √âcriture
        await users.updateOne(
            { userId: userId },
            { $set: updates },
            { session }
        );

        // Lecture imm√©diate des donn√©es mises √† jour
        const updatedUser = await users.findOne(
            { userId: userId },
            { session }
        );

        // Garantie : updatedUser refl√®te les modifications
        // M√™me si la lecture va sur un secondary

        return updatedUser;

    } finally {
        await session.endSession();
    }
}

// M√©triques comparatives (Replica Set 3 n≈ìuds, g√©ographiquement distribu√©) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Sans Causal Consistency :
// - Latence read P50 : 8ms
// - Latence read P99 : 25ms
// - Taux read-your-writes failure : 5% (lecture avant r√©plication)
// - N√©cessite retry applicatif
//
// Avec Causal Consistency :
// - Latence read P50 : 45ms (attente r√©plication)
// - Latence read P99 : 120ms
// - Taux read-your-writes failure : 0%
// - Pas de retry n√©cessaire
//
// Trade-off : +35-95ms latence pour garantie read-your-writes
```

### Options de Transaction par D√©faut

```javascript
// Configuration des options transactionnelles au niveau session

const session = client.startSession({
    defaultTransactionOptions: {
        // Read Concern : Niveau de coh√©rence des lectures
        readConcern: {
            level: "snapshot"  // Options : local, available, majority, snapshot, linearizable
        },

        // Write Concern : Garanties d'√©criture
        writeConcern: {
            w: "majority",     // Majorit√© des n≈ìuds
            j: true,           // Journalis√© sur disque
            wtimeout: 5000     // Timeout 5 secondes
        },

        // Read Preference : O√π lire
        readPreference: "primary",  // Options : primary, primaryPreferred, secondary, etc.

        // Timeout de la transaction
        maxCommitTimeMS: 60000  // 60 secondes max
    }
});

// Ces options sont utilis√©es par d√©faut pour toutes les transactions
// de cette session, mais peuvent √™tre surcharg√©es :

session.startTransaction({
    // Override pour cette transaction sp√©cifique
    readConcern: { level: "majority" },
    maxCommitTimeMS: 30000  // Plus court pour cette transaction
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Impact des diff√©rentes combinaisons
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Configuration 1 : Performance maximale (coh√©rence minimale)
const sessionFast = client.startSession({
    causalConsistency: false,
    defaultTransactionOptions: {
        readConcern: { level: "local" },
        writeConcern: { w: 1 },
        readPreference: "nearest"
    }
});

// Caract√©ristiques :
// ‚úì Latence minimale : 10-20ms
// ‚úì Throughput maximum
// ‚ö† Peut lire des donn√©es non durables
// ‚ö† Peut lire des donn√©es stale
// ‚ö† Risque de perte en cas de panne
// Use case : Logs, m√©triques, donn√©es non critiques

// Configuration 2 : √âquilibre
const sessionBalanced = client.startSession({
    causalConsistency: true,
    defaultTransactionOptions: {
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" },
        readPreference: "primary"
    }
});

// Caract√©ristiques :
// ‚úì Coh√©rence forte
// ‚úì Durabilit√© garantie
// ‚ö† Latence mod√©r√©e : 30-80ms
// ‚ö† Throughput r√©duit
// Use case : Applications standard, e-commerce

// Configuration 3 : Coh√©rence maximale
const sessionStrict = client.startSession({
    causalConsistency: true,
    defaultTransactionOptions: {
        readConcern: { level: "linearizable" },
        writeConcern: { w: "majority", j: true },
        readPreference: "primary"
    }
});

// Caract√©ristiques :
// ‚úì Coh√©rence lin√©arisable (la plus forte)
// ‚úì Durabilit√© maximale
// ‚ö† Latence √©lev√©e : 80-200ms
// ‚ö† Throughput faible
// ‚ö† Disponibilit√© r√©duite (n√©cessite majorit√©)
// Use case : Transactions financi√®res, syst√®mes critiques
```

## Gestion du Cycle de Vie : Patterns et Anti-Patterns

### Pattern 1 : Try-Finally (Correct)

```javascript
// ‚úÖ CORRECT : Garantit toujours le nettoyage

async function performTransaction() {
    const session = client.startSession();

    try {
        session.startTransaction();

        await collection1.insertOne({ data: "A" }, { session });
        await collection2.insertOne({ data: "B" }, { session });

        await session.commitTransaction();

        return { success: true };

    } catch (error) {
        // En cas d'erreur, abort automatique
        await session.abortTransaction();

        throw error;
    } finally {
        // ‚ö† CRITIQUE : Toujours endSession dans finally
        await session.endSession();
    }
}

// Garantie : La session est TOUJOURS nettoy√©e
// M√™me si :
// - commitTransaction √©choue
// - Une exception est lev√©e
// - Une promesse est rejet√©e
```

### Anti-Pattern 1 : Oubli de endSession

```javascript
// ‚ùå DANGEREUX : Fuite de ressources

async function performTransactionBAD() {
    const session = client.startSession();
    session.startTransaction();

    await collection1.insertOne({ data: "A" }, { session });
    await collection2.insertOne({ data: "B" }, { session });

    await session.commitTransaction();

    // ‚ùå ERREUR : endSession() jamais appel√©

    return { success: true };
}

// Cons√©quences :
// 1. Session reste en m√©moire c√¥t√© serveur pendant 30 minutes
// 2. Si appel√© 1000 fois : 1000 sessions accumul√©es
// 3. Consommation m√©moire : ~10-50 KB par session
// 4. Total : 10-50 MB de m√©moire "leaked"
// 5. Impact performance : GC fr√©quent, pression m√©moire
//
// Sympt√¥mes observables :
// - Augmentation constante de la RAM serveur
// - Slow queries non expliqu√©es
// - Warning dans les logs : "Session cleanup taking long time"
// - M√©trique db.serverStatus().sessions.activeSessions croissant

// M√©triques d'un incident r√©el :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Application e-commerce, 10k transactions/jour
// Bug : endSession() dans un path non ex√©cut√©
//
// Jour 1 : 10k sessions leaked ‚Üí 500 MB
// Jour 2 : 20k sessions leaked ‚Üí 1 GB
// Jour 7 : 70k sessions leaked ‚Üí 3.5 GB
// Jour 10 : OOM (Out of Memory)
//          Crash du Primary
//          Failover vers Secondary
//          Downtime : 15 minutes
//
// Co√ªt :
// - Perte revenue : $50k (15 min downtime peak hour)
// - Investigation : 8 heures engineering
// - Fix et d√©ploiement : 4 heures
// Total : $60k pour un await session.endSession() manquant
```

### Anti-Pattern 2 : Session R√©utilis√©e Entre Requ√™tes HTTP

```javascript
// ‚ùå TR√àS DANGEREUX : Session partag√©e entre requ√™tes

// Global session (singleton anti-pattern)
let globalSession = null;

async function initializeApp() {
    globalSession = client.startSession();  // ‚ùå BAD
}

// Route HTTP
app.post('/api/order', async (req, res) => {
    try {
        // ‚ùå R√©utilise la session globale
        globalSession.startTransaction();

        await orders.insertOne(req.body.order, { session: globalSession });
        await inventory.updateMany({...}, { session: globalSession });

        await globalSession.commitTransaction();

        res.json({ success: true });
    } catch (error) {
        await globalSession.abortTransaction();
        res.status(500).json({ error: error.message });
    }
});

// Probl√®mes CRITIQUES :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1. Race conditions entre requ√™tes concurrentes
//    - Requ√™te A d√©marre transaction (txnNumber = 1)
//    - Requ√™te B d√©marre transaction (txnNumber = 2)
//    - Requ√™te A essaie de committer txnNumber = 1 (ERREUR)
//    - √âtat incoh√©rent garanti
//
// 2. Transactions entrem√™l√©es
//    - Op√©rations de la requ√™te A et B m√©lang√©es
//    - Commit de A commite aussi les ops de B
//    - Incoh√©rence de donn√©es catastrophique
//
// 3. Sessions zombies
//    - Si une requ√™te plante sans abort
//    - La session reste "in transaction" ind√©finiment
//    - Bloque toutes les requ√™tes suivantes
//
// 4. Impossible √† d√©boguer
//    - Logs montrent op√©rations incoh√©rentes
//    - Impossible de tracer quelle requ√™te a fait quoi

// ‚úÖ CORRECT : Une session par requ√™te

app.post('/api/order', async (req, res) => {
    const session = client.startSession();  // ‚úì Session par requ√™te

    try {
        session.startTransaction();

        await orders.insertOne(req.body.order, { session });
        await inventory.updateMany({...}, { session });

        await session.commitTransaction();

        res.json({ success: true });
    } catch (error) {
        await session.abortTransaction();
        res.status(500).json({ error: error.message });
    } finally {
        await session.endSession();  // ‚úì Nettoyage garanti
    }
});

// Garanties :
// ‚úì Isolation compl√®te entre requ√™tes
// ‚úì Pas de race conditions
// ‚úì Traces claires (sessionId par requ√™te)
// ‚úì Nettoyage automatique
```

### Pattern 2 : Wrapper Utilitaire

```javascript
// ‚úÖ PATTERN RECOMMAND√â : Fonction wrapper r√©utilisable

async function withTransaction(operations, options = {}) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: options.readConcern || "snapshot" },
            writeConcern: {
                w: options.writeConcern || "majority",
                j: true
            },
            maxCommitTimeMS: options.maxCommitTimeMS || 60000
        });

        // Ex√©cuter les op√©rations dans la transaction
        const result = await operations(session);

        await session.commitTransaction();

        return result;

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}

// Utilisation simple et s√ªre

await withTransaction(async (session) => {
    await orders.insertOne({ orderId: "O001" }, { session });
    await inventory.updateOne({ sku: "P001" }, { $inc: { stock: -1 } }, { session });

    return { success: true };
});

// Avantages :
// ‚úì Gestion automatique du cycle de vie
// ‚úì Code m√©tier simplifi√©
// ‚úì Impossible d'oublier endSession
// ‚úì Configuration centralis√©e
// ‚úì Facile √† tester

// Pattern avanc√© : Avec retry automatique

async function withTransactionRetry(operations, options = {}) {
    const maxRetries = options.maxRetries || 5;
    let attempt = 0;

    while (attempt < maxRetries) {
        const session = client.startSession();

        try {
            session.startTransaction(options.transactionOptions || {});

            const result = await operations(session);

            await session.commitTransaction();

            return result;

        } catch (error) {
            await session.abortTransaction();

            // Retry sur TransientTransactionError
            if (error.hasErrorLabel('TransientTransactionError') &&
                attempt < maxRetries - 1) {

                attempt++;
                const backoffMs = Math.min(100 * Math.pow(2, attempt), 5000);

                console.log(
                    `Transaction attempt ${attempt} failed, ` +
                    `retrying in ${backoffMs}ms...`
                );

                await session.endSession();
                await sleep(backoffMs);
                continue;
            }

            throw error;
        } finally {
            await session.endSession();
        }
    }

    throw new Error(`Transaction failed after ${maxRetries} attempts`);
}

// Utilisation

await withTransactionRetry(async (session) => {
    // Op√©rations transactionnelles
    await collection.updateOne({...}, {...}, { session });
}, {
    maxRetries: 3,
    transactionOptions: {
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" }
    }
});
```

## Sessions dans les Environnements Distribu√©s

### Sessions et Sharded Clusters

Dans un cluster shard√©, les sessions ont une complexit√© additionnelle :

```javascript
// Architecture Sharded Cluster

//                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//                  ‚îÇ   Mongos    ‚îÇ  ‚Üê Point d'entr√©e
//                  ‚îÇ (Router)    ‚îÇ
//                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//                         ‚îÇ
//        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//        ‚îÇ                ‚îÇ                ‚îÇ
//   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê
//   ‚îÇ Shard 1 ‚îÇ      ‚îÇ Shard 2 ‚îÇ     ‚îÇ Shard 3 ‚îÇ
//   ‚îÇ  (RS)   ‚îÇ      ‚îÇ  (RS)   ‚îÇ     ‚îÇ  (RS)   ‚îÇ
//   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

const session = client.startSession();
session.startTransaction();

// Op√©ration 1 : Touche Shard 1
await collection.updateOne(
    { userId: "Alice" },  // ‚Üí Shard 1 (A-M)
    { $inc: { balance: -100 } },
    { session }
);

// Command envoy√©e via mongos :
// {
//     update: "collection",
//     updates: [...],
//     lsid: { id: UUID("session-123") },
//     txnNumber: NumberLong(1),
//     startTransaction: true,
//     coordinator: true  // ‚Üê Mongos devient coordinateur
// }

// Mongos routes vers Shard 1
// Shard 1 enregistre : "Je participe √† txn session-123-1"

// Op√©ration 2 : Touche Shard 3
await collection.updateOne(
    { userId: "Zoe" },  // ‚Üí Shard 3 (N-Z)
    { $inc: { balance: 100 } },
    { session }
);

// Mongos routes vers Shard 3
// Shard 3 enregistre : "Je participe √† txn session-123-1"

// Commit : Two-Phase Commit coordonn√© par mongos
await session.commitTransaction();

// Timeline du 2PC :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// T=0ms  : Client ‚Üí Mongos : commitTransaction
//
// PHASE 1 : PREPARE
// T=5ms  : Mongos ‚Üí Shard 1 : "prepareTransaction"
// T=5ms  : Mongos ‚Üí Shard 3 : "prepareTransaction"
// T=10ms : Shard 1 ‚Üí Mongos : "prepared" (verrous maintenus)
// T=15ms : Shard 3 ‚Üí Mongos : "prepared" (verrous maintenus)
// T=20ms : Mongos d√©cide : COMMIT (tous prepared)
//
// T=25ms : Mongos √©crit d√©cision dans config.transaction_coordinators
//          {
//            sessionId: "session-123",
//            txnNumber: 1,
//            decision: "commit",
//            participants: ["shard1", "shard3"]
//          }
//
// PHASE 2 : COMMIT
// T=30ms : Mongos ‚Üí Shard 1 : "commitTransaction"
// T=30ms : Mongos ‚Üí Shard 3 : "commitTransaction"
// T=35ms : Shard 1 applique et rel√¢che verrous
// T=40ms : Shard 3 applique et rel√¢che verrous
// T=45ms : Mongos ‚Üí Client : "committed"

// Points de d√©faillance et r√©cup√©ration :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Cas 1 : Mongos crash pendant PREPARE
// - Shards en √©tat "prepared" (ind√©cis)
// - Nouveau mongos lit config.transaction_coordinators
// - Reprend le 2PC depuis la phase courante
//
// Cas 2 : Shard inaccessible pendant PREPARE
// - Timeout (30s d√©faut)
// - Mongos d√©cide ABORT
// - Tous les shards pr√©par√©s re√ßoivent ABORT
//
// Cas 3 : Network partition apr√®s PREPARE, avant COMMIT
// - D√©cision √©crite dans config servers (durable)
// - Retry du COMMIT jusqu'√† succ√®s
// - Idempotence garantit r√©sultat correct

// Implications pour les sessions :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1. Session metadata partag√©e entre tous les shards participants
// 2. Coordination overhead significatif
// 3. Latence typique : 50-200ms (vs 10-30ms Replica Set)
// 4. Plus de points de d√©faillance
// 5. Consommation m√©moire sur tous les participants
```

### Sessions et Connection Pooling

```javascript
// Les sessions sont ind√©pendantes des connexions physiques

// Connection Pool (Driver) :
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Pool de Connections MongoDB          ‚îÇ
// ‚îÇ                                      ‚îÇ
// ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
// ‚îÇ ‚îÇ C1  ‚îÇ  ‚îÇ C2  ‚îÇ  ‚îÇ C3  ‚îÇ  ‚îÇ C4  ‚îÇ   ‚îÇ
// ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
// ‚îÇ   ‚ñ≤        ‚ñ≤        ‚ñ≤        ‚ñ≤       ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//     ‚îÇ        ‚îÇ        ‚îÇ        ‚îÇ
//     ‚îÇ        ‚îÇ        ‚îÇ        ‚îÇ
// ‚îå‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Sessions (Logiques)                  ‚îÇ
// ‚îÇ                                      ‚îÇ
// ‚îÇ S1 ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Peut utiliser n'importe     ‚îÇ
// ‚îÇ          quelle connection           ‚îÇ
// ‚îÇ S2 ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Peut changer de             ‚îÇ
// ‚îÇ          connection entre ops        ‚îÇ
// ‚îÇ S3 ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Ind√©pendant du pool         ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// Exemple concret

const session1 = client.startSession();
const session2 = client.startSession();

// Op√©ration 1 : Session 1 utilise Connection 1
await collection.insertOne(
    { data: "from session1" },
    { session: session1 }
);
// Connexion C1 utilis√©e et retourn√©e au pool

// Op√©ration 2 : Session 1 utilise Connection 3 (diff√©rente)
await collection.findOne(
    { data: "from session1" },
    { session: session1 }
);
// Connexion C3 prise du pool, utilis√©e, puis retourn√©e

// Op√©ration 3 : Session 2 utilise Connection 1 (lib√©r√©e)
await collection.insertOne(
    { data: "from session2" },
    { session: session2 }
);
// Connexion C1 r√©utilis√©e pour une session diff√©rente

// Garanties :
// ‚úì Session = identit√© logique pr√©serv√©e
// ‚úì Connexion physique = ressource partag√©e
// ‚úì Driver g√®re la correspondance automatiquement
// ‚úì Transparent pour l'application

// Implications :
// 1. Nombre de sessions >> nombre de connexions (OK)
// 2. Session longue ‚â† connexion monopolis√©e
// 3. Pool de connexions sizing ind√©pendant du nombre de sessions
// 4. Possibilit√© de milliers de sessions avec 10-50 connexions
```

## Monitoring et Diagnostics des Sessions

### M√©triques Cl√©s

```javascript
// Commandes de diagnostic

// 1. Lister toutes les sessions actives
db.aggregate([
    { $listLocalSessions: {} },
    { $limit: 100 }
]);

// R√©sultat exemple :
// [
//   {
//     _id: { id: UUID("..."), uid: Binary(...) },
//     lastUse: ISODate("2024-12-07T10:30:00Z"),
//     user: { name: "admin", db: "admin" }
//   },
//   ...
// ]

// 2. Statistiques globales des sessions
db.serverStatus().sessions

// Output :
// {
//     "sessions": 1523,           // Sessions actives totales
//     "inactiveSessions": 890,    // Sessions inactives (>30min)
//     "activeSessions": 633,      // Sessions actives
//     "logicalSessionTimeout": 30 // Timeout en minutes
// }

// 3. Transactions actives
db.currentOp({
    "active": true,
    "transaction": { $exists: true }
});

// Output :
// {
//     "inprog": [
//         {
//             "type": "op",
//             "host": "mongodb-primary:27017",
//             "desc": "conn123",
//             "connectionId": 123,
//             "client": "192.168.1.100:54321",
//             "active": true,
//             "currentOpTime": "2024-12-07T10:30:15.123Z",
//             "opid": 789456,
//             "secs_running": 5,
//             "microsecs_running": NumberLong(5234567),
//             "op": "command",
//             "ns": "mydb.mycollection",
//             "command": {
//                 "update": "mycollection",
//                 "updates": [...],
//                 "lsid": { "id": UUID("...") },
//                 "txnNumber": NumberLong(1)
//             },
//             "transaction": {
//                 "parameters": {
//                     "txnNumber": NumberLong(1),
//                     "autocommit": false,
//                     "readConcern": { "level": "snapshot" }
//                 },
//                 "readTimestamp": Timestamp(1701963000, 1),
//                 "startWallClockTime": "2024-12-07T10:30:10.000Z",
//                 "timeOpenMicros": NumberLong(5234567),
//                 "timeActiveMicros": NumberLong(5234567)
//             },
//             "numYields": 0,
//             "locks": {
//                 "Global": "w",
//                 "Database": "w",
//                 "Collection": "w"
//             }
//         }
//     ]
// }

// 4. Transactions lentes (> 10 secondes)
db.currentOp({
    "active": true,
    "secs_running": { $gt: 10 },
    "transaction": { $exists: true }
});

// 5. Tuer une transaction sp√©cifique
db.killOp(789456);  // OpId de la transaction

// 6. Logs des transactions
// Dans mongod.log :
//
// 2024-12-07T10:30:10.123+0000 I COMMAND  [conn123] transaction parameters:
//     { lsid: { id: UUID("...") }, txnNumber: 1, autocommit: false }
// 2024-12-07T10:30:15.456+0000 I COMMAND  [conn123] transaction commit time: 5233ms
// 2024-12-07T10:30:15.457+0000 I COMMAND  [conn123] transaction committed
```

### Alertes et Seuils Recommand√©s

```javascript
// Configuration de monitoring (Prometheus/Grafana style)

// Alerte 1 : Trop de sessions actives
// Seuil : > 10,000 sessions
// Cause possible : Fuite de sessions (endSession non appel√©)
if (serverStatus.sessions.sessions > 10000) {
    alert("High session count", {
        current: serverStatus.sessions.sessions,
        threshold: 10000,
        action: "Investigate session leaks"
    });
}

// Alerte 2 : Transactions longues
// Seuil : > 30 secondes
// Cause possible : Deadlock, contention, requ√™te lente
db.currentOp().inprog.filter(op =>
    op.transaction && op.secs_running > 30
).forEach(op => {
    alert("Long running transaction", {
        opId: op.opid,
        duration: op.secs_running,
        lsid: op.command.lsid,
        action: "Consider killing with db.killOp()"
    });
});

// Alerte 3 : Taux d'√©chec transactionnel √©lev√©
// Seuil : > 5% de WriteConflict
const txnStats = db.serverStatus().transactions;
const failureRate = txnStats.totalAborted / txnStats.totalStarted;

if (failureRate > 0.05) {
    alert("High transaction failure rate", {
        rate: (failureRate * 100).toFixed(2) + "%",
        totalStarted: txnStats.totalStarted,
        totalAborted: txnStats.totalAborted,
        action: "Review contention patterns, consider optimistic locking"
    });
}

// Alerte 4 : Sessions inactives √©lev√©es
// Seuil : > 50% du total
const inactiveRatio = serverStatus.sessions.inactiveSessions /
                     serverStatus.sessions.sessions;

if (inactiveRatio > 0.5) {
    alert("High inactive session ratio", {
        ratio: (inactiveRatio * 100).toFixed(2) + "%",
        inactive: serverStatus.sessions.inactiveSessions,
        total: serverStatus.sessions.sessions,
        action: "Sessions may be expiring frequently, review timeout settings"
    });
}
```

## Optimisations et Bonnes Pratiques

### R√©utilisation de Session pour Op√©rations Non-Transactionnelles

```javascript
// ‚úÖ OPTIMISATION : R√©utiliser session pour causal consistency

async function updateUserAndFetchUpdated(userId, updates) {
    const session = client.startSession({
        causalConsistency: true
    });

    try {
        // Op√©ration 1 : Mise √† jour (PAS dans une transaction)
        await users.updateOne(
            { userId: userId },
            { $set: updates },
            { session }  // ‚úì Session utilis√©e pour causal consistency
        );

        // Op√©ration 2 : Lecture (garantie de voir la mise √† jour)
        const updatedUser = await users.findOne(
            { userId: userId },
            {
                session,  // ‚úì M√™me session
                readPreference: "secondaryPreferred"  // Peut lire d'un secondary
            }
        );

        // Garantie : updatedUser refl√®te les modifications
        // gr√¢ce √† afterClusterTime

        return updatedUser;

    } finally {
        await session.endSession();
    }
}

// Avantage : Causal consistency SANS overhead transactionnel
// Latence : +40ms (r√©plication) vs +80ms (transaction)
// Use case : 90% des op√©rations read-after-write
```

### Batch Processing Sans Session

```javascript
// ‚ùå INEFFICACE : Session pour chaque batch

for (let i = 0; i < 1000; i++) {
    const session = client.startSession();

    try {
        await collection.insertMany(
            generateBatchData(1000),
            { session }
        );
    } finally {
        await session.endSession();
    }
}

// Overhead : 1000 cr√©ations/destructions de session
// Latency additionnelle : 1000 √ó 5ms = 5000ms

// ‚úÖ EFFICACE : Pas de session pour batch processing

for (let i = 0; i < 1000; i++) {
    await collection.insertMany(
        generateBatchData(1000),
        { writeConcern: { w: 1 } }  // √âcriture rapide
    );
}

// Pas d'overhead de session
// Latency gagn√©e : 5000ms
// Performance : 5x plus rapide

// R√®gle : N'utilisez des sessions que quand n√©cessaire
// - Causal consistency requise
// - Transaction multi-documents
// - Read-your-writes critique
```

## Conclusion

Les sessions sont le m√©canisme fondamental qui permet les transactions multi-documents dans MongoDB, mais elles ont un co√ªt et une complexit√© qu'il faut ma√Ætriser :

### Points Cl√©s

1. **Cr√©ation lazy** : Les sessions sont cr√©√©es c√¥t√© client, mais initialis√©es c√¥t√© serveur √† la premi√®re utilisation
2. **Cycle de vie critique** : Toujours appeler `endSession()` dans un bloc `finally`
3. **Causal consistency** : Utile pour read-your-writes sans transaction compl√®te
4. **One session per request** : Ne jamais partager une session entre requ√™tes concurrentes
5. **Monitoring essentiel** : Surveiller le nombre de sessions actives et les transactions longues

### Co√ªts et B√©n√©fices

**Co√ªts** :
- M√©moire : 10-50 KB par session active
- CPU : Overhead de bookkeeping
- Latence : +5-10ms par op√©ration
- Complexit√© : Gestion d'erreurs sophistiqu√©e

**B√©n√©fices** :
- Causal consistency : Garantie read-your-writes
- Transactions : ACID multi-documents possible
- Tra√ßabilit√© : SessionId pour debugging
- Coordination : 2PC dans sharded clusters

La ma√Ætrise des sessions est indispensable pour utiliser efficacement les transactions multi-documents sans introduire de fuites de ressources ou de d√©gradations de performance.

---


‚è≠Ô∏è [Syntaxe et API](/08-transactions/03.3-syntaxe-api.md)
