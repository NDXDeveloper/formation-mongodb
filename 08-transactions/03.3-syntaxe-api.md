ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.3 Syntaxe et API

## Introduction

L'API des transactions multi-documents dans MongoDB est conÃ§ue pour Ãªtre Ã  la fois simple d'utilisation pour les cas basiques et suffisamment flexible pour gÃ©rer des scÃ©narios complexes. Cependant, une utilisation correcte nÃ©cessite une comprÃ©hension approfondie des options disponibles, des mÃ©canismes de gestion d'erreurs, et des patterns de retry. Une erreur subtile dans la gestion des transactions peut conduire Ã  des incohÃ©rences de donnÃ©es, des deadlocks applicatifs, ou des dÃ©gradations de performance sÃ©vÃ¨res.

Cette section explore en dÃ©tail l'API des transactions Ã  travers diffÃ©rents drivers officiels, avec un focus particulier sur les subtilitÃ©s, les piÃ¨ges, et les patterns de code robustes.

## API de Base : Les Trois OpÃ©rations Fondamentales

### Structure Canonique

Toute transaction suit ce pattern fondamental :

```javascript
// Structure de base (Node.js)

const session = client.startSession();

try {
    session.startTransaction(options);

    // OpÃ©rations transactionnelles
    await operation1(session);
    await operation2(session);
    await operationN(session);

    await session.commitTransaction();

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}
```

Cette structure en trois phases (start â†’ operations â†’ commit/abort) est commune Ã  tous les drivers, avec des variations syntaxiques mineures.

## startTransaction() : Initialisation

### Signature et Options

```javascript
// Signature complÃ¨te

session.startTransaction({
    // Read Concern : Niveau d'isolation des lectures
    readConcern: {
        level: "snapshot" | "local" | "majority" | "linearizable"
    },

    // Write Concern : Garanties de durabilitÃ©
    writeConcern: {
        w: <number> | "majority",
        j: <boolean>,
        wtimeout: <number>
    },

    // Read Preference : OÃ¹ lire
    readPreference: {
        mode: "primary" | "primaryPreferred" | "secondary" |
              "secondaryPreferred" | "nearest",
        tags: [{ datacenter: "east" }],
        maxStalenessSeconds: <number>
    },

    // Timeout maximum pour le commit
    maxCommitTimeMS: <number>
});
```

### Read Concern : Niveaux d'Isolation

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Level "local" : Lit les derniÃ¨res donnÃ©es du nÅ“ud local
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    readConcern: { level: "local" }
});

// CaractÃ©ristiques :
// âœ“ Performance maximale
// âœ“ Latence minimale
// âš  Peut lire des donnÃ©es non rÃ©pliquÃ©es
// âš  Peut lire des donnÃ©es qui seront rollback
// âš  Pas de garantie de durabilitÃ©

// Cas d'usage :
// - Transactions peu critiques
// - DonnÃ©es temporaires
// - Performance > cohÃ©rence stricte

// Exemple : Cache de session utilisateur
await sessions.updateOne(
    { sessionId: "sess123" },
    {
        $set: {
            lastActivity: new Date(),
            data: userData
        }
    },
    { session }
);

// Si le primary crash avant rÃ©plication :
// â†’ Modification perdue (acceptable pour un cache)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Level "majority" : Lit les donnÃ©es rÃ©pliquÃ©es sur majoritÃ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    readConcern: { level: "majority" }
});

// CaractÃ©ristiques :
// âœ“ Garantit que les donnÃ©es sont durables
// âœ“ Pas de rollback possible
// âš  Latence plus Ã©levÃ©e (attente rÃ©plication)
// âš  Peut ne pas voir les Ã©critures trÃ¨s rÃ©centes

// Timeline :
// T=0ms  : Write sur Primary
// T=5ms  : Write confirmÃ©e (w: 1)
// T=50ms : RÃ©plication sur Secondaries
// T=51ms : MajoritÃ© atteinte
//
// Read avec majority @ T=10ms :
// â†’ Ne voit PAS encore le write (pas encore majority)
// Read avec majority @ T=60ms :
// â†’ Voit le write (majority atteinte)

// Cas d'usage :
// - Transactions importantes
// - Besoin de durabilitÃ© garantie
// - DonnÃ©es ne pouvant Ãªtre perdues

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Level "snapshot" : Isolation snapshot complÃ¨te
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    readConcern: { level: "snapshot" }
});

// CaractÃ©ristiques :
// âœ“ Repeatable reads garantis
// âœ“ Pas de phantom reads
// âœ“ Vue cohÃ©rente pendant toute la transaction
// âš  Overhead MVCC
// âš  Peut causer WriteConflict avec haute contention

// MÃ©canisme interne :
const session = client.startSession();
session.startTransaction({
    readConcern: { level: "snapshot" }
});

// Ã€ ce moment : snapshot timestamp capturÃ©
// Exemple : atClusterTime = Timestamp(1701963000, 42)

// OpÃ©ration 1 @ T=100ms
const doc1 = await collection.findOne({ _id: 1 }, { session });
// Lit la version du document Ã  Timestamp(1701963000, 42)

// Entre-temps, une autre transaction modifie le document
// et committe @ Timestamp(1701963050, 10)

// OpÃ©ration 2 @ T=200ms (mÃªme transaction)
const doc2 = await collection.findOne({ _id: 1 }, { session });
// Lit TOUJOURS la version @ Timestamp(1701963000, 42)
// Pas la nouvelle version @ Timestamp(1701963050, 10)

// Garantie : doc1 === doc2 (mÃªme snapshot)

// Cas d'usage :
// - Transactions financiÃ¨res
// - Rapports cohÃ©rents
// - OpÃ©rations analytiques transactionnelles

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Level "linearizable" : CohÃ©rence la plus stricte (RARE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    readConcern: { level: "linearizable" }
});

// CaractÃ©ristiques :
// âœ“ Garantit que la lecture voit toutes les Ã©critures committÃ©es
// âœ“ Ordre global des opÃ©rations respectÃ©
// âš  TRÃˆS LENT (consensus sur chaque read)
// âš  NÃ©cessite majoritÃ© disponible
// âš  Peut bloquer si partition rÃ©seau

// MÃ©canisme :
// Chaque lecture nÃ©cessite un consensus avec la majoritÃ©
// pour garantir qu'aucune Ã©criture plus rÃ©cente n'existe

// Timeline d'une lecture linearizable :
// T=0ms  : Client demande read
// T=5ms  : Primary vÃ©rifie auprÃ¨s de la majoritÃ©
// T=50ms : MajoritÃ© confirme (pas d'Ã©criture plus rÃ©cente)
// T=51ms : Lecture effectuÃ©e
// T=52ms : RÃ©ponse au client

// Cas d'usage :
// - TrÃ¨s rare en pratique
// - Leader election
// - Certains systÃ¨mes critiques
// - GÃ©nÃ©ralement Ã©vitÃ© car trÃ¨s coÃ»teux

// Comparaison des latences (mesures rÃ©elles) :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// local        : 2-5ms    (baseline)
// majority     : 10-80ms  (selon latence rÃ©seau)
// snapshot     : 5-15ms   (overhead MVCC)
// linearizable : 50-500ms (consensus sur chaque read)
```

### Write Concern : Garanties de DurabilitÃ©

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// w: 1 : Ã‰criture confirmÃ©e par le primary uniquement
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    writeConcern: { w: 1 }
});

// Timeline :
// T=0ms  : Write sur Primary
// T=2ms  : Write dans le cache WiredTiger
// T=3ms  : Confirmation au client
// T=100ms: RÃ©plication vers Secondaries (asynchrone)

// Risques :
// - Si Primary crash @ T=50ms (avant rÃ©plication)
// - Et si un Secondary devient Primary
// - La write est perdue (rollback)

// Cas d'usage :
// - Performance critique
// - DonnÃ©es non critiques
// - Cache, logs, mÃ©triques

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// w: "majority" : Ã‰criture rÃ©pliquÃ©e sur majoritÃ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    writeConcern: { w: "majority" }
});

// Timeline (Replica Set 3 nÅ“uds) :
// T=0ms  : Write sur Primary
// T=5ms  : RÃ©plication vers Secondary 1
// T=8ms  : RÃ©plication vers Secondary 2
// T=10ms : Secondary 1 applique
// T=12ms : Secondary 2 applique
// T=15ms : MajoritÃ© atteinte (Primary + Secondary 1)
// T=16ms : Confirmation au client

// Garanties :
// âœ“ Survit Ã  la perte du Primary
// âœ“ Pas de rollback possible
// âœ“ DurabilitÃ© garantie

// Cas d'usage :
// - Standard pour transactions importantes
// - DonnÃ©es critiques
// - ConformitÃ©

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// j: true : JournalisÃ© sur disque (Write-Ahead Log)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    writeConcern: { w: 1, j: true }
});

// Timeline :
// T=0ms  : Write sur Primary
// T=2ms  : Write dans le cache WiredTiger
// T=3ms  : Ã‰criture dans le journal (mÃ©moire)
// T=8ms  : fsync du journal sur disque
// T=9ms  : Confirmation au client

// Garanties :
// âœ“ Survit Ã  un crash du Primary
// âœ“ RÃ©cupÃ©ration via replay du journal
// âš  Latence accrue (~5-10ms)

// Cas d'usage :
// - Transactions financiÃ¨res
// - DurabilitÃ© absolue requise
// - ConformitÃ© rÃ©glementaire

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Combinaison w: "majority" + j: true : Maximum de garanties
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    writeConcern: { w: "majority", j: true }
});

// Timeline (pire cas) :
// T=0ms  : Write sur Primary
// T=8ms  : Primary journal fsync
// T=50ms : RÃ©plication et journal fsync sur Secondaries
// T=80ms : MajoritÃ© avec journal fsync atteinte
// T=81ms : Confirmation au client

// Garanties :
// âœ“ Survit Ã  perte de la majoritÃ© des nÅ“uds
// âœ“ Survit Ã  crash + corruption disque Primary
// âœ“ DurabilitÃ© maximale
// âš  Latence la plus Ã©levÃ©e

// Cas d'usage :
// - Transactions bancaires
// - Paiements
// - DonnÃ©es rÃ©gulÃ©es
// - Audit trail critique

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// wtimeout : Timeout pour write concern
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

session.startTransaction({
    writeConcern: {
        w: "majority",
        wtimeout: 5000  // 5 secondes max
    }
});

// Si la majoritÃ© n'est pas atteinte en 5 secondes :
// â†’ WriteConcernError levÃ©e
// â†’ Transaction peut Ãªtre abortÃ©e
// â†’ Retry nÃ©cessaire

// Causes de timeout :
// - Latence rÃ©seau Ã©levÃ©e
// - Secondary lent (disque saturÃ©)
// - Partition rÃ©seau
// - Charge Ã©levÃ©e sur Secondaries

// Gestion :
try {
    await session.commitTransaction();
} catch (error) {
    if (error.name === 'WriteConcernError') {
        // L'Ã©criture est effectuÃ©e mais pas confirmÃ©e par majoritÃ©
        // Ã‰tat incertain : peut Ãªtre committÃ©e ou non

        if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
            // VÃ©rifier si la transaction a Ã©tÃ© committÃ©e
            const committed = await verifyTransactionCommitted(session);

            if (!committed) {
                // Retry
                await retryTransaction();
            }
        }
    }
    throw error;
}

// MÃ©triques rÃ©elles (Replica Set multi-rÃ©gion) :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Configuration : Primary US-East, Secondaries US-West, EU
//
// w: 1
// - Latence P50 : 3ms
// - Latence P99 : 12ms
// - Timeout rate : 0.01%
//
// w: "majority", wtimeout: 5000
// - Latence P50 : 85ms (attente US-West)
// - Latence P99 : 450ms
// - Timeout rate : 2% (EU trop lent, timeout)
//
// w: "majority", wtimeout: 10000
// - Latence P50 : 120ms
// - Latence P99 : 800ms
// - Timeout rate : 0.5% (EU parfois trop lent)
//
// Trade-off : wtimeout plus long = moins d'Ã©checs, plus de latence
```

### maxCommitTimeMS : Timeout Global

```javascript
// Timeout maximum pour l'ensemble de la transaction

session.startTransaction({
    maxCommitTimeMS: 60000  // 60 secondes (dÃ©faut)
});

// La transaction doit committer dans ce dÃ©lai, sinon :
// â†’ TransactionTooLargeForCache ou autre erreur
// â†’ Abort automatique cÃ´tÃ© serveur

// Exemple de transaction longue

const session = client.startSession();

try {
    session.startTransaction({
        maxCommitTimeMS: 120000  // 2 minutes
    });

    // OpÃ©ration 1 : 30 secondes
    await longRunningQuery1(session);

    // OpÃ©ration 2 : 40 secondes
    await longRunningQuery2(session);

    // OpÃ©ration 3 : 20 secondes
    await longRunningQuery3(session);

    // Total : 90 secondes (< 120s, OK)
    await session.commitTransaction();

} catch (error) {
    if (error.code === 50838) {  // TransactionExceededLifetimeLimitSeconds
        console.error("Transaction timeout dÃ©passÃ©");
        // La transaction a Ã©tÃ© abortÃ©e automatiquement
    }
    throw error;
} finally {
    await session.endSession();
}

// Recommandations :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DurÃ©e transaction :
// - IdÃ©al : < 100ms
// - Acceptable : < 1s
// - ProblÃ©matique : > 10s
// - Dangereux : > 60s
//
// Si transaction > 60s rÃ©guliÃ¨rement :
// - Revoir l'architecture (probablement mauvais design)
// - Diviser en transactions plus petites
// - Utiliser pattern Saga
// - ConsidÃ©rer batch processing hors transaction
```

## commitTransaction() : Validation

### Comportement et Garanties

```javascript
// commitTransaction() est idempotente

const session = client.startSession();

try {
    session.startTransaction();

    await collection.insertOne({ data: "A" }, { session });
    await collection.insertOne({ data: "B" }, { session });

    // Tentative de commit
    await session.commitTransaction();

    // Si cette ligne est atteinte : commit rÃ©ussi
    console.log("Transaction committed successfully");

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©narios de commit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario 1 : Commit rÃ©ussi
await session.commitTransaction();
// â†’ Status : "committed"
// â†’ Modifications visibles
// â†’ Locks relÃ¢chÃ©s
// â†’ applyOps dans l'oplog

// ScÃ©nario 2 : WriteConflict pendant commit
try {
    await session.commitTransaction();
} catch (error) {
    if (error.hasErrorLabel('TransientTransactionError')) {
        // Une autre transaction a modifiÃ© les mÃªmes documents
        // Snapshot conflict dÃ©tectÃ©
        // â†’ Retry la transaction entiÃ¨re
        console.log("WriteConflict, retry needed");
    }
}

// ScÃ©nario 3 : Network error pendant commit
try {
    await session.commitTransaction();
} catch (error) {
    if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
        // Le commit peut avoir rÃ©ussi ou Ã©chouÃ©
        // Ã‰tat incertain dÃ» Ã  une erreur rÃ©seau

        // StratÃ©gie 1 : VÃ©rifier si committed
        const isCommitted = await checkTransactionStatus(session);

        if (isCommitted) {
            console.log("Transaction was actually committed");
            return;
        }

        // StratÃ©gie 2 : Retry le commit (idempotent)
        await session.commitTransaction();
    }
}

// ScÃ©nario 4 : WriteConcern timeout
try {
    await session.commitTransaction();
} catch (error) {
    if (error.code === 64) {  // WriteConcernError
        // Le commit a Ã©tÃ© appliquÃ© sur le Primary
        // Mais la majoritÃ© n'a pas confirmÃ© dans le timeout

        // Options :
        // 1. Attendre et vÃ©rifier manuellement
        // 2. ConsidÃ©rer comme rÃ©ussi (risque rollback)
        // 3. Retry le commit

        console.warn("WriteConcern timeout, commit state uncertain");
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Commit dans un Sharded Cluster (Two-Phase Commit)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Phase 1 : PREPARE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Mongos (coordinator) â†’ Tous les shards participants
// Command: { prepareTransaction: 1 }
//
// Chaque shard :
// 1. Applique les modifications (buffered)
// 2. Acquiert les locks
// 3. Ã‰crit "prepare" dans son oplog
// 4. RÃ©pond "prepared" ou "aborted"

// Phase 2 : COMMIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Si tous les shards sont "prepared" :
// Mongos Ã©crit la dÃ©cision "commit" dans config.transaction_coordinators
// Mongos â†’ Tous les shards : { commitTransaction: 1 }
//
// Chaque shard :
// 1. Applique dÃ©finitivement les modifications
// 2. Ã‰crit "commit" dans son oplog
// 3. RelÃ¢che les locks
// 4. RÃ©pond "committed"

const session = client.startSession();

try {
    session.startTransaction();

    // OpÃ©ration sur Shard 1
    await collection.updateOne(
        { userId: "Alice" },  // â†’ Shard 1
        { $inc: { balance: -100 } },
        { session }
    );

    // OpÃ©ration sur Shard 2
    await collection.updateOne(
        { userId: "Zoe" },  // â†’ Shard 2
        { $inc: { balance: 100 } },
        { session }
    );

    // Commit dÃ©clenche le 2PC
    await session.commitTransaction();

    // Timeline interne :
    // T=0ms  : Client appelle commitTransaction()
    // T=5ms  : Mongos â†’ Shard1: prepareTransaction
    // T=5ms  : Mongos â†’ Shard2: prepareTransaction
    // T=20ms : Shard1 â†’ Mongos: prepared
    // T=25ms : Shard2 â†’ Mongos: prepared
    // T=30ms : Mongos Ã©crit dÃ©cision dans config servers
    // T=35ms : Mongos â†’ Shard1: commitTransaction
    // T=35ms : Mongos â†’ Shard2: commitTransaction
    // T=50ms : Shard1 committed
    // T=55ms : Shard2 committed
    // T=60ms : Mongos â†’ Client: success

} finally {
    await session.endSession();
}

// Latence typique 2PC : 50-200ms (LAN)
//                       200-800ms (multi-rÃ©gion)
```

## abortTransaction() : Annulation

### Utilisation et Implications

```javascript
// abortTransaction() annule toutes les modifications

const session = client.startSession();

try {
    session.startTransaction();

    await collection.updateOne({ _id: 1 }, { $set: { value: 100 } }, { session });
    await collection.updateOne({ _id: 2 }, { $set: { value: 200 } }, { session });

    // Condition d'annulation
    const validation = await validateBusinessRule();

    if (!validation.valid) {
        // Annulation explicite
        await session.abortTransaction();

        // Aucune modification n'est appliquÃ©e
        // Les documents 1 et 2 conservent leurs valeurs originales

        return { success: false, reason: validation.reason };
    }

    await session.commitTransaction();

} catch (error) {
    // Annulation implicite en cas d'erreur
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Abort vs Rollback
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Dans MongoDB, abort = rollback (terminologie interchangeable)
// Mais mÃ©canisme diffÃ©rent des SGBDR traditionnels :

// SGBDR (PostgreSQL, MySQL) :
// - Modifications Ã©crites dans des segments UNDO
// - Rollback = application inverse des UNDO logs
// - Peut Ãªtre coÃ»teux si beaucoup de modifications

// MongoDB :
// - Modifications seulement en mÃ©moire (buffered)
// - Pas encore dans l'oplog (donc pas rÃ©pliquÃ©es)
// - Abort = simple discard du buffer
// - TrÃ¨s rapide (< 1ms typique)

// Timeline d'un abort :
// T=0ms  : OpÃ©ration 1 (modif en mÃ©moire)
// T=5ms  : OpÃ©ration 2 (modif en mÃ©moire)
// T=10ms : abortTransaction() appelÃ©
// T=11ms : Buffer discardÃ©
// T=12ms : Locks relÃ¢chÃ©s
// T=13ms : Session state â†’ "aborted"
// T=14ms : Confirmation au client

// CoÃ»t : NÃ©gligeable (~1-5ms)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Abort automatique
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// MongoDB abort automatiquement dans plusieurs cas :

// Cas 1 : Timeout de transaction (maxCommitTimeMS)
session.startTransaction({ maxCommitTimeMS: 30000 });

// ... opÃ©rations prenant 35 secondes ...

await session.commitTransaction();
// â†’ TransactionExceededLifetimeLimitSeconds
// â†’ Abort automatique effectuÃ© par le serveur

// Cas 2 : WriteConflict non rÃ©solu
// Deux transactions modifient le mÃªme document
// La premiÃ¨re committe
// La seconde reÃ§oit WriteConflict lors du commit
// â†’ Abort automatique

// Cas 3 : Session expirÃ©e (30 minutes par dÃ©faut)
// Si la session reste inactive > 30 minutes
// â†’ Session killed
// â†’ Transaction abortÃ©e automatiquement

// Cas 4 : Network disconnect
// Si le client se dÃ©connecte pendant une transaction
// â†’ Session abandonnÃ©e
// â†’ Transaction abortÃ©e aprÃ¨s session timeout

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Abort dans un Sharded Cluster
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Si abort pendant la phase PREPARE du 2PC :
// Mongos envoie "abortTransaction" Ã  tous les shards

// Timeline :
// T=0ms  : Client appelle abortTransaction()
// T=5ms  : Mongos â†’ Shard1: abortTransaction
// T=5ms  : Mongos â†’ Shard2: abortTransaction
// T=10ms : Shard1 : discard buffer, release locks
// T=12ms : Shard2 : discard buffer, release locks
// T=15ms : Mongos â†’ Client: aborted

// Si abort aprÃ¨s que certains shards sont "prepared" :
// Les shards en Ã©tat "prepared" doivent rollback
// (Plus coÃ»teux, mais rare)
```

## Gestion d'Erreurs : Labels et Retry Logic

### Labels d'Erreur MongoDB

```javascript
// MongoDB ajoute des labels aux erreurs pour faciliter la gestion

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Label "TransientTransactionError"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Indique une erreur temporaire, retry recommandÃ©

try {
    session.startTransaction();
    await operations(session);
    await session.commitTransaction();
} catch (error) {
    if (error.hasErrorLabel('TransientTransactionError')) {
        // Erreurs typiques avec ce label :
        // - WriteConflict (code 112)
        // - LockTimeout
        // - SnapshotTooOld
        // - TransactionAborted
        // - Network errors temporaires

        console.log("Transient error, safe to retry entire transaction");

        // Recommandation : Retry TOUTE la transaction
        // (pas juste le commit, mais startTransaction + operations + commit)

        await session.abortTransaction();

        // Retry logic (voir section suivante)
        await retryTransaction();
    } else {
        // Erreur non transient, ne pas retry
        throw error;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Label "UnknownTransactionCommitResult"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Indique que l'Ã©tat du commit est incertain

try {
    await session.commitTransaction();
} catch (error) {
    if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
        // Causes possibles :
        // - Network timeout pendant commit
        // - WriteConcern timeout
        // - Primary election pendant commit
        // - Cluster reconfiguration

        console.log("Commit result unknown, may have succeeded");

        // La transaction PEUT avoir Ã©tÃ© committÃ©e
        // Il est safe de retry le COMMIT seulement (idempotent)

        // Strategy 1 : Retry commit uniquement
        try {
            await session.commitTransaction();
            console.log("Commit retry succeeded");
        } catch (retryError) {
            if (retryError.hasErrorLabel('UnknownTransactionCommitResult')) {
                // Toujours incertain, peut nÃ©cessiter vÃ©rification manuelle
                await handleUncertainCommit(session);
            }
        }

        // Strategy 2 : VÃ©rifier l'Ã©tat puis dÃ©cider
        const isCommitted = await verifyTransactionCommitted(session);

        if (isCommitted) {
            console.log("Transaction was already committed");
            return;
        } else {
            console.log("Transaction was not committed, retrying");
            await session.commitTransaction();
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VÃ©rification d'Ã©tat de transaction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function verifyTransactionCommitted(session) {
    // MÃ©thode 1 : Lire avec read concern "majority"
    // Si les modifications sont visibles avec RC majority,
    // alors la transaction a Ã©tÃ© committÃ©e

    const doc = await collection.findOne(
        { _id: documentIdModifiedInTransaction },
        { readConcern: { level: "majority" } }
    );

    if (doc && doc.value === expectedValueAfterCommit) {
        return true;  // Transaction committÃ©e
    }

    // MÃ©thode 2 : VÃ©rifier dans les logs de transaction
    const txnLog = await db.admin().command({
        currentOp: true,
        "lsid.id": session.id.id,
        "txnNumber": session.txnNumber
    });

    if (txnLog.inprog.length === 0) {
        // Transaction n'est plus active
        // VÃ©rifier si elle a Ã©tÃ© committÃ©e ou abortÃ©e
        // (implÃ©mentation dÃ©pend du contexte applicatif)
    }

    return false;  // Incertain ou abortÃ©e
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Erreurs sans label (ne pas retry)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try {
    session.startTransaction();
    await operations(session);
    await session.commitTransaction();
} catch (error) {
    // Erreurs qui NE doivent PAS Ãªtre retryÃ©es :

    if (error.code === 251) {  // InvalidTransaction
        // Transaction dans un Ã©tat invalide
        // Ne pas retry
    }

    if (error.code === 256) {  // TransactionTooLarge
        // La transaction a trop d'opÃ©rations (> 16MB applyOps)
        // Ne pas retry, diviser la transaction
    }

    if (error.name === 'MongoParseError') {
        // Erreur de syntaxe dans la requÃªte
        // Ne pas retry, corriger le code
    }

    if (error.message.includes('Insufficient funds')) {
        // Erreur mÃ©tier (business logic)
        // Ne pas retry automatiquement
    }

    throw error;
}
```

### Patterns de Retry Robustes

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 1 : Retry simple avec backoff exponentiel
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function withRetry(transactionFn, maxRetries = 5) {
    let attempt = 0;

    while (attempt < maxRetries) {
        const session = client.startSession();

        try {
            session.startTransaction({
                readConcern: { level: "snapshot" },
                writeConcern: { w: "majority" }
            });

            // ExÃ©cuter les opÃ©rations transactionnelles
            const result = await transactionFn(session);

            await session.commitTransaction();

            return result;

        } catch (error) {
            await session.abortTransaction();

            // Retry sur erreur transiente
            if (error.hasErrorLabel('TransientTransactionError')) {
                attempt++;

                if (attempt >= maxRetries) {
                    throw new Error(
                        `Transaction failed after ${maxRetries} attempts: ${error.message}`
                    );
                }

                // Backoff exponentiel : 100ms, 200ms, 400ms, 800ms, 1600ms
                const backoffMs = Math.min(100 * Math.pow(2, attempt), 5000);

                console.log(
                    `Attempt ${attempt} failed: ${error.message}. ` +
                    `Retrying in ${backoffMs}ms...`
                );

                await sleep(backoffMs);
                continue;
            }

            // Retry commit sur rÃ©sultat incertain
            if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
                attempt++;

                if (attempt >= maxRetries) {
                    throw new Error(
                        `Commit uncertain after ${maxRetries} attempts`
                    );
                }

                console.log(`Commit result unknown, retrying commit only...`);

                try {
                    await session.commitTransaction();
                    return result;
                } catch (retryError) {
                    // Si toujours incertain, continuer le retry
                    if (retryError.hasErrorLabel('UnknownTransactionCommitResult')) {
                        await sleep(100 * Math.pow(2, attempt));
                        continue;
                    }
                    throw retryError;
                }
            }

            // Autres erreurs : ne pas retry
            throw error;

        } finally {
            await session.endSession();
        }
    }
}

// Utilisation
await withRetry(async (session) => {
    await collection.updateOne(
        { accountId: "A001" },
        { $inc: { balance: -100 } },
        { session }
    );

    await collection.updateOne(
        { accountId: "B002" },
        { $inc: { balance: 100 } },
        { session }
    );
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 2 : Retry avec jitter (Ã©viter thundering herd)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function withRetryAndJitter(transactionFn, maxRetries = 5) {
    let attempt = 0;

    while (attempt < maxRetries) {
        const session = client.startSession();

        try {
            session.startTransaction();
            const result = await transactionFn(session);
            await session.commitTransaction();
            return result;

        } catch (error) {
            await session.abortTransaction();

            if (error.hasErrorLabel('TransientTransactionError')) {
                attempt++;

                if (attempt >= maxRetries) {
                    throw error;
                }

                // Backoff avec jitter alÃ©atoire
                const baseBackoff = 100 * Math.pow(2, attempt);
                const jitter = Math.random() * 0.3 * baseBackoff;  // Â±30%
                const backoffMs = Math.min(baseBackoff + jitter, 5000);

                console.log(`Retry ${attempt} in ${backoffMs.toFixed(0)}ms`);

                await sleep(backoffMs);
                continue;
            }

            throw error;

        } finally {
            await session.endSession();
        }
    }
}

// Pourquoi le jitter ?
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sans jitter :
// - 100 clients Ã©chouent simultanÃ©ment @ T=0
// - Tous retry aprÃ¨s 100ms @ T=100
// - Collision de WriteConflict rÃ©pÃ©tÃ©e
// - Ã‰chec en cascade
//
// Avec jitter :
// - 100 clients Ã©chouent @ T=0
// - Retry Ã©talÃ©s entre T=70 et T=130
// - Moins de collisions
// - Meilleur taux de succÃ¨s

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 3 : Retry adaptatif basÃ© sur l'erreur
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function withAdaptiveRetry(transactionFn, maxRetries = 5) {
    let attempt = 0;
    const errorHistory = [];

    while (attempt < maxRetries) {
        const session = client.startSession();

        try {
            session.startTransaction();
            const result = await transactionFn(session);
            await session.commitTransaction();
            return result;

        } catch (error) {
            await session.abortTransaction();
            errorHistory.push(error.code);

            if (error.hasErrorLabel('TransientTransactionError')) {
                attempt++;

                if (attempt >= maxRetries) {
                    throw error;
                }

                // Adapter le backoff selon le type d'erreur
                let backoffMs;

                if (error.code === 112) {  // WriteConflict
                    // Haute contention, backoff plus long
                    backoffMs = 200 * Math.pow(2, attempt);

                    // Si WriteConflict rÃ©pÃ©tÃ©, augmenter encore
                    const writeConflictCount = errorHistory.filter(c => c === 112).length;
                    if (writeConflictCount > 2) {
                        backoffMs *= 2;
                        console.warn("High WriteConflict rate, increasing backoff");
                    }

                } else if (error.code === 24) {  // LockTimeout
                    // Lock contention, backoff trÃ¨s long
                    backoffMs = 500 * Math.pow(2, attempt);

                } else {
                    // Erreur gÃ©nÃ©rique, backoff standard
                    backoffMs = 100 * Math.pow(2, attempt);
                }

                backoffMs = Math.min(backoffMs, 10000);  // Cap Ã  10s

                console.log(
                    `Error ${error.code} (${error.message}), ` +
                    `retry ${attempt} in ${backoffMs}ms`
                );

                await sleep(backoffMs);
                continue;
            }

            throw error;

        } finally {
            await session.endSession();
        }
    }
}
```

## API SpÃ©cifiques aux Drivers

### Node.js Driver

```javascript
// Version : mongodb@6.0+

const { MongoClient } = require('mongodb');

const client = new MongoClient('mongodb://localhost:27017', {
    // Options de pool de connexions
    maxPoolSize: 50,
    minPoolSize: 10,
    maxIdleTimeMS: 30000
});

await client.connect();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern avec callback (deprecated, mais encore utilisÃ©)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

await session.withTransaction(async () => {
    // OpÃ©rations transactionnelles
    await collection.insertOne({ data: "A" }, { session });
    await collection.insertOne({ data: "B" }, { session });

    // Commit automatique si pas d'exception
    // Abort automatique si exception levÃ©e
}, {
    readConcern: { level: "snapshot" },
    writeConcern: { w: "majority" },
    maxCommitTimeMS: 60000
});

await session.endSession();

// Avantages withTransaction :
// âœ“ Gestion automatique du cycle de vie
// âœ“ Retry automatique intÃ©grÃ©
// âœ“ Moins de code boilerplate
//
// InconvÃ©nients :
// âš  Moins de contrÃ´le fin
// âš  Debugging plus difficile
// âš  Retry logic pas personnalisable

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern manuel (plus de contrÃ´le)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

try {
    session.startTransaction({
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" },
        readPreference: { mode: "primary" }
    });

    const result1 = await collection.insertOne(
        { data: "A" },
        { session }
    );

    const result2 = await collection.updateOne(
        { _id: result1.insertedId },
        { $set: { processed: true } },
        { session }
    );

    await session.commitTransaction();

    return { success: true, id: result1.insertedId };

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper personnalisÃ© avec TypeScript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { ClientSession, TransactionOptions } from 'mongodb';

interface TransactionResult<T> {
    success: boolean;
    data?: T;
    error?: Error;
    attempts: number;
}

async function executeTransaction<T>(
    fn: (session: ClientSession) => Promise<T>,
    options?: TransactionOptions,
    maxRetries: number = 5
): Promise<TransactionResult<T>> {
    let attempt = 0;

    while (attempt < maxRetries) {
        const session = client.startSession();

        try {
            session.startTransaction(options || {
                readConcern: { level: "snapshot" },
                writeConcern: { w: "majority" }
            });

            const result = await fn(session);

            await session.commitTransaction();

            return {
                success: true,
                data: result,
                attempts: attempt + 1
            };

        } catch (error) {
            await session.abortTransaction();

            if (error.hasErrorLabel('TransientTransactionError')) {
                attempt++;

                if (attempt < maxRetries) {
                    const backoffMs = Math.min(100 * Math.pow(2, attempt), 5000);
                    await new Promise(resolve => setTimeout(resolve, backoffMs));
                    continue;
                }
            }

            return {
                success: false,
                error: error as Error,
                attempts: attempt + 1
            };

        } finally {
            await session.endSession();
        }
    }

    return {
        success: false,
        error: new Error(`Transaction failed after ${maxRetries} attempts`),
        attempts: maxRetries
    };
}

// Utilisation
const result = await executeTransaction(async (session) => {
    await users.insertOne({ name: "Alice" }, { session });
    await accounts.insertOne({ userId: "alice", balance: 1000 }, { session });

    return { userId: "alice" };
});

if (result.success) {
    console.log(`Transaction succeeded after ${result.attempts} attempts`);
    console.log(`User ID: ${result.data?.userId}`);
} else {
    console.error(`Transaction failed: ${result.error?.message}`);
}
```

### Python Driver (PyMongo)

```python
# Version : pymongo@4.0+

from pymongo import MongoClient
from pymongo.errors import OperationFailure

client = MongoClient('mongodb://localhost:27017')
db = client.mydb

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Pattern de base avec context manager
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

with client.start_session() as session:
    with session.start_transaction(
        read_concern={"level": "snapshot"},
        write_concern={"w": "majority"},
        read_preference="primary"
    ):
        # OpÃ©rations transactionnelles
        db.collection1.insert_one({"data": "A"}, session=session)
        db.collection2.insert_one({"data": "B"}, session=session)

        # Commit automatique si pas d'exception
        # Abort automatique si exception

# Session automatiquement fermÃ©e (endSession)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Pattern avec retry manuel
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import time
import random

def with_transaction_retry(transaction_fn, max_retries=5):
    """
    ExÃ©cute une transaction avec retry automatique
    """
    attempt = 0

    while attempt < max_retries:
        with client.start_session() as session:
            try:
                with session.start_transaction():
                    result = transaction_fn(session)
                    return result

            except OperationFailure as error:
                # VÃ©rifier si retry recommandÃ©
                if error.has_error_label("TransientTransactionError"):
                    attempt += 1

                    if attempt >= max_retries:
                        raise Exception(
                            f"Transaction failed after {max_retries} attempts"
                        ) from error

                    # Backoff exponentiel avec jitter
                    backoff = min(0.1 * (2 ** attempt), 5.0)
                    jitter = random.uniform(0, 0.3 * backoff)
                    time.sleep(backoff + jitter)

                    print(f"Retry attempt {attempt} after {backoff + jitter:.2f}s")
                    continue

                # Erreur non transiente
                raise

    raise Exception(f"Transaction failed after {max_retries} attempts")

# Utilisation
def transfer_money(session):
    """Fonction de transaction"""
    db.accounts.update_one(
        {"account_id": "A001"},
        {"$inc": {"balance": -100}},
        session=session
    )

    db.accounts.update_one(
        {"account_id": "B002"},
        {"$inc": {"balance": 100}},
        session=session
    )

    return {"success": True}

result = with_transaction_retry(transfer_money)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Helper avec callback (similaire Ã  Node.js withTransaction)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def with_transaction(callback, **transaction_options):
    """
    Wrapper pour exÃ©cuter une transaction avec retry automatique
    """
    with client.start_session() as session:
        def execute_transaction():
            with session.start_transaction(**transaction_options):
                return callback(session)

        # Retry loop
        max_retries = 5
        for attempt in range(max_retries):
            try:
                return execute_transaction()
            except OperationFailure as error:
                if error.has_error_label("TransientTransactionError"):
                    if attempt < max_retries - 1:
                        backoff = 0.1 * (2 ** attempt)
                        time.sleep(backoff)
                        continue
                raise

# Utilisation
result = with_transaction(
    lambda session: db.collection.insert_one({"data": "test"}, session=session),
    read_concern={"level": "snapshot"},
    write_concern={"w": "majority"}
)
```

### Java Driver

```java
// Version : mongodb-driver-sync@4.x ou mongodb-driver-reactivestreams@4.x

import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.ClientSession;
import com.mongodb.TransactionOptions;
import com.mongodb.ReadConcern;
import com.mongodb.WriteConcern;
import com.mongodb.MongoException;

MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017");

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern de base
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try (ClientSession session = mongoClient.startSession()) {
    TransactionOptions txnOptions = TransactionOptions.builder()
        .readConcern(ReadConcern.SNAPSHOT)
        .writeConcern(WriteConcern.MAJORITY)
        .build();

    session.startTransaction(txnOptions);

    try {
        // OpÃ©rations transactionnelles
        collection1.insertOne(session, new Document("data", "A"));
        collection2.insertOne(session, new Document("data", "B"));

        session.commitTransaction();

    } catch (Exception e) {
        session.abortTransaction();
        throw e;
    }
}
// Session automatiquement fermÃ©e (try-with-resources)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern avec retry
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public class TransactionHelper {

    public static <T> T withRetry(
        MongoClient client,
        TransactionBody<T> body,
        int maxRetries
    ) {
        int attempt = 0;

        while (attempt < maxRetries) {
            try (ClientSession session = client.startSession()) {
                session.startTransaction(
                    TransactionOptions.builder()
                        .readConcern(ReadConcern.SNAPSHOT)
                        .writeConcern(WriteConcern.MAJORITY)
                        .build()
                );

                try {
                    T result = body.execute(session);
                    session.commitTransaction();
                    return result;

                } catch (MongoException e) {
                    session.abortTransaction();

                    if (e.hasErrorLabel(MongoException.TRANSIENT_TRANSACTION_ERROR)) {
                        attempt++;

                        if (attempt >= maxRetries) {
                            throw new RuntimeException(
                                "Transaction failed after " + maxRetries + " attempts",
                                e
                            );
                        }

                        // Backoff exponentiel
                        long backoffMs = Math.min(100L * (1L << attempt), 5000L);
                        Thread.sleep(backoffMs);
                        continue;
                    }

                    throw e;
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Transaction interrupted", e);
            }
        }

        throw new RuntimeException("Transaction failed after " + maxRetries + " attempts");
    }

    @FunctionalInterface
    public interface TransactionBody<T> {
        T execute(ClientSession session);
    }
}

// Utilisation
TransactionHelper.withRetry(mongoClient, session -> {
    collection.insertOne(session, new Document("name", "Alice"));
    return true;
}, 5);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern avec withTransaction (Java 4.3+)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try (ClientSession session = mongoClient.startSession()) {
    session.withTransaction(() -> {
        collection1.insertOne(session, new Document("data", "A"));
        collection2.insertOne(session, new Document("data", "B"));
        return null;
    }, TransactionOptions.builder()
        .readConcern(ReadConcern.SNAPSHOT)
        .writeConcern(WriteConcern.MAJORITY)
        .build()
    );
}

// Retry automatique intÃ©grÃ©
```

## Conclusion

L'API des transactions MongoDB offre une flexibilitÃ© considÃ©rable, mais nÃ©cessite une attention particuliÃ¨re Ã  plusieurs aspects critiques :

### Points ClÃ©s Ã  Retenir

1. **Options transactionnelles** : Comprendre l'impact de chaque niveau de readConcern et writeConcern sur la performance et les garanties
2. **Gestion d'erreurs** : Utiliser les labels d'erreur pour implÃ©menter une retry logic appropriÃ©e
3. **Retry avec backoff** : Toujours inclure un backoff exponentiel avec jitter pour Ã©viter les thundering herds
4. **Cycle de vie** : Toujours fermer les sessions dans un bloc `finally`
5. **Idempotence** : Les opÃ©rations transactionnelles doivent Ãªtre idempotentes pour supporter les retries

### Configurations RecommandÃ©es par Cas d'Usage

**Performance maximale** (cache, logs) :
```javascript
{ readConcern: { level: "local" }, writeConcern: { w: 1 } }
```

**Ã‰quilibre standard** (e-commerce) :
```javascript
{ readConcern: { level: "snapshot" }, writeConcern: { w: "majority" } }
```

**CohÃ©rence maximale** (banque) :
```javascript
{
    readConcern: { level: "snapshot" },
    writeConcern: { w: "majority", j: true },
    maxCommitTimeMS: 30000
}
```

La maÃ®trise de l'API des transactions est essentielle pour construire des applications robustes avec MongoDB qui garantissent la cohÃ©rence des donnÃ©es tout en maintenant des performances acceptables.

---


â­ï¸ [Commit et rollback](/08-transactions/03.4-commit-rollback.md)
