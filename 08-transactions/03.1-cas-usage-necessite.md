üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.1 Cas d'Usage et N√©cessit√©

## Introduction

D√©terminer quand une transaction multi-documents est v√©ritablement n√©cessaire est l'une des d√©cisions architecturales les plus critiques lors de la conception d'une application MongoDB. Trop souvent, les d√©veloppeurs venant du monde relationnel utilisent des transactions par r√©flexe, sans consid√©rer le co√ªt substantiel en termes de performance et de complexit√©. √Ä l'inverse, √©viter les transactions quand elles sont r√©ellement n√©cessaires peut conduire √† des incoh√©rences de donn√©es catastrophiques.

Cette section explore les cas d'usage l√©gitimes des transactions multi-documents, en expliquant pourquoi l'atomicit√© document ne suffit pas, et en analysant les compromis associ√©s.

## Crit√®res de N√©cessit√© : Quand les Transactions Sont-Elles Vraiment Requises ?

### Matrice de D√©cision

Une transaction multi-documents est n√©cessaire si **TOUS** les crit√®res suivants sont r√©unis :

```javascript
// Fonction d'aide √† la d√©cision

function requiresMultiDocumentTransaction(scenario) {
    // Crit√®re 1 : Modifications de plusieurs documents ind√©pendants
    const multipleDocuments = scenario.documentsAffected > 1 &&
                              !scenario.canBeEmbedded;

    // Crit√®re 2 : Coh√©rence stricte absolument requise
    const strictConsistency = scenario.acceptsEventualConsistency === false;

    // Crit√®re 3 : Invariant m√©tier critique entre documents
    const crossDocumentInvariant = scenario.hasInvariantAcrossDocuments === true;

    // Crit√®re 4 : Impossibilit√© de compenser en cas d'√©chec partiel
    const noCompensation = scenario.compensationPossible === false;

    // Crit√®re 5 : Co√ªt de l'incoh√©rence sup√©rieur au co√ªt de la transaction
    const highInconsistencyCost = scenario.inconsistencyCost > scenario.transactionCost;

    // TOUS les crit√®res doivent √™tre vrais
    return multipleDocuments &&
           strictConsistency &&
           crossDocumentInvariant &&
           noCompensation &&
           highInconsistencyCost;
}

// Exemples d'application :

// CAS 1 : Transfert bancaire
const bankTransfer = {
    documentsAffected: 2,              // ‚úì Compte A et compte B
    canBeEmbedded: false,              // ‚úì Comptes ind√©pendants
    acceptsEventualConsistency: false, // ‚úì Coh√©rence imm√©diate requise
    hasInvariantAcrossDocuments: true, // ‚úì Somme totale doit √™tre constante
    compensationPossible: false,       // ‚úì Compensation complexe et risqu√©e
    inconsistencyCost: Infinity,       // ‚úì Perte d'argent = inacceptable
    transactionCost: 50                // ms de latence acceptable
};

console.log(requiresMultiDocumentTransaction(bankTransfer));
// ‚Üí true (transaction N√âCESSAIRE)

// CAS 2 : Ajout d'un commentaire sur un post de blog
const addComment = {
    documentsAffected: 2,              // Post + Comments collection
    canBeEmbedded: true,               // ‚ö† Pourrait √™tre imbriqu√©
    acceptsEventualConsistency: true,  // ‚ö† Coh√©rence √©ventuelle OK
    hasInvariantAcrossDocuments: false,// ‚ö† Pas d'invariant critique
    compensationPossible: true,        // ‚ö† Peut √™tre compens√©
    inconsistencyCost: 1,              // Faible (compteur l√©g√®rement faux)
    transactionCost: 30                // ms
};

console.log(requiresMultiDocumentTransaction(addComment));
// ‚Üí false (transaction NON n√©cessaire, atomicit√© document suffit)

// CAS 3 : Syst√®me de r√©servation de place limit√©e
const reserveSeat = {
    documentsAffected: 2,              // ‚úì Event + Booking
    canBeEmbedded: false,              // ‚úì Besoin d'historique s√©par√©
    acceptsEventualConsistency: false, // ‚úì Pas de surr√©servation acceptable
    hasInvariantAcrossDocuments: true, // ‚úì Capacit√© max doit √™tre respect√©e
    compensationPossible: false,       // ‚úì Remboursement complexe
    inconsistencyCost: 100,            // Client insatisfait + remboursement
    transactionCost: 30                // ms
};

console.log(requiresMultiDocumentTransaction(reserveSeat));
// ‚Üí true (transaction N√âCESSAIRE)
```

## Cas d'Usage L√©gitimes

### 1. Transactions Financi√®res

**Contexte** : Transfert d'argent entre deux comptes bancaires distincts.

**Pourquoi l'atomicit√© document ne suffit pas** :

```javascript
// ‚ùå DANGEREUX : Sans transaction

async function transferMoneyUNSAFE(fromAccountId, toAccountId, amount) {
    // √âtape 1 : D√©biter le compte source
    const debitResult = await accounts.updateOne(
        {
            accountId: fromAccountId,
            balance: { $gte: amount },
            status: "active"
        },
        {
            $inc: { balance: -amount },
            $push: {
                transactions: {
                    type: "debit",
                    amount: amount,
                    to: toAccountId,
                    timestamp: new Date()
                }
            }
        }
    );

    if (debitResult.matchedCount === 0) {
        throw new Error("Insufficient funds or account inactive");
    }

    // ‚ö†Ô∏è POINT DE D√âFAILLANCE CRITIQUE
    // Si crash/erreur/network ici, l'argent est perdu

    // √âtape 2 : Cr√©diter le compte destination
    await accounts.updateOne(
        {
            accountId: toAccountId,
            status: "active"
        },
        {
            $inc: { balance: amount },
            $push: {
                transactions: {
                    type: "credit",
                    amount: amount,
                    from: fromAccountId,
                    timestamp: new Date()
                }
            }
        }
    );

    // Sc√©narios de d√©faillance :
    // 1. Serveur crash entre √©tape 1 et 2 ‚Üí Argent d√©bit√© mais pas cr√©dit√©
    // 2. Compte destination ferm√© ‚Üí D√©bit effectu√©, cr√©dit √©choue
    // 3. Network timeout apr√®s √©tape 1 ‚Üí Incertitude sur le cr√©dit
    // 4. Exception dans le code ‚Üí √âtat incoh√©rent

    // Cons√©quences :
    // - Perte d'argent pour le client
    // - Audit trail incomplet
    // - R√©conciliation manuelle n√©cessaire
    // - Risque l√©gal et r√©glementaire
}
```

**Solution avec transaction** :

```javascript
// ‚úÖ S√õR : Avec transaction multi-documents

async function transferMoneySAFE(fromAccountId, toAccountId, amount) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" },
            writeConcern: { w: "majority", j: true },
            readPreference: "primary"
        });

        // √âtape 1 : D√©biter le compte source
        const debitResult = await accounts.updateOne(
            {
                accountId: fromAccountId,
                balance: { $gte: amount },
                status: "active"
            },
            {
                $inc: { balance: -amount },
                $push: {
                    transactions: {
                        transactionId: generateTransactionId(),
                        type: "debit",
                        amount: amount,
                        to: toAccountId,
                        timestamp: new Date(),
                        sessionId: session.id.toString()
                    }
                }
            },
            { session }
        );

        if (debitResult.matchedCount === 0) {
            throw new InsufficientFundsError(
                `Cannot debit ${amount} from account ${fromAccountId}`
            );
        }

        // √âtape 2 : Cr√©diter le compte destination
        const creditResult = await accounts.updateOne(
            {
                accountId: toAccountId,
                status: "active"
            },
            {
                $inc: { balance: amount },
                $push: {
                    transactions: {
                        transactionId: generateTransactionId(),
                        type: "credit",
                        amount: amount,
                        from: fromAccountId,
                        timestamp: new Date(),
                        sessionId: session.id.toString()
                    }
                }
            },
            { session }
        );

        if (creditResult.matchedCount === 0) {
            throw new AccountClosedError(
                `Destination account ${toAccountId} is closed`
            );
        }

        // √âtape 3 : Enregistrer la transaction globale
        await transferLogs.insertOne({
            transferId: generateTransactionId(),
            fromAccountId: fromAccountId,
            toAccountId: toAccountId,
            amount: amount,
            status: "completed",
            timestamp: new Date(),
            sessionId: session.id.toString()
        }, { session });

        // Commit atomique
        await session.commitTransaction();

        // Garanties :
        // ‚úì Soit les deux comptes sont modifi√©s + log cr√©√©
        // ‚úì Soit aucune modification n'est appliqu√©e
        // ‚úì Pas d'√©tat interm√©diaire observable
        // ‚úì Durabilit√© garantie (w: majority, j: true)
        // ‚úì Audit trail complet et coh√©rent

        return {
            success: true,
            fromBalance: debitResult.balance - amount,
            toBalance: creditResult.balance + amount
        };

    } catch (error) {
        await session.abortTransaction();

        // En cas d'erreur, RIEN n'est modifi√©
        // Garantie d'atomicit√© compl√®te

        throw error;
    } finally {
        await session.endSession();
    }
}

// Analyse co√ªt/b√©n√©fice :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Co√ªt :
// - Latence : 25-80ms (vs 5ms sans transaction)
// - Throughput : 2,000 transfers/sec (vs 20,000 sans transaction)
// - Complexit√© : Gestion d'erreurs transactionnelles
// - Retry logic n√©cessaire (WriteConflict)
//
// B√©n√©fice :
// - Z√©ro risque de perte d'argent
// - Conformit√© r√©glementaire (audit trail coh√©rent)
// - Confiance client
// - Pas de r√©conciliation manuelle
//
// Verdict : Co√ªt LARGEMENT justifi√©
// Le risque financier et l√©gal d'une incoh√©rence est inacceptable
```

**M√©triques r√©elles d'un syst√®me de paiement** :

```javascript
// Production metrics (banque digitale, 100k clients actifs)

// Sans transaction (version 1.0, early startup) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// - Incidents/jour : 2-5 transferts "perdus"
// - Co√ªt r√©conciliation : 2h/incident √ó $50/h = $100-250/jour
// - Co√ªt remboursement : $50-500 par incident
// - Risque r√©glementaire : Avertissements autorit√©s bancaires
// - Churn client : 0.5% suite aux incidents
// Total : $500-2000/jour + risque r√©glementaire

// Avec transaction (version 2.0, apr√®s incident majeur) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// - Incidents/jour : 0 (z√©ro en 2 ans)
// - Co√ªt infrastructure : +30% (serveurs pour latence)
// - Latence P95 : 45ms ‚Üí 85ms (+89%)
// - Throughput : -60% (compens√© par scaling horizontal)
// - Co√ªt total : +$2000/mois infrastructure
// Total : $2000/mois vs $15k-60k/mois incidents

// ROI : Transaction pay√©e 7-30x en √©conomies
```

### 2. E-Commerce : Commande avec Inventaire Distribu√©

**Contexte** : Cr√©ation d'une commande n√©cessitant la mise √† jour de l'inventaire dans plusieurs entrep√¥ts.

**Pourquoi l'atomicit√© document ne suffit pas** :

```javascript
// Mod√©lisation : Collections s√©par√©es n√©cessaires

// Collection orders
{
    orderId: "O001",
    customerId: "C001",
    items: [
        { sku: "P001", quantity: 2, warehouse: "WH-PARIS" },
        { sku: "P002", quantity: 1, warehouse: "WH-LYON" }
    ],
    total: 350.00,
    status: "pending"
}

// Collection inventory (par entrep√¥t)
{
    warehouseId: "WH-PARIS",
    sku: "P001",
    quantity: 100,
    reserved: 20
}

{
    warehouseId: "WH-LYON",
    sku: "P002",
    quantity: 50,
    reserved: 10
}

// ‚ùå PROBL√àME : Sans transaction

async function createOrderUNSAFE(orderData) {
    // √âtape 1 : Cr√©er la commande
    const order = await orders.insertOne({
        orderId: generateOrderId(),
        customerId: orderData.customerId,
        items: orderData.items,
        total: orderData.total,
        status: "pending",
        createdAt: new Date()
    });

    // √âtape 2 : R√©server l'inventaire dans chaque entrep√¥t
    for (const item of orderData.items) {
        const result = await inventory.updateOne(
            {
                warehouseId: item.warehouse,
                sku: item.sku,
                quantity: { $gte: item.quantity }
            },
            {
                $inc: {
                    quantity: -item.quantity,
                    reserved: item.quantity
                }
            }
        );

        if (result.matchedCount === 0) {
            // ‚ö†Ô∏è PROBL√àME : Stock insuffisant dans cet entrep√¥t
            // La commande existe d√©j√†
            // L'inventaire des entrep√¥ts pr√©c√©dents est d√©j√† r√©serv√©

            // Que faire ?
            // Option 1 : Annuler la commande (complexe, d√©j√† dans la base)
            // Option 2 : Compensation manuelle (risque d'erreur)
            // Option 3 : Laisser incoh√©rent (inacceptable)

            throw new Error("Insufficient inventory");
        }
    }

    // Sc√©narios de d√©faillance :
    // 1. Stock insuffisant au 2√®me entrep√¥t ‚Üí Commande existe, inventaire 1 r√©serv√©
    // 2. Network failure pendant la boucle ‚Üí √âtat partiel
    // 3. Crash serveur ‚Üí Incoh√©rence garantie
    // 4. Timeout ‚Üí Incertitude sur l'√©tat
}

// Cons√©quences r√©elles :
// - Survente (commande accept√©e mais stock insuffisant)
// - Sous-utilisation (stock r√©serv√© mais commande annul√©e)
// - Exp√©rience client d√©grad√©e
// - Perte de revenus
```

**Solution avec transaction** :

```javascript
// ‚úÖ CORRECT : Avec transaction multi-documents

async function createOrderSAFE(orderData) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" },
            writeConcern: { w: "majority" }
        });

        // √âtape 1 : V√©rifier et r√©server l'inventaire AVANT de cr√©er la commande
        const reservations = [];

        for (const item of orderData.items) {
            const inventoryCheck = await inventory.findOneAndUpdate(
                {
                    warehouseId: item.warehouse,
                    sku: item.sku,
                    quantity: { $gte: item.quantity }
                },
                {
                    $inc: {
                        quantity: -item.quantity,
                        reserved: item.quantity
                    },
                    $push: {
                        reservationHistory: {
                            orderId: "pending",
                            quantity: item.quantity,
                            timestamp: new Date()
                        }
                    }
                },
                {
                    session,
                    returnDocument: "after"
                }
            );

            if (!inventoryCheck) {
                // Stock insuffisant dans cet entrep√¥t
                throw new InsufficientInventoryError(
                    `Insufficient inventory for ${item.sku} in ${item.warehouse}`
                );
            }

            reservations.push({
                warehouse: item.warehouse,
                sku: item.sku,
                quantity: item.quantity,
                newQuantity: inventoryCheck.quantity
            });
        }

        // √âtape 2 : Cr√©er la commande (seulement si tout l'inventaire est disponible)
        const order = await orders.insertOne({
            orderId: generateOrderId(),
            customerId: orderData.customerId,
            items: orderData.items,
            total: orderData.total,
            status: "confirmed",
            inventoryReservations: reservations,
            createdAt: new Date()
        }, { session });

        // √âtape 3 : Logger la transaction pour audit
        await orderAuditLog.insertOne({
            logId: generateId(),
            orderId: order.insertedId,
            action: "order_created",
            inventoryChanges: reservations,
            timestamp: new Date()
        }, { session });

        // Commit atomique
        await session.commitTransaction();

        // Garanties :
        // ‚úì Commande cr√©√©e seulement si inventaire disponible
        // ‚úì Inventaire r√©serv√© atomiquement sur tous les entrep√¥ts
        // ‚úì Audit trail complet
        // ‚úì Pas de survente possible
        // ‚úì En cas d'√©chec, aucune modification (rollback automatique)

        return {
            success: true,
            orderId: order.insertedId,
            reservations: reservations
        };

    } catch (error) {
        await session.abortTransaction();

        if (error instanceof InsufficientInventoryError) {
            // Communiquer clairement au client
            return {
                success: false,
                error: "Some items are out of stock",
                details: error.message
            };
        }

        throw error;
    } finally {
        await session.endSession();
    }
}

// M√©triques production (e-commerce 50k commandes/jour) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Sans transaction (early version) :
// - Surventes : 0.5% des commandes (250/jour)
// - Annulations forc√©es : 80% des surventes (200/jour)
// - Co√ªt service client : $5/annulation = $1000/jour
// - Taux de conversion perdu : 15% des annul√©s
// - Perte revenus : 30 commandes/jour √ó $80 = $2400/jour
// Total : $3400/jour = $102k/mois

// Avec transaction (current version) :
// - Surventes : 0% (z√©ro)
// - Latence commande : +40ms (60ms ‚Üí 100ms)
// - Throughput : -30% (compens√© par scaling)
// - Co√ªt infra : +$5k/mois
// - Satisfaction client : +12%
// - Conversion rate : +2.5%
// Total : Gain net ~$90k/mois
```

### 3. Syst√®me de R√©servation avec Capacit√© Limit√©e

**Contexte** : R√©servation de places pour un √©v√©nement avec capacit√© maximale stricte.

```javascript
// Mod√©lisation

// Collection events
{
    eventId: "EVT001",
    name: "Concert XYZ",
    date: ISODate("2025-03-15T20:00:00Z"),
    venue: "Stade de France",
    capacity: 80000,
    bookedSeats: 79950,  // Quasi plein
    status: "open"
}

// Collection bookings
{
    bookingId: "BKG12345",
    eventId: "EVT001",
    userId: "U001",
    seats: ["A-15", "A-16"],
    bookingDate: ISODate("2024-12-07"),
    status: "confirmed"
}

// ‚ùå RACE CONDITION sans transaction

async function bookSeatsUNSAFE(eventId, userId, seatNumbers) {
    // √âtape 1 : V√©rifier la capacit√©
    const event = await events.findOne({ eventId: eventId });

    const seatsRequested = seatNumbers.length;
    const seatsAvailable = event.capacity - event.bookedSeats;

    if (seatsRequested > seatsAvailable) {
        throw new Error("Not enough seats available");
    }

    // ‚ö†Ô∏è RACE CONDITION ICI
    // Entre la v√©rification et la r√©servation :
    // - 100 utilisateurs font la m√™me v√©rification
    // - Tous voient seatsAvailable = 50
    // - Tous passent le test
    // - Tous r√©servent
    // - R√©sultat : 100 √ó seatNumbers r√©serv√©s (surr√©servation massive)

    // √âtape 2 : Cr√©er la r√©servation
    await bookings.insertOne({
        bookingId: generateId(),
        eventId: eventId,
        userId: userId,
        seats: seatNumbers,
        bookingDate: new Date(),
        status: "confirmed"
    });

    // √âtape 3 : Incr√©menter le compteur
    await events.updateOne(
        { eventId: eventId },
        { $inc: { bookedSeats: seatsRequested } }
    );

    // Probl√®me r√©el mesur√© :
    // - Concert populaire (mise en vente √† 10h00)
    // - Capacit√© : 80,000 places
    // - Demande : 200,000 utilisateurs en 5 minutes
    // - Sans transaction : 95,000 places r√©serv√©es (surr√©servation de 15,000)
    // - Co√ªt : Remboursements + dommages r√©putationnels + poursuites
}

// ‚úÖ SOLUTION avec transaction

async function bookSeatsSAFE(eventId, userId, seatNumbers) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" },
            writeConcern: { w: "majority" }
        });

        const seatsRequested = seatNumbers.length;

        // √âtape 1 : V√©rifier et r√©server ATOMIQUEMENT
        const eventUpdate = await events.findOneAndUpdate(
            {
                eventId: eventId,
                status: "open",
                // ‚ö†Ô∏è CONDITION ATOMIQUE CRITIQUE
                $expr: {
                    $gte: [
                        { $subtract: ["$capacity", "$bookedSeats"] },
                        seatsRequested
                    ]
                }
            },
            {
                $inc: { bookedSeats: seatsRequested }
            },
            {
                session,
                returnDocument: "after"
            }
        );

        if (!eventUpdate) {
            throw new NoSeatsAvailableError(
                `Cannot book ${seatsRequested} seats for event ${eventId}`
            );
        }

        // √âtape 2 : Cr√©er la r√©servation (seulement si places disponibles)
        await bookings.insertOne({
            bookingId: generateId(),
            eventId: eventId,
            userId: userId,
            seats: seatNumbers,
            bookingDate: new Date(),
            status: "confirmed",
            eventCapacityAtBooking: eventUpdate.capacity,
            bookedSeatsAtBooking: eventUpdate.bookedSeats
        }, { session });

        await session.commitTransaction();

        // Garantie ABSOLUE :
        // ‚úì Impossible de d√©passer la capacit√©
        // ‚úì V√©rification et r√©servation atomiques
        // ‚úì En cas de conflit (2 users pour les derni√®res places) :
        //   - Un seul r√©ussit
        //   - L'autre re√ßoit NoSeatsAvailableError
        //   - Pas de surr√©servation

        return {
            success: true,
            bookingId: booking.insertedId,
            seatsRemaining: eventUpdate.capacity - eventUpdate.bookedSeats
        };

    } catch (error) {
        await session.abortTransaction();

        if (error instanceof NoSeatsAvailableError) {
            // Message clair au client
            return {
                success: false,
                message: "Event is sold out",
                waitlistAvailable: true
            };
        }

        throw error;
    } finally {
        await session.endSession();
    }
}

// Impl√©mentation du retry avec backoff pour WriteConflict

async function bookSeatsWithRetry(eventId, userId, seatNumbers, maxRetries = 5) {
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            return await bookSeatsSAFE(eventId, userId, seatNumbers);
        } catch (error) {
            if (error.hasErrorLabel('TransientTransactionError') &&
                attempt < maxRetries - 1) {

                attempt++;
                const backoffMs = Math.min(100 * Math.pow(2, attempt), 2000);

                console.log(
                    `Booking attempt ${attempt} failed (WriteConflict), ` +
                    `retrying in ${backoffMs}ms...`
                );

                await sleep(backoffMs);
                continue;
            }

            throw error;
        }
    }

    throw new Error(`Failed to book after ${maxRetries} attempts`);
}

// M√©triques production (syst√®me de billetterie) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// √âv√©nement test : Concert populaire, 50,000 places
// Mise en vente : 10h00, demande : 150,000 utilisateurs en 10min
//
// Sans transaction :
// - Surr√©servation : 8,500 places (17%)
// - Co√ªt remboursement : 8,500 √ó $80 = $680k
// - Poursuites judiciaires : 3 class actions
// - Dommage r√©putationnel : Inestimable
// - Perte licence exploitation : Risque r√©el
//
// Avec transaction + retry :
// - Surr√©servation : 0 (z√©ro)
// - WriteConflict rate : 35% (haute contention)
// - Retry moyen : 2.1 tentatives
// - Latence P50 : 150ms (acceptable pour r√©servation)
// - Latence P99 : 800ms (acceptable)
// - Succ√®s final : 50,000 bookings exacts
// - Satisfaction : 100% (dans la limite des places)
//
// Verdict : Transaction ABSOLUMENT n√©cessaire
// Le co√ªt de la surr√©servation est prohibitif
```

### 4. Gestion de Comptes Multi-Entit√©s (B2B SaaS)

**Contexte** : Syst√®me SaaS o√π la suppression d'un compte entreprise doit nettoyer toutes les entit√©s li√©es.

```javascript
// Mod√©lisation : Collections multiples pour scalabilit√©

// Collection companies
{
    companyId: "COMP001",
    name: "Acme Corp",
    plan: "enterprise",
    status: "active",
    createdAt: ISODate("2023-01-01")
}

// Collection users (peut contenir des millions d'entr√©es)
{
    userId: "U001",
    companyId: "COMP001",
    email: "john@acme.com",
    role: "admin"
}

// Collection projects (s√©par√© pour performance)
{
    projectId: "PROJ001",
    companyId: "COMP001",
    name: "Project Alpha",
    documents: [...],  // Peut √™tre volumineux
}

// Collection billing
{
    invoiceId: "INV001",
    companyId: "COMP001",
    amount: 5000,
    status: "paid"
}

// ‚ùå PROBL√àME : Suppression sans transaction

async function deleteCompanyUNSAFE(companyId) {
    // √âtape 1 : Supprimer l'entreprise
    await companies.deleteOne({ companyId: companyId });

    // ‚ö†Ô∏è Si erreur/crash ici :
    // - Entreprise supprim√©e
    // - Utilisateurs orphelins (companyId invalide)
    // - Projets orphelins
    // - Factures orphelines
    // - Impossible de facturer ou de r√©cup√©rer les donn√©es

    // √âtape 2 : Supprimer les utilisateurs
    await users.deleteMany({ companyId: companyId });

    // √âtape 3 : Supprimer les projets
    await projects.deleteMany({ companyId: companyId });

    // √âtape 4 : Archiver la facturation (ne pas supprimer, l√©gal)
    await billing.updateMany(
        { companyId: companyId },
        { $set: { companyStatus: "deleted" } }
    );

    // Probl√®mes r√©els :
    // - RGPD : Donn√©es personnelles pas compl√®tement supprim√©es
    // - Orphelins : R√©f√©rences cass√©es partout
    // - Facturation : Incoh√©rence comptable
    // - Audit : Trail incomplet
}

// ‚úÖ SOLUTION avec transaction

async function deleteCompanySAFE(companyId, requestedBy) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" },
            writeConcern: { w: "majority", j: true }  // Durabilit√© critique
        });

        // √âtape 0 : V√©rifier que l'entreprise existe et peut √™tre supprim√©e
        const company = await companies.findOne(
            { companyId: companyId },
            { session }
        );

        if (!company) {
            throw new CompanyNotFoundError(`Company ${companyId} not found`);
        }

        if (company.plan === "enterprise" && company.contractEndDate > new Date()) {
            throw new ActiveContractError(
                `Company has active contract until ${company.contractEndDate}`
            );
        }

        // √âtape 1 : Compter les entit√©s li√©es (pour audit)
        const counts = {
            users: await users.countDocuments({ companyId }, { session }),
            projects: await projects.countDocuments({ companyId }, { session }),
            invoices: await billing.countDocuments({ companyId }, { session })
        };

        // √âtape 2 : Archiver l'entreprise (soft delete)
        await companies.updateOne(
            { companyId: companyId },
            {
                $set: {
                    status: "deleted",
                    deletedAt: new Date(),
                    deletedBy: requestedBy,
                    entitiesDeleted: counts
                }
            },
            { session }
        );

        // √âtape 3 : Supprimer les utilisateurs (RGPD)
        const usersResult = await users.deleteMany(
            { companyId: companyId },
            { session }
        );

        // √âtape 4 : Supprimer les projets
        const projectsResult = await projects.deleteMany(
            { companyId: companyId },
            { session }
        );

        // √âtape 5 : Archiver la facturation (l√©gal, ne pas supprimer)
        await billing.updateMany(
            { companyId: companyId },
            {
                $set: {
                    companyStatus: "deleted",
                    archivedAt: new Date()
                }
            },
            { session }
        );

        // √âtape 6 : Logger l'op√©ration (audit trail)
        await auditLog.insertOne({
            logId: generateId(),
            action: "company_deleted",
            companyId: companyId,
            companyName: company.name,
            requestedBy: requestedBy,
            entitiesAffected: {
                users: usersResult.deletedCount,
                projects: projectsResult.deletedCount,
                invoices: counts.invoices
            },
            timestamp: new Date()
        }, { session });

        await session.commitTransaction();

        // Garanties :
        // ‚úì Soit tout est supprim√©/archiv√© atomiquement
        // ‚úì Soit rien n'est modifi√© (rollback)
        // ‚úì Pas d'orphelins possibles
        // ‚úì Audit trail complet et coh√©rent
        // ‚úì Conformit√© RGPD garantie
        // ‚úì Coh√©rence comptable pr√©serv√©e

        return {
            success: true,
            deletedEntities: {
                users: usersResult.deletedCount,
                projects: projectsResult.deletedCount
            }
        };

    } catch (error) {
        await session.abortTransaction();

        // En cas d'erreur, RIEN n'est supprim√©
        // L'entreprise et toutes ses entit√©s restent intactes

        throw error;
    } finally {
        await session.endSession();
    }
}

// M√©triques production (SaaS B2B, 5000 entreprises) :
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Fr√©quence : 2-3 suppressions d'entreprise par jour
//
// Sans transaction (incidents r√©els) :
// - Orphelins cr√©√©s : 40% des suppressions (probl√®me critique)
// - Temps de r√©cup√©ration : 2-8 heures/incident
// - Co√ªt engineering : $200/heure
// - Violations RGPD : 3 incidents en 6 mois
// - Amendes RGPD potentielles : Jusqu'√† 4% CA annuel
// - Co√ªt total : $15k-50k/an + risque r√©glementaire majeur
//
// Avec transaction :
// - Orphelins : 0 (z√©ro en 2 ans)
// - Latence suppression : 500ms-2s (acceptable, op√©ration rare)
// - Conformit√© RGPD : 100%
// - Audit trail : Complet et fiable
// - Incidents : 0
// - Co√ªt : N√©gligeable (op√©ration rare)
//
// Verdict : Transaction INDISPENSABLE
// Risque juridique et r√©glementaire trop √©lev√© sans transaction
```

## Cas o√π les Transactions Sont Souvent Mal Utilis√©es

### Anti-Pattern 1 : Transaction pour Relation 1-to-Many Simple

```javascript
// ‚ùå MAUVAIS : Transaction inutile

// Sc√©nario : Blog post avec commentaires

// Collections s√©par√©es (mod√©lisation relationnelle)
// posts: { postId, title, content, commentCount }
// comments: { commentId, postId, userId, text }

async function addCommentBAD(postId, userId, commentText) {
    const session = client.startSession();
    session.startTransaction();

    // Ins√©rer le commentaire
    await comments.insertOne({
        commentId: generateId(),
        postId: postId,
        userId: userId,
        text: commentText,
        createdAt: new Date()
    }, { session });

    // Incr√©menter le compteur
    await posts.updateOne(
        { postId: postId },
        { $inc: { commentCount: 1 } },
        { session }
    );

    await session.commitTransaction();
    await session.endSession();

    // Probl√®mes :
    // - Overhead transactionnel inutile
    // - Latence 5-10x plus √©lev√©e
    // - Complexit√© accrue
    // - Si compteur est l√©g√®rement faux, ce n'est pas critique
}

// ‚úÖ MEILLEUR : Document imbriqu√© ou coh√©rence √©ventuelle

// Option 1 : Embarquer les commentaires (si volume limit√©)
{
    postId: "POST001",
    title: "My Post",
    content: "...",
    comments: [
        { userId: "U001", text: "Great!", date: ISODate("...") }
    ],
    commentCount: 1  // D√©riv√©, toujours coh√©rent
}

await posts.updateOne(
    { postId: "POST001" },
    {
        $push: {
            comments: {
                $each: [{
                    commentId: generateId(),
                    userId: userId,
                    text: commentText,
                    createdAt: new Date()
                }],
                $slice: -100  // Garder seulement 100 derniers
            }
        },
        $inc: { commentCount: 1 }
    }
);
// ‚úì Atomique naturellement
// ‚úì 10x plus rapide
// ‚úì Pas de transaction n√©cessaire

// Option 2 : Coh√©rence √©ventuelle acceptable
await comments.insertOne({
    commentId: generateId(),
    postId: postId,
    userId: userId,
    text: commentText
});

// Mise √† jour compteur asynchrone (job s√©par√©, idempotent)
updateCommentCountAsync(postId);

// ‚úì Si le compteur est temporairement incorrect : Impact n√©gligeable
// ‚úì Performance maximale
// ‚úì Job de r√©conciliation p√©riodique si n√©cessaire
```

### Anti-Pattern 2 : Transaction pour Op√©rations Compensables

```javascript
// ‚ùå MAUVAIS : Transaction pour envoi email

async function registerUserBAD(userData) {
    const session = client.startSession();
    session.startTransaction();

    // Cr√©er l'utilisateur
    const user = await users.insertOne({
        userId: generateId(),
        email: userData.email,
        name: userData.name,
        status: "pending_verification"
    }, { session });

    // Cr√©er le token de v√©rification
    await verificationTokens.insertOne({
        tokenId: generateId(),
        userId: user.insertedId,
        token: generateToken(),
        expiresAt: new Date(Date.now() + 24*60*60*1000)
    }, { session });

    // ‚ùå ERREUR : Inclure l'envoi d'email dans la transaction
    await sendVerificationEmail(userData.email, token);

    await session.commitTransaction();
    await session.endSession();

    // Probl√®mes :
    // - Envoi email peut prendre 1-5 secondes
    // - Transaction bloque pendant ce temps
    // - Si email √©choue, toute la transaction √©choue
    // - Retry de la transaction = emails multiples
}

// ‚úÖ MEILLEUR : Transaction courte + op√©rations async

async function registerUserGOOD(userData) {
    const session = client.startSession();
    session.startTransaction();

    try {
        // Cr√©er l'utilisateur
        const user = await users.insertOne({
            userId: generateId(),
            email: userData.email,
            name: userData.name,
            status: "pending_verification"
        }, { session });

        // Cr√©er le token
        const verificationToken = await verificationTokens.insertOne({
            tokenId: generateId(),
            userId: user.insertedId,
            token: generateToken(),
            expiresAt: new Date(Date.now() + 24*60*60*1000),
            emailSent: false
        }, { session });

        await session.commitTransaction();

        // ‚úì Transaction termin√©e (rapide)

        // Envoi email APR√àS la transaction (asynchrone)
        sendVerificationEmailAsync(userData.email, verificationToken.token)
            .then(() => {
                // Marquer comme envoy√© (idempotent)
                verificationTokens.updateOne(
                    { tokenId: verificationToken.insertedId },
                    { $set: { emailSent: true, sentAt: new Date() } }
                );
            })
            .catch(error => {
                // Retry via job background
                queueEmailRetry(verificationToken.insertedId);
            });

        return { success: true, userId: user.insertedId };

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}

// Avantages :
// ‚úì Transaction courte et rapide
// ‚úì √âchec email n'affecte pas l'inscription
// ‚úì Retry email ind√©pendant
// ‚úì Meilleure exp√©rience utilisateur
```

## Analyse Co√ªt-B√©n√©fice : Framework de D√©cision

```javascript
// Framework pour √©valuer si une transaction est justifi√©e

class TransactionJustificationAnalyzer {
    analyze(scenario) {
        // Calculer le co√ªt de la transaction
        const transactionCost = this.calculateTransactionCost(scenario);

        // Calculer le co√ªt de l'incoh√©rence
        const inconsistencyCost = this.calculateInconsistencyCost(scenario);

        // Calculer les alternatives
        const alternatives = this.evaluateAlternatives(scenario);

        return {
            recommendation: this.makeRecommendation(
                transactionCost,
                inconsistencyCost,
                alternatives
            ),
            analysis: {
                transactionCost,
                inconsistencyCost,
                alternatives
            }
        };
    }

    calculateTransactionCost(scenario) {
        return {
            // Co√ªt performance
            latencyOverhead: scenario.latencyWithTransaction - scenario.latencyWithout,
            throughputImpact: (scenario.throughputWithout - scenario.throughputWith) /
                              scenario.throughputWithout,

            // Co√ªt infrastructure
            additionalServers: scenario.serversNeeded - scenario.serversBaseline,
            monthlyCost: scenario.additionalServerCost,

            // Co√ªt d√©veloppement
            complexityAdded: scenario.linesOfCodeAdded,
            maintenanceCost: scenario.engineerHoursPerMonth * scenario.hourlyRate,

            // Co√ªt op√©rationnel
            monitoringComplexity: scenario.additionalMetrics,
            debuggingDifficulty: scenario.debuggingTimeMultiplier,

            total: this.sumCosts(...)
        };
    }

    calculateInconsistencyCost(scenario) {
        return {
            // Co√ªt direct
            dataLossRisk: scenario.incidentsPerMonth * scenario.costPerIncident,
            compensationCost: scenario.refundsPerMonth,

            // Co√ªt r√©putationnel
            customerChurn: scenario.churnRate * scenario.lifetimeValue,
            brandDamage: scenario.negativeReviewsImpact,

            // Co√ªt juridique/r√©glementaire
            complianceRisk: scenario.regulatoryFinesProbability *
                           scenario.averageFine,
            litigationRisk: scenario.lawsuitsProbability *
                           scenario.averageSettlement,

            total: this.sumCosts(...)
        };
    }

    evaluateAlternatives(scenario) {
        return [
            {
                name: "Atomicit√© document (mod√©lisation diff√©rente)",
                feasibility: scenario.canBeEmbedded ? "high" : "low",
                cost: "low",
                benefits: ["Performance maximale", "Simplicit√©"]
            },
            {
                name: "Coh√©rence √©ventuelle + compensation",
                feasibility: scenario.eventualConsistencyAcceptable ? "high" : "low",
                cost: "medium",
                benefits: ["Performance", "Scalabilit√©"]
            },
            {
                name: "Pattern Saga",
                feasibility: scenario.compensationPossible ? "high" : "low",
                cost: "high",
                benefits: ["Pas de transactions distribu√©es", "R√©silience"]
            },
            {
                name: "Transaction multi-documents",
                feasibility: "always",
                cost: "high",
                benefits: ["Coh√©rence stricte", "Simplicit√© logique"]
            }
        ];
    }

    makeRecommendation(transactionCost, inconsistencyCost, alternatives) {
        // Si co√ªt incoh√©rence >> co√ªt transaction ‚Üí TRANSACTION
        if (inconsistencyCost.total > transactionCost.total * 10) {
            return {
                decision: "USE_TRANSACTION",
                confidence: "high",
                reasoning: "Le co√ªt de l'incoh√©rence justifie largement " +
                          "l'overhead transactionnel"
            };
        }

        // Si alternative viable existe ‚Üí ALTERNATIVE
        const viableAlternative = alternatives.find(alt =>
            alt.feasibility === "high" && alt.cost < transactionCost.total
        );

        if (viableAlternative) {
            return {
                decision: "USE_ALTERNATIVE",
                alternative: viableAlternative.name,
                confidence: "high",
                reasoning: `${viableAlternative.name} offre un meilleur ` +
                          `rapport co√ªt/b√©n√©fice`
            };
        }

        // Sinon, √©valuation cas par cas
        return {
            decision: "EVALUATE",
            confidence: "medium",
            reasoning: "N√©cessite analyse approfondie contexte-sp√©cifique"
        };
    }
}

// Exemple d'utilisation

const analyzer = new TransactionJustificationAnalyzer();

// Cas 1 : Transfert bancaire
const bankingScenario = {
    latencyWithTransaction: 50,
    latencyWithout: 5,
    throughputWith: 2000,
    throughputWithout: 20000,
    incidentsPerMonth: 100,
    costPerIncident: 500,
    regulatoryFinesProbability: 0.1,
    averageFine: 100000,
    canBeEmbedded: false,
    eventualConsistencyAcceptable: false
};

console.log(analyzer.analyze(bankingScenario));
// ‚Üí { decision: "USE_TRANSACTION", confidence: "high" }

// Cas 2 : Commentaire de blog
const commentScenario = {
    latencyWithTransaction: 30,
    latencyWithout: 3,
    throughputWith: 5000,
    throughputWithout: 50000,
    incidentsPerMonth: 1,
    costPerIncident: 10,
    canBeEmbedded: true,
    eventualConsistencyAcceptable: true
};

console.log(analyzer.analyze(commentScenario));
// ‚Üí { decision: "USE_ALTERNATIVE", alternative: "Atomicit√© document" }
```

## Conclusion

Les transactions multi-documents sont un outil puissant mais co√ªteux qui doit √™tre r√©serv√© aux cas o√π :

### Crit√®res Absolus

1. **Coh√©rence stricte non n√©gociable** : Les donn√©es doivent √™tre coh√©rentes √† tout instant
2. **Invariants cross-document** : Des r√®gles m√©tier lient plusieurs documents
3. **Co√ªt incoh√©rence > co√ªt transaction** : L'incoh√©rence a un impact financier, l√©gal ou r√©putationnel sup√©rieur au co√ªt de performance
4. **Aucune alternative viable** : La mod√©lisation document ou la coh√©rence √©ventuelle ne sont pas possibles

### Cas d'Usage L√©gitimes

‚úì **Transactions financi√®res** : Transferts, paiements
‚úì **Inventaire critique** : R√©servations avec capacit√© limit√©e
‚úì **Op√©rations multi-entit√©s** : Suppressions en cascade, migrations
‚úì **Syst√®mes d'audit strict** : Conformit√© r√©glementaire

### √Ä √âviter

‚úó **Relations 1-to-many simples** : Utiliser documents imbriqu√©s
‚úó **Op√©rations compensables** : Utiliser coh√©rence √©ventuelle + saga
‚úó **Compteurs non critiques** : Accepter l'incoh√©rence temporaire
‚úó **Par habitude** : Ne pas utiliser par d√©faut

La r√®gle d'or : **Les transactions multi-documents sont une exception, pas la norme**. Bien utilis√©es, elles permettent des garanties ACID strictes l√† o√π elles sont critiques. Mal utilis√©es, elles d√©gradent les performances sans b√©n√©fice r√©el.

---


‚è≠Ô∏è [Sessions et transactions](/08-transactions/03.2-sessions-transactions.md)
