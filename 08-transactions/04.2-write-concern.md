üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.4.2 Write Concern (w, j, wtimeout)

## Introduction au Write Concern

Si le Read Concern d√©finit ce qu'une application peut **lire**, le Write Concern d√©finit les garanties qu'elle obtient lorsqu'elle **√©crit**. Il s'agit d'un m√©canisme fondamental qui d√©termine le niveau d'accus√© de r√©ception requis avant que MongoDB consid√®re une op√©ration d'√©criture comme r√©ussie.

Le Write Concern r√©pond √† trois questions critiques :

1. **Durabilit√©** : Sur combien de n≈ìuds mes donn√©es doivent-elles √™tre persist√©es ?
2. **Persistance** : Mes donn√©es doivent-elles √™tre √©crites sur disque (journal) ?
3. **Temporalit√©** : Combien de temps suis-je pr√™t √† attendre cette confirmation ?

Ces trois questions sont contr√¥l√©es par trois param√®tres distincts : `w`, `j`, et `wtimeout`.

## Anatomie du Write Concern

Un Write Concern complet se pr√©sente sous la forme :

```javascript
{
  w: <value>,           // Niveau d'accus√© de r√©ception
  j: <boolean>,         // Journalisation
  wtimeout: <number>    // Timeout en millisecondes
}
```

### Vue d'ensemble du flux d'√©criture

Comprendre le Write Concern n√©cessite de visualiser le chemin d'une √©criture dans un Replica Set :

```
Client ‚Üí Primary (MongoDB)
         ‚Üì
         1. √âcriture en m√©moire (cache WiredTiger)
         2. √âcriture dans le journal (si j:true)
         3. R√©plication vers Secondaries
         4. Confirmation au client (selon w)

Timeline d√©taill√©e :
T0  : Client envoie write
T1  : Primary re√ßoit et √©crit en m√©moire (~1ms)
T2  : Primary √©crit dans le journal si j:true (~2-5ms)
T3  : Primary envoie aux Secondaries via oplog (~10-50ms selon r√©seau)
T4  : Secondaries acquittent la r√©ception
T5  : Primary confirme au client (selon w)
```

## Param√®tre w : Niveau d'accus√© de r√©ception

Le param√®tre `w` (write acknowledgment) est le plus important du Write Concern. Il d√©termine combien de n≈ìuds doivent confirmer l'√©criture avant que l'op√©ration soit consid√©r√©e comme r√©ussie.

### w: 0 - Fire and Forget (Unacknowledged)

**Comportement** : Le driver envoie l'op√©ration et ne attend **aucune** confirmation. Il ne sait m√™me pas si l'op√©ration a r√©ussi ou √©chou√©.

```javascript
db.logs.insertOne(
  {
    timestamp: new Date(),
    level: "DEBUG",
    message: "User action logged"
  },
  { writeConcern: { w: 0 } }
);
// Retourne imm√©diatement, aucune garantie
```

**Garanties** :
- ‚úÖ Latence minimale absolue (< 0.5ms)
- ‚úÖ Throughput maximal
- ‚ùå Aucune garantie de succ√®s
- ‚ùå Aucune d√©tection d'erreur (contrainte unique, validation, etc.)
- ‚ùå Risque de perte de donn√©es si crash imm√©diat

**M√©triques de performance** :

```
Write Concern: w:0
Latence moyenne : 0.3-0.8ms
Throughput : 100,000+ ops/sec (limit√© par le r√©seau)
Perte de donn√©es potentielle : 100-1000ms de donn√©es en cas de crash
```

**Cas d'usage l√©gitime** :

1. **Logs de debugging non critiques** : Les logs de d√©veloppement peuvent √™tre perdus sans impact

```javascript
// Logger en mode d√©veloppement
function debugLog(message) {
  db.debug_logs.insertOne(
    { message, timestamp: new Date() },
    { writeConcern: { w: 0 } }
  ).catch(() => {}); // Ignorer m√™me les erreurs
}
```

2. **M√©triques approximatives** : Compteurs de pages vues o√π la pr√©cision n'est pas critique

```javascript
// Incr√©menter un compteur non critique
db.page_views.updateOne(
  { page: "/home" },
  { $inc: { views: 1 } },
  { writeConcern: { w: 0 } }
);
```

**Antipattern critique** :

```javascript
// ‚ùå DANGEREUX : Donn√©es utilisateur avec w:0
db.users.insertOne(
  {
    email: "user@example.com",
    password: hashedPassword
  },
  { writeConcern: { w: 0 } }
);
// PROBL√àME : Aucune garantie que l'utilisateur a √©t√© cr√©√©
// L'application peut confirmer l'inscription alors que l'√©criture a √©chou√©
```

### w: 1 - Acknowledged (D√©faut)

**Comportement** : Le Primary confirme l'√©criture apr√®s qu'elle soit √©crite en m√©moire. C'est le **comportement par d√©faut** de MongoDB.

```javascript
db.articles.insertOne(
  { title: "MongoDB Guide", content: "..." },
  { writeConcern: { w: 1 } } // √âquivalent √† ne rien sp√©cifier
);
```

**Garanties** :
- ‚úÖ L'√©criture a r√©ussi sur le Primary
- ‚úÖ Les erreurs sont d√©tect√©es (contraintes, validations)
- ‚úÖ Latence faible (~2-5ms)
- ‚ö†Ô∏è Risque de perte si le Primary crash avant r√©plication
- ‚ùå Pas de garantie de durabilit√© distribu√©e

**Sc√©nario de perte de donn√©es** :

```
Timeline avec w:1 :

T0 : Client √©crit document { _id: 1, data: "important" }
T1 : Primary acquitte (w:1 satisfait) ‚Üí Client re√ßoit succ√®s
T2 : Document en m√©moire du Primary, pas encore r√©pliqu√©
T3 : PRIMARY CRASH (panne mat√©rielle)
T4 : Un Secondary est √©lu nouveau Primary
T5 : Le document n'existe pas sur le nouveau Primary
     ‚Üí PERTE DE DONN√âES

Fen√™tre de vuln√©rabilit√© : Typiquement 100-500ms
```

**Cas d'usage appropri√©s** :

1. **Donn√©es non critiques avec tol√©rance √† la perte** :

```javascript
// Pr√©f√©rences utilisateur non critiques
db.user_preferences.updateOne(
  { userId: "USER123" },
  { $set: { theme: "dark", language: "fr" } },
  { writeConcern: { w: 1 } }
);
// Acceptable : Si perdu, l'utilisateur peut refaire le r√©glage
```

2. **√âcritures haute fr√©quence avec backup externe** :

```javascript
// Cache de session : donn√©e √©ph√©m√®re
db.sessions.insertOne(
  {
    sessionId: uuid(),
    userId: "USER123",
    expiresAt: new Date(Date.now() + 3600000)
  },
  { writeConcern: { w: 1 } }
);
// Acceptable : TTL court, session peut √™tre recr√©√©e
```

3. **D√©veloppement et tests** :

```javascript
// Environnement de test : performances > durabilit√©
if (process.env.NODE_ENV === 'test') {
  db.collection.insertOne(data, { writeConcern: { w: 1 } });
}
```

**Trade-off performance vs durabilit√©** :

```
Comparaison w:1 vs w:majority (Replica Set 3 n≈ìuds) :

Write Concern  | Latence P50 | Latence P99 | Perte potentielle
---------------|-------------|-------------|-------------------
w: 1           | 2ms         | 8ms         | Oui (100-500ms)
w: majority    | 15ms        | 45ms        | Non
```

### w: "majority" - Durabilit√© garantie

**Comportement** : L'op√©ration doit √™tre acquitt√©e par une **majorit√©** des membres du Replica Set (incluant le Primary). C'est le niveau **recommand√© pour les donn√©es critiques**.

**Calcul de la majorit√©** :
- 3 n≈ìuds : majorit√© = 2
- 5 n≈ìuds : majorit√© = 3
- 7 n≈ìuds : majorit√© = 4
- Formule : `floor(n/2) + 1`

```javascript
db.orders.insertOne(
  {
    orderId: "ORD-2024-001",
    customerId: "CUST-123",
    amount: 599.99,
    status: "confirmed"
  },
  { writeConcern: { w: "majority" } }
);
// Retourne seulement quand 2+ n≈ìuds (sur 3) ont la donn√©e
```

**Garanties fondamentales** :
- ‚úÖ Protection contre les rollbacks (donn√©es durables)
- ‚úÖ Survie √† la perte d'un n≈ìud minoritaire
- ‚úÖ Coh√©rence avec `readConcern: majority`
- ‚ö†Ô∏è Latence augment√©e (d√©pend du r√©seau et du lag)
- ‚ùå Indisponible si majorit√© indisponible

**Illustration de la protection contre rollback** :

```
Scenario avec w:majority :

T0 : Client √©crit document { _id: 1, data: "critical" }
T1 : Primary √©crit et commence r√©plication
T2 : Secondary 1 acquitte (2/3 = majorit√©)
T3 : Client re√ßoit confirmation de succ√®s
T4 : PRIMARY CRASH
T5 : Secondary 1 devient Primary (poss√®de le document)
T6 : ‚úÖ Aucune perte : le document existe sur le nouveau Primary

Avec w:1, le document aurait pu ne pas √™tre r√©pliqu√© √† T4
```

**Cas d'usage essentiels** :

**1. Op√©rations financi√®res** :

```javascript
async function processerPaiement(orderId, amount, paymentMethod) {
  const session = client.startSession();

  try {
    await session.withTransaction(async () => {
      // Cr√©er l'enregistrement de paiement avec durabilit√©
      await db.payments.insertOne({
        orderId,
        amount,
        paymentMethod,
        status: "completed",
        processedAt: new Date()
      }, {
        session,
        writeConcern: { w: "majority", j: true }
      });

      // Mettre √† jour la commande
      await db.orders.updateOne(
        { _id: orderId },
        { $set: { paymentStatus: "paid", paidAt: new Date() } },
        {
          session,
          writeConcern: { w: "majority", j: true }
        }
      );

    });

    return { success: true };
  } catch (error) {
    console.error("√âchec du paiement:", error);
    return { success: false, error: error.message };
  } finally {
    await session.endSession();
  }
}

// Rationale : Aucun paiement ne doit √™tre perdu ou annul√©
```

**2. Gestion d'inventaire** :

```javascript
async function reserverStock(productId, quantity) {
  try {
    const result = await db.products.findOneAndUpdate(
      {
        _id: productId,
        stock: { $gte: quantity }
      },
      {
        $inc: { stock: -quantity, reserved: quantity }
      },
      {
        writeConcern: { w: "majority" },
        returnDocument: "after"
      }
    );

    if (!result.value) {
      throw new Error("Stock insuffisant");
    }

    return result.value;
  } catch (error) {
    throw new Error("√âchec de la r√©servation: " + error.message);
  }
}

// Rationale : √âviter les surventes dues √† des donn√©es non durables
```

**3. Modifications de configuration syst√®me** :

```javascript
async function updateSystemConfig(configKey, newValue) {
  await db.system_config.updateOne(
    { key: configKey },
    {
      $set: {
        value: newValue,
        updatedAt: new Date(),
        updatedBy: "admin"
      }
    },
    {
      writeConcern: { w: "majority", j: true },
      upsert: true
    }
  );

  // Invalider le cache applicatif
  cache.delete(configKey);

  console.log(`Configuration ${configKey} mise √† jour avec durabilit√© garantie`);
}

// Rationale : Configuration syst√®me critique ne doit jamais √™tre perdue
```

**Impact du Replication Lag** :

Le Write Concern `majority` est directement affect√© par le d√©lai de r√©plication :

```
Latence de w:majority selon le Replication Lag :

Replication Lag    Latence typique w:majority
-------------------------------------------------
< 10ms (m√™me DC)   10-20ms
50ms (inter-DC)    55-70ms
200ms (global)     210-250ms
> 1s (probl√®me)    > 1s (timeout possible)

Conclusion : Topologie r√©seau = facteur critique
```

**Configuration optimale pour `majority`** :

```javascript
// Configuration recommand√©e pour donn√©es critiques
const writeConcernCritique = {
  w: "majority",
  j: true,           // Garantie de journal (voir section suivante)
  wtimeout: 5000     // Timeout de 5 secondes
};

db.critical_data.insertOne(
  { /* donn√©es importantes */ },
  { writeConcern: writeConcernCritique }
);
```

### w: <number> - Nombre sp√©cifique de n≈ìuds

**Comportement** : Attend la confirmation d'un nombre sp√©cifique de n≈ìuds (incluant le Primary).

```javascript
// Attend confirmation de 3 n≈ìuds sur un Replica Set de 5
db.collection.insertOne(
  { data: "important" },
  { writeConcern: { w: 3 } }
);
```

**Cas d'usage** : Rarement utilis√© directement. Pr√©f√©rez `majority` qui s'adapte automatiquement √† la taille du Replica Set.

**Probl√®me avec un nombre fixe** :

```javascript
// ‚ùå FRAGILE : Codage en dur
db.collection.insertOne(data, { writeConcern: { w: 3 } });
// PROBL√àME : Si le Replica Set passe de 5 √† 3 n≈ìuds, w:3 = majority
// Si un n≈ìud est temporairement down, l'√©criture √©choue

// ‚úÖ ROBUSTE : Utiliser "majority"
db.collection.insertOne(data, { writeConcern: { w: "majority" } });
// S'adapte automatiquement √† la topologie
```

**Cas l√©gitime** : Exigence de r√©plication dans plusieurs datacenters :

```javascript
// Replica Set avec 5 n≈ìuds : 3 en DC1, 2 en DC2
// Exigence : Au moins 1 n≈ìud dans DC2 doit confirmer
// Configuration via tag sets (voir section suivante)
```

### w: <tag set> - R√©plication g√©ographique cibl√©e

**Comportement** : Utilise des tags pour exiger la r√©plication vers des n≈ìuds sp√©cifiques (par datacenter, r√©gion, etc.).

**Configuration du Replica Set avec tags** :

```javascript
// Configuration des tags sur les membres
rs.reconfig({
  _id: "myReplicaSet",
  members: [
    { _id: 0, host: "mongo1.dc1:27017", tags: { dc: "us-east", rack: "A" } },
    { _id: 1, host: "mongo2.dc1:27017", tags: { dc: "us-east", rack: "B" } },
    { _id: 2, host: "mongo3.dc2:27017", tags: { dc: "us-west", rack: "A" } },
    { _id: 3, host: "mongo4.dc2:27017", tags: { dc: "us-west", rack: "B" } },
    { _id: 4, host: "mongo5.eu:27017",  tags: { dc: "eu-central", rack: "A" } }
  ],
  settings: {
    getLastErrorModes: {
      multiDC: { dc: 2 },      // Au moins 2 DCs diff√©rents
      allRegions: { dc: 3 }    // Les 3 r√©gions
    }
  }
});
```

**Utilisation avec Write Concern** :

```javascript
// Exiger r√©plication dans au moins 2 datacenters
db.global_config.insertOne(
  { setting: "critical", value: 42 },
  { writeConcern: { w: "multiDC", wtimeout: 10000 } }
);

// Exiger r√©plication dans toutes les r√©gions
db.disaster_recovery.insertOne(
  { backup: "full", timestamp: new Date() },
  { writeConcern: { w: "allRegions", wtimeout: 30000 } }
);
```

**Cas d'usage** : Applications globales n√©cessitant une r√©silience multi-r√©gions

```javascript
// Application bancaire internationale
async function enregistrerTransactionGlobale(transaction) {
  try {
    await db.transactions.insertOne(
      transaction,
      {
        writeConcern: {
          w: "multiDC",    // Au moins 2 DCs
          j: true,          // Journal activ√©
          wtimeout: 15000   // 15 secondes max
        }
      }
    );
    console.log("Transaction r√©pliqu√©e sur plusieurs continents");
  } catch (error) {
    if (error.code === 64) { // WriteConcernError
      console.error("√âchec de r√©plication g√©ographique");
      // Alerter l'√©quipe ops
    }
    throw error;
  }
}
```

## Param√®tre j : Journalisation (Journal)

Le param√®tre `j` (journal) contr√¥le si l'√©criture doit √™tre persist√©e dans le **journal WiredTiger** avant confirmation. Le journal est un fichier de log write-ahead qui garantit la durabilit√© m√™me en cas de crash brutal.

### Comprendre le journal WiredTiger

Le journal fonctionne comme un syst√®me de log binaire :

```
Flux d'√©criture avec journal :

1. √âcriture en m√©moire (cache WiredTiger)
2. √âcriture dans le journal (si j:true)
   ‚îî‚îÄ Fichiers : journal/WiredTigerLog.*
   ‚îî‚îÄ Flush : Par d√©faut toutes les 50ms ou 100MB
3. √âcriture sur disque (checkpoint p√©riodique, ~60s)

En cas de crash :
- Sans journal : Perte de donn√©es non checkpoint√©es (jusqu'√† 60s)
- Avec journal : R√©cup√©ration compl√®te via replay du journal
```

### j: false (D√©faut)

**Comportement** : L'√©criture est confirm√©e d√®s qu'elle est en m√©moire, sans attendre la persistance sur le journal.

```javascript
db.collection.insertOne(
  { data: "example" },
  { writeConcern: { w: "majority", j: false } }
);
// Confirme quand la majorit√© a le document en m√©moire
// Pas d'attente du flush du journal
```

**Garanties** :
- ‚úÖ Latence r√©duite (~10-20ms pour w:majority)
- ‚úÖ Protection contre les rollbacks (avec w:majority)
- ‚ö†Ô∏è Fen√™tre de vuln√©rabilit√© de ~50-100ms
- ‚ùå Risque de perte si crash brutal de tous les n≈ìuds avec la donn√©e

**Sc√©nario de perte avec j:false** :

```
Timeline catastrophique (tr√®s rare) :

T0 : √âcriture avec w:majority, j:false
T1 : Primary et Secondary 1 confirment (majorit√©)
T2 : Client re√ßoit succ√®s
T3 : Donn√©es en m√©moire sur Primary et S1, pas encore sur journal
T4 : PANNE √âLECTRIQUE G√âN√âRALE (datacenter entier)
T5 : Tous les serveurs crashent brutalement
T6 : Red√©marrage : les donn√©es des 50 derni√®res ms sont perdues
     ‚Üí Le document √©crit √† T0 n'existe plus

Probabilit√© : Extr√™mement faible (besoin de crash simultan√© multi-n≈ìuds)
```

### j: true - Durabilit√© maximale

**Comportement** : L'√©criture n'est confirm√©e qu'apr√®s persistance dans le journal sur les n≈ìuds concern√©s par `w`.

```javascript
db.financial_transactions.insertOne(
  {
    transactionId: "TXN-2024-001",
    amount: 50000,
    type: "wire_transfer"
  },
  {
    writeConcern: {
      w: "majority",
      j: true,          // Attendre la journalisation
      wtimeout: 10000
    }
  }
);
```

**Garanties** :
- ‚úÖ Durabilit√© absolue m√™me en cas de crash brutal
- ‚úÖ Protection contre toute perte de donn√©es
- ‚úÖ R√©cup√©ration garantie via journal replay
- ‚ö†Ô∏è Latence augment√©e (~5-10ms suppl√©mentaires)
- ‚ö†Ô∏è Impact sur le throughput (flush du journal)

**M√©triques de performance** :

```
Comparaison j:false vs j:true (w:majority, Replica Set 3 n≈ìuds)

                      j: false    j: true    Diff√©rence
---------------------------------------------------------
Latence P50           15ms        22ms       +7ms (+47%)
Latence P99           40ms        65ms       +25ms (+63%)
Throughput max        15k ops/s   8k ops/s   -47%
Durabilit√©            Haute       Absolue    -

Conclusion : j:true co√ªte ~50% en performance pour une durabilit√© absolue
```

**Cas d'usage pour j:true** :

**1. Transactions financi√®res** :

```javascript
// Paiement par carte bancaire
async function processPayment(cardInfo, amount) {
  try {
    const payment = await db.payments.insertOne({
      cardLast4: cardInfo.last4,
      amount: amount,
      timestamp: new Date(),
      status: "captured"
    }, {
      writeConcern: { w: "majority", j: true, wtimeout: 15000 }
    });

    return { success: true, paymentId: payment.insertedId };
  } catch (error) {
    // En cas d'√©chec, aucun paiement n'est perdu
    return { success: false, error: error.message };
  }
}
```

**2. Donn√©es r√©glementaires et d'audit** :

```javascript
// Enregistrement d'audit : conformit√© RGPD/SOX
async function logAuditEvent(userId, action, details) {
  await db.audit_logs.insertOne({
    userId,
    action,
    details,
    timestamp: new Date(),
    ip: details.ipAddress
  }, {
    writeConcern: {
      w: "majority",
      j: true,          // Loi requiert preuve de conservation
      wtimeout: 5000
    }
  });

  // Log d'audit ne peut pas √™tre perdu, m√™me en cas de crash
}
```

**3. Changements de configuration critiques** :

```javascript
// Mise √† jour des r√®gles de s√©curit√©
async function updateSecurityPolicy(policyId, newRules) {
  await db.security_policies.findOneAndUpdate(
    { _id: policyId },
    {
      $set: {
        rules: newRules,
        updatedAt: new Date(),
        version: { $inc: 1 }
      }
    },
    {
      writeConcern: { w: "majority", j: true },
      returnDocument: "after"
    }
  );

  console.log("Politique de s√©curit√© mise √† jour avec durabilit√© garantie");
}
```

### Quand utiliser j:false vs j:true

**R√®gle g√©n√©rale** :

```javascript
// Arbre de d√©cision pour j
if (donn√©es_critiques_m√©tier || exigences_r√©glementaires) {
  use_j_true();
} else if (performance_critique && tol√©rance_perte_minime) {
  use_j_false();
} else {
  // Par d√©faut pour donn√©es importantes mais non critiques
  use_j_false();
}
```

**Configuration par type de donn√©e** :

```javascript
const writeConcernConfigs = {
  // Donn√©es financi√®res : durabilit√© absolue
  financial: { w: "majority", j: true, wtimeout: 10000 },

  // Donn√©es utilisateur importantes : haute durabilit√©
  userData: { w: "majority", j: true, wtimeout: 5000 },

  // Donn√©es de session : durabilit√© standard
  session: { w: "majority", j: false, wtimeout: 3000 },

  // Cache applicatif : performance maximale
  cache: { w: 1, j: false, wtimeout: 1000 },

  // Logs : fire-and-forget
  logs: { w: 0 }
};
```

## Param√®tre wtimeout : Gestion des d√©lais

Le param√®tre `wtimeout` sp√©cifie le **temps maximum en millisecondes** que le driver doit attendre la confirmation du Write Concern avant de lever une erreur.

### Comportement sans wtimeout

```javascript
// ‚ö†Ô∏è DANGEREUX : Pas de timeout
db.collection.insertOne(
  { data: "test" },
  { writeConcern: { w: "majority" } }
);
// Si un n≈ìud est down, l'op√©ration peut attendre ind√©finiment
// L'application freeze
```

### Comportement avec wtimeout

```javascript
// ‚úÖ SAFE : Timeout d√©fini
db.collection.insertOne(
  { data: "test" },
  { writeConcern: { w: "majority", wtimeout: 5000 } }
);
// Si la majorit√© n'acquitte pas en 5s ‚Üí WriteConcernError
// L'application peut g√©rer l'erreur proprement
```

### Comprendre le comportement en cas de timeout

**Point crucial** : Un timeout ne signifie PAS que l'√©criture a √©chou√©. Elle peut toujours r√©ussir apr√®s le timeout.

```
Timeline d'un timeout :

T0   : Client envoie write avec w:majority, wtimeout:3000
T1   : Primary √©crit en m√©moire
T2   : Primary envoie aux Secondaries
T3   : Un Secondary acquitte rapidement
T4   : L'autre Secondary a un probl√®me r√©seau (ralenti)
T3000: TIMEOUT - Client re√ßoit WriteConcernError
T4000: Le Secondary probl√©matique acquitte finalement
       ‚Üí L'√©criture est r√©ussie du point de vue du cluster
       ‚Üí Mais l'application a re√ßu une erreur

R√©sultat : L'√©criture existe dans la base malgr√© l'erreur
```

**Implications pour l'application** :

```javascript
async function insertWithRetry(collection, document) {
  try {
    await collection.insertOne(document, {
      writeConcern: { w: "majority", j: true, wtimeout: 5000 }
    });
    return { success: true };

  } catch (error) {
    if (error.code === 64) { // WriteConcernError (timeout)

      // L'√©criture peut exister - v√©rifier avant de retry
      const exists = await collection.findOne({ _id: document._id });

      if (exists) {
        console.log("Document existe malgr√© le timeout");
        return { success: true, wasTimeout: true };
      }

      // Si pas trouv√©, l'√©criture a vraiment √©chou√©
      console.error("Write concern non satisfait - Retry");
      throw error;

    } else {
      // Autre erreur (validation, duplicate key, etc.)
      throw error;
    }
  }
}
```

### Choisir un wtimeout appropri√©

**Facteurs √† consid√©rer** :

1. **Latence r√©seau** : Entre les membres du Replica Set
2. **Replication lag typique** : Historique du lag de r√©plication
3. **Tol√©rance utilisateur** : Temps d'attente acceptable
4. **Criticit√© de l'op√©ration** : Plus critique = timeout plus long

**Valeurs recommand√©es** :

```javascript
// Valeurs typiques selon le contexte

const timeoutConfigs = {
  // Application interactive : exp√©rience utilisateur
  interactive: {
    w: "majority",
    wtimeout: 3000  // 3 secondes max
  },

  // Batch processing : tol√©rance plus √©lev√©e
  batch: {
    w: "majority",
    wtimeout: 10000  // 10 secondes
  },

  // Op√©rations critiques : attente prolong√©e acceptable
  critical: {
    w: "majority",
    j: true,
    wtimeout: 30000  // 30 secondes
  },

  // API haute performance : timeout court
  fastAPI: {
    w: 1,
    wtimeout: 1000  // 1 seconde
  },

  // R√©plication g√©ographique : temps de propagation long
  global: {
    w: "multiDC",
    wtimeout: 15000  // 15 secondes
  }
};
```

**Calibrage bas√© sur les m√©triques** :

```javascript
// Monitorer le temps de r√©plication pour calibrer wtimeout
function calculateOptimalTimeout(replicationStats) {
  const p99Lag = replicationStats.replicationLag.p99;

  // R√®gle : wtimeout = 2x le P99 lag + buffer
  const buffer = 1000; // 1 seconde de buffer
  const optimalTimeout = (p99Lag * 2) + buffer;

  return Math.max(optimalTimeout, 3000); // Min 3 secondes
}

// Exemple : Si P99 lag = 50ms
// ‚Üí wtimeout optimal = (50 * 2) + 1000 = 1100ms
// ‚Üí Utilis√© : 3000ms (minimum)
```

### Strat√©gies de retry apr√®s timeout

**1. Retry avec backoff exponentiel** :

```javascript
async function writeWithRetry(collection, doc, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      await collection.insertOne(doc, {
        writeConcern: { w: "majority", wtimeout: 5000 }
      });
      return { success: true, attempts: attempt + 1 };

    } catch (error) {
      if (error.code === 64 && attempt < maxRetries - 1) {
        const backoff = Math.pow(2, attempt) * 1000;
        console.log(`Tentative ${attempt + 1} √©chou√©e, retry dans ${backoff}ms`);
        await new Promise(resolve => setTimeout(resolve, backoff));
        continue;
      }
      throw error;
    }
  }
}
```

**2. Circuit breaker pattern** :

```javascript
class WriteConcernCircuitBreaker {
  constructor(threshold = 5, resetTimeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.resetTimeout = resetTimeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.lastFailureTime = null;
  }

  async execute(writeOperation) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN - too many write concern failures');
      }
    }

    try {
      const result = await writeOperation();

      if (this.state === 'HALF_OPEN') {
        this.state = 'CLOSED';
        this.failureCount = 0;
      }

      return result;

    } catch (error) {
      if (error.code === 64) { // WriteConcernError
        this.failureCount++;
        this.lastFailureTime = Date.now();

        if (this.failureCount >= this.threshold) {
          this.state = 'OPEN';
          console.error('Circuit breaker OPENED - alerting ops team');
        }
      }
      throw error;
    }
  }
}

// Usage
const circuitBreaker = new WriteConcernCircuitBreaker();

await circuitBreaker.execute(async () => {
  return db.collection.insertOne(doc, {
    writeConcern: { w: "majority", wtimeout: 5000 }
  });
});
```

## Interaction entre w, j et wtimeout

Ces trois param√®tres interagissent pour former une strat√©gie coh√©rente :

### Configurations coh√©rentes recommand√©es

```javascript
// ‚úÖ Coh√©rent : Haute durabilit√© avec timeout appropri√©
{
  w: "majority",
  j: true,
  wtimeout: 10000
}
// Pour : Transactions financi√®res, donn√©es critiques

// ‚úÖ Coh√©rent : √âquilibre performance-durabilit√©
{
  w: "majority",
  j: false,
  wtimeout: 5000
}
// Pour : Donn√©es importantes mais non critiques

// ‚úÖ Coh√©rent : Performance maximale
{
  w: 1,
  j: false,
  wtimeout: 1000
}
// Pour : Donn√©es non critiques, haute fr√©quence
```

### Configurations incoh√©rentes √† √©viter

```javascript
// ‚ùå INCOH√âRENT : j:true sans w:majority
{
  w: 1,
  j: true,
  wtimeout: 5000
}
// Probl√®me : Journal sur le Primary uniquement
// Si le Primary crash, le journal est perdu
// Gaspillage de performance pour une fausse garantie

// ‚ùå INCOH√âRENT : wtimeout trop court pour w exigeant
{
  w: "majority",
  j: true,
  wtimeout: 500  // 500ms trop court
}
// Probl√®me : Timeouts fr√©quents m√™me en conditions normales
// Retries inutiles, exp√©rience utilisateur d√©grad√©e

// ‚ùå INCOH√âRENT : w:0 avec j:true
{
  w: 0,
  j: true
}
// Probl√®me : j est ignor√© car aucune confirmation attendue
// Param√®tre inutile
```

## Interaction avec Read Concern : Vue d'ensemble

Le Write Concern doit √™tre **coordonn√©** avec le Read Concern pour des garanties coh√©rentes :

### Matrice de coh√©rence Read/Write

```
                           Read Concern
                  local   majority   linearizable
Write   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Concern ‚îÇ
        ‚îÇ
w:1     ‚îÇ  ‚ö†Ô∏è        ‚ùå          ‚ùå
        ‚îÇ  Weak      Incoherent  Incoherent
        ‚îÇ
w:maj   ‚îÇ  ‚ö†Ô∏è        ‚úÖ          ‚úÖ
j:false ‚îÇ  Lag       Coh√©rent    Coh√©rent
        ‚îÇ
w:maj   ‚îÇ  ‚ö†Ô∏è        ‚úÖ‚úÖ         ‚úÖ‚úÖ
j:true  ‚îÇ  Lag       Optimal     Optimal

L√©gende :
‚úÖ‚úÖ Optimal : Garanties maximales align√©es
‚úÖ  Coh√©rent : Garanties raisonnables
‚ö†Ô∏è  Faible : Risques mineurs
‚ùå  Incoh√©rent : Configuration probl√©matique
```

### Exemples de configurations par cas d'usage

**Application bancaire** :

```javascript
const bankingConfig = {
  write: { w: "majority", j: true, wtimeout: 10000 },
  read: { level: "majority" }
};

// Lecture de solde avant transaction
const account = await db.accounts.findOne(
  { accountId: "ACC123" },
  { readConcern: bankingConfig.read }
);

// D√©bit du compte
await db.accounts.updateOne(
  { accountId: "ACC123" },
  { $inc: { balance: -amount } },
  { writeConcern: bankingConfig.write }
);
```

**Application e-commerce** :

```javascript
const ecommerceConfig = {
  // Stock : haute coh√©rence
  inventory: {
    write: { w: "majority", j: false, wtimeout: 5000 },
    read: { level: "majority" }
  },

  // Catalogue : performance
  catalog: {
    write: { w: "majority", j: false, wtimeout: 3000 },
    read: { level: "local" }
  },

  // Logs : minimal
  logs: {
    write: { w: 1, wtimeout: 1000 },
    read: { level: "local" }
  }
};
```

**Application IoT** :

```javascript
const iotConfig = {
  // Donn√©es de capteurs : volume √©lev√©
  sensors: {
    write: { w: 1, j: false, wtimeout: 1000 },
    read: { level: "local" }
  },

  // Alertes critiques : durabilit√©
  alerts: {
    write: { w: "majority", j: true, wtimeout: 5000 },
    read: { level: "majority" }
  }
};
```

## Monitoring et observabilit√© du Write Concern

### M√©triques critiques √† surveiller

**1. Write Concern Timeout Rate** :

```javascript
// Calculer le taux de timeout
const timeoutRate = writeConcernTimeouts / totalWrites;

// Alerte si > 1%
if (timeoutRate > 0.01) {
  console.error(`‚ö†Ô∏è  Write Concern timeout rate: ${(timeoutRate * 100).toFixed(2)}%`);
  // Investiguer : Replication lag ? N≈ìud down ? R√©seau ?
}
```

**2. Write Latency par niveau de Write Concern** :

```javascript
// Monitorer s√©par√©ment chaque configuration
const latencyMetrics = {
  'w:1': { p50: 2, p99: 8 },
  'w:majority': { p50: 15, p99: 45 },
  'w:majority,j:true': { p50: 22, p99: 65 }
};

// D√©tecter les d√©gradations
if (latencyMetrics['w:majority'].p99 > 100) {
  console.error('‚ö†Ô∏è  Write latency P99 d√©grad√©e');
}
```

**3. Replication Lag** :

```javascript
// V√©rifier r√©guli√®rement le lag
db.serverStatus().repl.members.forEach(member => {
  if (member.state === 2) { // SECONDARY
    const lag = member.optimeDate - member.lastHeartbeat;
    if (lag > 5000) { // > 5 secondes
      console.error(`‚ö†Ô∏è  Member ${member.name} lag: ${lag}ms`);
    }
  }
});
```

### Dashboard de d√©cision

```javascript
// Exemple de fonction d'aide au diagnostic
function diagnoseWritePerformance(metrics) {
  const diagnosis = [];

  if (metrics.timeoutRate > 0.01) {
    diagnosis.push({
      severity: 'HIGH',
      issue: 'Write Concern timeouts fr√©quents',
      causes: [
        'Replication lag √©lev√©',
        'N≈ìud Secondary down ou lent',
        'wtimeout trop court'
      ],
      actions: [
        'V√©rifier rs.status()',
        'Analyser les logs des Secondaries',
        'Augmenter wtimeout si lag structurel',
        'Investiguer la cause du lag'
      ]
    });
  }

  if (metrics.replicationLag.p99 > 1000) {
    diagnosis.push({
      severity: 'MEDIUM',
      issue: 'Replication lag √©lev√©',
      causes: [
        'Charge √©lev√©e sur Secondaries',
        'R√©seau lent entre n≈ìuds',
        'Op√©rations volumineuses'
      ],
      actions: [
        'Monitorer CPU/IO des Secondaries',
        'Optimiser les requ√™tes co√ªteuses',
        'Consid√©rer upgrade hardware',
        'V√©rifier la bande passante r√©seau'
      ]
    });
  }

  return diagnosis;
}
```

## Conclusion

Le Write Concern est un m√©canisme puissant qui permet de trouver l'√©quilibre optimal entre **durabilit√©**, **performance** et **disponibilit√©** pour chaque type d'op√©ration. Les trois param√®tres `w`, `j` et `wtimeout` interagissent pour former des configurations coh√©rentes adapt√©es aux besoins m√©tier.

**Principes directeurs** :

1. **Utiliser `w: "majority"` par d√©faut** pour les donn√©es importantes
2. **Ajouter `j: true`** uniquement pour les donn√©es v√©ritablement critiques
3. **Toujours d√©finir `wtimeout`** pour √©viter les blocages
4. **Aligner Read et Write Concern** pour des garanties coh√©rentes
5. **Monitorer les m√©triques** pour ajuster les configurations
6. **Diff√©rencier par type de donn√©e** plut√¥t qu'une configuration unique

Dans la section suivante, nous explorerons les compromis entre performance et coh√©rence, avec des √©tudes de cas d√©taill√©es et des strat√©gies d'optimisation.

---

**Points cl√©s √† retenir** :

- `w: 0` : Aucune garantie, performance maximale (rarement recommand√©)
- `w: 1` : D√©faut, risque de perte minime (100-500ms)
- `w: "majority"` : Recommand√© pour donn√©es importantes, protection contre rollback
- `j: true` : Durabilit√© absolue, co√ªt ~50% performance
- `wtimeout` : Toujours obligatoire, calibrer selon latence r√©seau et lag
- Tag sets : R√©plication g√©ographique cibl√©e pour applications globales
- Timeout ‚â† √©chec : L'√©criture peut r√©ussir malgr√© le timeout
- Coh√©rence Read/Write : Les deux doivent √™tre align√©s

‚è≠Ô∏è [Compromis performance vs coh√©rence](/08-transactions/04.3-compromis-performance-coherence.md)
