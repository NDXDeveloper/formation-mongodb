ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.4 Commit et Rollback

## Introduction

Le commit et le rollback (abort) sont les deux opÃ©rations terminales d'une transaction qui dÃ©terminent si les modifications sont dÃ©finitivement appliquÃ©es ou complÃ¨tement annulÃ©es. Contrairement aux bases de donnÃ©es relationnelles traditionnelles oÃ¹ ces mÃ©canismes reposent sur des logs UNDO/REDO sophistiquÃ©s, MongoDB implÃ©mente une approche diffÃ©rente basÃ©e sur le buffering en mÃ©moire et l'oplog atomique. Comprendre ces mÃ©canismes en profondeur est crucial pour maÃ®triser les transactions, dÃ©boguer les problÃ¨mes de performance, et gÃ©rer correctement les cas d'Ã©chec.

Cette section explore les mÃ©canismes internes du commit et du rollback, leurs garanties, leurs limites, et les scÃ©narios complexes de dÃ©faillance.

## Commit : Validation Atomique

### MÃ©canisme Interne du Commit

Le commit d'une transaction MongoDB est une opÃ©ration complexe en plusieurs Ã©tapes qui garantit l'atomicitÃ© complÃ¨te des modifications :

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phase 1 : PRÃ‰PARATION (avant commitTransaction)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();
session.startTransaction({
    readConcern: { level: "snapshot" },
    writeConcern: { w: "majority", j: true }
});

// OpÃ©rations transactionnelles (buffered en mÃ©moire)
await collection1.updateOne(
    { _id: 1 },
    { $set: { value: 100 } },
    { session }
);

await collection2.insertOne(
    { _id: 2, data: "new" },
    { session }
);

await collection3.deleteOne(
    { _id: 3 },
    { session }
);

// Ã‰tat interne Ã  ce stade :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WiredTiger Cache (in-memory) :
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Transaction Buffer (txnNumber: 1)                   â”‚
// â”‚                                                     â”‚
// â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
// â”‚ â”‚ Document 1 (collection1):                   â”‚     â”‚
// â”‚ â”‚   Original: { _id: 1, value: 50 }           â”‚     â”‚
// â”‚ â”‚   Modified: { _id: 1, value: 100 }          â”‚     â”‚
// â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
// â”‚                                                     â”‚
// â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
// â”‚ â”‚ Document 2 (collection2):                   â”‚     â”‚
// â”‚ â”‚   Operation: INSERT                         â”‚     â”‚
// â”‚ â”‚   Data: { _id: 2, data: "new" }             â”‚     â”‚
// â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
// â”‚                                                     â”‚
// â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
// â”‚ â”‚ Document 3 (collection3):                   â”‚     â”‚
// â”‚ â”‚   Operation: DELETE                         â”‚     â”‚
// â”‚ â”‚   Original: { _id: 3, ... }                 â”‚     â”‚
// â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// Locks acquis :
// - Document-level write locks sur _id: 1, 2, 3
// - Collection-level intent locks
//
// VisibilitÃ© :
// - Modifications INVISIBLES pour les autres transactions
// - Visibles seulement dans le contexte de cette session
// - Snapshot timestamp figÃ© au dÃ©but de la transaction

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phase 2 : VALIDATION DU COMMIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

await session.commitTransaction();

// T=0ms : Client appelle commitTransaction()
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Ã‰tape 2.1 : Validation des conflits
// T=1ms : WiredTiger vÃ©rifie WriteConflict
//
// Pour chaque document modifiÃ© :
// - VÃ©rifier si une autre transaction a modifiÃ© le document
//   depuis le snapshot timestamp de cette transaction
// - Si conflit dÃ©tectÃ© â†’ LÃ¨ve WriteConflictException
//                      â†’ Transaction abortÃ©e
//                      â†’ Toutes les modifications jetÃ©es

// Exemple de dÃ©tection de conflit :
//
// Transaction T1 (cette transaction) :
// - Snapshot @ Timestamp(1000)
// - Modifie document { _id: 1 }
// - Tente commit @ Timestamp(2000)
//
// Transaction T2 (autre transaction) :
// - A committÃ© @ Timestamp(1500)
// - A modifiÃ© le mÃªme document { _id: 1 }
//
// RÃ©sultat : WriteConflict dÃ©tectÃ©
// Raison : T2 a modifiÃ© le document aprÃ¨s le snapshot de T1
// Action : T1 doit aborter et retry

// Ã‰tape 2.2 : PrÃ©paration de l'entrÃ©e applyOps
// T=2ms : Construction de l'entrÃ©e oplog
//
const applyOpsEntry = {
    ts: Timestamp(2000, 1),           // Timestamp du commit
    t: NumberLong(1),                 // Term (rÃ©plication)
    op: "c",                          // Command
    ns: "mydb.$cmd",
    o: {
        applyOps: [
            // Toutes les opÃ©rations de la transaction
            {
                op: "u",                      // Update
                ns: "mydb.collection1",
                o: { $v: 2, $set: { value: 100 } },
                o2: { _id: 1 }
            },
            {
                op: "i",                      // Insert
                ns: "mydb.collection2",
                o: { _id: 2, data: "new" }
            },
            {
                op: "d",                      // Delete
                ns: "mydb.collection3",
                o: { _id: 3 }
            }
        ],
        // MÃ©tadonnÃ©es transactionnelles
        lsid: { id: UUID("session-id") },
        txnNumber: NumberLong(1),
        stmtIds: [0, 1, 2],
        prevOpTime: { ts: Timestamp(1999, 10), t: NumberLong(1) }
    },
    wall: ISODate("2024-12-07T10:30:00.000Z")
};

// VÃ©rification de la taille de applyOps
if (sizeOf(applyOpsEntry) > 16 * 1024 * 1024) {
    throw new TransactionTooLargeError(
        "Transaction exceeds 16MB limit"
    );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phase 3 : Ã‰CRITURE DANS L'OPLOG (Point de Non-Retour)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ã‰tape 3.1 : Ã‰criture dans l'oplog du Primary
// T=5ms : Write to oplog
//
// L'entrÃ©e applyOps est Ã©crite dans l'oplog local du Primary
// Ã€ partir de ce point, la transaction DOIT Ãªtre committÃ©e
// (pas de rollback possible)

// Si writeConcern: { w: 1 } :
// T=6ms : Confirmation immÃ©diate au client
// T=100ms : RÃ©plication asynchrone vers secondaries

// Si writeConcern: { w: "majority" } :
// T=6ms : Ã‰criture sur Primary
// T=10ms : RÃ©plication vers Secondary 1 dÃ©marre
// T=12ms : RÃ©plication vers Secondary 2 dÃ©marre
// T=50ms : Secondary 1 applique et ACK
// T=55ms : Secondary 2 applique et ACK
// T=56ms : MajoritÃ© atteinte (Primary + 1 secondary)
// T=57ms : Confirmation au client

// Si writeConcern: { w: "majority", j: true } :
// T=6ms : Ã‰criture dans l'oplog (en mÃ©moire)
// T=10ms : fsync du journal sur disque (Primary)
// T=50ms : RÃ©plication + journal fsync sur secondaries
// T=80ms : MajoritÃ© avec journal fsync atteinte
// T=81ms : Confirmation au client

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phase 4 : APPLICATION DES MODIFICATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ã‰tape 4.1 : Application des modifications depuis le buffer
// T=82ms : Modifications deviennent visibles
//
// Pour chaque opÃ©ration dans applyOps :
// 1. Lire depuis le transaction buffer
// 2. Ã‰crire dans le storage engine (WiredTiger)
// 3. Mettre Ã  jour les index
// 4. LibÃ©rer le buffer

// WiredTiger applique les modifications :
await wiredTiger.applyTransaction({
    operations: applyOpsEntry.o.applyOps,
    commitTimestamp: Timestamp(2000, 1)
});

// Les modifications sont maintenant :
// âœ“ Dans l'oplog (durable)
// âœ“ Dans le cache WiredTiger (visible)
// âœ“ En attente de checkpoint (flush sur disque)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phase 5 : NETTOYAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ã‰tape 5.1 : RelÃ¢chement des locks
// T=83ms : Document-level locks relÃ¢chÃ©s
//
// Les documents ne sont plus lockÃ©s
// D'autres transactions peuvent les modifier

// Ã‰tape 5.2 : Nettoyage du transaction buffer
// T=84ms : MÃ©moire libÃ©rÃ©e
//
// Le buffer transactionnel est vidÃ©
// Les anciennes versions MVCC peuvent Ãªtre garbage collected
// (si aucune autre transaction n'en a besoin)

// Ã‰tape 5.3 : Mise Ã  jour de l'Ã©tat de la session
// T=85ms : Transaction state â†’ "committed"
//
session.txnState = "committed";
session.lastCommittedTxnNumber = 1;

// T=86ms : RÃ©ponse finale au client
return { ok: 1, commitTimestamp: Timestamp(2000, 1) };

// Timeline complÃ¨te du commit :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=0ms  : Client â†’ commitTransaction()
// T=1ms  : Validation WriteConflict
// T=2ms  : Construction applyOps entry
// T=5ms  : Ã‰criture oplog Primary
// T=10ms : Journal fsync (si j: true)
// T=50ms : RÃ©plication secondaries
// T=80ms : MajoritÃ© + journal fsync atteinte
// T=82ms : Application modifications
// T=83ms : RelÃ¢chement locks
// T=86ms : RÃ©ponse client (success)
//
// DurÃ©e totale : 86ms (avec w: "majority", j: true)
```

### Commit dans un Replica Set : ScÃ©narios

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 1 : Commit rÃ©ussi (cas nominal)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

try {
    session.startTransaction({
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" }
    });

    await collection.updateOne({ _id: 1 }, { $set: { value: 100 } }, { session });

    await session.commitTransaction();
    // â†’ Status: committed
    // â†’ Modifications visibles pour tous
    // â†’ Durables (rÃ©pliquÃ©es sur majoritÃ©)

    console.log("Transaction committed successfully");

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 2 : WriteConflict au commit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ã‰tat initial : { _id: 1, value: 50, version: 1 }

// Transaction T1 (snapshot @ Timestamp 1000)
const session1 = client.startSession();
session1.startTransaction({ readConcern: { level: "snapshot" } });

await collection.findOne({ _id: 1 }, { session: session1 });
// T1 lit : { _id: 1, value: 50, version: 1 } @ Timestamp 1000

// Transaction T2 (concurrent)
const session2 = client.startSession();
session2.startTransaction();

await collection.updateOne(
    { _id: 1 },
    { $set: { value: 75 }, $inc: { version: 1 } },
    { session: session2 }
);

await session2.commitTransaction();  // T2 committe @ Timestamp 1500
await session2.endSession();

// Ã‰tat aprÃ¨s T2 : { _id: 1, value: 75, version: 2 } @ Timestamp 1500

// T1 tente de committer
await collection.updateOne(
    { _id: 1 },
    { $set: { value: 100 }, $inc: { version: 1 } },
    { session: session1 }
);

try {
    await session1.commitTransaction();
    // âŒ WriteConflictException levÃ©e

} catch (error) {
    if (error.code === 112) {  // WriteConflict
        console.log("WriteConflict detected:");
        console.log("- T1 snapshot: Timestamp(1000)");
        console.log("- T2 committed: Timestamp(1500)");
        console.log("- Same document modified");
        console.log("â†’ T1 must abort and retry");

        await session1.abortTransaction();

        // Retry logic nÃ©cessaire
        // (voir section patterns de retry)
    }
} finally {
    await session1.endSession();
}

// DÃ©tection du conflit :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WiredTiger maintient pour chaque document :
// - Timestamp de derniÃ¨re modification
// - Transactions actives ayant lu le document
//
// Lors du commit de T1 :
// 1. WiredTiger vÃ©rifie : "Le document 1 a-t-il Ã©tÃ© modifiÃ©
//    aprÃ¨s le snapshot de T1 (Timestamp 1000) ?"
// 2. RÃ©ponse : Oui, modifiÃ© @ Timestamp 1500 par T2
// 3. Action : WriteConflictException

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 3 : WriteConcern timeout
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

try {
    session.startTransaction({
        writeConcern: { w: "majority", wtimeout: 5000 }
    });

    await collection.insertOne({ data: "test" }, { session });

    await session.commitTransaction();
    // Timeline :
    // T=0ms : Commit demandÃ©
    // T=5ms : Ã‰criture sur Primary (succÃ¨s)
    // T=10ms : RÃ©plication vers Secondary 1 (lent, disque saturÃ©)
    // T=5000ms : Timeout atteint
    // â†’ WriteConcernError levÃ©e

} catch (error) {
    if (error.name === 'WriteConcernError') {
        // âš  SITUATION AMBIGUÃ‹
        console.log("WriteConcern timeout");
        console.log("- Write applied on Primary");
        console.log("- Majority NOT confirmed in time");
        console.log("- Transaction state: UNCERTAIN");

        // Options :
        // 1. ConsidÃ©rer comme rÃ©ussi (risque : rollback si Primary fail)
        // 2. VÃ©rifier manuellement l'Ã©tat
        // 3. Retry le commit (idempotent)

        // Option 3 : Retry commit
        try {
            await session.commitTransaction();
            console.log("Commit retry succeeded");
        } catch (retryError) {
            console.error("Commit retry also failed", retryError);
        }
    }

    await session.abortTransaction();
} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 4 : Network error pendant commit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

try {
    session.startTransaction();
    await collection.insertOne({ data: "test" }, { session });
    await session.commitTransaction();

} catch (error) {
    if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
        // Network error entre :
        // - Le serveur a reÃ§u commitTransaction
        // - Le client a reÃ§u la rÃ©ponse

        console.log("Commit result unknown:");
        console.log("- Network error occurred");
        console.log("- Transaction MAY be committed");
        console.log("- Transaction MAY be aborted");
        console.log("- Cannot determine from client side");

        // StratÃ©gies :

        // 1. Retry commit (idempotent)
        try {
            await session.commitTransaction();
            console.log("Transaction was NOT committed, retry succeeded");
        } catch (retryError) {
            if (!retryError.hasErrorLabel('UnknownTransactionCommitResult')) {
                // Autre erreur, transaction dÃ©finitivement Ã©chouÃ©e
                throw retryError;
            }
        }

        // 2. VÃ©rifier si donnÃ©es prÃ©sentes (application-specific)
        const doc = await collection.findOne(
            { data: "test" },
            { readConcern: { level: "majority" } }
        );

        if (doc) {
            console.log("Transaction was committed");
        } else {
            console.log("Transaction was NOT committed");
        }
    }

    await session.abortTransaction();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 5 : Primary failover pendant commit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Configuration : Replica Set (1 Primary, 2 Secondaries)

const session = client.startSession();
session.startTransaction({ writeConcern: { w: "majority" } });

await collection.insertOne({ data: "test" }, { session });

// Timeline :
// T=0ms : Client appelle commitTransaction()
// T=5ms : Primary reÃ§oit la commande
// T=10ms : Primary Ã©crit dans l'oplog
// T=15ms : Primary commence rÃ©plication
// âš  T=20ms : Primary CRASH (serveur down)
// T=50ms : Ã‰lection d'un nouveau Primary
// T=60ms : Secondary devient Primary
// T=61ms : Client dÃ©tecte la perte de connexion
// T=62ms : Client se reconnecte au nouveau Primary

// Que devient la transaction ?
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cas A : applyOps PAS encore dans l'oplog
// â†’ Transaction perdue (jamais rÃ©pliquÃ©e)
// â†’ Abort implicite
// â†’ Retry nÃ©cessaire

// Cas B : applyOps dans l'oplog, mais PAS rÃ©pliquÃ©
// â†’ Le nouveau Primary n'a pas l'oplog entry
// â†’ Rollback de l'entrÃ©e lors du rejoin de l'ancien Primary
// â†’ Transaction perdue
// â†’ Retry nÃ©cessaire

// Cas C : applyOps rÃ©pliquÃ© sur majoritÃ© avant crash
// â†’ Le nouveau Primary a l'oplog entry
// â†’ Transaction committÃ©e
// â†’ DonnÃ©es prÃ©servÃ©es
// â†’ Pas de retry nÃ©cessaire (mais client ne le sait pas)

try {
    await session.commitTransaction();
} catch (error) {
    if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
        // Le failover a causÃ© une incertitude
        // VÃ©rifier et retry si nÃ©cessaire

        const committed = await verifyCommitted();
        if (!committed) {
            await retryTransaction();
        }
    }
}
```

### Commit dans un Sharded Cluster : Two-Phase Commit

```javascript
// Commit distribuÃ© avec coordination entre multiples shards

// Architecture :
//                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//                  â”‚   Mongos     â”‚  â† Coordinator
//                  â”‚ (Coordinator)â”‚
//                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
//                         â”‚
//        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//        â”‚                â”‚                â”‚
//   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”
//   â”‚ Shard 1 â”‚      â”‚ Shard 2 â”‚     â”‚ Shard 3 â”‚
//   â”‚  (RS)   â”‚      â”‚  (RS)   â”‚     â”‚  (RS)   â”‚
//   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

const session = client.startSession();

try {
    session.startTransaction({
        readConcern: { level: "snapshot" },
        writeConcern: { w: "majority" }
    });

    // OpÃ©ration touchant Shard 1
    await collection.updateOne(
        { userId: "Alice" },  // Shard key route vers Shard 1
        { $inc: { balance: -100 } },
        { session }
    );

    // OpÃ©ration touchant Shard 3
    await collection.updateOne(
        { userId: "Zoe" },    // Shard key route vers Shard 3
        { $inc: { balance: 100 } },
        { session }
    );

    // Commit dÃ©clenche le Two-Phase Commit
    await session.commitTransaction();

} finally {
    await session.endSession();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Timeline dÃ©taillÃ©e du Two-Phase Commit
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// PHASE 1 : PREPARE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// T=0ms : Client â†’ Mongos : commitTransaction
console.log("T=0ms : Client requests commit");

// T=5ms : Mongos (coordinator) identifie les shards participants
// - Shard 1 (modifiÃ©)
// - Shard 3 (modifiÃ©)
// - Shard 2 (non impliquÃ©, ignorÃ©)
console.log("T=5ms : Coordinator identifies participants: Shard1, Shard3");

// T=10ms : Mongos â†’ Shard 1 : prepareTransaction
console.log("T=10ms : PREPARE â†’ Shard 1");
// Command: {
//     prepareTransaction: 1,
//     lsid: { id: UUID("session-id") },
//     txnNumber: NumberLong(1),
//     coordinator: true
// }

// T=10ms : Mongos â†’ Shard 3 : prepareTransaction
console.log("T=10ms : PREPARE â†’ Shard 3");

// T=20ms : Shard 1 traite PREPARE
// 1. Valide les modifications (WriteConflict check)
// 2. Ã‰crit "prepare" dans son oplog local
// {
//     ts: Timestamp(2000, 1),
//     op: "c",
//     ns: "config.$cmd",
//     o: {
//         prepareTransaction: 1,
//         coordinator: { id: "mongos-host:port" }
//     }
// }
// 3. MAINTIENT les locks (ne les relÃ¢che pas)
// 4. Modifications restent en buffer (pas encore appliquÃ©es)
console.log("T=20ms : Shard 1 prepared (locks held)");

// T=22ms : Shard 1 â†’ Mongos : "prepared" (ACK)
console.log("T=22ms : Shard 1 ACK (prepared)");

// T=25ms : Shard 3 traite PREPARE
console.log("T=25ms : Shard 3 prepared (locks held)");

// T=27ms : Shard 3 â†’ Mongos : "prepared" (ACK)
console.log("T=27ms : Shard 3 ACK (prepared)");

// T=30ms : Mongos reÃ§oit tous les ACK
console.log("T=30ms : All participants prepared");

// DÃ‰CISION DU COORDINATOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Si TOUS les shards sont "prepared" :
//   â†’ DÃ©cision : COMMIT
// Si AU MOINS UN shard "aborted" ou timeout :
//   â†’ DÃ©cision : ABORT

console.log("T=31ms : Coordinator decides: COMMIT");

// T=32ms : Mongos Ã©crit la dÃ©cision dans config servers
// Collection : config.transaction_coordinators
// {
//     _id: { lsid: UUID("session-id"), txnNumber: NumberLong(1) },
//     participants: [
//         { shardId: "shard1", state: "prepared" },
//         { shardId: "shard3", state: "prepared" }
//     ],
//     decision: "commit",
//     decisionTime: ISODate("2024-12-07T10:30:00.035Z"),
//     commitTimestamp: Timestamp(2000, 5)
// }
console.log("T=35ms : Decision written to config servers (durable)");

// âš  POINT DE NON-RETOUR
// AprÃ¨s Ã©criture de la dÃ©cision, le commit DOIT Ãªtre complÃ©tÃ©
// MÃªme si mongos crash, un autre mongos reprendra le processus

// PHASE 2 : COMMIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// T=40ms : Mongos â†’ Shard 1 : commitTransaction
console.log("T=40ms : COMMIT â†’ Shard 1");
// Command: {
//     commitTransaction: 1,
//     commitTimestamp: Timestamp(2000, 5)
// }

// T=40ms : Mongos â†’ Shard 3 : commitTransaction
console.log("T=40ms : COMMIT â†’ Shard 3");

// T=50ms : Shard 1 applique le commit
// 1. Ã‰crit "commit" dans son oplog
// {
//     ts: Timestamp(2000, 5),
//     op: "c",
//     ns: "admin.$cmd",
//     o: {
//         commitTransaction: 1,
//         commitTimestamp: Timestamp(2000, 5)
//     }
// }
// 2. Applique les modifications depuis le buffer
// 3. RELÃ‚CHE les locks
// 4. Modifications deviennent visibles
console.log("T=50ms : Shard 1 committed (locks released)");

// T=52ms : Shard 1 â†’ Mongos : "committed" (ACK)
console.log("T=52ms : Shard 1 ACK (committed)");

// T=55ms : Shard 3 committed
console.log("T=55ms : Shard 3 committed (locks released)");

// T=57ms : Shard 3 â†’ Mongos : "committed" (ACK)
console.log("T=57ms : Shard 3 ACK (committed)");

// T=60ms : Mongos reÃ§oit tous les ACK de commit
console.log("T=60ms : All participants committed");

// T=61ms : Mongos nettoie l'entrÃ©e dans config.transaction_coordinators
console.log("T=61ms : Cleanup coordinator state");

// T=62ms : Mongos â†’ Client : { ok: 1, commitTimestamp: Timestamp(2000, 5) }
console.log("T=62ms : SUCCESS response to client");

// DurÃ©e totale : 62ms (2PC dans LAN)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©narios de dÃ©faillance dans le 2PC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario A : Shard ne rÃ©pond pas pendant PREPARE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=10ms : Mongos â†’ Shard 3 : PREPARE
// T=30s : Timeout (shard ne rÃ©pond pas)
// â†’ Mongos dÃ©cide : ABORT
// â†’ Mongos â†’ Shard 1 : abortTransaction
// â†’ Shard 1 relÃ¢che locks, discard buffer
// â†’ Client reÃ§oit erreur, retry possible

// ScÃ©nario B : Mongos crash aprÃ¨s PREPARE, avant dÃ©cision
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=30ms : Tous les shards prÃ©parÃ©s
// âš  T=31ms : Mongos CRASH (avant d'Ã©crire la dÃ©cision)
//
// Ã‰tat : Shards en attente ("prepared"), locks maintenus
//
// T=50ms : Nouveau mongos Ã©lu
// T=60ms : Nouveau mongos scanne config.transaction_coordinators
//          Trouve : Aucune entrÃ©e pour cette transaction
//          Conclusion : Transaction jamais dÃ©cidÃ©e
// T=70ms : Nouveau mongos â†’ Shards : abortTransaction
// T=80ms : Shards relÃ¢chent locks, clean state

// ScÃ©nario C : Mongos crash aprÃ¨s dÃ©cision COMMIT Ã©crite
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=35ms : DÃ©cision "commit" Ã©crite dans config servers
// âš  T=36ms : Mongos CRASH (avant d'envoyer COMMIT aux shards)
//
// Ã‰tat : DÃ©cision durable, mais shards toujours "prepared"
//
// T=50ms : Nouveau mongos Ã©lu
// T=60ms : Nouveau mongos lit config.transaction_coordinators
//          Trouve : decision: "commit"
//          Conclusion : Doit complÃ©ter le commit
// T=70ms : Nouveau mongos â†’ Shards : commitTransaction
// T=90ms : Commit complÃ©tÃ©, locks relÃ¢chÃ©s

// ScÃ©nario D : Partition rÃ©seau pendant PHASE 2
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=40ms : Mongos â†’ Shard 1 : COMMIT (succÃ¨s)
// T=40ms : Mongos â†’ Shard 3 : COMMIT (network partition, Ã©choue)
//
// Ã‰tat : Shard 1 committÃ©, Shard 3 toujours "prepared"
//
// T=50ms : Mongos retry automatique
// T=60ms : Mongos â†’ Shard 3 : COMMIT (retry)
// T=70ms : Network rÃ©tabli, Shard 3 committe
//
// Garantie : Le 2PC garantit cohÃ©rence Ã©ventuelle
// MÃªme avec partitions, tous finissent par commit

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Implications de performance du 2PC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// MÃ©triques comparatives (mesurÃ©es) :

// Single Shard Transaction :
// - Latence : 10-30ms
// - Throughput : ~5,000 TPS

// Two-Shard Transaction (LAN) :
// - Latence : 50-80ms (2-3x plus lent)
// - Throughput : ~1,500 TPS (1/3 du throughput)

// Three-Shard Transaction (LAN) :
// - Latence : 60-100ms
// - Throughput : ~1,000 TPS

// Multi-RÃ©gion (US-East + US-West + EU) :
// - Latence : 200-500ms (10-20x plus lent)
// - Throughput : ~200 TPS (1/25 du throughput)

// Facteurs de dÃ©gradation :
// - Network round-trips multiples (PREPARE + COMMIT)
// - Locks maintenus pendant toute la durÃ©e du 2PC
// - Coordination overhead (config servers writes)
// - Plus de points de dÃ©faillance (chaque shard)
```

## Rollback (Abort) : Annulation Atomique

### MÃ©canisme Interne du Rollback

```javascript
// Le rollback dans MongoDB est trÃ¨s diffÃ©rent des SGBDR traditionnels

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SGBDR (PostgreSQL, MySQL) : Rollback via UNDO Logs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Dans les SGBDR :
// 1. Modifications Ã©crites immÃ©diatement dans les data files
// 2. Images BEFORE Ã©crites dans des segments UNDO
// 3. Rollback = appliquer les UNDO logs (opÃ©rations inverses)
// 4. Peut Ãªtre coÃ»teux si beaucoup de modifications

// Exemple PostgreSQL :
// BEGIN;
// UPDATE accounts SET balance = balance - 100 WHERE id = 1;
//   â†’ Ã‰crit : UNDO log : { id: 1, old_balance: 1000 }
//   â†’ Ã‰crit : Data file : { id: 1, balance: 900 }
// UPDATE accounts SET balance = balance + 100 WHERE id = 2;
//   â†’ Ã‰crit : UNDO log : { id: 2, old_balance: 500 }
//   â†’ Ã‰crit : Data file : { id: 2, balance: 600 }
// ROLLBACK;
//   â†’ Lit UNDO log : { id: 1, old_balance: 1000 }
//   â†’ RÃ©Ã©crit : { id: 1, balance: 1000 }
//   â†’ Lit UNDO log : { id: 2, old_balance: 500 }
//   â†’ RÃ©Ã©crit : { id: 2, balance: 500 }
//
// CoÃ»t du rollback : O(n) oÃ¹ n = nombre de modifications

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MongoDB : Rollback via Buffer Discard
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

try {
    session.startTransaction();

    // OpÃ©rations transactionnelles (buffered en mÃ©moire)
    await collection1.updateOne(
        { _id: 1 },
        { $set: { value: 100 } },
        { session }
    );

    await collection2.insertOne(
        { _id: 2, data: "new" },
        { session }
    );

    await collection3.deleteMany(
        { status: "old" },  // Suppose 1000 documents
        { session }
    );

    // Ã‰tat interne avant abort :
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WiredTiger Cache :
    // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    // â”‚ Transaction Buffer (in-memory, not on disk)          â”‚
    // â”‚                                                      â”‚
    // â”‚ - Update { _id: 1 } in collection1                   â”‚
    // â”‚ - Insert { _id: 2 } in collection2                   â”‚
    // â”‚ - Delete 1000 docs in collection3                    â”‚
    // â”‚                                                      â”‚
    // â”‚ Total memory : ~500 KB                               â”‚
    // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    //
    // Data files : INCHANGÃ‰S (aucune Ã©criture effectuÃ©e)
    // Oplog : VIDE (aucune entrÃ©e Ã©crite)
    // Indexes : INCHANGÃ‰S

    // DÃ©cision d'abort
    const validation = await businessLogicCheck();
    if (!validation.valid) {
        throw new Error("Business rule violated");
    }

} catch (error) {
    // ABORT dÃ©clenchÃ©
    await session.abortTransaction();

    // Timeline du rollback/abort :
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // T=0ms : abortTransaction() appelÃ©

    // T=1ms : WiredTiger marque la transaction comme "aborted"
    session.txnState = "aborted";

    // T=2ms : Discard du transaction buffer
    // â†’ Toutes les modifications jetÃ©es de la mÃ©moire
    // â†’ AUCUNE opÃ©ration inverse nÃ©cessaire
    // â†’ Simplement libÃ©rer la mÃ©moire

    // T=3ms : RelÃ¢chement des locks
    // â†’ Document-level locks relÃ¢chÃ©s
    // â†’ D'autres transactions peuvent accÃ©der aux documents

    // T=4ms : Nettoyage des mÃ©tadonnÃ©es
    // â†’ Session state mise Ã  jour
    // â†’ Transaction metadata supprimÃ©e

    // T=5ms : Confirmation au client
    // â†’ { ok: 1, aborted: true }

    // DurÃ©e totale : 5ms
    // CoÃ»t : O(1) - constant, indÃ©pendant du nombre de modifications

    console.log("Transaction aborted in ~5ms");
    console.log("All 1002 modifications discarded");
    console.log("No inverse operations performed");

    throw error;
} finally {
    await session.endSession();
}

// Comparaison des coÃ»ts de rollback :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PostgreSQL (1000 modifications) :
// - Rollback time : 50-200ms
// - Doit lire 1000 UNDO logs
// - Doit rÃ©Ã©crire 1000 tuples
// - I/O intensif
//
// MongoDB (1000 modifications) :
// - Abort time : 3-10ms
// - Discard buffer en mÃ©moire
// - Pas d'I/O
// - Performance constante

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Abort Automatique : Cas DÃ©clencheurs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cas 1 : Timeout de transaction
session.startTransaction({ maxCommitTimeMS: 30000 });

// ... opÃ©rations prenant 35 secondes ...

try {
    await session.commitTransaction();
} catch (error) {
    if (error.code === 50838) {  // TransactionExceededLifetimeLimitSeconds
        // Abort automatique effectuÃ© par le serveur
        console.log("Transaction auto-aborted: timeout");
        // PAS besoin d'appeler session.abortTransaction()
        // DÃ©jÃ  fait par MongoDB
    }
}

// Cas 2 : Session timeout (30 minutes par dÃ©faut)
const session = client.startSession();
session.startTransaction();

// ... application idle pendant 35 minutes ...

// MongoDB tue automatiquement la session
// â†’ Transaction abortÃ©e automatiquement
// â†’ Locks relÃ¢chÃ©s
// â†’ Buffer discardÃ©

// Cas 3 : Client disconnect
const session = client.startSession();
session.startTransaction();

await collection.insertOne({ data: "test" }, { session });

// Client crash ou network disconnect
// â†’ Connexion perdue
// â†’ AprÃ¨s session timeout, MongoDB nettoie :
//   - Abort la transaction
//   - RelÃ¢che les locks
//   - LibÃ¨re la session

// Cas 4 : WriteConflict non rÃ©solu
try {
    session.startTransaction();
    await operations(session);
    await session.commitTransaction();
} catch (error) {
    if (error.code === 112) {  // WriteConflict
        // MongoDB a automatiquement abortÃ© la transaction
        // lors de la dÃ©tection du conflit
        console.log("Auto-aborted due to WriteConflict");
    }
}
```

### Abort dans un Sharded Cluster

```javascript
// Rollback distribuÃ© avec coordination

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 1 : Abort avant PREPARE (phase prÃ©coce)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const session = client.startSession();

try {
    session.startTransaction();

    await collection.updateOne(
        { userId: "Alice" },  // â†’ Shard 1
        { $inc: { balance: -100 } },
        { session }
    );

    // DÃ©cision d'abort (validation mÃ©tier Ã©choue)
    const validation = await checkBusinessRules();
    if (!validation.valid) {
        throw new Error("Business rule violation");
    }

    await collection.updateOne(
        { userId: "Zoe" },  // â†’ Shard 3
        { $inc: { balance: 100 } },
        { session }
    );

    await session.commitTransaction();

} catch (error) {
    await session.abortTransaction();

    // Timeline de l'abort prÃ©coce :
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // T=0ms : Client appelle abortTransaction()
    // T=5ms : Mongos identifie les participants (Shard 1 seulement)
    // T=10ms : Mongos â†’ Shard 1 : abortTransaction
    // T=15ms : Shard 1 discard buffer, release locks
    // T=20ms : Shard 1 â†’ Mongos : "aborted" (ACK)
    // T=25ms : Mongos â†’ Client : { ok: 1, aborted: true }
    //
    // DurÃ©e : 25ms
    // Simple : Un seul shard impliquÃ©, pas de 2PC nÃ©cessaire
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 2 : Abort pendant PREPARE (phase 2PC)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Configuration : Transaction touche Shard 1 et Shard 3

try {
    session.startTransaction();

    await collection.updateOne({ userId: "Alice" }, { ... }, { session });
    await collection.updateOne({ userId: "Zoe" }, { ... }, { session });

    await session.commitTransaction();

} catch (error) {
    // Supposons que Shard 3 Ã©choue pendant PREPARE
    // (exemple : WriteConflict dÃ©tectÃ©)

    // Timeline :
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // T=0ms : Client â†’ commitTransaction()
    // T=10ms : Mongos â†’ Shard 1 : PREPARE
    // T=10ms : Mongos â†’ Shard 3 : PREPARE
    // T=20ms : Shard 1 â†’ Mongos : "prepared"
    // T=25ms : Shard 3 â†’ Mongos : ERROR (WriteConflict)
    //
    // T=30ms : Mongos dÃ©cide : ABORT (au moins un Ã©chec)
    // T=31ms : PAS d'Ã©criture dans config.transaction_coordinators
    //          (dÃ©cision ABORT n'est pas persistÃ©e)
    //
    // T=35ms : Mongos â†’ Shard 1 : abortTransaction
    // T=40ms : Shard 1 discard buffer, release locks
    // T=41ms : Shard 1 â†’ Mongos : "aborted"
    //
    // T=45ms : Mongos â†’ Shard 3 : abortTransaction (optionnel)
    // T=50ms : Shard 3 confirme abort
    //
    // T=55ms : Mongos â†’ Client : WriteConflictException

    await session.abortTransaction();

    // CoÃ»t : 55ms
    // Plus long qu'un abort local car coordination nÃ©cessaire
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ScÃ©nario 3 : Abort aprÃ¨s PREPARE, shards en Ã©tat "prepared"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cas rare mais possible : abort demandÃ© alors que shards sont prÃ©parÃ©s

// Timeline :
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// T=0ms : Client â†’ commitTransaction()
// T=10ms : Mongos â†’ Shards : PREPARE
// T=30ms : Tous les shards â†’ "prepared" (locks maintenus)
// T=35ms : Mongos Ã©crit dÃ©cision "commit" dans config
//
// âš  T=40ms : Client change d'avis, appelle abortTransaction()
//
// PROBLÃˆME : Trop tard !
// Une fois la dÃ©cision "commit" Ã©crite dans config servers,
// la transaction DOIT Ãªtre committÃ©e.
// Il n'est plus possible d'abort.

try {
    await session.abortTransaction();
} catch (error) {
    if (error.code === 251) {  // NoSuchTransaction
        console.error("Cannot abort: transaction already committed");
        // Le commit a dÃ©jÃ  Ã©tÃ© dÃ©cidÃ© et est en cours
        // L'abort n'est plus possible
    }
}

// Implication : Le point de non-retour est l'Ã©criture de la
// dÃ©cision dans config.transaction_coordinators
```

## Garanties et Limitations

### Ce Qui Est Garanti

```javascript
// âœ“ GARANTIES ABSOLUES

// 1. AtomicitÃ© complÃ¨te du commit
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const session = client.startSession();
session.startTransaction();

await collection1.insertOne({ _id: 1 }, { session });
await collection2.insertOne({ _id: 2 }, { session });
await collection3.insertOne({ _id: 3 }, { session });

await session.commitTransaction();

// Garantie : SOIT les 3 documents sont insÃ©rÃ©s
//            SOIT aucun n'est insÃ©rÃ©
// Jamais : 1 ou 2 documents seulement

// 2. Isolation complÃ¨te pendant la transaction
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction({ readConcern: { level: "snapshot" } });

const doc1 = await collection.findOne({ _id: 1 }, { session });
// doc1 = { _id: 1, value: 100 }

// Une autre transaction modifie et committe :
await otherTransaction({ _id: 1, value: 200 });

const doc2 = await collection.findOne({ _id: 1 }, { session });
// doc2 = { _id: 1, value: 100 }  // PAS 200 !

// Garantie : Snapshot isolation prÃ©servÃ©e
// Cette transaction voit toujours le mÃªme Ã©tat

// 3. Abort instantanÃ© et complet
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction();

await collection.insertOne({ _id: 1, data: "x".repeat(1000000) }, { session });
await collection.insertOne({ _id: 2, data: "y".repeat(1000000) }, { session });
// ... 10,000 insertions, total 10GB de modifications en buffer

await session.abortTransaction();  // < 10ms

// Garantie : Abort rapide indÃ©pendamment du volume de modifications
// Toutes les modifications jetÃ©es atomiquement

// 4. DurabilitÃ© configurable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction({
    writeConcern: { w: "majority", j: true }
});

await collection.insertOne({ critical: "data" }, { session });
await session.commitTransaction();

// Garantie : Les donnÃ©es survivent Ã  :
// - Crash du Primary
// - Perte de (n-1)/2 nÅ“uds (oÃ¹ n = replica set size)
// - Corruption disque (journal fsync)

// 5. CohÃ©rence post-commit
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction();

await accounts.updateOne({ _id: "A" }, { $inc: { balance: -100 } }, { session });
await accounts.updateOne({ _id: "B" }, { $inc: { balance: 100 } }, { session });

await session.commitTransaction();

// Garantie : AprÃ¨s le commit, TOUS les lecteurs voient les deux modifications
// Pas d'Ã©tat intermÃ©diaire observable
```

### Ce Qui N'Est PAS Garanti

```javascript
// âš  LIMITATIONS ET NON-GARANTIES

// 1. Pas de vrai Serializable (anomalies possibles)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Write skew possible avec snapshot isolation

const session1 = client.startSession();
const session2 = client.startSession();

session1.startTransaction({ readConcern: { level: "snapshot" } });
session2.startTransaction({ readConcern: { level: "snapshot" } });

// Invariant mÃ©tier : Au moins un docteur doit Ãªtre on-call

// T1 vÃ©rifie
const count1 = await doctors.countDocuments({ onCall: true }, { session: session1 });
// count1 = 2 (Smith et Jones)

// T2 vÃ©rifie (mÃªme snapshot)
const count2 = await doctors.countDocuments({ onCall: true }, { session: session2 });
// count2 = 2

// T1 : Smith part (1 reste, OK)
if (count1 > 1) {
    await doctors.updateOne(
        { name: "Smith" },
        { $set: { onCall: false } },
        { session: session1 }
    );
}
await session1.commitTransaction();

// T2 : Jones part (suppose 1 reste, mais non !)
if (count2 > 1) {
    await doctors.updateOne(
        { name: "Jones" },
        { $set: { onCall: false } },
        { session: session2 }
    );
}
await session2.commitTransaction();

// RÃ©sultat : count = 0 (INVARIANT VIOLÃ‰!)
// âš  MongoDB ne dÃ©tecte pas cette anomalie

// 2. Pas de garantie sur le temps de commit
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction({
    writeConcern: { w: "majority" },
    maxCommitTimeMS: 60000
});

await operations(session);

// Le commit peut prendre :
// - 10ms (best case, LAN)
// - 500ms (multi-rÃ©gion)
// - 60 secondes (avant timeout)
// - Timeout et Ã©chec

// âš  Aucune garantie de latence maximale
// Le temps de commit dÃ©pend de :
// - Latence rÃ©seau
// - Charge des secondaries
// - Nombre de shards (si distribuÃ©)
// - Contention (WriteConflict)

// 3. Limite de taille de transaction (16 MB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction();

for (let i = 0; i < 100000; i++) {
    await collection.insertOne({
        _id: i,
        data: "x".repeat(1000)  // 1 KB par document
    }, { session });
}

try {
    await session.commitTransaction();
    // âŒ Ã‰chec : applyOps entry > 16 MB
} catch (error) {
    if (error.code === 256) {  // TransactionTooLarge
        console.error("Transaction exceeds 16MB limit");
        // 100,000 Ã— 1 KB = 100 MB > 16 MB
    }
}

// 4. Pas de modification DDL dans les transactions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction();

try {
    await db.createCollection("newcollection", { session });
    // âŒ ERREUR : DDL not allowed in transactions
} catch (error) {
    console.error("Cannot create collection in transaction");
}

try {
    await collection.createIndex({ field: 1 }, { session });
    // âŒ ERREUR : Index creation not allowed
} catch (error) {
    console.error("Cannot create index in transaction");
}

// Operations DDL supportÃ©es HORS transaction seulement

// 5. Pas de garantie de progression (livelock possible)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Avec haute contention, une transaction peut indÃ©finiment retry

async function transferMoney() {
    let attempts = 0;
    const maxAttempts = 100;

    while (attempts < maxAttempts) {
        try {
            const session = client.startSession();
            session.startTransaction();

            await accounts.updateOne(
                { _id: "hot-account" },  // â† TrÃ¨s contentieux
                { $inc: { balance: -100 } },
                { session }
            );

            await session.commitTransaction();
            return;

        } catch (error) {
            if (error.code === 112) {  // WriteConflict
                attempts++;
                // Peut retry indÃ©finiment si contention trop forte
                continue;
            }
            throw error;
        }
    }

    throw new Error("Failed after 100 attempts (livelock)");
}

// âš  MongoDB ne garantit PAS qu'une transaction finira par rÃ©ussir
// mÃªme avec retry infini

// 6. Timeout strict (pas de grÃ¢ce)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
session.startTransaction({ maxCommitTimeMS: 60000 });

// ... opÃ©rations prenant 59.9 secondes ...

await session.commitTransaction();  // Commence @ T=59.9s

// Si le commit lui-mÃªme prend 200ms :
// T=60.1s : Timeout dÃ©passÃ©
// â†’ Transaction abortÃ©e
// â†’ Toutes les modifications perdues
// â†’ Pas de "grÃ¢ce period"

// âš  Le timeout est strict, pas de tolÃ©rance
```

## Optimisations et Bonnes Pratiques

### Optimiser le Commit

```javascript
// 1. Minimiser la durÃ©e de transaction
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ MAUVAIS : OpÃ©rations lentes dans la transaction
session.startTransaction();

const data = await fetchFromExternalAPI();  // 2 secondes
await processData(data);                    // 5 secondes
await collection.insertOne(data, { session });

await session.commitTransaction();
// DurÃ©e totale : 7+ secondes (locks maintenus)

// âœ… BON : PrÃ©parer hors transaction
const data = await fetchFromExternalAPI();
const processed = await processData(data);

session.startTransaction();
await collection.insertOne(processed, { session });
await session.commitTransaction();
// DurÃ©e transaction : < 100ms

// 2. Batcher les opÃ©rations similaires
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ MAUVAIS : Boucle dans la transaction
session.startTransaction();
for (let i = 0; i < 1000; i++) {
    await collection.insertOne({ data: i }, { session });
}
await session.commitTransaction();
// 1000 round-trips, trÃ¨s lent

// âœ… BON : insertMany
session.startTransaction();
const docs = Array.from({ length: 1000 }, (_, i) => ({ data: i }));
await collection.insertMany(docs, { session });
await session.commitTransaction();
// 1 round-trip, beaucoup plus rapide

// 3. Choisir le writeConcern appropriÃ©
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pour donnÃ©es non critiques :
session.startTransaction({
    writeConcern: { w: 1 }  // Primary seulement
});
// Latence : 5-15ms

// Pour donnÃ©es importantes :
session.startTransaction({
    writeConcern: { w: "majority" }  // MajoritÃ©
});
// Latence : 30-80ms

// Pour donnÃ©es critiques :
session.startTransaction({
    writeConcern: { w: "majority", j: true }  // MajoritÃ© + journal
});
// Latence : 50-120ms

// Choisir selon le cas d'usage

// 4. Ã‰viter les transactions cross-shard si possible
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ COÃ›TEUX : Transaction cross-shard
session.startTransaction();
await collection.updateOne({ userId: "Alice" }, ..., { session });  // Shard 1
await collection.updateOne({ userId: "Zoe" }, ..., { session });    // Shard 3
await session.commitTransaction();
// Latence : 50-200ms (2PC)

// âœ… PRÃ‰FÃ‰RABLE : Remodeler pour single shard
// Option 1 : Colocate related data (mÃªme shard key)
// Option 2 : Utiliser des documents imbriquÃ©s
// Option 3 : Accepter cohÃ©rence Ã©ventuelle + compensation
```

### Optimiser l'Abort

```javascript
// L'abort est dÃ©jÃ  trÃ¨s rapide (< 10ms), mais on peut optimiser davantage

// 1. Abort prÃ©coce
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… BON : Valider tÃ´t
session.startTransaction();

// VÃ©rifier conditions avant modifications coÃ»teuses
const balance = await accounts.findOne({ _id: "A" }, { session });
if (balance.amount < 100) {
    await session.abortTransaction();  // Abort immÃ©diat
    throw new InsufficientFundsError();
}

// Seulement si validation passe, continuer
await expensiveOperations(session);
await session.commitTransaction();

// 2. Ã‰viter les locks inutiles
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âŒ MAUVAIS : Lock tout dÃ¨s le dÃ©but
session.startTransaction();
await collection.find({}).toArray({ session });  // Lock TOUS les documents
await validation();
if (!valid) {
    await session.abortTransaction();  // Mais a bloquÃ© beaucoup de docs
}

// âœ… BON : Lock seulement ce qui est nÃ©cessaire
session.startTransaction();
await validation();
if (!valid) {
    await session.abortTransaction();  // Abort rapide, peu de locks
    return;
}
await collection.find({}).toArray({ session });
await session.commitTransaction();
```

## Conclusion

Le commit et le rollback sont les opÃ©rations terminales qui scellent le sort d'une transaction. Leur implÃ©mentation dans MongoDB, basÃ©e sur le buffering en mÃ©moire et l'oplog atomique, offre des caractÃ©ristiques uniques :

### Points ClÃ©s

**Commit** :
- Multi-phases : validation, oplog, application, cleanup
- Point de non-retour : Ã©criture dans l'oplog
- DurabilitÃ© configurable via writeConcern
- Two-Phase Commit pour sharded clusters (complexe et coÃ»teux)
- Latence : 10-200ms (RS) Ã  50-800ms (sharded multi-rÃ©gion)

**Rollback** :
- TrÃ¨s rapide : 3-10ms constant
- Pas d'opÃ©rations inverses (contrairement aux SGBDR)
- Simple discard du buffer mÃ©moire
- CoÃ»t O(1) indÃ©pendant du nombre de modifications

**Garanties** :
- AtomicitÃ© complÃ¨te garantie
- Snapshot isolation maintenue
- DurabilitÃ© selon writeConcern

**Limitations** :
- Pas de vrai Serializable (write skew possible)
- Limite 16 MB par transaction
- Timeout strict (60s dÃ©faut)
- Pas de DDL dans les transactions

La maÃ®trise de ces mÃ©canismes est essentielle pour construire des applications robustes avec des transactions MongoDB efficaces et fiables.

---


â­ï¸ [Niveaux de cohÃ©rence et d'isolation](/08-transactions/04-niveaux-coherence-isolation.md)
