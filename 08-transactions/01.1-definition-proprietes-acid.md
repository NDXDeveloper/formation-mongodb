üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.1 D√©finition des Propri√©t√©s ACID

## Introduction

Les propri√©t√©s ACID constituent un contrat formel entre un syst√®me de base de donn√©es et ses utilisateurs. Derri√®re l'acronyme simple se cachent des d√©finitions math√©matiquement rigoureuses, des mod√®les th√©oriques complexes, et des implications pratiques profondes. Cette section explore chaque propri√©t√© en d√©tail, allant au-del√† des d√©finitions superficielles pour examiner leur signification formelle, leurs variantes, et leur manifestation concr√®te dans MongoDB.

## A comme Atomicit√© : L'Indivisibilit√© des Op√©rations

### D√©finition Formelle

**Atomicit√©** : Une transaction T est atomique si et seulement si :
- Soit toutes les op√©rations de T sont appliqu√©es (COMMIT)
- Soit aucune op√©ration de T n'est appliqu√©e (ABORT)
- Il n'existe aucun √©tat observable o√π T est partiellement appliqu√©e

Formellement :
```
‚àÄT ‚àà Transactions : √âtat(T) ‚àà {NON_D√âMARR√âE, COMMITT√âE, AVORT√âE}
√âtat(T) ‚àâ {PARTIELLEMENT_APPLIQU√âE}
```

### Niveaux d'Atomicit√©

L'atomicit√© n'est pas binaire mais existe sur un spectre :

#### Niveau 0 : Atomicit√© au niveau instruction

```javascript
// Niveau le plus basique : une seule instruction de base de donn√©es
await collection.updateOne(
    { _id: ObjectId("...") },
    { $set: { field: "value" } }
);

// Garantie :
// L'instruction s'ex√©cute enti√®rement ou pas du tout
// Pas de "demi-modification" possible

// Contre-exemple (ce qui N'est PAS garanti) :
// Si le serveur crash pendant l'ex√©cution :
// - L'instruction sera r√©p√©t√©e au red√©marrage (si journalis√©e)
// - Ou sera totalement abandonn√©e (si pas journalis√©e)
// Mais jamais dans un √©tat interm√©diaire
```

#### Niveau 1 : Atomicit√© au niveau document

```javascript
// MongoDB : Atomicit√© native pour un document complet
await users.updateOne(
    { userId: "U001" },
    {
        $set: {
            "profile.firstName": "Jean",
            "profile.lastName": "Dupont",
            "profile.lastUpdated": new Date()
        },
        $inc: { "profile.version": 1 },
        $push: {
            "auditLog": {
                action: "profile_update",
                timestamp: new Date(),
                fields: ["firstName", "lastName"]
            }
        },
        $addToSet: { "tags": "updated" }
    }
);

// Garantie formelle :
// Soit toutes les modifications ($set, $inc, $push, $addToSet) sont appliqu√©es
// Soit aucune n'est appliqu√©e
//
// Preuve observable :
// ‚àÑ √©tat o√π firstName="Jean" mais version non incr√©ment√©e
// ‚àÑ √©tat o√π auditLog contient l'entr√©e mais firstName non modifi√©
```

**Implications de l'atomicit√© document** :

```javascript
// Sc√©nario : Syst√®me de r√©servation de salle
// Probl√®me : Assurer qu'une r√©servation ne peut pas cr√©er de double-booking

// Approche 1 : Lecture puis √©criture (NON ATOMIQUE)
async function reserveRoomWRONG(roomId, userId, timeSlot) {
    // ‚ùå RACE CONDITION POSSIBLE

    const room = await rooms.findOne({ roomId });

    // DANGER : Entre cette lecture et l'√©criture suivante,
    // un autre thread peut faire la m√™me chose
    // T1: lit ‚Üí salle libre
    // T2: lit ‚Üí salle libre (T1 pas encore √©crit)
    // T1: √©crit r√©servation A
    // T2: √©crit r√©servation B (√©crase A !)

    if (room.reservations.some(r => r.timeSlot === timeSlot)) {
        throw new Error("Cr√©neau d√©j√† r√©serv√©");
    }

    await rooms.updateOne(
        { roomId },
        { $push: { reservations: { userId, timeSlot, bookedAt: new Date() } } }
    );
}

// Approche 2 : Op√©ration atomique (CORRECT)
async function reserveRoomCORRECT(roomId, userId, timeSlot) {
    // ‚úì ATOMIQUE : condition et modification en une seule op√©ration

    const result = await rooms.updateOne(
        {
            roomId: roomId,
            // Condition : aucune r√©servation pour ce cr√©neau n'existe
            "reservations.timeSlot": { $ne: timeSlot }
        },
        {
            $push: {
                reservations: {
                    userId,
                    timeSlot,
                    bookedAt: new Date()
                }
            }
        }
    );

    if (result.matchedCount === 0) {
        throw new Error("Cr√©neau d√©j√† r√©serv√© ou salle inexistante");
    }

    // Garantie formelle :
    // Si deux threads T1 et T2 tentent de r√©server le m√™me cr√©neau :
    // - Exactement un thread r√©ussira (matchedCount = 1)
    // - L'autre √©chouera (matchedCount = 0)
    // - Impossible que les deux r√©ussissent (atomicit√©)
}

// Preuve de l'atomicit√© :
// MongoDB garantit que updateOne est une op√©ration atomique
// Donc la v√©rification et la modification forment une unit√© indivisible
// C'est l'√©quivalent d'un "compare-and-swap" atomique
```

#### Niveau 2 : Atomicit√© multi-documents (transactions)

```javascript
// MongoDB 4.0+ : Extension de l'atomicit√© √† plusieurs documents

async function transferInventory(fromWarehouse, toWarehouse, productId, quantity) {
    const session = client.startSession();

    try {
        session.startTransaction();

        // Op√©ration 1 : D√©cr√©menter l'inventaire source
        const decrementResult = await inventory.updateOne(
            {
                warehouseId: fromWarehouse,
                productId: productId,
                quantity: { $gte: quantity }
            },
            { $inc: { quantity: -quantity } },
            { session }
        );

        if (decrementResult.matchedCount === 0) {
            throw new Error("Stock insuffisant dans l'entrep√¥t source");
        }

        // Op√©ration 2 : Incr√©menter l'inventaire destination
        await inventory.updateOne(
            {
                warehouseId: toWarehouse,
                productId: productId
            },
            { $inc: { quantity: quantity } },
            { session, upsert: true }
        );

        // Op√©ration 3 : Enregistrer le mouvement
        await movements.insertOne({
            movementId: generateId(),
            fromWarehouse,
            toWarehouse,
            productId,
            quantity,
            timestamp: new Date(),
            status: "completed"
        }, { session });

        await session.commitTransaction();

        // Garantie formelle post-commit :
        // ‚àÄ observer O, apr√®s commit :
        // - inventory(from).quantity diminu√© de quantity
        // - inventory(to).quantity augment√© de quantity
        // - movements contient l'enregistrement correspondant
        // - Aucun observer ne peut voir un √©tat interm√©diaire

    } catch (error) {
        await session.abortTransaction();

        // Garantie formelle post-abort :
        // ‚àÄ observer O, apr√®s abort :
        // - √âtat de la base identique √† avant startTransaction()
        // - Comme si la transaction n'avait jamais exist√©

        throw error;
    } finally {
        await session.endSession();
    }
}
```

### Atomicit√© et D√©faillances

L'atomicit√© doit √™tre maintenue m√™me en pr√©sence de d√©faillances :

```javascript
// Types de d√©faillances et garanties d'atomicit√©

// D√âFAILLANCE TYPE 1 : Crash application
async function processOrderWithCrash() {
    const session = client.startSession();
    session.startTransaction();

    await orders.insertOne({ orderId: "O001", status: "pending" }, { session });
    await inventory.updateOne(
        { productId: "P001" },
        { $inc: { stock: -1 } },
        { session }
    );

    // ‚ö° CRASH APPLICATION ICI (avant commit)
    // process.exit(1);

    await session.commitTransaction();
}

// Comportement MongoDB :
// 1. La session expire apr√®s timeout (defaultMaxTimeMS = 60000)
// 2. MongoDB avorte automatiquement la transaction
// 3. R√©sultat : ordre ET inventaire inchang√©s (atomicit√© pr√©serv√©e)

// D√âFAILLANCE TYPE 2 : Crash serveur MongoDB (avant commit)
async function processOrderServerCrashBefore() {
    const session = client.startSession();
    session.startTransaction();

    await orders.insertOne({ orderId: "O002", status: "pending" }, { session });

    // ‚ö° CRASH SERVEUR MONGODB ICI
    // - Toutes les op√©rations de la transaction sont en m√©moire
    // - Pas encore √©crites dans le journal

    await inventory.updateOne(
        { productId: "P001" },
        { $inc: { stock: -1 } },
        { session }
    );
    await session.commitTransaction();
}

// Comportement au red√©marrage :
// 1. MongoDB r√©cup√®re depuis le dernier checkpoint
// 2. Rejoue le journal (Write-Ahead Log)
// 3. Les modifications non committ√©es sont ignor√©es
// 4. R√©sultat : ordre ET inventaire inchang√©s (atomicit√© pr√©serv√©e)

// D√âFAILLANCE TYPE 3 : Crash serveur pendant commit
async function processOrderServerCrashDuring() {
    const session = client.startSession();
    session.startTransaction({
        writeConcern: { w: "majority", j: true }
    });

    await orders.insertOne({ orderId: "O003", status: "pending" }, { session });
    await inventory.updateOne(
        { productId: "P001" },
        { $inc: { stock: -1 } },
        { session }
    );

    await session.commitTransaction();
    // ‚ö° CRASH SERVEUR PENDANT LE COMMIT
    // - Le commit a commenc√© √† s'√©crire
    // - Mais pas termin√©
}

// Comportement au red√©marrage :
// Avec w: "majority" et j: true :
// 1. Si le commit a atteint le journal ‚Üí Transaction r√©cup√©r√©e et compl√©t√©e
// 2. Si le commit n'a pas atteint le journal ‚Üí Transaction avort√©e
// 3. Atomicit√© pr√©serv√©e dans les deux cas
//
// MAIS : L'application ne sait pas quel cas s'est produit
// ‚Üí C'est le probl√®me "UnknownTransactionCommitResult"
```

### L'√ânigme de l'Atomicit√© Distribu√©e

Dans un cluster shard√©, l'atomicit√© devient un d√©fi de coordination :

```javascript
// Contexte : Cluster avec 3 shards
// Shard A : produits A-H
// Shard B : produits I-P
// Shard C : produits Q-Z

async function orderMultipleProductsSharded() {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" },
            writeConcern: { w: "majority" }
        });

        // Ces op√©rations touchent diff√©rents shards
        await orders.insertOne({
            orderId: "O004",
            items: [
                { productId: "Apple" },      // ‚Üí Shard A
                { productId: "Kiwi" },       // ‚Üí Shard B
                { productId: "Strawberry" }  // ‚Üí Shard C
            ]
        }, { session });

        await inventory.updateOne(
            { productId: "Apple" },         // ‚Üí Shard A
            { $inc: { stock: -1 } },
            { session }
        );

        await inventory.updateOne(
            { productId: "Kiwi" },          // ‚Üí Shard B
            { $inc: { stock: -1 } },
            { session }
        );

        await inventory.updateOne(
            { productId: "Strawberry" },    // ‚Üí Shard C
            { $inc: { stock: -1 } },
            { session }
        );

        await session.commitTransaction();

        // M√©canisme sous-jacent : Two-Phase Commit (2PC)
        //
        // PHASE 1 : PREPARE
        // Coordinator (mongos) demande √† chaque shard : "Peux-tu committer ?"
        // Shard A ‚Üí "PREPARED" (verrous acquis, modifications en attente)
        // Shard B ‚Üí "PREPARED"
        // Shard C ‚Üí "PREPARED"
        //
        // PHASE 2 : COMMIT
        // Si tous r√©pondent PREPARED :
        //   Coordinator ‚Üí "COMMIT" √† tous les shards
        //   Shard A ‚Üí applique et rel√¢che verrous
        //   Shard B ‚Üí applique et rel√¢che verrous
        //   Shard C ‚Üí applique et rel√¢che verrous
        //
        // Si au moins un r√©pond ABORT :
        //   Coordinator ‚Üí "ABORT" √† tous les shards
        //   Tous les shards annulent leurs modifications

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}

// Co√ªt de l'atomicit√© distribu√©e :
// - Latence : 50-200ms (vs 5-10ms mono-shard)
// - Verrous maintenus plus longtemps ‚Üí plus de contention
// - Plus de messages r√©seau ‚Üí plus de risques d'√©chec
// - Coordination complexe ‚Üí overhead significatif
```

## C comme Coh√©rence : Le Respect des Invariants

### D√©finition Formelle

**Coh√©rence** : Une transaction T pr√©serve la coh√©rence si :
- Avant T, la base de donn√©es est dans un √©tat coh√©rent (respecte tous les invariants I)
- Apr√®s T (si committ√©e), la base respecte toujours tous les invariants I
- Pendant T, des √©tats incoh√©rents peuvent exister (mais ne sont pas observables)

Formellement :
```
‚àÄI ‚àà Invariants, ‚àÄT ‚àà Transactions :
  √âtat_Avant(T) ‚ä® I ‚àß COMMIT(T) ‚üπ √âtat_Apr√®s(T) ‚ä® I
```

### Types d'Invariants

#### Invariant 1 : Contraintes d'int√©grit√© structurelle

```javascript
// Exemple : Syst√®me bancaire
// INVARIANT : Le solde d'un compte ne peut jamais √™tre n√©gatif

// D√©finition de l'invariant via validation de sch√©ma
db.createCollection("accounts", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["accountId", "balance", "currency"],
            properties: {
                balance: {
                    bsonType: "double",
                    minimum: 0,  // ‚Üê INVARIANT STRUCTUREL
                    description: "Le solde doit √™tre >= 0"
                }
            }
        }
    },
    validationLevel: "strict",
    validationAction: "error"
});

// Tentative de violation
try {
    await accounts.insertOne({
        accountId: "ACC001",
        balance: -500,  // ‚ùå Viole l'invariant
        currency: "EUR"
    });
} catch (error) {
    // DocumentValidationFailure
    // L'invariant est pr√©serv√© par rejet de l'op√©ration
}

// Sc√©nario plus subtil : Modification qui violerait l'invariant
async function withdrawMoney(accountId, amount) {
    // Approche 1 : Dangereuse (peut violer l'invariant)
    const account = await accounts.findOne({ accountId });

    if (account.balance >= amount) {
        await accounts.updateOne(
            { accountId },
            { $inc: { balance: -amount } }
        );
        // ‚ùå RACE CONDITION : Entre le if et le update,
        // un autre thread peut avoir retir√© de l'argent
        // R√©sultat : balance peut devenir n√©gative
    }

    // Approche 2 : S√ªre (pr√©serve l'invariant atomiquement)
    const result = await accounts.updateOne(
        {
            accountId: accountId,
            balance: { $gte: amount }  // ‚Üê Invariant v√©rifi√© atomiquement
        },
        { $inc: { balance: -amount } }
    );

    if (result.matchedCount === 0) {
        throw new Error("Solde insuffisant");
    }

    // Garantie : L'invariant balance >= 0 est toujours respect√©
}
```

#### Invariant 2 : Contraintes d'int√©grit√© r√©f√©rentielle

```javascript
// Exemple : Syst√®me de commandes
// INVARIANT : Chaque ligne de commande doit r√©f√©rencer un produit existant

// Dans un syst√®me relationnel, ceci serait une cl√© √©trang√®re
// Dans MongoDB, plusieurs approches existent :

// Approche 1 : Validation applicative (faible garantie)
async function createOrderLine(orderLineData) {
    // V√©rifier que le produit existe
    const product = await products.findOne({
        productId: orderLineData.productId
    });

    if (!product) {
        throw new Error("Produit inexistant");
    }

    // ‚ùå PROBL√àME : Le produit pourrait √™tre supprim√© ici
    // Entre la v√©rification et l'insertion

    await orderLines.insertOne(orderLineData);
}

// Approche 2 : D√©normalisation (√©limine le probl√®me)
async function createOrderDenormalized(orderData) {
    // Embarquer les donn√©es du produit dans la commande
    const order = {
        orderId: generateId(),
        customerId: orderData.customerId,
        items: await Promise.all(
            orderData.items.map(async item => {
                const product = await products.findOne({
                    productId: item.productId
                });

                if (!product) {
                    throw new Error(`Produit ${item.productId} inexistant`);
                }

                return {
                    productId: product.productId,
                    // ‚úì Snapshot des donn√©es au moment de la commande
                    productName: product.name,
                    price: product.price,
                    quantity: item.quantity
                };
            })
        ),
        createdAt: new Date()
    };

    await orders.insertOne(order);

    // Garantie : L'invariant est respect√© par construction
    // M√™me si les produits sont supprim√©s plus tard,
    // la commande conserve leurs donn√©es
}

// Approche 3 : Transaction multi-documents (garantie forte)
async function createOrderWithTransaction(orderData) {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" }
        });

        // V√©rifier et verrouiller les produits
        for (const item of orderData.items) {
            const product = await products.findOne(
                { productId: item.productId },
                { session }
            );

            if (!product) {
                throw new Error(`Produit ${item.productId} inexistant`);
            }
        }

        // Cr√©er la commande
        await orders.insertOne({
            orderId: generateId(),
            items: orderData.items,
            createdAt: new Date()
        }, { session });

        await session.commitTransaction();

        // Garantie : snapshot isolation assure que les produits
        // n'ont pas √©t√© supprim√©s pendant la transaction

    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        await session.endSession();
    }
}
```

#### Invariant 3 : Contraintes m√©tier complexes

```javascript
// Exemple : Syst√®me de r√©servation de vols
// INVARIANT : La somme des si√®ges r√©serv√©s ne peut pas d√©passer la capacit√©

// Mod√©lisation du probl√®me
{
    flightId: "FL001",
    capacity: 180,
    // Approche na√Øve : compteur de r√©servations
    reservedSeats: 0,
    // Probl√®me : Le compteur peut devenir incoh√©rent
}

// Sc√©nario de violation sans protection ad√©quate
async function reserveSeatVULNERABLE(flightId, passengerId) {
    const flight = await flights.findOne({ flightId });

    // ‚ùå VIOLATION POSSIBLE
    // T1 lit : reservedSeats = 179, capacity = 180
    // T2 lit : reservedSeats = 179, capacity = 180
    // T1 √©crit : reservedSeats = 180 ‚úì
    // T2 √©crit : reservedSeats = 180 ‚úì (mais devrait √™tre 181 !)
    // R√©sultat : 181 si√®ges r√©serv√©s sur un vol de 180 places

    if (flight.reservedSeats < flight.capacity) {
        await flights.updateOne(
            { flightId },
            { $inc: { reservedSeats: 1 } }
        );

        await reservations.insertOne({
            flightId,
            passengerId,
            reservedAt: new Date()
        });

        return { success: true };
    }

    throw new Error("Vol complet");
}

// Solution 1 : Op√©ration atomique avec condition
async function reserveSeatATOMIC(flightId, passengerId, seatNumber) {
    const result = await flights.updateOne(
        {
            flightId: flightId,
            capacity: { $gt: "$reservedSeats" }  // V√©rifie atomiquement
        },
        {
            $inc: { reservedSeats: 1 },
            $push: {
                reservations: {
                    passengerId,
                    seatNumber,
                    reservedAt: new Date()
                }
            }
        }
    );

    if (result.matchedCount === 0) {
        throw new Error("Vol complet ou inexistant");
    }

    // Garantie : L'invariant est v√©rifi√© et pr√©serv√© atomiquement
}

// Solution 2 : Mod√©lisation alternative (√©limine le compteur)
{
    flightId: "FL001",
    capacity: 180,
    seats: {
        "1A": { status: "available" },
        "1B": { status: "reserved", passengerId: "P001" },
        "1C": { status: "available" },
        // ... tous les si√®ges
    }
}

async function reserveSpecificSeat(flightId, seatNumber, passengerId) {
    const result = await flights.updateOne(
        {
            flightId: flightId,
            [`seats.${seatNumber}.status`]: "available"
        },
        {
            $set: {
                [`seats.${seatNumber}`]: {
                    status: "reserved",
                    passengerId: passengerId,
                    reservedAt: new Date()
                }
            }
        }
    );

    if (result.matchedCount === 0) {
        throw new Error("Si√®ge non disponible");
    }

    // Avantages :
    // ‚úì Pas de compteur √† maintenir
    // ‚úì Information pr√©cise sur chaque si√®ge
    // ‚úì Atomicit√© native
    // ‚úì Invariant respect√© par construction
    //
    // L'invariant devient :
    // ‚àÄ seatNumber : count(seats[*].status == "reserved") <= capacity
    // Et il est impossible de le violer
}
```

### Coh√©rence dans les Syst√®mes Distribu√©s

#### Coh√©rence Forte vs √âventuelle

```javascript
// COH√âRENCE FORTE : Linearizability

// D√©finition formelle :
// Une ex√©cution est linearizable si on peut trouver un ordre s√©quentiel
// des op√©rations qui :
// 1. Respecte l'ordre temps r√©el des op√©rations
// 2. Pr√©serve la s√©mantique s√©quentielle de chaque op√©ration

// Exemple : Syst√®me de vote
async function voteWithStrongConsistency(pollId, optionId, userId) {
    const result = await votes.updateOne(
        {
            pollId: pollId,
            optionId: optionId,
            voters: { $ne: userId }  // Utilisateur n'a pas d√©j√† vot√©
        },
        {
            $inc: { count: 1 },
            $addToSet: { voters: userId }
        },
        {
            writeConcern: { w: "majority" },
            readConcern: { level: "linearizable" }
        }
    );

    if (result.matchedCount === 0) {
        throw new Error("Vote d√©j√† enregistr√© ou sondage inexistant");
    }

    // Garantie Linearizability :
    // Si l'utilisateur A vote puis l'utilisateur B lit le r√©sultat,
    // B verra toujours le vote de A
    //
    // Timeline :
    // T=0 : A vote (count: 100 ‚Üí 101)
    // T=1 : √âcriture r√©pliqu√©e sur majorit√©
    // T=2 : B lit (avec readConcern: linearizable)
    // R√©sultat de B : count >= 101 (garanti)
}

// COH√âRENCE √âVENTUELLE : Eventual Consistency

async function voteWithEventualConsistency(pollId, optionId, userId) {
    const result = await votes.updateOne(
        {
            pollId: pollId,
            optionId: optionId,
            voters: { $ne: userId }
        },
        {
            $inc: { count: 1 },
            $addToSet: { voters: userId }
        },
        {
            writeConcern: { w: 1 },  // Juste le primary
            readPreference: "secondaryPreferred"
        }
    );

    // Lecture potentiellement depuis un secondary
    const currentVotes = await votes.findOne(
        { pollId, optionId },
        { readPreference: "secondaryPreferred" }
    );

    // ‚ö† ATTENTION : currentVotes.count peut ne PAS inclure le vote actuel
    //
    // Timeline :
    // T=0 : A vote sur Primary (count: 100 ‚Üí 101)
    // T=1 : A lit depuis Secondary (r√©plication lag)
    // R√©sultat : count = 100 (le vote n'a pas encore √©t√© r√©pliqu√©)
    //
    // Mais :
    // T=100 : A lit depuis Secondary
    // R√©sultat : count = 101 (√©ventuellement coh√©rent)
}

// Analyse des trade-offs
//
// Coh√©rence forte :
// ‚úì Garanties s√©mantiques simples
// ‚úì Pas de surprises pour les d√©veloppeurs
// ‚úó Latence √©lev√©e (50-200ms)
// ‚úó Disponibilit√© r√©duite (n√©cessite majorit√© accessible)
//
// Coh√©rence √©ventuelle :
// ‚úì Latence minimale (2-10ms)
// ‚úì Haute disponibilit√©
// ‚úó Complexit√© applicative (g√©rer l'inconsistance temporaire)
// ‚úó Bugs subtils possibles
```

#### Monotonie et Causalit√©

```javascript
// MONOTONIC READS : Une fois qu'une valeur est lue,
// les lectures suivantes verront cette valeur ou une plus r√©cente

// Sc√©nario : Session utilisateur
async function userSessionMONOTONIC(userId, sessionId) {
    const session = client.startSession();

    // Lecture initiale
    const user = await users.findOne(
        { userId },
        {
            session,
            readConcern: { level: "majority" }
        }
    );

    console.log(`Version initiale : ${user.version}`); // version: 5

    // Modification concurrente par un autre thread
    // (sur le primary, version passe de 5 √† 6)

    // Lecture suivante dans la m√™me session
    const userAgain = await users.findOne(
        { userId },
        {
            session,
            readConcern: { level: "majority" }
        }
    );

    console.log(`Version suivante : ${userAgain.version}`); // version: >= 5

    // Garantie : userAgain.version >= user.version
    // Jamais de retour en arri√®re (pas de "time travel")
}

// CAUSAL CONSISTENCY : Si A cause B, tout observer qui voit B voit aussi A

// Sc√©nario : Publication d'article et notification
async function publishWithCausality(articleData) {
    const session = client.startSession();
    session.startSession({ causalConsistency: true });

    try {
        // Op√©ration A : Publier l'article
        const article = await articles.insertOne({
            articleId: generateId(),
            title: articleData.title,
            content: articleData.content,
            publishedAt: new Date(),
            status: "published"
        }, {
            session,
            writeConcern: { w: "majority" }
        });

        // Op√©ration B : Cr√©er la notification (caus√©e par A)
        await notifications.insertOne({
            notificationId: generateId(),
            type: "new_article",
            articleId: article.insertedId,
            recipients: articleData.followers,
            createdAt: new Date()
        }, { session });

        await session.endSession();

        // Garantie de causalit√© :
        // Tout utilisateur qui re√ßoit la notification (B)
        // sera capable de lire l'article (A)
        //
        // M√™me si la lecture se fait sur un secondary,
        // MongoDB garantit que ce secondary a d√©j√† r√©pliqu√© A

    } catch (error) {
        await session.endSession();
        throw error;
    }
}
```

## I comme Isolation : La Non-Interf√©rence

### D√©finition Formelle

**Isolation** : L'ex√©cution concurrente de transactions T1, T2, ..., Tn produit un r√©sultat √©quivalent √† une ex√©cution s√©quentielle (s√©rialisable) de ces transactions dans un ordre quelconque.

Formellement :
```
‚àÄ ex√©cution concurrente E(T1, T2, ..., Tn) :
  ‚àÉ ex√©cution s√©quentielle S(TœÄ(1), TœÄ(2), ..., TœÄ(n)) :
    R√©sultat(E) ‚â° R√©sultat(S)
```

O√π œÄ est une permutation de {1, 2, ..., n}

### Niveaux d'Isolation Standards (SQL)

MongoDB impl√©mente des variantes de ces niveaux :

#### Niveau 0 : Read Uncommitted

```javascript
// MongoDB √©quivalent : readConcern "local", pas de transaction

// Probl√®me : Dirty Reads (lectures sales)
// Transaction T1 peut lire des modifications non committ√©es de T2

// Sc√©nario : Syst√®me de facturation
async function dirtyReadScenario() {
    // T1 : G√©n√©ration de rapport
    const reportTask = async () => {
        // Lecture avec readConcern local (d√©faut)
        const invoices = await invoices.find({
            status: "unpaid",
            customerId: "C001"
        }).toArray();

        const total = invoices.reduce((sum, inv) => sum + inv.amount, 0);
        console.log(`Total impay√© : ${total}`);
    };

    // T2 : Modification d'une facture (dans une transaction)
    const updateTask = async () => {
        const session = client.startSession();
        session.startTransaction();

        // Modification visible localement mais pas committ√©e
        await invoices.updateOne(
            { invoiceId: "INV001", customerId: "C001" },
            { $set: { amount: 10000 } },  // √âtait 1000
            { session }
        );

        // Attendre un peu avant de rollback
        await sleep(100);

        // Finalement, annuler la transaction
        await session.abortTransaction();
        await session.endSession();
    };

    // Ex√©cution concurrente
    await Promise.all([reportTask(), updateTask()]);

    // Probl√®me potentiel avec readConcern "local" :
    // Le rapport peut avoir lu amount=10000 alors que cette valeur
    // sera annul√©e (dirty read)
    //
    // Solution : Utiliser readConcern "snapshot" dans une transaction
}
```

#### Niveau 1 : Read Committed

```javascript
// MongoDB : readConcern "majority"

// Garantie : Jamais de dirty reads
// Une transaction ne lit que des donn√©es committ√©es

async function readCommittedScenario() {
    // Configuration read committed
    const invoices = await invoices.find({
        status: "unpaid",
        customerId: "C001"
    }, {
        readConcern: { level: "majority" }
    }).toArray();

    // Garantie : Toutes les factures lues ont √©t√© committ√©es
    // et r√©pliqu√©es sur la majorit√© du replica set

    // Probl√®me subsistant : Non-Repeatable Reads
    // Si on relit les m√™mes factures, on peut obtenir des valeurs diff√©rentes
}

// Probl√®me : Non-Repeatable Reads
async function nonRepeatableReadProblem() {
    // Premi√®re lecture
    const invoice1 = await invoices.findOne(
        { invoiceId: "INV001" },
        { readConcern: { level: "majority" } }
    );
    console.log(`Premi√®re lecture : ${invoice1.amount}`); // 1000

    // Entre les deux lectures, une autre transaction modifie et committe
    await sleep(100);

    // Deuxi√®me lecture
    const invoice2 = await invoices.findOne(
        { invoiceId: "INV001" },
        { readConcern: { level: "majority" } }
    );
    console.log(`Deuxi√®me lecture : ${invoice2.amount}`); // 1500

    // Probl√®me : M√™me requ√™te, r√©sultats diff√©rents
    // invoice1.amount !== invoice2.amount
}
```

#### Niveau 2 : Repeatable Read

```javascript
// MongoDB : Transaction avec readConcern "snapshot"

// Garantie : Lectures r√©p√©tables
// Toutes les lectures dans une transaction voient le m√™me snapshot

async function repeatableReadScenario() {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" }
        });

        // Premi√®re lecture
        const invoice1 = await invoices.findOne(
            { invoiceId: "INV001" },
            { session }
        );
        console.log(`Premi√®re lecture : ${invoice1.amount}`); // 1000

        // M√™me si une autre transaction modifie entre temps,
        // notre transaction voit toujours le m√™me snapshot
        await sleep(100);

        // Deuxi√®me lecture
        const invoice2 = await invoices.findOne(
            { invoiceId: "INV001" },
            { session }
        );
        console.log(`Deuxi√®me lecture : ${invoice2.amount}`); // 1000

        // Garantie : invoice1.amount === invoice2.amount
        // (Repeatable Read)

        await session.commitTransaction();

    } finally {
        await session.endSession();
    }

    // Probl√®me subsistant : Phantom Reads
    // De nouveaux documents peuvent appara√Ætre
}

// Probl√®me : Phantom Reads
async function phantomReadProblem() {
    const session = client.startSession();

    try {
        session.startTransaction({
            readConcern: { level: "snapshot" }
        });

        // Premi√®re requ√™te
        const invoices1 = await invoices.find(
            { customerId: "C001", status: "unpaid" },
            { session }
        ).toArray();
        console.log(`Premi√®re count : ${invoices1.length}`); // 5

        // Une autre transaction ins√®re une nouvelle facture
        // et committe avant notre transaction

        // Deuxi√®me requ√™te (m√™me crit√®re)
        const invoices2 = await invoices.find(
            { customerId: "C001", status: "unpaid" },
            { session }
        ).toArray();
        console.log(`Deuxi√®me count : ${invoices2.length}`); // 5 aussi

        // Avec snapshot isolation, pas de phantom reads non plus !
        // MongoDB garantit que le snapshot est complet

        await session.commitTransaction();

    } finally {
        await session.endSession();
    }
}
```

#### Niveau 3 : Serializable

```javascript
// MongoDB : Transaction avec snapshot isolation
// + d√©tection de conflits √©criture-√©criture

// Note : MongoDB impl√©mente Snapshot Isolation, qui est tr√®s proche
// de Serializable mais pas totalement √©quivalent

// Write Skew : Anomalie possible avec Snapshot Isolation
async function writeSkewAnomaly() {
    // Contexte : Syst√®me de garde m√©dicale
    // Invariant : Au moins un m√©decin doit √™tre de garde

    const doctors = [
        { doctorId: "D1", name: "Dr. Smith", onCall: true },
        { doctorId: "D2", name: "Dr. Jones", onCall: true }
    ];

    // T1 : Dr. Smith veut partir
    const t1 = async () => {
        const session = client.startSession();
        session.startTransaction({ readConcern: { level: "snapshot" } });

        // V√©rifier qu'au moins un autre est de garde
        const onCallCount = await doctors.countDocuments(
            { onCall: true },
            { session }
        );

        if (onCallCount > 1) {
            // OK, je peux partir
            await doctors.updateOne(
                { doctorId: "D1" },
                { $set: { onCall: false } },
                { session }
            );
        }

        await session.commitTransaction();
        await session.endSession();
    };

    // T2 : Dr. Jones veut partir (simultan√©ment)
    const t2 = async () => {
        const session = client.startSession();
        session.startTransaction({ readConcern: { level: "snapshot" } });

        // V√©rifier qu'au moins un autre est de garde
        const onCallCount = await doctors.countDocuments(
            { onCall: true },
            { session }
        );

        if (onCallCount > 1) {
            // OK, je peux partir
            await doctors.updateOne(
                { doctorId: "D2" },
                { $set: { onCall: false } },
                { session }
            );
        }

        await session.commitTransaction();
        await session.endSession();
    };

    // Ex√©cution concurrente
    await Promise.all([t1(), t2()]);

    // R√âSULTAT POTENTIEL :
    // Les deux transactions voient onCallCount=2 dans leur snapshot
    // Les deux d√©cident qu'elles peuvent partir
    // Les deux committent avec succ√®s
    // R√©sultat final : onCallCount=0 (VIOLE L'INVARIANT!)

    // C'est le "Write Skew" - possible avec Snapshot Isolation
    // mais pas avec vrai Serializable
}

// Solution au Write Skew : Verrous explicites
async function writeSkewSolution() {
    const t1 = async () => {
        const session = client.startSession();
        session.startTransaction({ readConcern: { level: "snapshot" } });

        // Acqu√©rir un verrou en √©crivant d'abord
        await doctors.updateMany(
            { onCall: true },
            { $inc: { version: 0 } },  // No-op update pour verrouiller
            { session }
        );

        const onCallCount = await doctors.countDocuments(
            { onCall: true },
            { session }
        );

        if (onCallCount > 1) {
            await doctors.updateOne(
                { doctorId: "D1" },
                { $set: { onCall: false } },
                { session }
            );
        }

        await session.commitTransaction();
        await session.endSession();
    };

    // Maintenant, T1 et T2 se bloquent mutuellement
    // Une seule pourra committer
}
```

## D comme Durabilit√© : La Persistance Garantie

### D√©finition Formelle

**Durabilit√©** : Une fois qu'une transaction T est committ√©e, ses modifications persistent m√™me en cas de d√©faillance syst√®me.

Formellement :
```
‚àÄT ‚àà Transactions : COMMIT(T) ‚üπ ‚àÄ d√©faillance F : R√©sultat(T) ‚àà √âtat_Apr√®s_R√©cup√©ration(F)
```

### M√©canismes de Durabilit√©

#### Niveau 1 : Write-Ahead Logging (WAL)

```javascript
// Le journal (oplog dans MongoDB) enregistre les modifications
// AVANT qu'elles soient appliqu√©es aux donn√©es principales

// Configuration avec journaling
await orders.insertOne({
    orderId: "O001",
    amount: 1000
}, {
    writeConcern: {
        w: 1,      // √âcriture sur le primary
        j: true    // ET √©crite dans le journal
    }
});

// Timeline interne MongoDB :
// 1. Modification √©crite dans le journal (sur disque, fsync)
// 2. R√©ponse envoy√©e au client (succ√®s garanti)
// 3. Modification appliqu√©e dans le cache WiredTiger (RAM)
// 4. Flush p√©riodique du cache vers les fichiers de donn√©es (60s par d√©faut)

// Garantie de durabilit√© :
// M√™me si le serveur crash apr√®s l'√©tape 2 et avant l'√©tape 4 :
// - Au red√©marrage, MongoDB rejoue le journal
// - La modification est reconstruite et appliqu√©e
// - Donn√©es restaur√©es compl√®tement
```

#### Niveau 2 : R√©plication

```javascript
// Durabilit√© via r√©plication : les donn√©es existent sur plusieurs n≈ìuds

await orders.insertOne({
    orderId: "O002",
    amount: 2000
}, {
    writeConcern: {
        w: "majority",  // Majorit√© du replica set
        j: true,        // Journal sur chaque n≈ìud
        wtimeout: 5000
    }
});

// Garantie multi-niveaux :
//
// Niveau 1 : Durabilit√© locale (j: true)
// - Survit au crash du primary
//
// Niveau 2 : Durabilit√© distribu√©e (w: "majority")
// - Replica Set √† 3 n≈ìuds : survit √† la perte de 1 n≈ìud
// - Replica Set √† 5 n≈ìuds : survit √† la perte de 2 n≈ìuds
//
// Formule : Tol√®re floor(n/2) pannes simultan√©es
```

#### Niveau 3 : Durabilit√© vs Performance

```javascript
// Spectre de configurations durabilit√©-performance

// CONFIGURATION 1 : Performance maximale (durabilit√© minimale)
await logs.insertOne({
    timestamp: new Date(),
    level: "INFO",
    message: "User logged in"
}, {
    writeConcern: { w: 0 }  // Fire-and-forget
});
// Latence : <1ms
// Durabilit√© : Aucune garantie
// Perte potentielle : Jusqu'aux 60 derni√®res secondes
// Cas d'usage : Logs non critiques, m√©triques temps r√©el

// CONFIGURATION 2 : √âquilibr√©e (d√©faut production)
await orders.insertOne({
    orderId: "O003",
    amount: 3000
}, {
    writeConcern: { w: 1, j: false }  // Primary, pas de journal forc√©
});
// Latence : 2-5ms
// Durabilit√© : Survit √† la plupart des pannes
// Perte potentielle : Rare, en cas de crash + perte disque simultan√©
// Cas d'usage : Applications web classiques

// CONFIGURATION 3 : Durabilit√© forte
await orders.insertOne({
    orderId: "O004",
    amount: 4000
}, {
    writeConcern: { w: "majority", j: true }
});
// Latence : 50-150ms (d√©pend de la g√©ographie)
// Durabilit√© : Survit √† la perte de n/2-1 n≈ìuds
// Perte potentielle : Quasi-nulle (catastrophe datacenter)
// Cas d'usage : Transactions financi√®res, donn√©es critiques

// CONFIGURATION 4 : Durabilit√© maximale (paranoia)
await orders.insertOne({
    orderId: "O005",
    amount: 5000
}, {
    writeConcern: {
        w: 5,           // 5 n≈ìuds sp√©cifiques (dont primaire)
        j: true,        // Journal sur tous
        wtimeout: 10000
    }
});
// Latence : 200-500ms (multi-r√©gion)
// Durabilit√© : Survit √† la destruction de 4 datacenters sur 5
// Perte potentielle : Apocalypse seulement
// Cas d'usage : Donn√©es irrempla√ßables (backup final, archives l√©gales)
```

### Durabilit√© et Compromis

```javascript
// √âtude de cas : E-commerce haute performance

// D√©cision : Durabilit√© diff√©renci√©e par type d'op√©ration

class OrderService {
    async createOrder(orderData) {
        const session = client.startSession();

        try {
            session.startTransaction({
                writeConcern: { w: "majority", j: true }  // üîí CRITIQUE
            });

            // Op√©rations critiques : durabilit√© maximale
            const order = await orders.insertOne({
                orderId: generateId(),
                customerId: orderData.customerId,
                items: orderData.items,
                total: orderData.total,
                status: "pending",
                createdAt: new Date()
            }, { session });

            await payments.insertOne({
                paymentId: generateId(),
                orderId: order.insertedId,
                amount: orderData.total,
                status: "pending"
            }, { session });

            await session.commitTransaction();

            // Op√©rations secondaires : durabilit√© rel√¢ch√©e (async)
            this.updateAnalytics(order.insertedId);  // Fire-and-forget
            this.sendConfirmationEmail(order.insertedId);  // Retry possible

            return order;

        } catch (error) {
            await session.abortTransaction();
            throw error;
        } finally {
            await session.endSession();
        }
    }

    async updateAnalytics(orderId) {
        // Pas de writeConcern strict : performances
        await analytics.insertOne({
            event: "order_created",
            orderId: orderId,
            timestamp: new Date()
        }, {
            writeConcern: { w: 1, j: false }  // üöÄ PERFORMANCE
        });

        // Si perdu : impact minimal sur le business
    }
}

// R√©sultat :
// - Commande : latence 80ms, durabilit√© forte
// - Analytics : latence 3ms, durabilit√© rel√¢ch√©e
// - Trade-off optimal : critique prot√©g√©, secondaire rapide
```

## Interactions et D√©pendances ACID

### La Cascade des Garanties

```
Durabilit√© ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> N√©cessite journaling et/ou r√©plication
    ‚îÇ                    ‚îÇ
    ‚îÇ                    ‚ñº
    ‚îÇ                Co√ªt : Latence, I/O
    ‚îÇ
    ‚ñº
Coh√©rence ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> N√©cessite validation et contraintes
    ‚îÇ                    ‚îÇ
    ‚îÇ                    ‚ñº
    ‚îÇ                Co√ªt : CPU, v√©rifications
    ‚îÇ
    ‚ñº
Isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> N√©cessite verrous et versionnement
    ‚îÇ                    ‚îÇ
    ‚îÇ                    ‚ñº
    ‚îÇ                Co√ªt : Contention, m√©moire
    ‚îÇ
    ‚ñº
Atomicit√© ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> Fondation de tout le reste
                       ‚îÇ
                       ‚ñº
                   Co√ªt : Coordination distribu√©e
```

### Th√©or√®me Fondamental

**Il n'existe pas de configuration ACID qui maximise simultan√©ment :**
- Performance (latence, d√©bit)
- Disponibilit√© (r√©sistance aux pannes)
- Coh√©rence (garanties s√©mantiques)

**Preuve par l'absurde** :
- Coh√©rence forte + Disponibilit√© ‚Üí Impossible avec partition r√©seau (CAP)
- Performance maximale + Durabilit√© ‚Üí Contradiction (fsync co√ªteux)
- Isolation stricte + D√©bit √©lev√© ‚Üí Contention de verrous

**Cons√©quence pratique** : Chaque syst√®me doit choisir ses priorit√©s

## Conclusion : ACID comme Outil de Conception

Les propri√©t√©s ACID ne sont pas des absolus √† appliquer uniform√©ment, mais des outils √† utiliser avec discernement :

### Matrice de D√©cision

| Cas d'Usage | A | C | I | D | Justification |
|-------------|---|---|---|---|---------------|
| Transaction bancaire | Stricte | Stricte | Serializable | Maximale | Argent r√©el |
| Panier e-commerce | Document | √âventuelle | Read Committed | Standard | Exp√©rience UX |
| Session utilisateur | Document | Faible | Local | Minimale | Reconstructible |
| Analytics temps r√©el | Document | N/A | Local | Minimale | Volume √©lev√© |
| Audit l√©gal | Stricte | Stricte | Serializable | Paranoia | Conformit√© |

### Principes Directeurs

1. **Mesurer avant d'optimiser** : Les suppositions sur les performances sont souvent fausses

2. **Diff√©rencier par criticit√©** : Toutes les donn√©es ne m√©ritent pas les m√™mes garanties

3. **Comprendre les co√ªts** : Chaque niveau ACID a un prix mesurable

4. **Privil√©gier la simplicit√©** : Un document bien mod√©lis√© √©vite souvent le besoin de transactions complexes

---


‚è≠Ô∏è [ACID dans le contexte NoSQL](/08-transactions/01.2-acid-contexte-nosql.md)
