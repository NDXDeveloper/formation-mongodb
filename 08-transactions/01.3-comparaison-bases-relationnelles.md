ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.3 Comparaison avec les Bases Relationnelles

## Introduction

Comparer les transactions MongoDB avec celles des bases de donnÃ©es relationnelles rÃ©vÃ¨le des diffÃ©rences fondamentales qui vont bien au-delÃ  d'une simple question de syntaxe. Ces diffÃ©rences reflÃ¨tent des philosophies architecturales divergentes, des compromis de conception opposÃ©s, et des modÃ¨les mentaux radicalement diffÃ©rents. Cette section explore ces diffÃ©rences en profondeur, non pas pour Ã©tablir une supÃ©rioritÃ© de l'un sur l'autre, mais pour Ã©clairer le choix architectural appropriÃ© selon le contexte.

## Fondements Architecturaux : Deux Visions du Monde

### L'Architecture Relationnelle : La CohÃ©rence par Construction

```
Architecture SGBDR Classique (PostgreSQL, Oracle, SQL Server)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Transaction Manager                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚         Lock Manager (Verrous)                 â”‚    â”‚
â”‚  â”‚  - Table locks                                 â”‚    â”‚
â”‚  â”‚  - Row locks (shared/exclusive)                â”‚    â”‚
â”‚  â”‚  - Lock escalation                             â”‚    â”‚
â”‚  â”‚  - Deadlock detection                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚         MVCC Engine (Multi-Version)            â”‚    â”‚
â”‚  â”‚  - Snapshot isolation                          â”‚    â”‚
â”‚  â”‚  - Version chains                              â”‚    â”‚
â”‚  â”‚  - Vacuum/cleanup                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚         WAL (Write-Ahead Log)                  â”‚    â”‚
â”‚  â”‚  - REDO log                                    â”‚    â”‚
â”‚  â”‚  - UNDO log                                    â”‚    â”‚
â”‚  â”‚  - Checkpoint                                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CaractÃ©ristiques :
âœ“ ACID strict par dÃ©faut
âœ“ Verrous pessimistes natifs
âœ“ Isolation jusqu'Ã  Serializable
âœ“ Contraintes d'intÃ©gritÃ© strictes (FK, CHECK)
âœ“ OptimisÃ© pour un serveur unique puissant
```

```sql
-- Exemple PostgreSQL : Transaction typique

BEGIN;  -- DÃ©but transaction

-- Verrous automatiques acquis
UPDATE accounts
SET balance = balance - 100
WHERE account_id = 'A001';
-- â–² Verrou exclusif (FOR UPDATE implicite) sur la ligne

UPDATE accounts
SET balance = balance + 100
WHERE account_id = 'B002';
-- â–² Autre verrou exclusif

-- VÃ©rification des contraintes
-- âœ“ CHECK constraints Ã©valuÃ©s
-- âœ“ Foreign keys vÃ©rifiÃ©es
-- âœ“ Triggers exÃ©cutÃ©s

COMMIT;  -- Validation

-- Garanties PostgreSQL :
-- 1. Isolation : MVCC (snapshots par transaction)
-- 2. AtomicitÃ© : WAL garantit tout-ou-rien
-- 3. CohÃ©rence : Contraintes vÃ©rifiÃ©es avant commit
-- 4. DurabilitÃ© : fsync du WAL avant rÃ©ponse

-- Performance mesurÃ©e :
-- - Latence : 2-5ms (local), 10-20ms (avec fsync)
-- - Throughput : 5,000-15,000 tps (serveur unique)
-- - ScalabilitÃ© : Verticale principalement
```

### L'Architecture MongoDB : La FlexibilitÃ© par Conception

```
Architecture MongoDB (Distributed)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replica Set :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Primary    â”‚  â”‚  Secondary   â”‚  â”‚  Secondary   â”‚
â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
â”‚  Document    â”‚  â”‚  Replication â”‚  â”‚  Replication â”‚
â”‚  Storage     â”‚â—„â”€â”¤  (Oplog)     â”‚â—„â”€â”¤  (Oplog)     â”‚
â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
â”‚  WiredTiger  â”‚  â”‚  WiredTiger  â”‚  â”‚  WiredTiger  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Sharded Cluster :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Shard 1    â”‚  â”‚   Shard 2    â”‚  â”‚   Shard N    â”‚
â”‚  (RS 1)      â”‚  â”‚  (RS 2)      â”‚  â”‚  (RS N)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚ Mongos  â”‚ â† Query Router
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CaractÃ©ristiques :
âœ“ ACID configurable (document â†’ multi-shard)
âœ“ Verrous optimistes (document-level)
âœ“ Isolation snapshot dans transactions
âœ“ Contraintes flexibles (validation JSON schema)
âœ“ OptimisÃ© pour distribution horizontale
```

```javascript
// Exemple MongoDB : Transaction similaire

const session = client.startSession();
session.startTransaction({
    readConcern: { level: "snapshot" },
    writeConcern: { w: "majority" }
});

try {
    // Pas de verrous explicites
    // Document-level atomic operations
    await accounts.updateOne(
        { accountId: "A001" },
        { $inc: { balance: -100 } },
        { session }
    );

    await accounts.updateOne(
        { accountId: "B002" },
        { $inc: { balance: 100 } },
        { session }
    );

    // Validation optionnelle (schema validation)
    // Pas de foreign keys par dÃ©faut

    await session.commitTransaction();

    // Garanties MongoDB :
    // 1. Isolation : Snapshot (version documents)
    // 2. AtomicitÃ© : Oplog + two-phase commit (sharded)
    // 3. CohÃ©rence : Configurable (eventual â†’ strict)
    // 4. DurabilitÃ© : Configurable (w:1 â†’ w:majority)

    // Performance mesurÃ©e :
    // - Latence : 5-15ms (RS), 50-200ms (sharded)
    // - Throughput : 2,000-10,000 tps (RS), 10,000-100,000 tps (sharded)
    // - ScalabilitÃ© : Horizontale nativement

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}
```

## ModÃ¨les de Verrouillage : Pessimiste vs Optimiste

### SGBDR : Verrouillage Pessimiste

Les bases relationnelles utilisent traditionnellement des verrous pessimistes : on suppose qu'il y aura des conflits, donc on verrouille prÃ©ventivement.

```sql
-- PostgreSQL : Exemple de verrouillage explicite

BEGIN;

-- 1. Verrou partagÃ© (lecture)
SELECT * FROM products
WHERE product_id = 'P001'
FOR SHARE;
-- â–² Autorise d'autres lectures, bloque les Ã©critures

-- 2. Verrou exclusif (Ã©criture)
SELECT * FROM products
WHERE product_id = 'P001'
FOR UPDATE;
-- â–² Bloque tout (lectures et Ã©critures)

-- 3. Verrou avec SKIP LOCKED
SELECT * FROM tasks
WHERE status = 'pending'
LIMIT 10
FOR UPDATE SKIP LOCKED;
-- â–² Saute les lignes dÃ©jÃ  verrouillÃ©es (file d'attente)

-- 4. Verrou avec NOWAIT
SELECT * FROM inventory
WHERE sku = 'SKU001'
FOR UPDATE NOWAIT;
-- â–² Ã‰choue immÃ©diatement si verrou impossible

COMMIT;

-- Timeline dÃ©taillÃ©e de contention :

-- T1 (Transaction 1)              T2 (Transaction 2)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- BEGIN;
-- SELECT ... FOR UPDATE (P001)
-- âœ“ Verrou acquis
--                                  BEGIN;
--                                  SELECT ... FOR UPDATE (P001)
--                                  â³ ATTEND (bloquÃ© par T1)
--
-- ... traitement (500ms) ...
--                                  â³ TOUJOURS EN ATTENTE
-- COMMIT;
-- âœ“ Verrou relÃ¢chÃ©
--                                  âœ“ Verrou acquis
--                                  ... traitement ...
--                                  COMMIT;

-- Impact mesurable :
-- - T2 latence : latence(T1) + latence_propre(T2)
-- - Si T1 prend 500ms, T2 attend 500ms avant de commencer
```

**Gestion des Deadlocks dans PostgreSQL** :

```sql
-- ScÃ©nario classique de deadlock

-- T1                                T2
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BEGIN;                               BEGIN;

UPDATE accounts                      UPDATE accounts
SET balance = balance - 100          SET balance = balance + 50
WHERE id = 'A001';                   WHERE id = 'B002';
-- âœ“ Verrou sur A001                 -- âœ“ Verrou sur B002

UPDATE accounts                      UPDATE accounts
SET balance = balance + 100          SET balance = balance - 50
WHERE id = 'B002';                   WHERE id = 'A001';
-- â³ ATTEND verrou sur B002          -- â³ ATTEND verrou sur A001

-- ğŸ’€ DEADLOCK DÃ‰TECTÃ‰ !
-- PostgreSQL choisit une victime (gÃ©nÃ©ralement T2)
-- ERROR: deadlock detected
-- DETAIL: Process 1234 waits for ShareLock on transaction 5678;
--         blocked by process 5678.
--         Process 5678 waits for ShareLock on transaction 1234;
--         blocked by process 1234.

-- Solution PostgreSQL :
-- 1. DÃ©tection automatique (deadlock_timeout = 1s par dÃ©faut)
-- 2. Abort d'une transaction (victime choisie arbitrairement)
-- 3. L'application doit retry

-- PrÃ©vention :
-- âœ“ Toujours acquÃ©rir les verrous dans le mÃªme ordre
-- âœ“ Garder les transactions courtes
-- âœ“ Utiliser des timeout appropriÃ©s
```

### MongoDB : Verrouillage Optimiste

MongoDB adopte une approche optimiste : on suppose qu'il n'y aura pas de conflits, et on dÃ©tecte a posteriori.

```javascript
// MongoDB : Pas de verrous explicites dans les transactions

const session = client.startSession();
session.startTransaction({
    readConcern: { level: "snapshot" }
});

try {
    // Lecture sans verrou
    const account = await accounts.findOne(
        { accountId: "A001" },
        { session }
    );

    // Modification locale
    const newBalance = account.balance - 100;

    // Tentative d'Ã©criture (sans verrou prÃ©alable)
    await accounts.updateOne(
        { accountId: "A001" },
        { $set: { balance: newBalance } },
        { session }
    );

    // Commit : DÃ©tection de conflit ici si nÃ©cessaire
    await session.commitTransaction();

    // Si une autre transaction a modifiÃ© le document entre temps :
    // â†’ WriteConflict exception
    // â†’ Retry nÃ©cessaire

} catch (error) {
    await session.abortTransaction();

    if (error.hasErrorLabel('TransientTransactionError')) {
        // Conflit optimiste dÃ©tectÃ©
        console.log("Conflit, retry...");
        // L'application doit implÃ©menter le retry
    }

    throw error;
} finally {
    await session.endSession();
}

// Timeline de contention optimiste :

// T1 (Transaction 1)              T2 (Transaction 2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•             â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEGIN (snapshot@version 10)
// READ (A001) â†’ balance: 1000
//                                  BEGIN (snapshot@version 10)
//                                  READ (A001) â†’ balance: 1000
//
// UPDATE (A001) balance: 900
// (pas de verrou, juste intention)
--                                  UPDATE (A001) balance: 800
--                                  (pas de verrou, juste intention)
//
// COMMIT
// âœ“ A001 version: 11
--
--                                  COMMIT
--                                  âŒ WriteConflict!
--                                  (A001 modifiÃ© depuis snapshot)
--                                  ABORT automatique

// Avantages :
// âœ“ Pas d'attente (pas de blocage)
// âœ“ Performance Ã©levÃ©e avec faible contention
// âœ“ Pas de deadlock possible
//
// InconvÃ©nients :
// âœ— Retry nÃ©cessaire en cas de conflit
// âœ— Travail perdu en cas de conflit
// âœ— Inefficace avec haute contention
```

**ImplÃ©mentation du Retry avec Backoff** :

```javascript
// Pattern recommandÃ© : Retry avec backoff exponentiel

async function executeWithRetry(transactionFn, maxRetries = 5) {
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            return await transactionFn();

        } catch (error) {
            // TransientTransactionError : conflit optimiste ou panne temporaire
            if (error.hasErrorLabel('TransientTransactionError')) {
                attempt++;

                if (attempt >= maxRetries) {
                    throw new Error(`Transaction failed after ${maxRetries} attempts`);
                }

                // Backoff exponentiel : 100ms, 200ms, 400ms, 800ms, 1600ms
                const backoffMs = Math.min(100 * Math.pow(2, attempt), 5000);

                console.log(`Attempt ${attempt} failed, retrying in ${backoffMs}ms...`);
                await sleep(backoffMs);

                continue;
            }

            // UnknownTransactionCommitResult : incertitude sur le commit
            if (error.hasErrorLabel('UnknownTransactionCommitResult')) {
                // Le commit peut avoir rÃ©ussi ou Ã©chouÃ©
                // VÃ©rification nÃ©cessaire avant retry

                const committed = await verifyCommit();
                if (committed) {
                    return { success: true, note: "Committed despite uncertainty" };
                }

                // Si pas committed, retry
                attempt++;
                await sleep(Math.min(100 * Math.pow(2, attempt), 5000));
                continue;
            }

            // Autre erreur : ne pas retry
            throw error;
        }
    }
}

// Utilisation
await executeWithRetry(async () => {
    const session = client.startSession();
    session.startTransaction();

    try {
        await accounts.updateOne(
            { accountId: "A001" },
            { $inc: { balance: -100 } },
            { session }
        );

        await accounts.updateOne(
            { accountId: "B002" },
            { $inc: { balance: 100 } },
            { session }
        );

        await session.commitTransaction();
    } finally {
        await session.endSession();
    }
});
```

## Niveaux d'Isolation : Comparaison DÃ©taillÃ©e

### Tableau Comparatif

| Niveau d'Isolation | PostgreSQL | MySQL (InnoDB) | SQL Server | MongoDB |
|-------------------|------------|----------------|------------|---------|
| **Read Uncommitted** | âœ“ (rare) | âœ“ | âœ“ | âœ— (non supportÃ©) |
| **Read Committed** | âœ“ (dÃ©faut) | âœ“ (dÃ©faut) | âœ“ (dÃ©faut) | â‰ˆ (readConcern: "local") |
| **Repeatable Read** | âœ“ | âœ“ (dÃ©faut) | âœ“ | â‰ˆ (readConcern: "snapshot") |
| **Serializable** | âœ“ | âœ“ | âœ“ | â‰ˆ (snapshot isolation) |
| **Snapshot Isolation** | âœ“ (â‰ˆ Repeatable Read) | âœ“ (Repeatable Read) | âœ“ | âœ“ (natif) |

### Read Uncommitted : Dirty Reads

```sql
-- PostgreSQL : READ UNCOMMITTED (thÃ©orique, rarement utilisÃ©)

-- T1
BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
UPDATE accounts SET balance = 2000 WHERE id = 'A001';
-- Pas encore committÃ©

-- T2 (concurrent)
BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT balance FROM accounts WHERE id = 'A001';
-- Peut lire 2000 (dirty read)

-- T1
ROLLBACK;  -- Annulation

-- RÃ©sultat T2 : A lu une valeur qui n'existe plus (fantÃ´me)
```

```javascript
// MongoDB : Read Uncommitted non supportÃ©
// Minimum : readConcern "local"

const data = await collection.findOne(
    { accountId: "A001" },
    { readConcern: { level: "local" } }
);

// "local" garantit :
// âœ“ Pas de dirty reads (donnÃ©es non committÃ©es)
// âœ“ Lit les donnÃ©es du nÅ“ud local
// âš  Peut lire des donnÃ©es non encore rÃ©pliquÃ©es
// âš  Peut lire des donnÃ©es qui seront rollback aprÃ¨s panne primary
```

### Read Committed

```sql
-- PostgreSQL : READ COMMITTED (dÃ©faut)

-- T1
BEGIN;  -- Isolation READ COMMITTED par dÃ©faut
SELECT balance FROM accounts WHERE id = 'A001';
-- balance = 1000

-- T2 modifie et committe
UPDATE accounts SET balance = 2000 WHERE id = 'A001';
-- (dans une transaction auto-commit)

-- T1 relit
SELECT balance FROM accounts WHERE id = 'A001';
-- balance = 2000 (non-repeatable read)

-- CaractÃ©ristique :
-- âœ“ Pas de dirty reads
-- âœ— Non-repeatable reads possibles
-- âœ— Phantom reads possibles

COMMIT;
```

```javascript
// MongoDB : Ã‰quivalent approximatif avec readConcern "majority"

// Hors transaction
const read1 = await accounts.findOne(
    { accountId: "A001" },
    { readConcern: { level: "majority" } }
);
// balance: 1000

// Une autre opÃ©ration modifie
await accounts.updateOne(
    { accountId: "A001" },
    { $set: { balance: 2000 } },
    { writeConcern: { w: "majority" } }
);

// Relecture
const read2 = await accounts.findOne(
    { accountId: "A001" },
    { readConcern: { level: "majority" } }
);
// balance: 2000 (non-repeatable read)

// Similaire Ã  READ COMMITTED :
// âœ“ Lit seulement les donnÃ©es committÃ©es (et rÃ©pliquÃ©es)
// âœ— Les lectures ne sont pas rÃ©pÃ©tables
```

### Repeatable Read / Snapshot Isolation

```sql
-- PostgreSQL : REPEATABLE READ (implÃ©mentÃ© via MVCC/Snapshot)

-- T1
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT balance FROM accounts WHERE id = 'A001';
-- balance = 1000 (snapshot Ã  T0)

-- T2 modifie et committe
UPDATE accounts SET balance = 2000 WHERE id = 'A001';

-- T1 relit
SELECT balance FROM accounts WHERE id = 'A001';
-- balance = 1000 (toujours, vue snapshot)

-- T1 tente de modifier
UPDATE accounts SET balance = 1500 WHERE id = 'A001';
-- ERROR: could not serialize access due to concurrent update

COMMIT;

-- CaractÃ©ristiques PostgreSQL Repeatable Read :
-- âœ“ Repeatable reads (snapshot)
-- âœ“ Pas de phantom reads (diffÃ©rent de SQL standard)
-- âœ“ DÃ©tection de conflits write-write
-- â‰ˆ Ã‰quivalent Ã  Snapshot Isolation
```

```javascript
// MongoDB : Snapshot Isolation (natif dans transactions)

const session = client.startSession();
session.startTransaction({
    readConcern: { level: "snapshot" }
});

try {
    // Snapshot crÃ©Ã© au dÃ©but de la transaction
    const read1 = await accounts.findOne(
        { accountId: "A001" },
        { session }
    );
    console.log(read1.balance);  // 1000

    // Une autre transaction modifie et committe (en parallÃ¨le)
    // ...

    // Relecture dans la mÃªme transaction
    const read2 = await accounts.findOne(
        { accountId: "A001" },
        { session }
    );
    console.log(read2.balance);  // 1000 (toujours, snapshot)

    // Tentative de modification
    await accounts.updateOne(
        { accountId: "A001" },
        { $set: { balance: 1500 } },
        { session }
    );

    await session.commitTransaction();
    // Si conflit : WriteConflict exception

} catch (error) {
    await session.abortTransaction();
    throw error;
} finally {
    await session.endSession();
}

// CaractÃ©ristiques MongoDB Snapshot :
// âœ“ Repeatable reads (snapshot)
// âœ“ Pas de phantom reads
// âœ“ DÃ©tection de conflits write-write
// â‰ˆ Ã‰quivalent Ã  PostgreSQL Repeatable Read
```

### Serializable

```sql
-- PostgreSQL : SERIALIZABLE (le plus strict)

-- T1
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SELECT COUNT(*) FROM accounts WHERE balance < 1000;
-- count = 5

-- T2 (concurrent)
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
INSERT INTO accounts (id, balance) VALUES ('A999', 500);
COMMIT;

-- T1 continue
SELECT COUNT(*) FROM accounts WHERE balance < 1000;
-- count = 5 (phantom read bloquÃ© par snapshot)

UPDATE accounts SET balance = balance + 100
WHERE balance < 1000;
-- Modifie 5 comptes (basÃ© sur le snapshot initial)

COMMIT;
-- ERROR: could not serialize access due to read/write dependencies

-- PostgreSQL dÃ©tecte que :
-- - T1 a lu un ensemble de lignes
-- - T2 a modifiÃ© cet ensemble
-- - T1 a basÃ© ses Ã©critures sur sa lecture
-- â†’ Anomalie sÃ©rialisabilitÃ© (write skew)
-- â†’ Abort de T1

-- ImplÃ©mentation : Serializable Snapshot Isolation (SSI)
-- DÃ©tecte les dÃ©pendances dangereuses entre transactions
```

```javascript
// MongoDB : Pas de vrai Serializable
// Snapshot Isolation peut avoir des anomalies write skew

const session1 = client.startSession();
session1.startTransaction({ readConcern: { level: "snapshot" } });

const session2 = client.startSession();
session2.startTransaction({ readConcern: { level: "snapshot" } });

try {
    // T1 : MÃ©decin Smith veut partir
    const onCallCount1 = await doctors.countDocuments(
        { onCall: true },
        { session: session1 }
    );  // count = 2

    if (onCallCount1 > 1) {
        // OK, un autre est de garde
        await doctors.updateOne(
            { doctorId: "D1" },
            { $set: { onCall: false } },
            { session: session1 }
        );
    }

    // T2 : MÃ©decin Jones veut partir (simultanÃ©ment)
    const onCallCount2 = await doctors.countDocuments(
        { onCall: true },
        { session: session2 }
    );  // count = 2 (mÃªme snapshot)

    if (onCallCount2 > 1) {
        // OK, un autre est de garde
        await doctors.updateOne(
            { doctorId: "D2" },
            { $set: { onCall: false } },
            { session: session2 }
        );
    }

    // Les deux committent
    await session1.commitTransaction();
    await session2.commitTransaction();

    // RÃ©sultat : onCallCount = 0 (VIOLE L'INVARIANT!)
    // Write skew : Snapshot Isolation ne dÃ©tecte pas cette anomalie

} finally {
    await session1.endSession();
    await session2.endSession();
}

// MongoDB ne dÃ©tecte pas les dÃ©pendances read-write
// Solution : Verrous applicatifs explicites
```

## Contraintes d'IntÃ©gritÃ© : DÃ©claratif vs Applicatif

### SGBDR : Contraintes DÃ©claratives

```sql
-- PostgreSQL : Contraintes riches et vÃ©rifiÃ©es par le moteur

CREATE TABLE accounts (
    account_id VARCHAR(20) PRIMARY KEY,
    customer_id VARCHAR(20) NOT NULL,
    balance DECIMAL(15, 2) NOT NULL DEFAULT 0,
    currency CHAR(3) NOT NULL DEFAULT 'EUR',
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),

    -- Contraintes au niveau colonne
    CONSTRAINT balance_positive CHECK (balance >= 0),
    CONSTRAINT valid_currency CHECK (currency IN ('EUR', 'USD', 'GBP')),
    CONSTRAINT valid_status CHECK (status IN ('active', 'frozen', 'closed')),

    -- ClÃ© Ã©trangÃ¨re
    CONSTRAINT fk_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE
);

-- Contrainte au niveau table
ALTER TABLE accounts ADD CONSTRAINT account_number_format
CHECK (account_id ~ '^ACC[0-9]{8}$');

-- Contrainte multi-colonnes
ALTER TABLE accounts ADD CONSTRAINT frozen_zero_balance
CHECK (status != 'frozen' OR balance = 0);

-- Index unique
CREATE UNIQUE INDEX idx_customer_currency
ON accounts(customer_id, currency);

-- Tentative de violation
INSERT INTO accounts (account_id, customer_id, balance, currency)
VALUES ('ACC12345678', 'C001', -500, 'EUR');
-- ERROR: new row violates check constraint "balance_positive"

-- Tentative de suppression avec FK
DELETE FROM customers WHERE customer_id = 'C001';
-- ERROR: update or delete violates foreign key constraint "fk_customer"

-- Garanties :
-- âœ“ VÃ©rification automatique par le moteur
-- âœ“ Impossible de violer (sauf dÃ©sactivation)
-- âœ“ DocumentÃ©es dans le schÃ©ma
-- âœ“ CohÃ©rence garantie Ã  100%
```

### MongoDB : Validation Flexible

```javascript
// MongoDB : Validation de schÃ©ma JSON (depuis 3.2, amÃ©liorÃ©e 3.6+)

db.createCollection("accounts", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["accountId", "customerId", "balance", "currency", "status"],
            properties: {
                accountId: {
                    bsonType: "string",
                    pattern: "^ACC[0-9]{8}$",
                    description: "Format: ACCxxxxxxxx"
                },
                customerId: {
                    bsonType: "string",
                    description: "RÃ©fÃ©rence client (non vÃ©rifiÃ©e)"
                },
                balance: {
                    bsonType: "double",
                    minimum: 0,
                    description: "Solde >= 0"
                },
                currency: {
                    enum: ["EUR", "USD", "GBP"],
                    description: "Devise valide"
                },
                status: {
                    enum: ["active", "frozen", "closed"],
                    description: "Statut du compte"
                },
                createdAt: {
                    bsonType: "date"
                }
            },
            // Contrainte multi-champs (avec $expr)
            $expr: {
                $cond: {
                    if: { $eq: ["$status", "frozen"] },
                    then: { $eq: ["$balance", 0] },
                    else: true
                }
            }
        }
    },
    validationLevel: "strict",     // "strict" ou "moderate"
    validationAction: "error"      // "error" ou "warn"
});

// Tentative de violation
try {
    await accounts.insertOne({
        accountId: "ACC12345678",
        customerId: "C001",
        balance: -500,  // âŒ Viole la contrainte
        currency: "EUR",
        status: "active"
    });
} catch (error) {
    // DocumentValidationFailure
    console.error("Validation failed:", error.message);
}

// DiffÃ©rences clÃ©s avec SGBDR :

// 1. Pas de clÃ©s Ã©trangÃ¨res natives
//    â†’ Ã€ implÃ©menter en applicatif si nÃ©cessaire

// 2. Validation dÃ©sactivable
await db.runCommand({
    collMod: "accounts",
    validationLevel: "moderate"  // Valide seulement les nouveaux docs
});

// 3. Validation conditionnelle possible
validator: {
    $or: [
        { documentType: "type1", requiredField1: { $exists: true } },
        { documentType: "type2", requiredField2: { $exists: true } }
    ]
}

// 4. SchÃ©ma flexible (documents hÃ©tÃ©rogÃ¨nes possibles)
await accounts.insertOne({
    accountId: "ACC99999999",
    customerId: "C002",
    balance: 1000,
    currency: "USD",
    status: "active",
    // Champs additionnels autorisÃ©s
    vipStatus: true,
    creditLimit: 5000
});

// Garanties :
// âœ“ Validation configurable par collection
// âš  Pas de foreign keys (Ã  gÃ©rer en applicatif)
// âš  Peut Ãªtre dÃ©sactivÃ©e/contournÃ©e
// âš  CohÃ©rence Ã  la charge de l'application
```

## Performance et ScalabilitÃ© : Compromis Fondamentaux

### Benchmark Comparatif : Serveur Unique

```
Test : 10,000 transactions simples (read + write)
Environnement : Serveur unique, SSD, 16 cores, 64GB RAM

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         PostgreSQL 15 (Serveur unique)                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Configuration :                                           â•‘
â•‘ - default_transaction_isolation = 'read committed'        â•‘
â•‘ - synchronous_commit = on                                 â•‘
â•‘ - fsync = on                                              â•‘
â•‘                                                           â•‘
â•‘ RÃ©sultats :                                               â•‘
â•‘ - Transactions/sec : 8,500 TPS                            â•‘
â•‘ - Latence P50 : 3.2ms                                     â•‘
â•‘ - Latence P95 : 12ms                                      â•‘
â•‘ - Latence P99 : 28ms                                      â•‘
â•‘ - CPU : 65%                                               â•‘
â•‘ - I/O : WAL writes bottleneck                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         MongoDB 6.0 (Replica Set - 3 nÅ“uds)               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Configuration :                                           â•‘
â•‘ - writeConcern: { w: 1 }                                  â•‘
â•‘ - readConcern: { level: "local" }                         â•‘
â•‘ - Pas de transactions multi-documents                     â•‘
â•‘                                                           â•‘
â•‘ RÃ©sultats :                                               â•‘
â•‘ - OpÃ©rations/sec : 45,000 OPS                             â•‘
â•‘ - Latence P50 : 0.8ms                                     â•‘
â•‘ - Latence P95 : 2.1ms                                     â•‘
â•‘ - Latence P99 : 4.5ms                                     â•‘
â•‘ - CPU : 45%                                               â•‘
â•‘ - I/O : DistribuÃ© sur 3 nÅ“uds                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Analyse :
MongoDB ~5x plus rapide pour opÃ©rations simples
Mais : pas de transactions ACID strictes (w:1)
```

### Benchmark : Avec Garanties ACID Ã‰quivalentes

```
Test : 10,000 transactions avec garanties ACID strictes

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         PostgreSQL 15                                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Configuration :                                           â•‘
â•‘ - ISOLATION LEVEL REPEATABLE READ                         â•‘
â•‘ - synchronous_commit = on                                 â•‘
â•‘ - Transactions multi-tables                               â•‘
â•‘                                                           â•‘
â•‘ RÃ©sultats :                                               â•‘
â•‘ - TPS : 6,200                                             â•‘
â•‘ - Latence P50 : 4.8ms                                     â•‘
â•‘ - Latence P95 : 18ms                                      â•‘
â•‘ - Latence P99 : 45ms                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         MongoDB 6.0                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Configuration :                                           â•‘
â•‘ - writeConcern: { w: "majority", j: true }                â•‘
â•‘ - readConcern: { level: "snapshot" }                      â•‘
â•‘ - Transactions multi-documents                            â•‘
â•‘                                                           â•‘
â•‘ RÃ©sultats :                                               â•‘
â•‘ - TPS : 3,800                                             â•‘
â•‘ - Latence P50 : 12ms                                      â•‘
â•‘ - Latence P95 : 45ms                                      â•‘
â•‘ - Latence P99 : 120ms                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Analyse :
PostgreSQL ~60% plus rapide avec ACID strict
MongoDB : Overhead de la coordination distribuÃ©e
```

### ScalabilitÃ© Horizontale : Le Grand Ã‰cart

```
Test : Scaling de 1 Ã  100 nÅ“uds

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         PostgreSQL (avec Citus - sharding extension)      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ 1 nÅ“ud   : 8,500 TPS                                      â•‘
â•‘ 2 nÅ“uds  : 14,000 TPS  (1.6x)                             â•‘
â•‘ 4 nÅ“uds  : 22,000 TPS  (2.6x)                             â•‘
â•‘ 8 nÅ“uds  : 35,000 TPS  (4.1x)                             â•‘
â•‘ 16 nÅ“uds : 48,000 TPS  (5.6x) âš  Coordination coÃ»teuse    â•‘
â•‘                                                           â•‘
â•‘ Limitations :                                             â•‘
â•‘ - Transactions cross-shard trÃ¨s coÃ»teuses (2PC)           â•‘
â•‘ - JOINs cross-shard impossibles ou lents                  â•‘
â•‘ - Resharding complexe                                     â•‘
â•‘ - Coordination = bottleneck                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         MongoDB (Sharded Cluster)                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ 1 shard  : 45,000 OPS                                     â•‘
â•‘ 2 shards : 88,000 OPS  (1.95x) âœ“ Scaling quasi-linÃ©aire   â•‘
â•‘ 4 shards : 172,000 OPS (3.8x)                             â•‘
â•‘ 8 shards : 340,000 OPS (7.5x)                             â•‘
â•‘ 16 shards: 650,000 OPS (14.4x) âœ“ Excellent scaling        â•‘
â•‘ 32 shards: 1,200,000 OPS (26x) âœ“ Production prouvÃ©e       â•‘
â•‘                                                           â•‘
â•‘ Avantages :                                               â•‘
â•‘ - Scaling quasi-linÃ©aire si shard key appropriÃ©e          â•‘
â•‘ - Pas de JOINs â†’ pas de problÃ¨me cross-shard              â•‘
â•‘ - Resharding automatique (balancer)                       â•‘
â•‘ - Coordination minimale                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Note : OPS MongoDB sans transactions multi-documents
Avec transactions cross-shard, performances similaires Ã  PostgreSQL
```

## Cas d'Usage : Quand Choisir Quoi ?

### Matrice de DÃ©cision DÃ©taillÃ©e

```javascript
// SystÃ¨me d'aide Ã  la dÃ©cision

class DatabaseSelector {
    evaluate(requirements) {
        const scores = {
            postgresql: 0,
            mongodb: 0
        };

        // Facteurs favorisant PostgreSQL
        if (requirements.strictACID) {
            scores.postgresql += 10;
            console.log("+10 PostgreSQL: ACID strict requis");
        }

        if (requirements.complexJoins) {
            scores.postgresql += 9;
            console.log("+9 PostgreSQL: JOINs complexes");
        }

        if (requirements.reporting) {
            scores.postgresql += 8;
            console.log("+8 PostgreSQL: Analytics/reporting");
        }

        if (requirements.foreignKeys) {
            scores.postgresql += 8;
            console.log("+8 PostgreSQL: Foreign keys essentielles");
        }

        if (requirements.serializableIsolation) {
            scores.postgresql += 7;
            console.log("+7 PostgreSQL: Isolation Serializable");
        }

        // Facteurs favorisant MongoDB
        if (requirements.horizontalScaling) {
            scores.mongodb += 10;
            console.log("+10 MongoDB: Scaling horizontal");
        }

        if (requirements.flexibleSchema) {
            scores.mongodb += 9;
            console.log("+9 MongoDB: SchÃ©ma flexible");
        }

        if (requirements.documentOriented) {
            scores.mongodb += 9;
            console.log("+9 MongoDB: DonnÃ©es orientÃ©es document");
        }

        if (requirements.highThroughput) {
            scores.mongodb += 8;
            console.log("+8 MongoDB: Haute performance");
        }

        if (requirements.geospatial) {
            scores.mongodb += 7;
            console.log("+7 MongoDB: RequÃªtes gÃ©ospatiales");
        }

        if (requirements.eventualConsistency) {
            scores.mongodb += 6;
            console.log("+6 MongoDB: CohÃ©rence Ã©ventuelle acceptable");
        }

        console.log("\nScores:");
        console.log(`PostgreSQL: ${scores.postgresql}`);
        console.log(`MongoDB: ${scores.mongodb}`);

        if (Math.abs(scores.postgresql - scores.mongodb) < 5) {
            return "HYBRID (utilisez les deux)";
        }

        return scores.postgresql > scores.mongodb ? "PostgreSQL" : "MongoDB";
    }
}

// Exemples concrets

// CAS 1 : Application bancaire
const banking = {
    strictACID: true,               // +10 PG
    complexJoins: true,             // +9 PG
    reporting: true,                // +8 PG
    foreignKeys: true,              // +8 PG
    serializableIsolation: true,    // +7 PG
    horizontalScaling: false,       // 0
    flexibleSchema: false,          // 0
    documentOriented: false,        // 0
    highThroughput: false,          // 0
    geospatial: false,              // 0
    eventualConsistency: false      // 0
};
// RÃ©sultat : PostgreSQL (42 vs 0) âœ“

// CAS 2 : RÃ©seau social
const socialNetwork = {
    strictACID: false,              // 0
    complexJoins: false,            // 0
    reporting: false,               // 0
    foreignKeys: false,             // 0
    serializableIsolation: false,   // 0
    horizontalScaling: true,        // +10 Mongo
    flexibleSchema: true,           // +9 Mongo
    documentOriented: true,         // +9 Mongo
    highThroughput: true,           // +8 Mongo
    geospatial: true,               // +7 Mongo (nearby users)
    eventualConsistency: true       // +6 Mongo
};
// RÃ©sultat : MongoDB (0 vs 49) âœ“

// CAS 3 : E-commerce
const ecommerce = {
    strictACID: true,               // +10 PG (commandes)
    complexJoins: false,            // 0 (catalogue dÃ©normalisÃ©)
    reporting: true,                // +8 PG (ventes)
    foreignKeys: false,             // 0 (peut Ãªtre gÃ©rÃ© en app)
    serializableIsolation: false,   // 0 (snapshot suffit)
    horizontalScaling: true,        // +10 Mongo
    flexibleSchema: true,           // +9 Mongo (catalogue produits)
    documentOriented: true,         // +9 Mongo
    highThroughput: true,           // +8 Mongo (peak traffic)
    geospatial: false,              // 0
    eventualConsistency: false      // 0 (commandes critiques)
};
// RÃ©sultat : HYBRID (18 vs 36, mais facteurs critiques des deux cÃ´tÃ©s)
// Solution : PostgreSQL pour commandes/paiements
//           MongoDB pour catalogue/sessions/analytics
```

### Architectures Hybrides RÃ©elles

```javascript
// Pattern : Polyglot Persistence

class HybridEcommerceArchitecture {
    constructor() {
        this.postgres = new PostgresClient();  // Transactions critiques
        this.mongodb = new MongoClient();      // Catalogue et performances
        this.redis = new RedisClient();        // Cache et sessions
    }

    // Commande : PostgreSQL (ACID strict)
    async createOrder(orderData) {
        const pgClient = await this.postgres.connect();

        try {
            await pgClient.query('BEGIN');

            // InsÃ©rer la commande (table normalisÃ©e)
            const order = await pgClient.query(`
                INSERT INTO orders (customer_id, total, status)
                VALUES ($1, $2, $3)
                RETURNING order_id
            `, [orderData.customerId, orderData.total, 'pending']);

            // InsÃ©rer les lignes de commande
            for (const item of orderData.items) {
                await pgClient.query(`
                    INSERT INTO order_items (order_id, product_id, quantity, price)
                    VALUES ($1, $2, $3, $4)
                `, [order.rows[0].order_id, item.productId, item.quantity, item.price]);
            }

            // Mettre Ã  jour le stock (avec verrou)
            for (const item of orderData.items) {
                await pgClient.query(`
                    UPDATE inventory
                    SET quantity = quantity - $1
                    WHERE product_id = $2 AND quantity >= $1
                `, [item.quantity, item.productId]);
            }

            await pgClient.query('COMMIT');

            // Publier Ã©vÃ©nement pour mise Ã  jour MongoDB (async)
            this.publishOrderCreated(order.rows[0].order_id);

            return order.rows[0];

        } catch (error) {
            await pgClient.query('ROLLBACK');
            throw error;
        } finally {
            pgClient.release();
        }
    }

    // Catalogue : MongoDB (performance et flexibilitÃ©)
    async searchProducts(query, filters) {
        return await this.mongodb.collection('products').find({
            $text: { $search: query },
            category: { $in: filters.categories },
            price: { $gte: filters.minPrice, $lte: filters.maxPrice },
            inStock: true
        }, {
            readPreference: "secondaryPreferred"  // Distribuer la charge
        }).limit(50).toArray();
    }

    async getProductDetails(productId) {
        // Document riche avec toutes les infos
        return await this.mongodb.collection('products').findOne({
            productId: productId
        }, {
            readPreference: "nearest"
        });

        // Document type :
        // {
        //   productId: "P001",
        //   name: "Laptop XYZ",
        //   description: "...",
        //   specs: { cpu: "i7", ram: "16GB", ... },
        //   images: ["url1", "url2", ...],
        //   reviews: [
        //     { userId: "U001", rating: 5, comment: "Excellent", date: ... }
        //   ],
        //   relatedProducts: ["P002", "P003"],
        //   seo: { title: "...", meta: "..." }
        // }
    }

    // Session : Redis (ultra-rapide)
    async getUserSession(sessionId) {
        const session = await this.redis.get(`session:${sessionId}`);
        return JSON.parse(session);
    }

    // Analytics : MongoDB (agrÃ©gations complexes)
    async getDailySalesReport(date) {
        return await this.mongodb.collection('orders_view').aggregate([
            { $match: { createdAt: { $gte: date, $lt: nextDay(date) } } },
            { $group: {
                _id: "$category",
                totalSales: { $sum: "$total" },
                orderCount: { $sum: 1 },
                avgOrderValue: { $avg: "$total" }
            }},
            { $sort: { totalSales: -1 } }
        ]).toArray();
    }
}

// Avantages de l'approche hybride :
// âœ“ PostgreSQL : ACID strict pour transactions critiques
// âœ“ MongoDB : Performance et scalabilitÃ© pour catalogue
// âœ“ Redis : Ultra-rapide pour sessions/cache
// âœ“ Chaque outil utilisÃ© pour son point fort
//
// InconvÃ©nients :
// âš  ComplexitÃ© opÃ©rationnelle accrue
// âš  CohÃ©rence Ã©ventuelle entre systÃ¨mes
// âš  Plus de code de synchronisation
```

## Conclusion : Choisir en Connaissance de Cause

Les transactions MongoDB et PostgreSQL ne sont pas simplement deux implÃ©mentations diffÃ©rentes du mÃªme concept. Elles reprÃ©sentent deux philosophies architecturales fondamentalement diffÃ©rentes, chacune avec ses forces et ses faiblesses.

### PostgreSQL : La Garantie Relationnelle

**Quand choisir PostgreSQL :**
- IntÃ©gritÃ© des donnÃ©es absolument critique
- Transactions complexes multi-tables courantes
- Reporting et analytics avec JOINs complexes
- SchÃ©ma stable et bien dÃ©fini
- Volumes modÃ©rÃ©s sur serveur puissant
- Expertise SQL dans l'Ã©quipe

**Forces :**
- ACID strict natif, Ã©prouvÃ© depuis 30+ ans
- Niveau Serializable vÃ©ritable
- Contraintes dÃ©claratives complÃ¨tes
- Ã‰cosystÃ¨me mature (outils, extensions)
- Performance excellente sur serveur unique

**Faiblesses :**
- Scaling horizontal difficile
- SchÃ©ma rigide (migrations complexes)
- Verrous peuvent crÃ©er contention
- Transactions distribuÃ©es trÃ¨s coÃ»teuses

### MongoDB : La FlexibilitÃ© DistribuÃ©e

**Quand choisir MongoDB :**
- Scaling horizontal nÃ©cessaire dÃ¨s le dÃ©part
- SchÃ©ma Ã©volutif (produit en dÃ©veloppement rapide)
- DonnÃ©es orientÃ©es document (catalogues, profils, contenus)
- Performance et throughput critiques
- Distribution gÃ©ographique (multi-rÃ©gion)
- DonnÃ©es semi-structurÃ©es ou hÃ©tÃ©rogÃ¨nes

**Forces :**
- Scaling horizontal natif et prouvÃ©
- SchÃ©ma flexible (Ã©volution sans downtime)
- Performance exceptionnelle (opÃ©rations simples)
- Document model riche et naturel
- RÃ©plication et haute disponibilitÃ© natives

**Faiblesses :**
- ACID multi-documents plus rÃ©cent, moins mature
- Pas de vrai Serializable (anomalies possibles)
- Pas de foreign keys natives
- NÃ©cessite discipline de modÃ©lisation
- Transactions distribuÃ©es coÃ»teuses

### Le Pragmatisme Moderne

La question n'est plus "PostgreSQL OU MongoDB" mais "PostgreSQL ET/OU MongoDB" selon les besoins spÃ©cifiques de chaque partie de votre systÃ¨me. L'approche polyglot persistence devient la norme pour les applications modernes complexes.

**Principe directeur :**
Utilisez PostgreSQL lÃ  oÃ¹ la cohÃ©rence est critique et les relations sont naturelles. Utilisez MongoDB lÃ  oÃ¹ la performance et la scalabilitÃ© sont prioritaires et les donnÃ©es sont naturellement documentaires. Et n'ayez pas peur d'utiliser les deux.

---


â­ï¸ [AtomicitÃ© native : Transactions mono-document](/08-transactions/02-transactions-mono-document.md)
