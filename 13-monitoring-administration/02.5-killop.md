ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.5 killOp

## Introduction

La commande `killOp` permet de terminer une opÃ©ration spÃ©cifique en cours d'exÃ©cution sur MongoDB. C'est une commande d'intervention d'urgence, Ã  utiliser avec prÃ©caution et discernement. Pour les SRE et administrateurs systÃ¨me, `killOp` est l'Ã©quivalent de `kill -9` sous Linux : un outil puissant mais potentiellement dangereux qui nÃ©cessite une comprÃ©hension approfondie de ses implications.

âš ï¸ **ATTENTION** : `killOp` est une commande destructive qui peut avoir des consÃ©quences importantes sur l'intÃ©gritÃ© des donnÃ©es, les transactions en cours et la cohÃ©rence du systÃ¨me. Cette section dÃ©taille quand, comment et pourquoi l'utiliser.

## Vue d'ensemble

### CaractÃ©ristiques principales

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        killOp                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Type:        Commande d'intervention                       â”‚
â”‚  Scope:       OpÃ©ration spÃ©cifique (via opid)               â”‚
â”‚  Permission:  killop action (clusterAdmin/admin)            â”‚
â”‚  Impact:      DESTRUCTIF - Termine l'opÃ©ration              â”‚
â”‚  RÃ©versible:  NON - Action irrÃ©versible                     â”‚
â”‚  Urgence:     Dernier recours                               â”‚
â”‚  Risque:      Ã‰LEVÃ‰ - Peut causer des effets secondaires    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Syntaxe

```javascript
// Syntaxe de base
db.killOp(<opid>)

// Via adminCommand
db.adminCommand({
  killOp: 1,
  op: <opid>
})

// Avec commentaire (MongoDB 4.4+)
db.adminCommand({
  killOp: 1,
  op: <opid>,
  comment: "Killing long-running query - Incident #12345"
})

// Sur un cluster shardÃ© (depuis mongos)
db.adminCommand({
  killOp: 1,
  op: "<shard_name>:<opid>"
})
```

### Permissions requises

```javascript
// RÃ´le minimum : clusterAdmin ou hostManager
// Ou rÃ´le personnalisÃ© avec action killop

// VÃ©rifier les permissions
db.runCommand({
  connectionStatus: 1,
  showPrivileges: true
}).authInfo.authenticatedUserPrivileges.forEach(p => {
  if (p.actions.includes("killop")) {
    print("âœ… User has killop permission")
    print(`   Resource: ${JSON.stringify(p.resource)}`)
  }
})

// CrÃ©er un rÃ´le pour killop (si nÃ©cessaire)
db.getSiblingDB("admin").createRole({
  role: "operationKiller",
  privileges: [
    {
      resource: { cluster: true },
      actions: ["killop", "inprog"]
    }
  ],
  roles: []
})
```

---

## Quand utiliser killOp

### Situations lÃ©gitimes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CAS D'USAGE LÃ‰GITIMES POUR killOp              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  âœ… ACCEPTABLE                                              â”‚
â”‚  â€¢ RequÃªte lente bloquant le systÃ¨me (> 10-30 min)          â”‚
â”‚  â€¢ Collection scan massif non intentionnel                  â”‚
â”‚  â€¢ OpÃ©ration mal conÃ§ue consommant toutes les ressources    â”‚
â”‚  â€¢ Transaction zombie (inactive depuis longtemps)           â”‚
â”‚  â€¢ Deadlock dÃ©tectÃ© nÃ©cessitant intervention manuelle       â”‚
â”‚  â€¢ OpÃ©ration lancÃ©e par erreur (mauvais paramÃ¨tres)         â”‚
â”‚  â€¢ Maintenance d'urgence nÃ©cessitant arrÃªt propre           â”‚
â”‚                                                             â”‚
â”‚  âš ï¸ AVEC PRÃ‰CAUTION                                         â”‚
â”‚  â€¢ OpÃ©ration d'Ã©criture longue (risque d'incohÃ©rence)       â”‚
â”‚  â€¢ Transaction multi-documents (rollback)                   â”‚
â”‚  â€¢ Index build (perte de progression)                       â”‚
â”‚  â€¢ OpÃ©ration de rÃ©plication                                 â”‚
â”‚                                                             â”‚
â”‚  âŒ Ã‰VITER                                                  â”‚
â”‚  â€¢ OpÃ©rations de maintenance systÃ¨me                        â”‚
â”‚  â€¢ OpÃ©rations de rÃ©plication critiques                      â”‚
â”‚  â€¢ Checkpoints WiredTiger                                   â”‚
â”‚  â€¢ OpÃ©rations internes MongoDB                              â”‚
â”‚  â€¢ Sans analyse prÃ©alable                                   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CritÃ¨res de dÃ©cision

```javascript
function shouldKillOperation(op) {
  var decision = {
    opid: op.opid,
    recommendation: "ANALYZE",
    reasons: [],
    risks: [],
    alternatives: []
  }

  // CritÃ¨re 1: DurÃ©e d'exÃ©cution
  if (op.secs_running > 1800) {  // > 30 minutes
    decision.reasons.push("Running for " + op.secs_running + " seconds (> 30 min)")
    decision.recommendation = "KILL"
  } else if (op.secs_running > 600) {  // > 10 minutes
    decision.reasons.push("Running for " + op.secs_running + " seconds (> 10 min)")
    if (decision.recommendation === "ANALYZE") {
      decision.recommendation = "CONSIDER"
    }
  }

  // CritÃ¨re 2: Type d'opÃ©ration
  if (op.op === "remove" || op.op === "update") {
    decision.risks.push("Write operation - may cause data inconsistency")
  }

  if (op.transaction) {
    decision.risks.push("Part of transaction - will rollback entire transaction")
  }

  // CritÃ¨re 3: Plan d'exÃ©cution
  if (op.planSummary && op.planSummary.includes("COLLSCAN")) {
    decision.reasons.push("Using collection scan (inefficient)")
    decision.alternatives.push("Create appropriate index to optimize query")
  }

  // CritÃ¨re 4: Lock contention
  if (op.waitingForLock && op.secs_running > 300) {  // > 5 min
    decision.reasons.push("Waiting for lock for " + op.secs_running + " seconds")
    decision.recommendation = "KILL"
    decision.alternatives.push("Identify and kill the blocking operation first")
  }

  // CritÃ¨re 5: Ressources consommÃ©es
  if (op.docsExamined > 10000000) {  // > 10M docs
    decision.reasons.push("Examined " + op.docsExamined + " documents (excessive)")
    if (decision.recommendation === "ANALYZE") {
      decision.recommendation = "CONSIDER"
    }
  }

  // CritÃ¨re 6: Type d'opÃ©ration systÃ¨me
  if (op.desc && (op.desc.includes("repl") || op.desc.includes("system"))) {
    decision.recommendation = "DO_NOT_KILL"
    decision.risks.push("System operation - killing may cause instability")
  }

  // Ajouter des alternatives gÃ©nÃ©rales
  if (decision.recommendation !== "DO_NOT_KILL") {
    decision.alternatives.push("Wait for operation to complete naturally")
    decision.alternatives.push("Optimize query in application code")
    decision.alternatives.push("Add query timeout in application")
  }

  return decision
}

// Utilisation
var op = db.currentOp({ opid: 123456 }).inprog[0]
if (op) {
  var decision = shouldKillOperation(op)
  print(JSON.stringify(decision, null, 2))

  if (decision.recommendation === "KILL") {
    print("\nâš ï¸ Recommendation: KILL this operation")
    print("Reasons:")
    decision.reasons.forEach(r => print(`  â€¢ ${r}`))
    print("\nRisks:")
    decision.risks.forEach(r => print(`  âš ï¸ ${r}`))
    print("\nCommand: db.killOp(" + decision.opid + ")")
  } else if (decision.recommendation === "DO_NOT_KILL") {
    print("\nâŒ Recommendation: DO NOT KILL this operation")
    print("Risks:")
    decision.risks.forEach(r => print(`  âš ï¸ ${r}`))
  }
}
```

---

## Processus de dÃ©cision et documentation

### Checklist prÃ©-killOp

```javascript
function preKillOpChecklist(opid) {
  print("\n" + "â•".repeat(80))
  print("                    PRE-KILLOP CHECKLIST")
  print("â•".repeat(80))
  print(`OpID: ${opid}\n`)

  // 1. RÃ©cupÃ©rer les dÃ©tails de l'opÃ©ration
  var op = db.currentOp({ opid: opid }).inprog[0]

  if (!op) {
    print("âŒ Operation not found - may have already completed")
    return false
  }

  var checklist = []

  // Check 1: Identifier l'opÃ©ration
  checklist.push({
    step: "1. Operation identified",
    status: "âœ…",
    details: {
      type: op.op,
      namespace: op.ns,
      duration: op.secs_running + "s",
      client: op.client,
      user: op.effectiveUsers ? op.effectiveUsers[0].user : "N/A"
    }
  })

  // Check 2: Documenter la commande
  checklist.push({
    step: "2. Document command",
    status: "âœ…",
    details: {
      command: JSON.stringify(op.command).substring(0, 200)
    }
  })

  // Check 3: VÃ©rifier si c'est une opÃ©ration d'Ã©criture
  var isWrite = ["insert", "update", "remove"].includes(op.op)
  checklist.push({
    step: "3. Check if write operation",
    status: isWrite ? "âš ï¸" : "âœ…",
    details: {
      isWrite: isWrite,
      warning: isWrite ? "May cause data inconsistency" : "Read operation - safer to kill"
    }
  })

  // Check 4: VÃ©rifier si partie d'une transaction
  var inTransaction = op.transaction !== undefined
  checklist.push({
    step: "4. Check if in transaction",
    status: inTransaction ? "âš ï¸" : "âœ…",
    details: {
      inTransaction: inTransaction,
      warning: inTransaction ? "Will rollback entire transaction" : "Not in transaction"
    }
  })

  // Check 5: VÃ©rifier les dÃ©pendances (blocking chain)
  var blocking = db.currentOp({
    waitingForLock: true,
    ns: op.ns
  }).inprog.filter(waiting => waiting.opid !== opid)

  checklist.push({
    step: "5. Check for dependent operations",
    status: blocking.length > 0 ? "âš ï¸" : "âœ…",
    details: {
      dependentOps: blocking.length,
      warning: blocking.length > 0 ?
        blocking.length + " operations waiting on this namespace" :
        "No dependent operations"
    }
  })

  // Check 6: Avoir un plan de rollback
  checklist.push({
    step: "6. Rollback plan",
    status: "â“",
    details: {
      question: "What if killing this operation causes issues?",
      considerations: [
        "Can the operation be retried?",
        "Are there backup/restore procedures?",
        "Is there a rollback strategy?"
      ]
    }
  })

  // Check 7: Notification stakeholders
  checklist.push({
    step: "7. Stakeholder notification",
    status: "â“",
    details: {
      question: "Have stakeholders been notified?",
      considerations: [
        "Application team aware?",
        "Business impact assessed?",
        "Incident ticket created?"
      ]
    }
  })

  // Afficher la checklist
  checklist.forEach((check, idx) => {
    print(`${check.status} ${check.step}`)
    if (check.details) {
      Object.entries(check.details).forEach(([key, value]) => {
        if (typeof value === "object") {
          print(`   ${key}:`)
          value.forEach(v => print(`     â€¢ ${v}`))
        } else {
          print(`   ${key}: ${value}`)
        }
      })
    }
    print("")
  })

  // Recommandation finale
  var criticalWarnings = checklist.filter(c => c.status === "âš ï¸").length
  var unknowns = checklist.filter(c => c.status === "â“").length

  print("â•".repeat(80))
  if (criticalWarnings > 2 || unknowns > 0) {
    print("âš ï¸ RECOMMENDATION: Review warnings before proceeding")
    print(`   Critical warnings: ${criticalWarnings}`)
    print(`   Unresolved items: ${unknowns}`)
    return false
  } else {
    print("âœ… READY TO PROCEED with caution")
    print(`   Command: db.killOp(${opid})`)
    return true
  }
}

// Utilisation
var canProceed = preKillOpChecklist(123456)
if (canProceed) {
  // ProcÃ©der avec killOp
  // db.killOp(123456)
}
```

---

## ExÃ©cution de killOp

### Syntaxe dÃ©taillÃ©e

```javascript
// 1. MÃ©thode simple (helper)
db.killOp(123456)

// 2. Via adminCommand avec documentation
db.adminCommand({
  killOp: 1,
  op: 123456,
  comment: "Incident #INC-2025-001: Killing runaway query on users collection"
})

// 3. Sur un cluster shardÃ©
// Format: "shardName:opid"
db.adminCommand({
  killOp: 1,
  op: "shard01:123456"
})

// 4. Avec vÃ©rification du rÃ©sultat
var result = db.adminCommand({
  killOp: 1,
  op: 123456
})

if (result.ok === 1) {
  print("âœ… Kill signal sent successfully")
} else {
  print("âŒ Failed to kill operation")
  print("Error: " + result.errmsg)
}
```

### Fonction wrapper sÃ©curisÃ©e

```javascript
function safeKillOp(opid, reason, ticketNumber) {
  print("\nğŸ”ª Attempting to kill operation...")
  print("â•".repeat(80))

  // 1. VÃ©rifier que l'opÃ©ration existe
  var op = db.currentOp({ opid: opid }).inprog[0]
  if (!op) {
    print("âŒ Operation not found (opid: " + opid + ")")
    return { success: false, error: "Operation not found" }
  }

  // 2. Logger les dÃ©tails avant killOp
  var preKillState = {
    timestamp: new Date(),
    opid: opid,
    operation: {
      type: op.op,
      namespace: op.ns,
      duration: op.secs_running,
      client: op.client,
      user: op.effectiveUsers ? op.effectiveUsers[0].user : "N/A",
      command: op.command,
      planSummary: op.planSummary
    },
    reason: reason,
    ticket: ticketNumber,
    executor: db.runCommand({ connectionStatus: 1 }).authInfo.authenticatedUsers[0]
  }

  print("Operation details:")
  print(`  Type: ${preKillState.operation.type}`)
  print(`  Namespace: ${preKillState.operation.namespace}`)
  print(`  Duration: ${preKillState.operation.duration}s`)
  print(`  Client: ${preKillState.operation.client}`)
  print(`  Reason: ${reason}`)
  print(`  Ticket: ${ticketNumber}`)
  print("")

  // 3. Sauvegarder l'Ã©tat prÃ©-kill
  try {
    db.getSiblingDB("monitoring").killOpLog.insertOne(preKillState)
  } catch (e) {
    print("âš ï¸ Warning: Failed to log pre-kill state: " + e.message)
  }

  // 4. ExÃ©cuter killOp
  print("Sending kill signal...")
  var result = db.adminCommand({
    killOp: 1,
    op: opid,
    comment: `${reason} - Ticket: ${ticketNumber}`
  })

  // 5. VÃ©rifier le rÃ©sultat
  if (result.ok === 1) {
    print("âœ… Kill signal sent successfully")

    // 6. Attendre et vÃ©rifier que l'opÃ©ration est terminÃ©e
    print("Waiting for operation to terminate...")
    sleep(2000)  // 2 secondes

    var stillRunning = db.currentOp({ opid: opid }).inprog[0]
    if (stillRunning) {
      print("âš ï¸ Warning: Operation still running after 2 seconds")
      print("   This is normal for some operations (may take time to rollback)")

      return {
        success: true,
        warning: "Operation still running (may be rolling back)",
        opid: opid
      }
    } else {
      print("âœ… Operation terminated successfully")

      // Logger le succÃ¨s
      try {
        db.getSiblingDB("monitoring").killOpLog.updateOne(
          { "opid": opid, "timestamp": preKillState.timestamp },
          {
            $set: {
              success: true,
              terminatedAt: new Date(),
              duration: (new Date() - preKillState.timestamp) / 1000
            }
          }
        )
      } catch (e) {
        print("âš ï¸ Warning: Failed to update kill log: " + e.message)
      }

      return {
        success: true,
        opid: opid,
        terminatedAt: new Date()
      }
    }
  } else {
    print("âŒ Failed to kill operation")
    print("Error: " + result.errmsg)

    // Logger l'Ã©chec
    try {
      db.getSiblingDB("monitoring").killOpLog.updateOne(
        { "opid": opid, "timestamp": preKillState.timestamp },
        {
          $set: {
            success: false,
            error: result.errmsg,
            attemptedAt: new Date()
          }
        }
      )
    } catch (e) {
      // Ignorer les erreurs de logging
    }

    return {
      success: false,
      error: result.errmsg,
      opid: opid
    }
  }
}

// Utilisation
var result = safeKillOp(
  123456,
  "Runaway query causing system overload",
  "INC-2025-001"
)

print("\n" + "â•".repeat(80))
print("KILL OPERATION RESULT:")
print(JSON.stringify(result, null, 2))
```

---

## ConsÃ©quences et effets secondaires

### Comportement par type d'opÃ©ration

```javascript
var killOpConsequences = {
  "query": {
    risk: "LOW",
    consequences: [
      "Query is interrupted immediately",
      "Cursor is closed",
      "Partial results are discarded",
      "Client receives error"
    ],
    dataIntegrity: "âœ… No impact on data",
    rollback: "N/A - Read operation"
  },

  "insert": {
    risk: "MEDIUM",
    consequences: [
      "Insert may be partially completed",
      "Some documents may be inserted, others not",
      "Client receives error"
    ],
    dataIntegrity: "âš ï¸ May have partial inserts",
    rollback: "âš ï¸ Manual verification needed for batch inserts"
  },

  "update": {
    risk: "MEDIUM-HIGH",
    consequences: [
      "Update may be partially completed",
      "Some documents updated, others not",
      "No automatic rollback for non-transactional updates",
      "Client receives error"
    ],
    dataIntegrity: "âš ï¸ Partial updates possible",
    rollback: "âš ï¸ May need manual correction"
  },

  "remove": {
    risk: "HIGH",
    consequences: [
      "Delete may be partially completed",
      "Some documents deleted, others not",
      "No automatic rollback",
      "Deleted data lost unless in transaction"
    ],
    dataIntegrity: "âš ï¸ Partial deletes possible",
    rollback: "ğŸ”¥ Manual recovery needed (restore from backup)"
  },

  "command": {
    risk: "VARIES",
    consequences: [
      "Depends on the specific command",
      "Index builds: progress lost, must restart",
      "Aggregation: pipeline interrupted",
      "Map-reduce: partial results discarded"
    ],
    dataIntegrity: "âš ï¸ Depends on command",
    rollback: "âš ï¸ Varies by command type"
  },

  "transaction": {
    risk: "LOW",
    consequences: [
      "Entire transaction is rolled back automatically",
      "All operations in transaction are reverted",
      "Atomicity is preserved",
      "Client receives abort error"
    ],
    dataIntegrity: "âœ… ACID guarantees maintained",
    rollback: "âœ… Automatic rollback"
  }
}

function analyzeKillConsequences(op) {
  var opType = op.op
  var inTxn = op.transaction !== undefined

  // Si dans une transaction, utiliser les consÃ©quences de transaction
  var consequences = inTxn ?
    killOpConsequences["transaction"] :
    killOpConsequences[opType] || killOpConsequences["command"]

  print("\nâš ï¸ CONSEQUENCES OF KILLING THIS OPERATION:")
  print("â•".repeat(80))
  print(`Operation Type: ${opType}`)
  print(`In Transaction: ${inTxn ? "YES" : "NO"}`)
  print(`Risk Level: ${consequences.risk}`)
  print("")
  print("Expected consequences:")
  consequences.consequences.forEach(c => {
    print(`  â€¢ ${c}`)
  })
  print("")
  print(`Data Integrity: ${consequences.dataIntegrity}`)
  print(`Rollback: ${consequences.rollback}`)
  print("â•".repeat(80))

  return consequences
}

// Utilisation avant killOp
var op = db.currentOp({ opid: 123456 }).inprog[0]
if (op) {
  var consequences = analyzeKillConsequences(op)

  if (consequences.risk === "HIGH") {
    print("\nğŸ”¥ HIGH RISK - Consider alternatives before proceeding")
  }
}
```

---

## Cas d'usage dÃ©taillÃ©s

### Cas 1: RequÃªte lente bloquant le systÃ¨me

```javascript
// ScÃ©nario: Une requÃªte mal optimisÃ©e consomme toutes les ressources

// 1. Identifier la requÃªte
var slowQueries = db.currentOp({
  active: true,
  secs_running: { $gt: 600 },
  op: "query"
}).inprog

if (slowQueries.length > 0) {
  print(`Found ${slowQueries.length} slow queries\n`)

  slowQueries.forEach((query, idx) => {
    print(`${idx + 1}. OpID: ${query.opid}`)
    print(`   Duration: ${query.secs_running}s`)
    print(`   Namespace: ${query.ns}`)
    print(`   Plan: ${query.planSummary}`)
    print(`   Docs examined: ${query.docsExamined}`)
    print(`   Client: ${query.client}`)

    // DÃ©cision
    if (query.planSummary && query.planSummary.includes("COLLSCAN") &&
        query.docsExamined > 1000000) {
      print(`   âš ï¸ RECOMMENDATION: Kill this query`)
      print(`   Reason: Collection scan examining ${query.docsExamined} documents`)
      print(`   Action: db.killOp(${query.opid})`)
      print(`   Follow-up: Create index to prevent recurrence`)
    }
    print("")
  })
}
```

### Cas 2: Deadlock nÃ©cessitant intervention

```javascript
// ScÃ©nario: Deux opÃ©rations s'attendent mutuellement

function detectAndResolveDeadlock() {
  var waitingOps = db.currentOp({
    waitingForLock: true,
    secs_running: { $gt: 300 }  // > 5 minutes
  }).inprog

  if (waitingOps.length < 2) {
    print("No deadlock detected")
    return
  }

  print(`âš ï¸ Potential deadlock: ${waitingOps.length} operations waiting`)
  print("")

  // Grouper par namespace pour trouver les conflits
  var byNamespace = {}
  waitingOps.forEach(op => {
    if (!byNamespace[op.ns]) {
      byNamespace[op.ns] = []
    }
    byNamespace[op.ns].push(op)
  })

  // Identifier les deadlocks (plusieurs ops waiting sur mÃªme ns)
  Object.entries(byNamespace).forEach(([ns, ops]) => {
    if (ops.length > 1) {
      print(`Deadlock on ${ns}:`)
      ops.forEach(op => {
        print(`  OpID ${op.opid}: ${op.op}, waiting ${op.secs_running}s`)
        print(`    Client: ${op.client}`)
      })

      // Recommandation: tuer l'opÃ©ration la plus rÃ©cente
      var newest = ops.reduce((a, b) =>
        a.secs_running < b.secs_running ? a : b
      )

      print(`  ğŸ’¡ Recommendation: Kill newest operation (OpID ${newest.opid})`)
      print(`     Command: db.killOp(${newest.opid})`)
      print("")
    }
  })
}

detectAndResolveDeadlock()
```

### Cas 3: Transaction zombie (inactive)

```javascript
// ScÃ©nario: Transaction ouverte mais inactive depuis longtemps

function findZombieTransactions() {
  var txns = db.currentOp({
    "transaction": { $exists: true }
  }).inprog

  var zombies = txns.filter(op => {
    if (!op.transaction) return false

    var timeInactive = op.transaction.timeInactiveMicros / 1000000  // En secondes
    var timeActive = op.transaction.timeActiveMicros / 1000000

    // Zombie si inactive > 5 minutes ET active < 10% du temps total
    return timeInactive > 300 &&
           (timeActive / (timeActive + timeInactive)) < 0.1
  })

  if (zombies.length > 0) {
    print(`ğŸ§Ÿ Found ${zombies.length} zombie transactions\n`)

    zombies.forEach(txn => {
      var timeInactive = (txn.transaction.timeInactiveMicros / 1000000).toFixed(0)
      var timeOpen = (txn.transaction.timeOpenMicros / 1000000).toFixed(0)

      print(`OpID: ${txn.opid}`)
      print(`  Client: ${txn.client}`)
      print(`  User: ${txn.effectiveUsers ? txn.effectiveUsers[0].user : "N/A"}`)
      print(`  Time open: ${timeOpen}s`)
      print(`  Time inactive: ${timeInactive}s`)
      print(`  Current operation: ${txn.op} on ${txn.ns}`)
      print(`  âš ï¸ RECOMMENDATION: Kill this zombie transaction`)
      print(`  Command: db.killOp(${txn.opid})`)
      print(`  Impact: Transaction will rollback (ACID guarantees maintained)`)
      print("")
    })

    return zombies
  } else {
    print("âœ… No zombie transactions found")
    return []
  }
}

var zombies = findZombieTransactions()
```

### Cas 4: OpÃ©ration lancÃ©e par erreur

```javascript
// ScÃ©nario: Un dÃ©veloppeur a lancÃ© une opÃ©ration destructive par erreur

function emergencyKill(namespace, opType, reason) {
  print(`ğŸš¨ EMERGENCY KILL on ${namespace}`)
  print(`Looking for ${opType} operations...`)

  var ops = db.currentOp({
    active: true,
    ns: namespace,
    op: opType
  }).inprog

  if (ops.length === 0) {
    print("âœ… No matching operations found")
    return
  }

  print(`âš ï¸ Found ${ops.length} matching operations\n`)

  ops.forEach(op => {
    print(`OpID: ${op.opid}`)
    print(`  Duration: ${op.secs_running}s`)
    print(`  Client: ${op.client}`)
    print(`  Command: ${JSON.stringify(op.command).substring(0, 150)}`)

    // Confirmer avant de tuer
    print(`  Kill this operation? (y/n)`)
    // En production, implÃ©menter confirmation

    var result = safeKillOp(
      op.opid,
      reason,
      "EMERGENCY-" + Date.now()
    )

    if (result.success) {
      print(`  âœ… Operation killed`)
    } else {
      print(`  âŒ Failed to kill: ${result.error}`)
    }
    print("")
  })
}

// Utilisation
// emergencyKill("production.users", "remove", "Accidental delete initiated")
```

---

## Alternatives Ã  killOp

### 1. Attendre la complÃ©tion naturelle

```javascript
function waitForCompletion(opid, maxWaitSeconds = 300) {
  print(`Waiting for operation ${opid} to complete naturally...`)
  print(`Max wait time: ${maxWaitSeconds}s\n`)

  var startTime = Date.now()
  var checkInterval = 10000  // 10 secondes

  var intervalId = setInterval(() => {
    var elapsed = (Date.now() - startTime) / 1000

    var op = db.currentOp({ opid: opid }).inprog[0]

    if (!op) {
      clearInterval(intervalId)
      print(`âœ… Operation completed after ${elapsed.toFixed(0)}s`)
      return true
    }

    print(`[${elapsed.toFixed(0)}s] Still running (${op.secs_running}s total)`)

    if (elapsed > maxWaitSeconds) {
      clearInterval(intervalId)
      print(`âš ï¸ Timeout after ${maxWaitSeconds}s`)
      print(`Recommendation: Consider killOp(${opid})`)
      return false
    }
  }, checkInterval)

  return intervalId
}

// Utilisation
// waitForCompletion(123456, 600)  // Attendre jusqu'Ã  10 minutes
```

### 2. Limite de timeout applicative

```javascript
// Au lieu de killOp, configurer des timeouts dans l'application

// Exemple avec driver Node.js
const options = {
  maxTimeMS: 30000,  // Timeout de 30 secondes
  socketTimeoutMS: 45000
}

// La requÃªte s'arrÃªtera automatiquement aprÃ¨s 30s
collection.find(query, options)

// Exemple avec cursor timeout
const cursor = collection.find(query)
cursor.maxTimeMS(30000)
```

### 3. Optimisation de la requÃªte

```javascript
// Au lieu de tuer, optimiser la requÃªte problÃ©matique

function optimizationSuggestions(op) {
  var suggestions = []

  // Suggestion 1: Index manquant
  if (op.planSummary && op.planSummary.includes("COLLSCAN")) {
    suggestions.push({
      issue: "Collection scan detected",
      solution: "Create index",
      priority: "HIGH",
      command: `db.${op.ns.split('.')[1]}.createIndex({ /* appropriate fields */ })`
    })
  }

  // Suggestion 2: Trop de documents examinÃ©s
  if (op.docsExamined > op.nreturned * 10) {
    suggestions.push({
      issue: `Examined ${op.docsExamined} docs to return ${op.nreturned}`,
      solution: "Add selective index or refine query",
      priority: "MEDIUM"
    })
  }

  // Suggestion 3: Projection manquante
  if (op.command && op.command.find && !op.command.projection) {
    suggestions.push({
      issue: "No projection - retrieving all fields",
      solution: "Add projection to return only needed fields",
      priority: "LOW",
      example: "db.collection.find({...}, { field1: 1, field2: 1 })"
    })
  }

  return suggestions
}

var op = db.currentOp({ opid: 123456 }).inprog[0]
if (op) {
  var suggestions = optimizationSuggestions(op)

  if (suggestions.length > 0) {
    print("\nğŸ’¡ OPTIMIZATION SUGGESTIONS (alternative to killOp):")
    suggestions.forEach((s, idx) => {
      print(`\n${idx + 1}. ${s.issue} [${s.priority}]`)
      print(`   Solution: ${s.solution}`)
      if (s.command) print(`   Command: ${s.command}`)
      if (s.example) print(`   Example: ${s.example}`)
    })
  }
}
```

---

## Monitoring post-killOp

### VÃ©rification aprÃ¨s intervention

```javascript
function postKillOpVerification(opid, namespace) {
  print("\nğŸ“‹ POST-KILLOP VERIFICATION")
  print("â•".repeat(80))

  var checks = []

  // Check 1: OpÃ©ration terminÃ©e
  var stillExists = db.currentOp({ opid: opid }).inprog[0]
  checks.push({
    check: "Operation terminated",
    status: !stillExists ? "âœ… PASS" : "âš ï¸ STILL RUNNING",
    details: !stillExists ? "Operation no longer in currentOp" :
             "Operation still running (may be rolling back)"
  })

  // Check 2: Pas de nouvelles opÃ©rations similaires
  var similar = db.currentOp({
    active: true,
    ns: namespace
  }).inprog.length

  checks.push({
    check: "No new similar operations",
    status: similar === 0 ? "âœ… PASS" : "âš ï¸ WARNING",
    details: similar === 0 ? "No active operations on namespace" :
             `${similar} operations still active on ${namespace}`
  })

  // Check 3: Pas de spike de charge
  var serverStatus = db.serverStatus()
  var activeOps = serverStatus.globalLock.activeClients.total
  var queuedOps = serverStatus.globalLock.currentQueue.total

  checks.push({
    check: "System load normal",
    status: queuedOps < 10 ? "âœ… PASS" : "âš ï¸ WARNING",
    details: `Active clients: ${activeOps}, Queued: ${queuedOps}`
  })

  // Check 4: Logs d'erreurs
  checks.push({
    check: "Check logs for errors",
    status: "âš ï¸ MANUAL",
    details: "Review MongoDB logs for related errors"
  })

  // Check 5: IntÃ©gritÃ© des donnÃ©es (si write operation)
  checks.push({
    check: "Data integrity verification",
    status: "âš ï¸ MANUAL",
    details: "If write operation, verify data consistency in application"
  })

  // Afficher les rÃ©sultats
  checks.forEach(check => {
    print(`${check.status} ${check.check}`)
    print(`   ${check.details}`)
    print("")
  })

  print("â•".repeat(80))

  // Recommandations
  var warnings = checks.filter(c => c.status.includes("WARNING"))
  var manual = checks.filter(c => c.status.includes("MANUAL"))

  if (warnings.length > 0) {
    print("âš ï¸ WARNINGS DETECTED:")
    warnings.forEach(w => {
      print(`  â€¢ ${w.check}: ${w.details}`)
    })
    print("")
  }

  if (manual.length > 0) {
    print("ğŸ“‹ MANUAL VERIFICATION REQUIRED:")
    manual.forEach(m => {
      print(`  â€¢ ${m.check}`)
      print(`    ${m.details}`)
    })
  }

  return checks
}

// Utilisation aprÃ¨s killOp
var verifyChecks = postKillOpVerification(123456, "production.users")
```

---

## Post-mortem et documentation

### Template de rapport d'incident

```javascript
function generateIncidentReport(opid, killReason, ticketNumber) {
  var report = {
    incident: {
      timestamp: new Date(),
      ticketNumber: ticketNumber,
      type: "KILLOP_INTERVENTION",
      severity: "HIGH"
    },

    operation: {
      opid: opid,
      // RÃ©cupÃ©rer depuis killOpLog
      details: db.getSiblingDB("monitoring").killOpLog.findOne({ opid: opid })
    },

    decision: {
      reason: killReason,
      decisionMaker: db.runCommand({ connectionStatus: 1 }).authInfo.authenticatedUsers[0],
      alternativesConsidered: [
        "Wait for natural completion - rejected due to system impact",
        "Query optimization - not feasible during incident",
        "System restart - too disruptive"
      ]
    },

    impact: {
      userImpact: "To be assessed",
      dataImpact: "To be verified",
      systemImpact: "Operation terminated, system stabilized"
    },

    rootCause: {
      immediate: "Query without appropriate index causing full collection scan",
      underlying: "Missing index on frequently queried field",
      contributing: [
        "No query timeout in application",
        "No monitoring alert for slow queries"
      ]
    },

    remediation: {
      immediate: [
        "Killed problematic operation",
        "Verified system stability"
      ],
      shortTerm: [
        "Create missing index",
        "Add query timeout in application",
        "Update monitoring alerts"
      ],
      longTerm: [
        "Implement query review process",
        "Add automated slow query detection",
        "Developer training on query optimization"
      ]
    },

    lessons: [
      "Need better pre-deployment query testing",
      "Monitoring alerts should trigger earlier",
      "Document escalation procedures"
    ],

    verification: {
      dataIntegrity: "PENDING",
      systemStability: "VERIFIED",
      preventionMeasures: "IN_PROGRESS"
    }
  }

  // Sauvegarder le rapport
  db.getSiblingDB("monitoring").incidentReports.insertOne(report)

  print("\n" + "â•".repeat(80))
  print("                    INCIDENT REPORT GENERATED")
  print("â•".repeat(80))
  print(JSON.stringify(report, null, 2))

  return report
}

// GÃ©nÃ©rer le rapport aprÃ¨s rÃ©solution
// generateIncidentReport(123456, "Runaway query causing system overload", "INC-2025-001")
```

---

## SÃ©curitÃ© et permissions

### Audit de killOp

```javascript
// CrÃ©er un systÃ¨me d'audit pour toutes les opÃ©rations killOp

function setupKillOpAudit() {
  // CrÃ©er la collection d'audit si elle n'existe pas
  db.getSiblingDB("monitoring").createCollection("killOpAudit")

  // CrÃ©er un index pour recherches rapides
  db.getSiblingDB("monitoring").killOpAudit.createIndex({ timestamp: -1 })
  db.getSiblingDB("monitoring").killOpAudit.createIndex({ executor: 1 })

  print("âœ… KillOp audit system configured")
}

function auditKillOp(opid, reason, result) {
  var auditRecord = {
    timestamp: new Date(),
    opid: opid,
    reason: reason,
    executor: db.runCommand({ connectionStatus: 1 }).authInfo.authenticatedUsers[0],
    executorIP: db.runCommand({ connectionStatus: 1 }).authInfo.authenticatedUsers[0],
    success: result.success,
    error: result.error || null,
    systemState: {
      activeOps: db.serverStatus().globalLock.activeClients.total,
      queuedOps: db.serverStatus().globalLock.currentQueue.total
    }
  }

  db.getSiblingDB("monitoring").killOpAudit.insertOne(auditRecord)
  return auditRecord
}

// RequÃªtes d'audit
function getKillOpHistory(days = 7) {
  var cutoff = new Date(Date.now() - days * 24 * 3600 * 1000)

  return db.getSiblingDB("monitoring").killOpAudit.find({
    timestamp: { $gte: cutoff }
  }).sort({ timestamp: -1 }).toArray()
}

function getKillOpByUser(username) {
  return db.getSiblingDB("monitoring").killOpAudit.find({
    "executor.user": username
  }).sort({ timestamp: -1 }).toArray()
}
```

---

## RÃ©sumÃ© et bonnes pratiques

### Checklist complÃ¨te killOp

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   KILLOP DECISION TREE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚
â”‚  1. â“ Is the operation causing a CRITICAL incident?
â”‚     â””â”€ NO  â†’ Consider alternatives
â”‚     â””â”€ YES â†’ Continue to step 2
â”‚
â”‚  2. â“ Have you identified the operation with currentOp()?
â”‚     â””â”€ NO  â†’ Run db.currentOp() to identify
â”‚     â””â”€ YES â†’ Continue to step 3
â”‚
â”‚  3. â“ Is it a system/replication operation?
â”‚     â””â”€ YES â†’ âŒ DO NOT KILL - Severe consequences
â”‚     â””â”€ NO  â†’ Continue to step 4
â”‚
â”‚  4. â“ Is it a write operation or in a transaction?
â”‚     â””â”€ YES â†’ âš ï¸ HIGH RISK - Document extensively
â”‚     â””â”€ NO  â†’ Continue to step 5
â”‚
â”‚  5. â“ Have alternatives been considered?
â”‚     â””â”€ NO  â†’ Review: wait, timeout, optimization
â”‚     â””â”€ YES â†’ Continue to step 6
â”‚
â”‚  6. â“ Is there an incident ticket?
â”‚     â””â”€ NO  â†’ Create ticket first
â”‚     â””â”€ YES â†’ Continue to step 7
â”‚
â”‚  7. âœ… Execute killOp with full documentation
â”‚     â€¢ Log operation details
â”‚     â€¢ Execute: db.killOp(opid)
â”‚     â€¢ Verify termination
â”‚     â€¢ Document in incident report
â”‚     â€¢ Implement prevention measures
â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Principes directeurs

```
ğŸ¯ GOLDEN RULES FOR KILLOP:

1. ğŸ“‹ DOCUMENT FIRST
   â€¢ Capture operation details before killing
   â€¢ Create incident ticket
   â€¢ Log decision reasoning

2. âš ï¸ ASSESS RISK
   â€¢ Understand operation type (read vs write)
   â€¢ Check if in transaction
   â€¢ Identify potential data impact

3. ğŸ” VERIFY NECESSITY
   â€¢ Is this truly an emergency?
   â€¢ Have alternatives been exhausted?
   â€¢ What's the business impact of waiting?

4. ğŸ‘¥ COMMUNICATE
   â€¢ Notify stakeholders
   â€¢ Update incident ticket
   â€¢ Coordinate with application team

5. âœ… VERIFY RESULT
   â€¢ Confirm operation terminated
   â€¢ Check system stability
   â€¢ Verify data integrity if write operation

6. ğŸ“ POST-MORTEM
   â€¢ Document what happened
   â€¢ Identify root cause
   â€¢ Implement prevention measures

7. ğŸ›¡ï¸ PREVENT RECURRENCE
   â€¢ Add missing indexes
   â€¢ Implement query timeouts
   â€¢ Update monitoring alerts
   â€¢ Training and documentation
```

### Commandes de rÃ©fÃ©rence rapide

```javascript
// 1. Identifier les opÃ©rations problÃ©matiques
db.currentOp({ active: true, secs_running: { $gt: 300 }})

// 2. Analyser une opÃ©ration spÃ©cifique
db.currentOp({ opid: 123456 })

// 3. ExÃ©cuter killOp avec documentation
db.adminCommand({
  killOp: 1,
  op: 123456,
  comment: "Reason and ticket number"
})

// 4. VÃ©rifier que l'opÃ©ration est terminÃ©e
db.currentOp({ opid: 123456 })

// 5. VÃ©rifier l'Ã©tat du systÃ¨me
db.serverStatus().globalLock

// 6. Consulter l'historique
db.getSiblingDB("monitoring").killOpLog.find().sort({ timestamp: -1 })
```

---

## Conclusion

La commande `killOp` est un outil puissant mais **dangereux** qui doit Ãªtre utilisÃ© en dernier recours :

âœ… **Dernier recours** : Uniquement aprÃ¨s avoir Ã©puisÃ© les alternatives

âœ… **Documentation obligatoire** : Toujours documenter la raison et le contexte

âœ… **Ã‰valuation des risques** : Comprendre les consÃ©quences potentielles

âœ… **VÃ©rification post-intervention** : Confirmer que le systÃ¨me est stable

âœ… **PrÃ©vention** : ImplÃ©menter des mesures pour Ã©viter la rÃ©currence

âš ï¸ **JAMAIS** sans :
- Analyse prÃ©alable avec `currentOp()`
- ComprÃ©hension du type d'opÃ©ration
- Documentation du contexte
- Plan de rollback si nÃ©cessaire
- VÃ©rification post-kill

**Alternatives prÃ©fÃ©rables** :
- Query optimization avec index appropriÃ©s
- Timeouts configurÃ©s dans l'application
- Attendre la complÃ©tion naturelle
- Optimisation du schÃ©ma de donnÃ©es

**Quand killOp est appropriÃ©** :
- OpÃ©ration bloquant tout le systÃ¨me
- Deadlock nÃ©cessitant intervention manuelle
- RequÃªte mal conÃ§ue en production
- Maintenance d'urgence requise

---


â­ï¸ [Profiler de requÃªtes](/13-monitoring-administration/03-profiler-requetes.md)
