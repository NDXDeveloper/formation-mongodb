ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.4 currentOp

## Introduction

La commande `currentOp` fournit un snapshot en temps rÃ©el de toutes les opÃ©rations en cours d'exÃ©cution sur le serveur MongoDB. C'est l'outil indispensable pour le diagnostic immÃ©diat de problÃ¨mes de performance : requÃªtes lentes, contentions de locks, transactions bloquÃ©es, ou charge anormale. Pour les SRE et administrateurs systÃ¨me, `currentOp` est l'Ã©quivalent de `top` ou `ps` sous Linux : la premiÃ¨re commande Ã  exÃ©cuter lors d'un incident de performance.

## Vue d'ensemble

### CaractÃ©ristiques principales

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      currentOp                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Type:        Commande de diagnostic temps rÃ©el             â”‚
â”‚  Scope:       Serveur MongoDB (mongod/mongos)               â”‚
â”‚  Permission:  inprog action (clusterMonitor/admin)          â”‚
â”‚  Impact:      TrÃ¨s lÃ©ger (< 10ms)                           â”‚
â”‚  FrÃ©quence:   Temps rÃ©el / Ã  la demande                     â”‚
â”‚  Taille:      Variable (dÃ©pend des ops en cours)            â”‚
â”‚  CoÃ»t:        Lecture snapshot en mÃ©moire                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Syntaxe et options

```javascript
// Syntaxe de base - uniquement ops actives
db.currentOp()

// Toutes les opÃ©rations (y compris inactives)
db.currentOp(true)

// Ou via adminCommand
db.adminCommand({ currentOp: 1 })

// Avec filtres (syntaxe prÃ©fÃ©rÃ©e)
db.currentOp({
  "active": true,               // Uniquement les ops actives
  "secs_running": { $gt: 5 },   // Plus de 5 secondes
  "ns": /^mydb\./,              // Sur une base spÃ©cifique
  "op": "query"                 // Type d'opÃ©ration
})

// Options avancÃ©es
db.adminCommand({
  currentOp: 1,
  $ownOps: false,        // Toutes les ops, pas seulement celles de l'utilisateur
  $all: true,            // Inclure ops systÃ¨me/internes
  localOps: true         // Ops locales uniquement (pas via mongos)
})

// Via helper avec filtres
db.currentOp({
  "active": true,
  "microsecs_running": { $gt: 100000 }  // > 100ms
})
```

### Filtres courants

```javascript
// Filtres frÃ©quemment utilisÃ©s

// OpÃ©rations lentes (> 10 secondes)
db.currentOp({
  "active": true,
  "secs_running": { $gt: 10 }
})

// Collection scans
db.currentOp({
  "active": true,
  "planSummary": "COLLSCAN"
})

// OpÃ©rations en attente de lock
db.currentOp({
  "waitingForLock": true
})

// OpÃ©rations d'Ã©criture
db.currentOp({
  "active": true,
  "op": { $in: ["insert", "update", "remove"] }
})

// Sur une collection spÃ©cifique
db.currentOp({
  "active": true,
  "ns": "mydb.users"
})

// Transactions en cours
db.currentOp({
  "active": true,
  "transaction": { $exists: true }
})

// Kill en cours
db.currentOp({
  "killPending": true
})
```

---

## Structure du document retournÃ©

```javascript
{
  "inprog": [
    {
      "type": "op",                    // Type: "op", "idleSession", "idleCursor"
      "host": "server01:27017",        // HÃ´te exÃ©cutant l'opÃ©ration
      "desc": "conn123",               // Descripteur de connexion
      "connectionId": 123,             // ID de connexion
      "client": "10.0.1.45:54321",     // Client IP:port
      "clientMetadata": { ... },       // MÃ©tadonnÃ©es du driver client

      // OpÃ©ration
      "opid": 456789,                  // Operation ID (pour killOp)
      "active": true,                  // OpÃ©ration active?
      "currentOpTime": "2025-12-08T15:42:30.123Z",
      "secs_running": 45,              // DurÃ©e en secondes
      "microsecs_running": 45123456,   // DurÃ©e en microsecondes
      "op": "query",                   // Type: query, insert, update, remove, command
      "ns": "mydb.users",              // Namespace (database.collection)
      "command": { ... },              // Commande complÃ¨te

      // Query details
      "planSummary": "IXSCAN { username: 1 }",  // Plan d'exÃ©cution
      "numYields": 234,                // Nombre de yields
      "locks": { ... },                // Locks tenus
      "waitingForLock": false,         // En attente de lock?
      "lockStats": { ... },            // Stats des locks

      // Progression
      "msg": "query",                  // Message de statut
      "progress": {                    // Progression (si applicable)
        "done": 50000,
        "total": 100000
      },

      // Curseur (si query)
      "cursor": {
        "cursorId": 123456789,
        "createdDate": ISODate("..."),
        "lastAccessDate": ISODate("..."),
        "nDocsReturned": 1000,
        "nBatchesReturned": 10
      },

      // Transaction (si applicable)
      "transaction": {
        "parameters": {
          "txnNumber": 1,
          "autocommit": false,
          "readConcern": { "level": "snapshot" }
        },
        "readTimestamp": Timestamp(...),
        "startWallClockTime": ISODate("..."),
        "timeOpenMicros": 123456,
        "timeActiveMicros": 98765,
        "timeInactiveMicros": 24691
      },

      // RÃ©seau
      "networkOp": "query",
      "waitingForFlowControl": false,

      // Utilisateur
      "effectiveUsers": [
        {
          "user": "appuser",
          "db": "admin"
        }
      ],

      // MÃ©triques
      "cpuUsageMicros": 234567,
      "responseLength": 123456,
      "docsExamined": 50000,
      "keysExamined": 50000,
      "nreturned": 1000,
      "ninserted": 0,
      "ndeleted": 0,
      "nMatched": 0,
      "nModified": 0
    }
    // ... autres opÃ©rations
  ],
  "ok": 1
}
```

---

## Section 1 : Analyse des opÃ©rations actives

### Vue d'ensemble rapide

```javascript
function quickSnapshot() {
  var ops = db.currentOp({ active: true })

  var summary = {
    timestamp: new Date(),
    activeOps: ops.inprog.length,
    breakdown: {
      query: 0,
      insert: 0,
      update: 0,
      remove: 0,
      command: 0,
      getmore: 0
    },
    slowOps: 0,
    waitingForLock: 0,
    collectionScans: 0
  }

  ops.inprog.forEach(op => {
    // Compter par type
    if (op.op) {
      summary.breakdown[op.op] = (summary.breakdown[op.op] || 0) + 1
    }

    // OpÃ©rations lentes (> 5s)
    if (op.secs_running > 5) {
      summary.slowOps++
    }

    // En attente de lock
    if (op.waitingForLock) {
      summary.waitingForLock++
    }

    // Collection scans
    if (op.planSummary && op.planSummary.includes("COLLSCAN")) {
      summary.collectionScans++
    }
  })

  return summary
}

var snapshot = quickSnapshot()
print(JSON.stringify(snapshot, null, 2))

// RÃ©sultat exemple :
// {
//   "timestamp": "2025-12-08T15:42:30.123Z",
//   "activeOps": 45,
//   "breakdown": {
//     "query": 32,
//     "insert": 5,
//     "update": 6,
//     "remove": 1,
//     "command": 1
//   },
//   "slowOps": 3,
//   "waitingForLock": 2,
//   "collectionScans": 1
// }
```

### Affichage formatÃ©

```javascript
function displayCurrentOps() {
  var ops = db.currentOp({
    active: true,
    secs_running: { $exists: true }
  })

  // Trier par durÃ©e dÃ©croissante
  var sorted = ops.inprog.sort((a, b) =>
    (b.secs_running || 0) - (a.secs_running || 0)
  )

  print("\n" + "â•".repeat(100))
  print("                           CURRENT OPERATIONS")
  print("â•".repeat(100))
  print(`Updated: ${new Date().toLocaleString()}`)
  print(`Active operations: ${sorted.length}\n`)

  if (sorted.length === 0) {
    print("âœ… No active operations")
    return
  }

  print("OpID".padEnd(10) +
        "Type".padEnd(8) +
        "Duration".padEnd(10) +
        "NS".padEnd(30) +
        "Status")
  print("-".repeat(100))

  sorted.slice(0, 20).forEach(op => {
    var opid = op.opid || "N/A"
    var type = op.op || "N/A"
    var duration = op.secs_running ? op.secs_running + "s" : "N/A"
    var ns = op.ns || "N/A"

    // Indicateurs de statut
    var status = []
    if (op.waitingForLock) status.push("â³LOCK")
    if (op.secs_running > 60) status.push("ğŸ”¥SLOW")
    if (op.planSummary && op.planSummary.includes("COLLSCAN")) status.push("âš ï¸SCAN")
    if (op.killPending) status.push("â˜ ï¸KILL")

    var statusStr = status.length > 0 ? status.join(" ") : "âœ…OK"

    print(opid.toString().padEnd(10) +
          type.padEnd(8) +
          duration.padEnd(10) +
          ns.substring(0, 29).padEnd(30) +
          statusStr)
  })

  print("â•".repeat(100) + "\n")
}

// Utilisation
displayCurrentOps()
```

---

## Section 2 : Identification des requÃªtes lentes

### DÃ©tection et analyse

```javascript
function findSlowQueries(thresholdSeconds = 5) {
  var ops = db.currentOp({
    active: true,
    secs_running: { $gt: thresholdSeconds }
  })

  var slowQueries = []

  ops.inprog.forEach(op => {
    var query = {
      opid: op.opid,
      type: op.op,
      duration: op.secs_running + "s",
      namespace: op.ns,
      client: op.client || "N/A",
      user: op.effectiveUsers ? op.effectiveUsers[0].user : "N/A",

      // DÃ©tails de la requÃªte
      planSummary: op.planSummary || "N/A",
      docsExamined: op.docsExamined || 0,
      keysExamined: op.keysExamined || 0,
      nreturned: op.nreturned || 0,

      // Commande (tronquÃ©e si trop longue)
      command: JSON.stringify(op.command).substring(0, 200),

      // MÃ©triques d'efficacitÃ©
      efficiency: {
        scanRatio: op.keysExamined && op.nreturned ?
          (op.keysExamined / Math.max(op.nreturned, 1)).toFixed(2) : "N/A",
        docsToKeys: op.docsExamined && op.keysExamined ?
          (op.docsExamined / Math.max(op.keysExamined, 1)).toFixed(2) : "N/A"
      },

      // Indicateurs de problÃ¨mes
      issues: []
    }

    // Identifier les problÃ¨mes
    if (op.planSummary && op.planSummary.includes("COLLSCAN")) {
      query.issues.push({
        type: "COLLECTION_SCAN",
        severity: "HIGH",
        description: "Full collection scan - missing index"
      })
    }

    if (op.docsExamined > op.nreturned * 10) {
      query.issues.push({
        type: "INEFFICIENT_SCAN",
        severity: "MEDIUM",
        description: `Examined ${op.docsExamined} docs to return ${op.nreturned}`
      })
    }

    if (op.waitingForLock) {
      query.issues.push({
        type: "LOCK_WAIT",
        severity: "HIGH",
        description: "Waiting for lock"
      })
    }

    if (op.secs_running > 60) {
      query.issues.push({
        type: "VERY_SLOW",
        severity: "CRITICAL",
        description: `Running for ${op.secs_running} seconds`
      })
    }

    slowQueries.push(query)
  })

  // Trier par durÃ©e dÃ©croissante
  slowQueries.sort((a, b) =>
    parseFloat(b.duration) - parseFloat(a.duration)
  )

  return {
    threshold: thresholdSeconds + "s",
    count: slowQueries.length,
    queries: slowQueries
  }
}

// Utilisation
var slowOps = findSlowQueries(5)

if (slowOps.count > 0) {
  print(`\nğŸŒ Found ${slowOps.count} slow queries (> ${slowOps.threshold}):\n`)

  slowOps.queries.forEach((q, idx) => {
    print(`${idx + 1}. OpID: ${q.opid} | ${q.type} on ${q.namespace}`)
    print(`   Duration: ${q.duration} | Client: ${q.client}`)
    print(`   Plan: ${q.planSummary}`)
    print(`   Examined: ${q.docsExamined} docs, ${q.keysExamined} keys â†’ Returned: ${q.nreturned}`)

    if (q.issues.length > 0) {
      print(`   Issues:`)
      q.issues.forEach(issue => {
        var icon = issue.severity === "CRITICAL" ? "ğŸ”¥" :
                   issue.severity === "HIGH" ? "âš ï¸" : "â„¹ï¸"
        print(`     ${icon} [${issue.severity}] ${issue.type}: ${issue.description}`)
      })
    }

    print(`   Command: ${q.command}`)
    print("")
  })

  print(`ğŸ’¡ To kill an operation: db.killOp(<opid>)`)
} else {
  print(`âœ… No slow queries detected (threshold: ${slowOps.threshold})`)
}
```

### Analyse de patterns de requÃªtes

```javascript
function analyzeQueryPatterns() {
  var ops = db.currentOp({ active: true })
  var patterns = {
    byCollection: {},
    byType: {},
    byPlan: {},
    byClient: {}
  }

  ops.inprog.forEach(op => {
    // Par collection
    if (op.ns) {
      patterns.byCollection[op.ns] = (patterns.byCollection[op.ns] || 0) + 1
    }

    // Par type d'opÃ©ration
    if (op.op) {
      patterns.byType[op.op] = (patterns.byType[op.op] || 0) + 1
    }

    // Par plan (IXSCAN vs COLLSCAN)
    if (op.planSummary) {
      var planType = op.planSummary.includes("COLLSCAN") ? "COLLSCAN" : "IXSCAN"
      patterns.byPlan[planType] = (patterns.byPlan[planType] || 0) + 1
    }

    // Par client
    if (op.client) {
      var clientIP = op.client.split(':')[0]
      patterns.byClient[clientIP] = (patterns.byClient[clientIP] || 0) + 1
    }
  })

  // Convertir en arrays triÃ©s
  var result = {
    totalOps: ops.inprog.length,
    topCollections: Object.entries(patterns.byCollection)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([ns, count]) => ({ namespace: ns, operations: count })),

    operationTypes: Object.entries(patterns.byType)
      .sort((a, b) => b[1] - a[1])
      .map(([type, count]) => ({ type: type, count: count })),

    planTypes: patterns.byPlan,

    topClients: Object.entries(patterns.byClient)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([ip, count]) => ({ ip: ip, operations: count })),

    warnings: []
  }

  // Ajouter des warnings
  if (patterns.byPlan.COLLSCAN > 0) {
    result.warnings.push({
      type: "COLLECTION_SCANS",
      count: patterns.byPlan.COLLSCAN,
      message: `${patterns.byPlan.COLLSCAN} operations using collection scans`
    })
  }

  // Client unique avec beaucoup d'opÃ©rations
  var maxClientOps = Math.max(...Object.values(patterns.byClient))
  if (maxClientOps > result.totalOps * 0.5) {
    result.warnings.push({
      type: "CLIENT_CONCENTRATION",
      message: `One client accounts for > 50% of operations`
    })
  }

  return result
}

var patterns = analyzeQueryPatterns()
print(JSON.stringify(patterns, null, 2))
```

---

## Section 3 : DÃ©tection de contentions (locks)

### Analyse des locks

```javascript
function analyzeLockContention() {
  var ops = db.currentOp()

  var analysis = {
    timestamp: new Date(),
    waiting: [],
    holding: [],
    deadlockRisk: []
  }

  ops.inprog.forEach(op => {
    // OpÃ©rations en attente de lock
    if (op.waitingForLock) {
      analysis.waiting.push({
        opid: op.opid,
        type: op.op,
        namespace: op.ns,
        duration: op.secs_running,
        client: op.client,
        locks: op.locks,
        command: JSON.stringify(op.command).substring(0, 100)
      })
    }

    // OpÃ©rations tenant des locks (Ã©critures longues)
    if (op.locks && !op.waitingForLock && op.secs_running > 5) {
      var hasWriteLock = false
      for (var lockType in op.locks) {
        if (op.locks[lockType] === "w" || op.locks[lockType] === "W") {
          hasWriteLock = true
          break
        }
      }

      if (hasWriteLock) {
        analysis.holding.push({
          opid: op.opid,
          type: op.op,
          namespace: op.ns,
          duration: op.secs_running,
          locks: op.locks,
          potentialBlocker: true
        })
      }
    }
  })

  // DÃ©tecter les risques de deadlock (simplifiÃ©)
  // Plusieurs ops en attente sur la mÃªme ressource
  var waitingByNs = {}
  analysis.waiting.forEach(w => {
    if (w.namespace) {
      waitingByNs[w.namespace] = (waitingByNs[w.namespace] || 0) + 1
    }
  })

  Object.entries(waitingByNs).forEach(([ns, count]) => {
    if (count > 1) {
      analysis.deadlockRisk.push({
        namespace: ns,
        waitingCount: count,
        message: `${count} operations waiting on ${ns}`
      })
    }
  })

  return analysis
}

var lockAnalysis = analyzeLockContention()

print(`\nğŸ”’ Lock Contention Analysis`)
print(`â•`.repeat(80))

if (lockAnalysis.waiting.length > 0) {
  print(`\nâ³ ${lockAnalysis.waiting.length} operations waiting for locks:\n`)

  lockAnalysis.waiting.forEach((op, idx) => {
    print(`${idx + 1}. OpID ${op.opid}: ${op.type} on ${op.namespace}`)
    print(`   Waiting for: ${op.duration}s`)
    print(`   Client: ${op.client}`)
    print(`   Locks: ${JSON.stringify(op.locks)}`)
    print("")
  })
} else {
  print(`\nâœ… No operations waiting for locks`)
}

if (lockAnalysis.holding.length > 0) {
  print(`\nğŸ” ${lockAnalysis.holding.length} operations holding locks (potential blockers):\n`)

  lockAnalysis.holding.forEach((op, idx) => {
    print(`${idx + 1}. OpID ${op.opid}: ${op.type} on ${op.namespace}`)
    print(`   Duration: ${op.duration}s`)
    print(`   Locks held: ${JSON.stringify(op.locks)}`)
    print("")
  })
}

if (lockAnalysis.deadlockRisk.length > 0) {
  print(`\nâš ï¸ Potential deadlock risks detected:\n`)

  lockAnalysis.deadlockRisk.forEach(risk => {
    print(`  ${risk.message}`)
  })
}

print(`â•`.repeat(80))
```

### ChaÃ®ne de blocage

```javascript
function findBlockingChain() {
  var ops = db.currentOp()
  var opMap = {}

  // Indexer toutes les opÃ©rations
  ops.inprog.forEach(op => {
    opMap[op.opid] = op
  })

  var chains = []

  // Trouver les opÃ©rations en attente
  ops.inprog.forEach(op => {
    if (op.waitingForLock && op.locks) {
      var chain = {
        waiting: {
          opid: op.opid,
          type: op.op,
          ns: op.ns,
          duration: op.secs_running,
          waitingFor: op.locks
        },
        blockers: []
      }

      // Trouver les blockers potentiels
      // (mÃªme namespace, tenant un write lock)
      ops.inprog.forEach(potential => {
        if (potential.opid !== op.opid &&
            potential.ns === op.ns &&
            !potential.waitingForLock &&
            potential.locks) {

          // VÃ©rifier si tient un write lock
          for (var lockType in potential.locks) {
            if (potential.locks[lockType] === "w" ||
                potential.locks[lockType] === "W") {
              chain.blockers.push({
                opid: potential.opid,
                type: potential.op,
                duration: potential.secs_running,
                locks: potential.locks
              })
              break
            }
          }
        }
      })

      if (chain.blockers.length > 0) {
        chains.push(chain)
      }
    }
  })

  return chains
}

var blockingChains = findBlockingChain()

if (blockingChains.length > 0) {
  print(`\nğŸ”— Blocking chains detected:\n`)

  blockingChains.forEach((chain, idx) => {
    print(`Chain ${idx + 1}:`)
    print(`  Waiting: OpID ${chain.waiting.opid} (${chain.waiting.type} on ${chain.waiting.ns})`)
    print(`           Duration: ${chain.waiting.duration}s`)
    print(`  Blocked by:`)

    chain.blockers.forEach(blocker => {
      print(`    â†’ OpID ${blocker.opid} (${blocker.type}, running ${blocker.duration}s)`)
      print(`      Locks: ${JSON.stringify(blocker.locks)}`)
    })
    print("")
  })

  print(`ğŸ’¡ Consider killing blocking operations: db.killOp(<opid>)`)
}
```

---

## Section 4 : Analyse des transactions

### Transactions actives

```javascript
function analyzeActiveTransactions() {
  var ops = db.currentOp({
    active: true,
    "transaction": { $exists: true }
  })

  var transactions = []

  ops.inprog.forEach(op => {
    var txn = op.transaction
    if (!txn) return

    var timeOpen = txn.timeOpenMicros / 1000000  // En secondes
    var timeActive = txn.timeActiveMicros / 1000000
    var timeInactive = txn.timeInactiveMicros / 1000000

    transactions.push({
      opid: op.opid,
      client: op.client,
      user: op.effectiveUsers ? op.effectiveUsers[0].user : "N/A",
      txnNumber: txn.parameters?.txnNumber,
      autocommit: txn.parameters?.autocommit,
      readConcern: txn.parameters?.readConcern?.level || "N/A",

      timing: {
        totalOpen: timeOpen.toFixed(2) + "s",
        active: timeActive.toFixed(2) + "s",
        inactive: timeInactive.toFixed(2) + "s",
        activePercent: ((timeActive / timeOpen) * 100).toFixed(2) + "%"
      },

      operation: {
        type: op.op,
        namespace: op.ns,
        command: JSON.stringify(op.command).substring(0, 150)
      },

      warnings: []
    })

    // Ajouter des warnings
    if (timeOpen > 60) {
      transactions[transactions.length - 1].warnings.push({
        type: "LONG_TRANSACTION",
        severity: "HIGH",
        message: `Transaction open for ${timeOpen.toFixed(0)} seconds`
      })
    }

    if (timeInactive > 30) {
      transactions[transactions.length - 1].warnings.push({
        type: "IDLE_TRANSACTION",
        severity: "MEDIUM",
        message: `Transaction idle for ${timeInactive.toFixed(0)} seconds`
      })
    }
  })

  // Trier par durÃ©e dÃ©croissante
  transactions.sort((a, b) =>
    parseFloat(b.timing.totalOpen) - parseFloat(a.timing.totalOpen)
  )

  return {
    count: transactions.length,
    transactions: transactions
  }
}

var txnAnalysis = analyzeActiveTransactions()

if (txnAnalysis.count > 0) {
  print(`\nğŸ’³ Active Transactions: ${txnAnalysis.count}\n`)

  txnAnalysis.transactions.forEach((txn, idx) => {
    print(`${idx + 1}. Transaction ${txn.txnNumber}`)
    print(`   OpID: ${txn.opid} | Client: ${txn.client}`)
    print(`   User: ${txn.user} | Read Concern: ${txn.readConcern}`)
    print(`   Timing: Open ${txn.timing.totalOpen}, Active ${txn.timing.active} ` +
          `(${txn.timing.activePercent}), Idle ${txn.timing.inactive}`)
    print(`   Current: ${txn.operation.type} on ${txn.operation.namespace}`)

    if (txn.warnings.length > 0) {
      print(`   Warnings:`)
      txn.warnings.forEach(w => {
        var icon = w.severity === "HIGH" ? "âš ï¸" : "â„¹ï¸"
        print(`     ${icon} [${w.severity}] ${w.type}: ${w.message}`)
      })
    }
    print("")
  })
} else {
  print(`\nâœ… No active transactions`)
}
```

---

## Section 5 : Monitoring par collection

### Charge par collection

```javascript
function analyzeLoadByCollection() {
  var ops = db.currentOp({ active: true })
  var byCollection = {}

  ops.inprog.forEach(op => {
    if (!op.ns) return

    if (!byCollection[op.ns]) {
      byCollection[op.ns] = {
        namespace: op.ns,
        operations: 0,
        reads: 0,
        writes: 0,
        totalDuration: 0,
        slowOps: 0,
        collScans: 0,
        clients: new Set()
      }
    }

    var coll = byCollection[op.ns]
    coll.operations++
    coll.totalDuration += (op.secs_running || 0)

    if (op.op === "query" || op.op === "getmore") {
      coll.reads++
    } else if (["insert", "update", "remove"].includes(op.op)) {
      coll.writes++
    }

    if (op.secs_running > 5) {
      coll.slowOps++
    }

    if (op.planSummary && op.planSummary.includes("COLLSCAN")) {
      coll.collScans++
    }

    if (op.client) {
      coll.clients.add(op.client)
    }
  })

  // Convertir en array et calculer mÃ©triques
  var collections = Object.values(byCollection).map(coll => ({
    namespace: coll.namespace,
    operations: coll.operations,
    reads: coll.reads,
    writes: coll.writes,
    avgDuration: coll.operations > 0 ?
      (coll.totalDuration / coll.operations).toFixed(2) + "s" : "0s",
    slowOps: coll.slowOps,
    collScans: coll.collScans,
    uniqueClients: coll.clients.size,
    hotness: coll.operations * (coll.slowOps + 1)  // Score de "hotness"
  }))

  // Trier par hotness
  collections.sort((a, b) => b.hotness - a.hotness)

  return collections
}

var loadByCollection = analyzeLoadByCollection()

print(`\nğŸ”¥ Load by Collection (hottest first):\n`)
print("Namespace".padEnd(40) + "Ops".padEnd(6) + "R/W".padEnd(8) +
      "Avg".padEnd(8) + "Slow".padEnd(6) + "Scans".padEnd(6) + "Clients")
print("-".repeat(90))

loadByCollection.slice(0, 15).forEach(coll => {
  var icon = coll.slowOps > 0 || coll.collScans > 0 ? "âš ï¸" : "âœ…"
  print(`${icon} ${coll.namespace.padEnd(38)} ` +
        `${coll.operations.toString().padEnd(5)} ` +
        `${(coll.reads + "/" + coll.writes).padEnd(7)} ` +
        `${coll.avgDuration.padEnd(7)} ` +
        `${coll.slowOps.toString().padEnd(5)} ` +
        `${coll.collScans.toString().padEnd(5)} ` +
        `${coll.uniqueClients}`)
})
```

---

## Section 6 : Patterns de problÃ¨mes

### DÃ©tection automatique de patterns

```javascript
function detectProblemPatterns() {
  var ops = db.currentOp()
  var problems = []

  // Pattern 1: Trop d'opÃ©rations actives
  var activeOps = ops.inprog.filter(op => op.active).length
  if (activeOps > 100) {
    problems.push({
      pattern: "HIGH_CONCURRENCY",
      severity: activeOps > 500 ? "CRITICAL" : "HIGH",
      value: activeOps,
      description: `${activeOps} active operations (normal: < 100)`,
      impact: "Server may be overloaded",
      actions: [
        "Check for missing indexes causing slow queries",
        "Verify connection pool configuration",
        "Consider scaling (vertical or horizontal)"
      ]
    })
  }

  // Pattern 2: Beaucoup de collection scans
  var collScans = ops.inprog.filter(op =>
    op.planSummary && op.planSummary.includes("COLLSCAN")
  ).length

  if (collScans > 5) {
    problems.push({
      pattern: "EXCESSIVE_COLLSCANS",
      severity: "HIGH",
      value: collScans,
      description: `${collScans} operations using collection scans`,
      impact: "Poor query performance, high I/O",
      actions: [
        "Identify missing indexes with db.currentOp()",
        "Review query patterns in application",
        "Create appropriate indexes"
      ]
    })
  }

  // Pattern 3: OpÃ©rations trÃ¨s longues
  var verySlowOps = ops.inprog.filter(op => op.secs_running > 120)
  if (verySlowOps.length > 0) {
    problems.push({
      pattern: "VERY_LONG_OPERATIONS",
      severity: "CRITICAL",
      value: verySlowOps.length,
      description: `${verySlowOps.length} operations running > 2 minutes`,
      impact: "May cause timeouts, block other operations",
      actions: [
        "Review operation details with db.currentOp()",
        "Consider killing operations: db.killOp(<opid>)",
        "Optimize queries or split into smaller operations"
      ],
      opids: verySlowOps.map(op => op.opid)
    })
  }

  // Pattern 4: Lock contention
  var waitingOps = ops.inprog.filter(op => op.waitingForLock).length
  if (waitingOps > 10) {
    problems.push({
      pattern: "LOCK_CONTENTION",
      severity: "HIGH",
      value: waitingOps,
      description: `${waitingOps} operations waiting for locks`,
      impact: "Operations queued, increased latency",
      actions: [
        "Identify blocking operations",
        "Consider breaking up large transactions",
        "Review write patterns for optimization"
      ]
    })
  }

  // Pattern 5: Un seul client monopolise les ressources
  var byClient = {}
  ops.inprog.forEach(op => {
    if (op.client) {
      var ip = op.client.split(':')[0]
      byClient[ip] = (byClient[ip] || 0) + 1
    }
  })

  var maxClientOps = Math.max(...Object.values(byClient))
  var totalOps = ops.inprog.length

  if (maxClientOps > totalOps * 0.7 && totalOps > 10) {
    problems.push({
      pattern: "CLIENT_MONOPOLIZATION",
      severity: "MEDIUM",
      value: maxClientOps,
      description: `One client has ${maxClientOps} operations (${(maxClientOps/totalOps*100).toFixed(0)}% of total)`,
      impact: "Resource imbalance, potential DoS",
      actions: [
        "Identify the client: " + Object.entries(byClient).sort((a,b) => b[1] - a[1])[0][0],
        "Review application connection pooling",
        "Check for runaway processes or loops"
      ]
    })
  }

  // Pattern 6: Transactions longues
  var longTxns = ops.inprog.filter(op =>
    op.transaction &&
    op.transaction.timeOpenMicros > 60000000  // > 60s
  ).length

  if (longTxns > 0) {
    problems.push({
      pattern: "LONG_TRANSACTIONS",
      severity: "HIGH",
      value: longTxns,
      description: `${longTxns} transactions open > 60 seconds`,
      impact: "Holds locks, prevents oplog trimming",
      actions: [
        "Review transaction scope in application",
        "Break up large transactions",
        "Set appropriate transaction timeouts"
      ]
    })
  }

  return {
    timestamp: new Date(),
    problemsDetected: problems.length,
    problems: problems,
    overallSeverity: problems.some(p => p.severity === "CRITICAL") ? "CRITICAL" :
                     problems.some(p => p.severity === "HIGH") ? "HIGH" : "MEDIUM"
  }
}

var problemAnalysis = detectProblemPatterns()

if (problemAnalysis.problemsDetected > 0) {
  print(`\nâš ï¸ Problem Patterns Detected: ${problemAnalysis.problemsDetected}`)
  print(`Overall Severity: ${problemAnalysis.overallSeverity}`)
  print(`â•`.repeat(80) + "\n")

  problemAnalysis.problems.forEach((problem, idx) => {
    var icon = problem.severity === "CRITICAL" ? "ğŸ”¥" :
               problem.severity === "HIGH" ? "âš ï¸" : "â„¹ï¸"

    print(`${icon} ${idx + 1}. ${problem.pattern} [${problem.severity}]`)
    print(`   ${problem.description}`)
    print(`   Impact: ${problem.impact}`)
    print(`   Recommended actions:`)
    problem.actions.forEach(action => {
      print(`     â€¢ ${action}`)
    })
    if (problem.opids) {
      print(`   Affected OpIDs: ${problem.opids.join(", ")}`)
    }
    print("")
  })
} else {
  print(`\nâœ… No problem patterns detected`)
}
```

---

## Section 7 : Cas d'usage pratiques

### 1. Incident response dashboard

```javascript
function incidentResponseDashboard() {
  print("\n" + "â•”".repeat(1) + "â•".repeat(98) + "â•—")
  print("â•‘" + " ".repeat(30) + "ğŸš¨ INCIDENT RESPONSE DASHBOARD" + " ".repeat(37) + "â•‘")
  print("â• " + "â•".repeat(98) + "â•£")
  print(`â•‘ Timestamp: ${new Date().toLocaleString()}`.padEnd(99) + "â•‘")
  print("â• " + "â•".repeat(98) + "â•£")

  // Section 1: Overall metrics
  var snapshot = quickSnapshot()
  print("â•‘ OVERALL METRICS".padEnd(99) + "â•‘")
  print(`â•‘   Active operations: ${snapshot.activeOps}`.padEnd(99) + "â•‘")
  print(`â•‘   Slow operations (>5s): ${snapshot.slowOps}`.padEnd(99) + "â•‘")
  print(`â•‘   Waiting for lock: ${snapshot.waitingForLock}`.padEnd(99) + "â•‘")
  print(`â•‘   Collection scans: ${snapshot.collectionScans}`.padEnd(99) + "â•‘")
  print("â• " + "â•".repeat(98) + "â•£")

  // Section 2: Slowest operations
  print("â•‘ TOP 5 SLOWEST OPERATIONS".padEnd(99) + "â•‘")
  var slowOps = findSlowQueries(0).queries.slice(0, 5)
  if (slowOps.length > 0) {
    slowOps.forEach((op, idx) => {
      print(`â•‘ ${idx + 1}. OpID ${op.opid}: ${op.type} on ${op.namespace} (${op.duration})`.padEnd(99) + "â•‘")
      print(`â•‘    Plan: ${op.planSummary}`.substring(0, 98).padEnd(99) + "â•‘")
    })
  } else {
    print("â•‘   No slow operations".padEnd(99) + "â•‘")
  }
  print("â• " + "â•".repeat(98) + "â•£")

  // Section 3: Lock contention
  print("â•‘ LOCK CONTENTION".padEnd(99) + "â•‘")
  var locks = analyzeLockContention()
  print(`â•‘   Operations waiting: ${locks.waiting.length}`.padEnd(99) + "â•‘")
  print(`â•‘   Operations holding locks: ${locks.holding.length}`.padEnd(99) + "â•‘")
  if (locks.deadlockRisk.length > 0) {
    print(`â•‘   âš ï¸ Deadlock risk: ${locks.deadlockRisk.length} cases`.padEnd(99) + "â•‘")
  }
  print("â• " + "â•".repeat(98) + "â•£")

  // Section 4: Problem patterns
  var problems = detectProblemPatterns()
  print(`â•‘ PROBLEMS DETECTED: ${problems.problemsDetected} (Severity: ${problems.overallSeverity})`.padEnd(99) + "â•‘")
  if (problems.problemsDetected > 0) {
    problems.problems.slice(0, 3).forEach(p => {
      print(`â•‘   ${p.pattern}: ${p.description}`.substring(0, 98).padEnd(99) + "â•‘")
    })
  }
  print("â•š" + "â•".repeat(98) + "â•")
}

// ExÃ©cuter le dashboard
incidentResponseDashboard()

// Peut Ãªtre rafraÃ®chi pÃ©riodiquement
// setInterval(incidentResponseDashboard, 5000)  // Toutes les 5 secondes
```

### 2. Surveillance continue

```javascript
// Monitorer en continu et alerter
function continuousMonitoring(intervalSeconds = 10, duration = 300) {
  var startTime = Date.now()
  var alertLog = []

  print(`Starting continuous monitoring for ${duration}s (interval: ${intervalSeconds}s)`)
  print(`Press Ctrl+C to stop\n`)

  var intervalId = setInterval(() => {
    var elapsed = (Date.now() - startTime) / 1000
    if (elapsed >= duration) {
      clearInterval(intervalId)
      print(`\nğŸ“Š Monitoring complete. Alerts: ${alertLog.length}`)
      return
    }

    var snapshot = quickSnapshot()
    var alerts = []

    // DÃ©finir des seuils
    if (snapshot.slowOps > 5) {
      alerts.push(`âš ï¸ ${snapshot.slowOps} slow operations`)
    }
    if (snapshot.waitingForLock > 10) {
      alerts.push(`âš ï¸ ${snapshot.waitingForLock} operations waiting for lock`)
    }
    if (snapshot.collectionScans > 5) {
      alerts.push(`âš ï¸ ${snapshot.collectionScans} collection scans`)
    }
    if (snapshot.activeOps > 100) {
      alerts.push(`âš ï¸ ${snapshot.activeOps} active operations (high load)`)
    }

    if (alerts.length > 0) {
      var timestamp = new Date().toLocaleTimeString()
      print(`[${timestamp}] ALERTS:`)
      alerts.forEach(alert => {
        print(`  ${alert}`)
        alertLog.push({ timestamp: timestamp, alert: alert })
      })
      print("")
    } else {
      print(`[${new Date().toLocaleTimeString()}] âœ… All metrics normal`)
    }

  }, intervalSeconds * 1000)

  return intervalId
}

// Lancer le monitoring
// var monitorId = continuousMonitoring(10, 300)
// Pour arrÃªter: clearInterval(monitorId)
```

### 3. Export pour analyse

```javascript
function exportCurrentOpSnapshot(filename) {
  var ops = db.currentOp()
  var snapshot = {
    timestamp: new Date(),
    host: db.serverStatus().host,
    totalOps: ops.inprog.length,
    operations: ops.inprog.map(op => ({
      opid: op.opid,
      type: op.op,
      ns: op.ns,
      secs_running: op.secs_running,
      microsecs_running: op.microsecs_running,
      client: op.client,
      active: op.active,
      waitingForLock: op.waitingForLock,
      planSummary: op.planSummary,
      docsExamined: op.docsExamined,
      keysExamined: op.keysExamined,
      nreturned: op.nreturned,
      locks: op.locks,
      command: op.command
    }))
  }

  // En production, Ã©crire dans un fichier
  // Dans mongosh, on peut seulement afficher
  print(JSON.stringify(snapshot, null, 2))

  // Pour sauvegarder dans MongoDB pour analyse ultÃ©rieure
  db.getSiblingDB("monitoring").currentOpSnapshots.insertOne(snapshot)

  return snapshot
}

// Utilisation
var snapshot = exportCurrentOpSnapshot("currentop_snapshot.json")
print(`Snapshot saved with ${snapshot.totalOps} operations`)
```

---

## Section 8 : Automatisation et scripts

### Script bash de monitoring

```bash
#!/bin/bash
# monitor_current_ops.sh
# Monitoring continu de currentOp avec alerting

MONGO_HOST="localhost:27017"
MONGO_USER="monitoring_user"
MONGO_PASS="password"
SLOW_THRESHOLD=5
LOCK_THRESHOLD=5
INTERVAL=10

while true; do
  TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

  # Obtenir le snapshot currentOp
  STATS=$(mongosh "$MONGO_HOST" -u "$MONGO_USER" -p "$MONGO_PASS" --quiet --eval "
    var ops = db.currentOp({ active: true });
    var slowOps = ops.inprog.filter(op => op.secs_running > $SLOW_THRESHOLD).length;
    var waitingLock = ops.inprog.filter(op => op.waitingForLock).length;
    var collScans = ops.inprog.filter(op => op.planSummary && op.planSummary.includes('COLLSCAN')).length;

    print(JSON.stringify({
      timestamp: new Date(),
      activeOps: ops.inprog.length,
      slowOps: slowOps,
      waitingLock: waitingLock,
      collScans: collScans
    }));
  ")

  # Parser les rÃ©sultats
  ACTIVE_OPS=$(echo "$STATS" | jq -r '.activeOps')
  SLOW_OPS=$(echo "$STATS" | jq -r '.slowOps')
  WAITING_LOCK=$(echo "$STATS" | jq -r '.waitingLock')
  COLL_SCANS=$(echo "$STATS" | jq -r '.collScans')

  # Logger
  echo "[$TIMESTAMP] Active: $ACTIVE_OPS | Slow: $SLOW_OPS | Lock: $WAITING_LOCK | Scans: $COLL_SCANS" |
    tee -a /var/log/mongodb/currentop_monitor.log

  # Alerter si seuils dÃ©passÃ©s
  if [ "$SLOW_OPS" -gt "$SLOW_THRESHOLD" ]; then
    echo "âš ï¸ ALERT: $SLOW_OPS slow operations detected" |
      tee -a /var/log/mongodb/currentop_alerts.log
    # Envoyer alerte (email, Slack, PagerDuty)
  fi

  if [ "$WAITING_LOCK" -gt "$LOCK_THRESHOLD" ]; then
    echo "âš ï¸ ALERT: $WAITING_LOCK operations waiting for lock" |
      tee -a /var/log/mongodb/currentop_alerts.log
  fi

  # Attendre avant la prochaine itÃ©ration
  sleep $INTERVAL
done
```

### IntÃ©gration Prometheus

```javascript
// Export currentOp metrics pour Prometheus
function exportCurrentOpPrometheus() {
  var ops = db.currentOp({ active: true })
  var timestamp = Date.now()

  var metrics = []
  var labels = `{host="${db.serverStatus().host}"}`

  // Compter par type
  var byType = {}
  var slowOps = 0
  var waitingLock = 0
  var collScans = 0

  ops.inprog.forEach(op => {
    byType[op.op] = (byType[op.op] || 0) + 1

    if (op.secs_running > 5) slowOps++
    if (op.waitingForLock) waitingLock++
    if (op.planSummary && op.planSummary.includes("COLLSCAN")) collScans++
  })

  // MÃ©triques gÃ©nÃ©rales
  metrics.push(`mongodb_current_op_active_total${labels} ${ops.inprog.length} ${timestamp}`)
  metrics.push(`mongodb_current_op_slow_total${labels} ${slowOps} ${timestamp}`)
  metrics.push(`mongodb_current_op_waiting_lock_total${labels} ${waitingLock} ${timestamp}`)
  metrics.push(`mongodb_current_op_collscans_total${labels} ${collScans} ${timestamp}`)

  // Par type d'opÃ©ration
  for (var opType in byType) {
    var typeLabels = `{host="${db.serverStatus().host}",op_type="${opType}"}`
    metrics.push(`mongodb_current_op_by_type${typeLabels} ${byType[opType]} ${timestamp}`)
  }

  return metrics.join("\n")
}

// Utilisation
var promMetrics = exportCurrentOpPrometheus()
print(promMetrics)
```

---

## RÃ©sumÃ©

La commande `currentOp` est l'outil de diagnostic en temps rÃ©el le plus important :

âœ… **Diagnostic immÃ©diat** : Snapshot instantanÃ© des opÃ©rations

âœ… **Identification de problÃ¨mes** : RequÃªtes lentes, locks, transactions

âœ… **Analyse de patterns** : Charge par collection, par client

âœ… **Intervention ciblÃ©e** : OpID pour killOp

âœ… **Monitoring continu** : Base de dashboards temps rÃ©el

âœ… **Incident response** : Premier rÃ©flexe lors de problÃ¨mes

**MÃ©triques critiques** :
- `secs_running` : DurÃ©e d'exÃ©cution
- `planSummary` : Type de scan (IXSCAN vs COLLSCAN)
- `waitingForLock` : Contentions
- `docsExamined` / `nreturned` : EfficacitÃ©
- `locks` : Locks tenus
- `transaction` : Transactions actives

**Filtres essentiels** :
- `{ active: true }` : OpÃ©rations actives
- `{ secs_running: { $gt: 5 }}` : Lentes (> 5s)
- `{ waitingForLock: true }` : En attente de lock
- `{ planSummary: "COLLSCAN" }` : Collection scans
- `{ transaction: { $exists: true }}` : Transactions

**Bonnes pratiques** :
- ExÃ©cuter lors de problÃ¨mes de performance
- Combiner avec `explain()` pour analyse dÃ©taillÃ©e
- Utiliser filtres pour cibler les problÃ¨mes
- Documenter opids avant killOp
- Automatiser le monitoring continu
- CorrÃ©ler avec serverStatus et logs

**Workflow typique** :
1. `db.currentOp()` â†’ Vue d'ensemble
2. Filtrer les opÃ©rations problÃ©matiques
3. Analyser `planSummary` et mÃ©triques
4. VÃ©rifier contentions avec `waitingForLock`
5. DÃ©cider : optimiser, attendre, ou killOp
6. Documenter pour post-mortem

---


â­ï¸ [killOp](/13-monitoring-administration/02.5-killop.md)
