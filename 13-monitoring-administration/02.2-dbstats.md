ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.2.2 dbStats

## Introduction

La commande `dbStats` fournit des statistiques dÃ©taillÃ©es sur une base de donnÃ©es spÃ©cifique : taille des donnÃ©es, nombre de collections, utilisation des index, espace disque allouÃ©, et bien plus. Pour les SRE et administrateurs systÃ¨me, `dbStats` est essentiel pour le suivi de la croissance, la planification de capacitÃ©, l'identification de la fragmentation, et l'audit des ressources par base de donnÃ©es.

Contrairement Ã  `serverStatus` qui donne une vue globale du serveur, `dbStats` permet une analyse granulaire au niveau de chaque base de donnÃ©es.

## Vue d'ensemble

### CaractÃ©ristiques principales

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        dbStats                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Type:        Commande de base de donnÃ©es                   â”‚
â”‚  Scope:       Base de donnÃ©es spÃ©cifique                    â”‚
â”‚  Permission:  read sur la base ciblÃ©e                       â”‚
â”‚  Impact:      LÃ©ger (10-100ms selon taille)                 â”‚
â”‚  FrÃ©quence:   PÃ©riodique (5-15 min)                         â”‚
â”‚  Taille:      ~1-5 KB JSON                                  â”‚
â”‚  CoÃ»t:        Parcours des mÃ©tadonnÃ©es                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Syntaxe et options

```javascript
// Syntaxe de base
db.stats()

// Ou via runCommand
db.runCommand({ dbStats: 1 })

// Avec facteur d'Ã©chelle (bytes, KB, MB, GB)
db.stats(1)           // Bytes (dÃ©faut)
db.stats(1024)        // Kilobytes
db.stats(1024*1024)   // Megabytes
db.stats(1024*1024*1024)  // Gigabytes

// Via runCommand avec scale
db.runCommand({ dbStats: 1, scale: 1024*1024 })  // MB

// Options supplÃ©mentaires
db.runCommand({
  dbStats: 1,
  scale: 1024*1024,
  freeStorage: 1  // Inclure les stats de stockage libre (MongoDB 6.0+)
})
```

### Choix du facteur d'Ã©chelle

```javascript
// Pour bases de petite taille (< 10 GB)
db.stats(1)  // Bytes - plus de prÃ©cision

// Pour bases moyennes (10 GB - 1 TB)
db.stats(1024*1024)  // Megabytes - lisibilitÃ©

// Pour grandes bases (> 1 TB)
db.stats(1024*1024*1024)  // Gigabytes - vue d'ensemble

// Fonction helper pour auto-scaling
function smartStats(dbName) {
  var stats = db.getSiblingDB(dbName).stats(1)
  var dataSize = stats.dataSize

  // Choisir l'Ã©chelle appropriÃ©e
  var scale, unit
  if (dataSize > 1024*1024*1024*1024) {  // > 1 TB
    scale = 1024*1024*1024*1024
    unit = "TB"
  } else if (dataSize > 1024*1024*1024) {  // > 1 GB
    scale = 1024*1024*1024
    unit = "GB"
  } else if (dataSize > 1024*1024) {  // > 1 MB
    scale = 1024*1024
    unit = "MB"
  } else {
    scale = 1024
    unit = "KB"
  }

  var scaledStats = db.getSiblingDB(dbName).stats(scale)
  scaledStats._scale = scale
  scaledStats._unit = unit

  return scaledStats
}

// Utilisation
var stats = smartStats("production")
print(`Database size: ${stats.dataSize} ${stats._unit}`)
```

---

## Structure du document retournÃ©

```javascript
{
  "db": "production",           // Nom de la base de donnÃ©es
  "collections": 24,            // Nombre de collections
  "views": 2,                   // Nombre de vues
  "objects": 45789234,          // Nombre total de documents
  "avgObjSize": 1247.56,        // Taille moyenne d'un document
  "dataSize": 57123456789,      // Taille totale des donnÃ©es (bytes)
  "storageSize": 62345678901,   // Espace disque allouÃ©
  "freeStorageSize": 234567890, // Espace libre (MongoDB 6.0+)
  "indexes": 48,                // Nombre total d'index
  "indexSize": 4567890123,      // Taille totale des index
  "indexFreeStorageSize": 12345678, // Espace libre dans les index
  "totalSize": 66913568024,     // storageSize + indexSize
  "totalFreeStorageSize": 246913568, // Total espace libre
  "scaleFactor": 1,             // Facteur d'Ã©chelle appliquÃ©
  "fsUsedSize": 445678901234,   // Espace utilisÃ© sur le filesystem
  "fsTotalSize": 1099511627776, // Taille totale du filesystem
  "ok": 1
}
```

### Comprendre les mÃ©triques de taille

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HIÃ‰RARCHIE DES TAILLES                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  fsTotalSize (Taille totale du disque)                      â”‚
â”‚  â”œâ”€ fsUsedSize (UtilisÃ© par toutes les donnÃ©es)             â”‚
â”‚  â”‚  â””â”€ totalSize (MongoDB sur cette DB)                     â”‚
â”‚  â”‚     â”œâ”€ storageSize (DonnÃ©es)                             â”‚
â”‚  â”‚     â”‚  â”œâ”€ dataSize (DonnÃ©es utiles)                      â”‚
â”‚  â”‚     â”‚  â””â”€ freeStorageSize (Fragmentation interne)        â”‚
â”‚  â”‚     â””â”€ indexSize (Index)                                 â”‚
â”‚  â”‚        â”œâ”€ (Index data)                                   â”‚
â”‚  â”‚        â””â”€ indexFreeStorageSize (Fragmentation index)     â”‚
â”‚  â””â”€ (Autres fichiers, logs, journal, etc.)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**MÃ©triques clÃ©s** :
- `dataSize` : Taille rÃ©elle des donnÃ©es (sans compression ni fragmentation)
- `storageSize` : Espace disque allouÃ© pour les donnÃ©es (inclut fragmentation)
- `indexSize` : Espace disque allouÃ© pour les index
- `totalSize` : `storageSize + indexSize`

**Ratio important** :
```javascript
fragmentation = storageSize / dataSize
// IdÃ©al : proche de 1.0
// > 1.5 : Fragmentation significative, considÃ©rer compact
```

---

## Section 1 : MÃ©triques de base

### Informations gÃ©nÃ©rales

```javascript
var stats = db.stats(1024*1024)  // En MB

print(`Database: ${stats.db}`)
print(`Collections: ${stats.collections}`)
print(`Views: ${stats.views}`)
print(`Total documents: ${stats.objects.toLocaleString()}`)
print(`Average document size: ${stats.avgObjSize.toFixed(2)} bytes`)

// RÃ©sultat :
// Database: production
// Collections: 24
// Views: 2
// Total documents: 45,789,234
// Average document size: 1247.56 bytes
```

### Calcul de mÃ©triques dÃ©rivÃ©es

```javascript
function analyzeBasicMetrics(stats) {
  return {
    database: stats.db,
    collections: {
      total: stats.collections,
      views: stats.views,
      avgDocsPerCollection: Math.round(stats.objects / stats.collections)
    },
    documents: {
      total: stats.objects,
      avgSize: stats.avgObjSize.toFixed(2) + " bytes",
      avgSizeKB: (stats.avgObjSize / 1024).toFixed(2) + " KB"
    },
    assessment: {
      collectionCount: stats.collections > 100 ?
        "âš ï¸ Many collections - consider schema design" : "âœ… OK",
      avgDocSize: stats.avgObjSize > 16000 ?
        "âš ï¸ Large documents - check for embedded arrays" :
        stats.avgObjSize < 100 ?
        "âš ï¸ Very small documents - storage overhead may be high" :
        "âœ… OK"
    }
  }
}

var basicAnalysis = analyzeBasicMetrics(db.stats())
print(JSON.stringify(basicAnalysis, null, 2))
```

---

## Section 2 : Taille des donnÃ©es et stockage

### Analyse de la taille

```javascript
function analyzeStorageSize(stats) {
  var scaleFactor = stats.scaleFactor || 1
  var unit = scaleFactor === 1 ? "bytes" :
             scaleFactor === 1024 ? "KB" :
             scaleFactor === 1024*1024 ? "MB" : "GB"

  // Calcul du ratio de fragmentation
  var fragmentation = (stats.storageSize / stats.dataSize).toFixed(2)

  // Calcul du ratio index/data
  var indexToDataRatio = (stats.indexSize / stats.dataSize).toFixed(2)

  // Espace libre (si disponible, MongoDB 6.0+)
  var freePercent = stats.freeStorageSize ?
    (stats.freeStorageSize / stats.storageSize * 100).toFixed(2) : "N/A"

  return {
    data: {
      actual: stats.dataSize.toFixed(2) + " " + unit,
      allocated: stats.storageSize.toFixed(2) + " " + unit,
      fragmentation: fragmentation + "x",
      free: stats.freeStorageSize ?
        stats.freeStorageSize.toFixed(2) + " " + unit + " (" + freePercent + "%)" :
        "N/A"
    },
    indexes: {
      size: stats.indexSize.toFixed(2) + " " + unit,
      count: stats.indexes,
      avgSizePerIndex: (stats.indexSize / stats.indexes).toFixed(2) + " " + unit,
      toDataRatio: indexToDataRatio + "x",
      free: stats.indexFreeStorageSize ?
        stats.indexFreeStorageSize.toFixed(2) + " " + unit : "N/A"
    },
    total: {
      size: stats.totalSize.toFixed(2) + " " + unit,
      free: stats.totalFreeStorageSize ?
        stats.totalFreeStorageSize.toFixed(2) + " " + unit : "N/A"
    },
    alerts: {
      fragmentation: parseFloat(fragmentation) > 1.5 ?
        "âš ï¸ High fragmentation - consider compact" : "âœ… OK",
      indexOverhead: parseFloat(indexToDataRatio) > 0.5 ?
        "âš ï¸ Indexes > 50% of data size - audit indexes" : "âœ… OK"
    }
  }
}

var storageAnalysis = analyzeStorageSize(db.stats(1024*1024))
print(JSON.stringify(storageAnalysis, null, 2))

// RÃ©sultat exemple :
// {
//   "data": {
//     "actual": "54495.15 MB",
//     "allocated": "59452.78 MB",
//     "fragmentation": "1.09x",
//     "free": "4957.63 MB (8.34%)"
//   },
//   "indexes": {
//     "size": "4356.78 MB",
//     "count": 48,
//     "avgSizePerIndex": "90.77 MB",
//     "toDataRatio": "0.08x",
//     "free": "123.45 MB"
//   },
//   "total": {
//     "size": "63809.56 MB",
//     "free": "5081.08 MB"
//   },
//   "alerts": {
//     "fragmentation": "âœ… OK",
//     "indexOverhead": "âœ… OK"
//   }
// }
```

### DÃ©tection de fragmentation excessive

```javascript
function checkFragmentation(stats) {
  var fragmentation = stats.storageSize / stats.dataSize

  var result = {
    dataSize: stats.dataSize,
    storageSize: stats.storageSize,
    fragmentationRatio: fragmentation.toFixed(2),
    wastedSpace: (stats.storageSize - stats.dataSize),
    wastedPercent: ((stats.storageSize - stats.dataSize) / stats.storageSize * 100).toFixed(2) + "%"
  }

  // Classification
  if (fragmentation < 1.2) {
    result.level = "LOW"
    result.action = "No action needed"
    result.icon = "âœ…"
  } else if (fragmentation < 1.5) {
    result.level = "MODERATE"
    result.action = "Monitor, consider compact during maintenance window"
    result.icon = "âš ï¸"
  } else if (fragmentation < 2.0) {
    result.level = "HIGH"
    result.action = "Plan compact operation soon"
    result.icon = "ğŸ”¥"
  } else {
    result.level = "SEVERE"
    result.action = "Immediate compact recommended"
    result.icon = "ğŸ’€"
  }

  return result
}

var fragCheck = checkFragmentation(db.stats())
print(`${fragCheck.icon} Fragmentation: ${fragCheck.fragmentationRatio}x (${fragCheck.level})`)
print(`Wasted space: ${(fragCheck.wastedSpace / (1024*1024*1024)).toFixed(2)} GB (${fragCheck.wastedPercent})`)
print(`Action: ${fragCheck.action}`)
```

---

## Section 3 : Analyse des index

### Ratio index/data

```javascript
function analyzeIndexes(stats) {
  var indexToDataRatio = stats.indexSize / stats.dataSize
  var indexCount = stats.indexes
  var avgIndexSize = stats.indexSize / indexCount

  // Estimation du nombre d'index par collection
  var avgIndexPerCollection = (indexCount / stats.collections).toFixed(1)

  return {
    count: {
      total: indexCount,
      perCollection: avgIndexPerCollection
    },
    size: {
      total: (stats.indexSize / (1024*1024*1024)).toFixed(2) + " GB",
      average: (avgIndexSize / (1024*1024)).toFixed(2) + " MB",
      toDataRatio: (indexToDataRatio * 100).toFixed(2) + "%"
    },
    assessment: {
      ratio: indexToDataRatio > 0.5 ?
        "âš ï¸ HIGH - Indexes > 50% of data" :
        indexToDataRatio > 0.3 ?
        "âš ï¸ MODERATE - Indexes 30-50% of data" :
        "âœ… GOOD - Indexes < 30% of data",

      countPerCollection: parseFloat(avgIndexPerCollection) > 10 ?
        "âš ï¸ Many indexes per collection - audit usage" :
        "âœ… OK",

      recommendation: indexToDataRatio > 0.5 ?
        "Audit indexes with db.collection.getIndexes() and $indexStats" :
        "Index count appears reasonable"
    }
  }
}

var indexAnalysis = analyzeIndexes(db.stats())
print(JSON.stringify(indexAnalysis, null, 2))
```

### Comparaison avec les collections

```javascript
// Obtenir les stats dÃ©taillÃ©es des index par collection
function getIndexStatsPerCollection(dbName) {
  var db = db.getSiblingDB(dbName)
  var collections = db.getCollectionNames()
  var results = []

  collections.forEach(collName => {
    var collStats = db[collName].stats()

    if (collStats.ok && collStats.size > 0) {
      var indexRatio = (collStats.totalIndexSize / collStats.size).toFixed(2)

      results.push({
        collection: collName,
        dataSize: collStats.size,
        indexSize: collStats.totalIndexSize,
        indexCount: collStats.nindexes,
        ratio: parseFloat(indexRatio)
      })
    }
  })

  // Trier par ratio dÃ©croissant
  results.sort((a, b) => b.ratio - a.ratio)

  return results
}

// Afficher les collections avec le plus fort ratio index/data
var collIndexStats = getIndexStatsPerCollection("production")
print("Top 5 collections by index/data ratio:")
collIndexStats.slice(0, 5).forEach(c => {
  print(`  ${c.collection}: ${c.ratio}x (${c.indexCount} indexes)`)
})
```

---

## Section 4 : Utilisation du filesystem

### Analyse de l'espace disque

```javascript
function analyzeFilesystem(stats) {
  // Espace utilisÃ© par MongoDB sur le filesystem
  var mongoUsedGB = stats.fsUsedSize / (1024*1024*1024)
  var fsTotalGB = stats.fsTotalSize / (1024*1024*1024)
  var mongoPercent = (stats.fsUsedSize / stats.fsTotalSize * 100).toFixed(2)

  // Espace utilisÃ© par cette base spÃ©cifiquement
  var thisDbGB = stats.totalSize / (1024*1024*1024)
  var dbPercentOfFilesystem = (stats.totalSize / stats.fsTotalSize * 100).toFixed(2)
  var dbPercentOfMongo = (stats.totalSize / stats.fsUsedSize * 100).toFixed(2)

  // Espace libre
  var freeGB = (stats.fsTotalSize - stats.fsUsedSize) / (1024*1024*1024)
  var freePercent = (freeGB / fsTotalGB * 100).toFixed(2)

  return {
    filesystem: {
      total: fsTotalGB.toFixed(2) + " GB",
      used: mongoUsedGB.toFixed(2) + " GB",
      free: freeGB.toFixed(2) + " GB (" + freePercent + "%)"
    },
    database: {
      name: stats.db,
      size: thisDbGB.toFixed(2) + " GB",
      percentOfFilesystem: dbPercentOfFilesystem + "%",
      percentOfMongoDB: dbPercentOfMongo + "%"
    },
    alerts: {
      diskSpace: freePercent < 10 ?
        "ğŸ”¥ CRITICAL - Less than 10% free" :
        freePercent < 20 ?
        "âš ï¸ WARNING - Less than 20% free" :
        "âœ… OK"
    },
    projection: {
      // Estimation simple : combien de fois peut-on encore doubler la DB ?
      doublings: Math.floor(Math.log2(freeGB / thisDbGB)),
      message: freeGB > thisDbGB * 2 ?
        `Can double database size ${Math.floor(freeGB / thisDbGB)} times` :
        "âš ï¸ Limited growth capacity remaining"
    }
  }
}

var fsAnalysis = analyzeFilesystem(db.stats())
print(JSON.stringify(fsAnalysis, null, 2))
```

---

## Section 5 : Comparaison multi-bases

### Analyser toutes les bases de donnÃ©es

```javascript
function getAllDatabaseStats() {
  var dbs = db.adminCommand({ listDatabases: 1 })
  var results = []

  dbs.databases.forEach(dbInfo => {
    // Ignorer les bases systÃ¨me pour l'analyse
    if (dbInfo.name === "admin" || dbInfo.name === "config" || dbInfo.name === "local") {
      return
    }

    try {
      var stats = db.getSiblingDB(dbInfo.name).stats(1024*1024*1024)  // GB

      results.push({
        name: stats.db,
        dataSize: stats.dataSize,
        storageSize: stats.storageSize,
        indexSize: stats.indexSize,
        totalSize: stats.totalSize,
        collections: stats.collections,
        objects: stats.objects,
        fragmentation: (stats.storageSize / stats.dataSize).toFixed(2),
        indexRatio: (stats.indexSize / stats.dataSize).toFixed(2)
      })
    } catch (e) {
      print(`Error getting stats for ${dbInfo.name}: ${e.message}`)
    }
  })

  return results
}

// Obtenir et afficher les stats
var allDbStats = getAllDatabaseStats()

// Trier par taille totale dÃ©croissante
allDbStats.sort((a, b) => b.totalSize - a.totalSize)

print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
print("â•‘           DATABASE SIZE COMPARISON (GB)                        â•‘")
print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
print("â•‘ Database       Data    Storage  Index   Total   Frag   Ratio  â•‘")
print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")

allDbStats.forEach(db => {
  var line = `â•‘ ${db.name.padEnd(12)} ` +
             `${db.dataSize.toFixed(1).padStart(6)} ` +
             `${db.storageSize.toFixed(1).padStart(7)} ` +
             `${db.indexSize.toFixed(1).padStart(6)} ` +
             `${db.totalSize.toFixed(1).padStart(6)} ` +
             `${db.fragmentation.padStart(6)} ` +
             `${db.indexRatio.padStart(6)} â•‘`
  print(line)
})

print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

// RÃ©sumÃ©
var totalData = allDbStats.reduce((sum, db) => sum + db.dataSize, 0)
var totalStorage = allDbStats.reduce((sum, db) => sum + db.storageSize, 0)
var totalIndex = allDbStats.reduce((sum, db) => sum + db.indexSize, 0)

print(`\nTotal across all databases:`)
print(`  Data: ${totalData.toFixed(2)} GB`)
print(`  Storage: ${totalStorage.toFixed(2)} GB`)
print(`  Index: ${totalIndex.toFixed(2)} GB`)
print(`  Grand Total: ${(totalStorage + totalIndex).toFixed(2)} GB`)
```

### Identifier les bases Ã  problÃ¨mes

```javascript
function identifyProblematicDatabases(allDbStats) {
  var issues = []

  allDbStats.forEach(db => {
    var dbIssues = []

    // Fragmentation excessive
    if (parseFloat(db.fragmentation) > 1.5) {
      dbIssues.push({
        type: "fragmentation",
        severity: parseFloat(db.fragmentation) > 2 ? "HIGH" : "MEDIUM",
        value: db.fragmentation,
        message: `Fragmentation ratio: ${db.fragmentation}x`
      })
    }

    // Index overhead Ã©levÃ©
    if (parseFloat(db.indexRatio) > 0.5) {
      dbIssues.push({
        type: "index_overhead",
        severity: parseFloat(db.indexRatio) > 1 ? "HIGH" : "MEDIUM",
        value: db.indexRatio,
        message: `Index/data ratio: ${db.indexRatio}x`
      })
    }

    // Taille excessive (> 100 GB arbitraire)
    if (db.totalSize > 100) {
      dbIssues.push({
        type: "large_size",
        severity: db.totalSize > 500 ? "HIGH" : "MEDIUM",
        value: db.totalSize.toFixed(2) + " GB",
        message: `Large database: ${db.totalSize.toFixed(2)} GB`
      })
    }

    // Beaucoup de collections (> 50)
    if (db.collections > 50) {
      dbIssues.push({
        type: "many_collections",
        severity: db.collections > 100 ? "HIGH" : "MEDIUM",
        value: db.collections,
        message: `Many collections: ${db.collections}`
      })
    }

    if (dbIssues.length > 0) {
      issues.push({
        database: db.name,
        issues: dbIssues
      })
    }
  })

  return issues
}

// Utilisation
var problematicDbs = identifyProblematicDatabases(allDbStats)

if (problematicDbs.length > 0) {
  print("\nâš ï¸  DATABASES REQUIRING ATTENTION:")
  print("=" .repeat(60))

  problematicDbs.forEach(db => {
    print(`\n${db.database}:`)
    db.issues.forEach(issue => {
      var icon = issue.severity === "HIGH" ? "ğŸ”¥" : "âš ï¸"
      print(`  ${icon} [${issue.severity}] ${issue.message}`)
    })
  })
} else {
  print("\nâœ… All databases appear healthy")
}
```

---

## Section 6 : Suivi de la croissance

### Collecter les stats dans le temps

```javascript
// Fonction pour enregistrer les stats pÃ©riodiquement
function recordDatabaseStats(dbName, storageDb = "monitoring") {
  var stats = db.getSiblingDB(dbName).stats()

  var record = {
    timestamp: new Date(),
    database: stats.db,
    dataSize: stats.dataSize,
    storageSize: stats.storageSize,
    indexSize: stats.indexSize,
    totalSize: stats.totalSize,
    collections: stats.collections,
    objects: stats.objects,
    avgObjSize: stats.avgObjSize,
    indexes: stats.indexes
  }

  // Stocker dans une collection de monitoring
  db.getSiblingDB(storageDb).databaseStats.insertOne(record)

  return record
}

// Collecter les stats de toutes les bases
function recordAllDatabaseStats() {
  var dbs = db.adminCommand({ listDatabases: 1 })
  var recorded = []

  dbs.databases.forEach(dbInfo => {
    if (dbInfo.name !== "admin" && dbInfo.name !== "config" &&
        dbInfo.name !== "local" && dbInfo.name !== "monitoring") {
      try {
        var record = recordDatabaseStats(dbInfo.name)
        recorded.push(record.database)
      } catch (e) {
        print(`Error recording stats for ${dbInfo.name}: ${e.message}`)
      }
    }
  })

  print(`Recorded stats for ${recorded.length} databases: ${recorded.join(", ")}`)
  return recorded
}

// ExÃ©cuter pÃ©riodiquement (ex: via cron toutes les heures)
// recordAllDatabaseStats()
```

### Analyser la tendance de croissance

```javascript
function analyzeGrowthTrend(dbName, days = 7) {
  var cutoff = new Date(Date.now() - days * 24 * 3600 * 1000)

  var records = db.getSiblingDB("monitoring").databaseStats.find({
    database: dbName,
    timestamp: { $gte: cutoff }
  }).sort({ timestamp: 1 }).toArray()

  if (records.length < 2) {
    return { error: "Not enough data points" }
  }

  var first = records[0]
  var last = records[records.length - 1]
  var timeDiffDays = (last.timestamp - first.timestamp) / (1000 * 3600 * 24)

  // Calcul de la croissance
  var dataGrowth = last.dataSize - first.dataSize
  var storageGrowth = last.storageSize - first.storageSize
  var indexGrowth = last.indexSize - first.indexSize
  var objectsGrowth = last.objects - first.objects

  // Taux de croissance par jour
  var dataGrowthPerDay = dataGrowth / timeDiffDays
  var objectsGrowthPerDay = objectsGrowth / timeDiffDays

  // Projection (linÃ©aire simple)
  var daysToDouble = dataGrowthPerDay > 0 ?
    (last.dataSize / dataGrowthPerDay).toFixed(0) : Infinity

  return {
    database: dbName,
    period: {
      days: timeDiffDays.toFixed(1),
      from: first.timestamp,
      to: last.timestamp
    },
    growth: {
      data: {
        absolute: (dataGrowth / (1024*1024*1024)).toFixed(2) + " GB",
        percent: ((dataGrowth / first.dataSize) * 100).toFixed(2) + "%",
        perDay: (dataGrowthPerDay / (1024*1024*1024)).toFixed(2) + " GB/day"
      },
      storage: {
        absolute: (storageGrowth / (1024*1024*1024)).toFixed(2) + " GB",
        percent: ((storageGrowth / first.storageSize) * 100).toFixed(2) + "%"
      },
      index: {
        absolute: (indexGrowth / (1024*1024*1024)).toFixed(2) + " GB",
        percent: ((indexGrowth / first.indexSize) * 100).toFixed(2) + "%"
      },
      documents: {
        absolute: objectsGrowth.toLocaleString(),
        percent: ((objectsGrowth / first.objects) * 100).toFixed(2) + "%",
        perDay: Math.round(objectsGrowthPerDay).toLocaleString() + " docs/day"
      }
    },
    projection: {
      daysToDouble: daysToDouble !== Infinity ? daysToDouble + " days" : "N/A (no growth)",
      in30Days: {
        data: ((last.dataSize + dataGrowthPerDay * 30) / (1024*1024*1024)).toFixed(2) + " GB",
        objects: (last.objects + objectsGrowthPerDay * 30).toLocaleString()
      },
      in90Days: {
        data: ((last.dataSize + dataGrowthPerDay * 90) / (1024*1024*1024)).toFixed(2) + " GB",
        objects: (last.objects + objectsGrowthPerDay * 90).toLocaleString()
      }
    },
    alerts: {
      rapidGrowth: (dataGrowth / first.dataSize) > 0.5 ?
        "âš ï¸ Growing > 50% in " + timeDiffDays.toFixed(0) + " days" : "âœ… OK",
      capacityPlanning: daysToDouble < 90 ?
        "âš ï¸ Will double in less than 90 days" : "âœ… OK"
    }
  }
}

// Utilisation
var growthAnalysis = analyzeGrowthTrend("production", 30)
print(JSON.stringify(growthAnalysis, null, 2))
```

### Visualisation de la croissance

```javascript
// GÃ©nÃ©rer un graphique texte de la croissance
function visualizeGrowth(dbName, days = 30) {
  var cutoff = new Date(Date.now() - days * 24 * 3600 * 1000)

  var records = db.getSiblingDB("monitoring").databaseStats.find({
    database: dbName,
    timestamp: { $gte: cutoff }
  }).sort({ timestamp: 1 }).toArray()

  if (records.length < 2) {
    print("Not enough data points")
    return
  }

  // Normaliser les valeurs pour affichage (0-50 caractÃ¨res)
  var maxSize = Math.max(...records.map(r => r.dataSize))
  var minSize = Math.min(...records.map(r => r.dataSize))
  var range = maxSize - minSize

  print(`\nDatabase Growth: ${dbName}`)
  print(`Period: ${records[0].timestamp.toLocaleDateString()} - ${records[records.length-1].timestamp.toLocaleDateString()}`)
  print("-".repeat(70))

  records.forEach(record => {
    var date = record.timestamp.toLocaleDateString()
    var sizeGB = (record.dataSize / (1024*1024*1024)).toFixed(2)
    var normalized = range > 0 ? Math.round((record.dataSize - minSize) / range * 50) : 25
    var bar = "â–ˆ".repeat(normalized) + "â–‘".repeat(50 - normalized)

    print(`${date.padEnd(12)} ${bar} ${sizeGB} GB`)
  })

  print("-".repeat(70))

  // Statistiques de croissance
  var first = records[0]
  var last = records[records.length - 1]
  var growth = ((last.dataSize - first.dataSize) / first.dataSize * 100).toFixed(2)

  print(`Growth: ${growth}% over ${days} days`)
}

// Utilisation
visualizeGrowth("production", 30)
```

---

## Section 7 : Alerting et seuils

### DÃ©finir des seuils par mÃ©trique

```javascript
var thresholds = {
  fragmentation: {
    warning: 1.3,
    critical: 1.8
  },
  indexRatio: {
    warning: 0.3,
    critical: 0.5
  },
  diskUsage: {
    warning: 0.8,  // 80% du filesystem
    critical: 0.9   // 90% du filesystem
  },
  growthRate: {
    warning: 0.1,  // 10% par semaine
    critical: 0.3   // 30% par semaine
  }
}

function checkThresholds(stats, thresholds) {
  var alerts = []

  // Check fragmentation
  var fragmentation = stats.storageSize / stats.dataSize
  if (fragmentation > thresholds.fragmentation.critical) {
    alerts.push({
      severity: "CRITICAL",
      metric: "fragmentation",
      value: fragmentation.toFixed(2),
      threshold: thresholds.fragmentation.critical,
      message: `Fragmentation ${fragmentation.toFixed(2)}x exceeds critical threshold`,
      action: "Run compact immediately during maintenance window"
    })
  } else if (fragmentation > thresholds.fragmentation.warning) {
    alerts.push({
      severity: "WARNING",
      metric: "fragmentation",
      value: fragmentation.toFixed(2),
      threshold: thresholds.fragmentation.warning,
      message: `Fragmentation ${fragmentation.toFixed(2)}x exceeds warning threshold`,
      action: "Schedule compact operation"
    })
  }

  // Check index ratio
  var indexRatio = stats.indexSize / stats.dataSize
  if (indexRatio > thresholds.indexRatio.critical) {
    alerts.push({
      severity: "CRITICAL",
      metric: "indexRatio",
      value: indexRatio.toFixed(2),
      threshold: thresholds.indexRatio.critical,
      message: `Index/data ratio ${indexRatio.toFixed(2)}x is very high`,
      action: "Audit indexes with $indexStats, remove unused indexes"
    })
  } else if (indexRatio > thresholds.indexRatio.warning) {
    alerts.push({
      severity: "WARNING",
      metric: "indexRatio",
      value: indexRatio.toFixed(2),
      threshold: thresholds.indexRatio.warning,
      message: `Index/data ratio ${indexRatio.toFixed(2)}x is elevated`,
      action: "Review index usage statistics"
    })
  }

  // Check disk usage
  var diskUsage = stats.fsUsedSize / stats.fsTotalSize
  if (diskUsage > thresholds.diskUsage.critical) {
    alerts.push({
      severity: "CRITICAL",
      metric: "diskUsage",
      value: (diskUsage * 100).toFixed(2) + "%",
      threshold: (thresholds.diskUsage.critical * 100) + "%",
      message: `Disk usage ${(diskUsage * 100).toFixed(2)}% is critical`,
      action: "Add storage immediately or archive old data"
    })
  } else if (diskUsage > thresholds.diskUsage.warning) {
    alerts.push({
      severity: "WARNING",
      metric: "diskUsage",
      value: (diskUsage * 100).toFixed(2) + "%",
      threshold: (thresholds.diskUsage.warning * 100) + "%",
      message: `Disk usage ${(diskUsage * 100).toFixed(2)}% is high`,
      action: "Plan for storage expansion"
    })
  }

  return {
    database: stats.db,
    timestamp: new Date(),
    alertCount: alerts.length,
    alerts: alerts,
    status: alerts.some(a => a.severity === "CRITICAL") ? "CRITICAL" :
            alerts.some(a => a.severity === "WARNING") ? "WARNING" : "OK"
  }
}

// Utilisation
var alertReport = checkThresholds(db.stats(), thresholds)

if (alertReport.status !== "OK") {
  print(`\nâš ï¸  ALERT REPORT for ${alertReport.database}`)
  print(`Status: ${alertReport.status}`)
  print(`Alerts: ${alertReport.alertCount}`)
  print("=" .repeat(70))

  alertReport.alerts.forEach(alert => {
    var icon = alert.severity === "CRITICAL" ? "ğŸ”¥" : "âš ï¸"
    print(`\n${icon} [${alert.severity}] ${alert.metric}`)
    print(`   Value: ${alert.value} (threshold: ${alert.threshold})`)
    print(`   ${alert.message}`)
    print(`   Action: ${alert.action}`)
  })
} else {
  print(`âœ… Database ${alertReport.database} is healthy`)
}
```

---

## Section 8 : Cas d'usage pratiques

### 1. Audit de capacitÃ© mensuel

```javascript
function monthlyCapacityAudit() {
  var report = {
    timestamp: new Date(),
    databases: [],
    summary: {}
  }

  var dbs = db.adminCommand({ listDatabases: 1 })

  dbs.databases.forEach(dbInfo => {
    if (["admin", "config", "local", "monitoring"].includes(dbInfo.name)) return

    var stats = db.getSiblingDB(dbInfo.name).stats(1024*1024*1024)  // GB

    var dbReport = {
      name: stats.db,
      size: {
        data: stats.dataSize.toFixed(2),
        storage: stats.storageSize.toFixed(2),
        index: stats.indexSize.toFixed(2),
        total: stats.totalSize.toFixed(2)
      },
      metrics: {
        collections: stats.collections,
        documents: stats.objects,
        indexes: stats.indexes,
        fragmentation: (stats.storageSize / stats.dataSize).toFixed(2),
        indexRatio: (stats.indexSize / stats.dataSize).toFixed(2)
      },
      filesystem: {
        used: (stats.fsUsedSize / (1024*1024*1024)).toFixed(2),
        total: (stats.fsTotalSize / (1024*1024*1024)).toFixed(2),
        free: ((stats.fsTotalSize - stats.fsUsedSize) / (1024*1024*1024)).toFixed(2),
        percentUsed: ((stats.fsUsedSize / stats.fsTotalSize) * 100).toFixed(2)
      }
    }

    report.databases.push(dbReport)
  })

  // Calcul du rÃ©sumÃ© global
  report.summary = {
    totalDatabases: report.databases.length,
    totalDataGB: report.databases.reduce((sum, db) => sum + parseFloat(db.size.data), 0).toFixed(2),
    totalStorageGB: report.databases.reduce((sum, db) => sum + parseFloat(db.size.total), 0).toFixed(2),
    avgFragmentation: (report.databases.reduce((sum, db) =>
      sum + parseFloat(db.metrics.fragmentation), 0) / report.databases.length).toFixed(2),
    highFragmentationCount: report.databases.filter(db =>
      parseFloat(db.metrics.fragmentation) > 1.5).length,
    highIndexRatioCount: report.databases.filter(db =>
      parseFloat(db.metrics.indexRatio) > 0.5).length
  }

  return report
}

// GÃ©nÃ©rer et afficher le rapport
var audit = monthlyCapacityAudit()
print(JSON.stringify(audit, null, 2))

// Sauvegarder pour historique
db.getSiblingDB("monitoring").capacityAudits.insertOne(audit)
```

### 2. Identification des candidats au compact

```javascript
function findCompactCandidates(fragmentationThreshold = 1.5) {
  var dbs = db.adminCommand({ listDatabases: 1 })
  var candidates = []

  dbs.databases.forEach(dbInfo => {
    if (["admin", "config", "local"].includes(dbInfo.name)) return

    try {
      var dbObj = db.getSiblingDB(dbInfo.name)
      var stats = dbObj.stats()
      var collections = dbObj.getCollectionNames()

      collections.forEach(collName => {
        var collStats = dbObj[collName].stats()

        if (!collStats.ok) return

        var fragmentation = collStats.storageSize / collStats.size

        if (fragmentation > fragmentationThreshold) {
          var wastedMB = (collStats.storageSize - collStats.size) / (1024*1024)

          candidates.push({
            database: dbInfo.name,
            collection: collName,
            dataSize: (collStats.size / (1024*1024)).toFixed(2) + " MB",
            storageSize: (collStats.storageSize / (1024*1024)).toFixed(2) + " MB",
            fragmentation: fragmentation.toFixed(2),
            wastedSpace: wastedMB.toFixed(2) + " MB",
            priority: fragmentation > 2 ? "HIGH" : "MEDIUM"
          })
        }
      })
    } catch (e) {
      print(`Error analyzing ${dbInfo.name}: ${e.message}`)
    }
  })

  // Trier par espace gaspillÃ© (impact le plus fort en premier)
  candidates.sort((a, b) =>
    parseFloat(b.wastedSpace) - parseFloat(a.wastedSpace))

  return candidates
}

// Utilisation
var compactCandidates = findCompactCandidates(1.5)

if (compactCandidates.length > 0) {
  print(`\nFound ${compactCandidates.length} collections requiring compact:\n`)
  print("Priority | Database.Collection | Fragmentation | Wasted Space")
  print("-".repeat(70))

  compactCandidates.slice(0, 10).forEach(c => {
    var icon = c.priority === "HIGH" ? "ğŸ”¥" : "âš ï¸"
    print(`${icon} ${c.priority.padEnd(6)} | ${(c.database + "." + c.collection).padEnd(35)} | ` +
          `${c.fragmentation.padStart(6)}x | ${c.wastedSpace.padStart(12)}`)
  })

  var totalWasted = compactCandidates.reduce((sum, c) =>
    sum + parseFloat(c.wastedSpace), 0)
  print("-".repeat(70))
  print(`Total wasted space: ${totalWasted.toFixed(2)} MB`)
} else {
  print("âœ… No collections require compact")
}
```

### 3. Comparaison avant/aprÃ¨s maintenance

```javascript
function compareBeforeAfter(dbName, beforeStats, afterStats) {
  var comparison = {
    database: dbName,
    timestamp: new Date(),
    before: {
      dataSize: (beforeStats.dataSize / (1024*1024*1024)).toFixed(2) + " GB",
      storageSize: (beforeStats.storageSize / (1024*1024*1024)).toFixed(2) + " GB",
      indexSize: (beforeStats.indexSize / (1024*1024*1024)).toFixed(2) + " GB",
      totalSize: (beforeStats.totalSize / (1024*1024*1024)).toFixed(2) + " GB",
      fragmentation: (beforeStats.storageSize / beforeStats.dataSize).toFixed(2)
    },
    after: {
      dataSize: (afterStats.dataSize / (1024*1024*1024)).toFixed(2) + " GB",
      storageSize: (afterStats.storageSize / (1024*1024*1024)).toFixed(2) + " GB",
      indexSize: (afterStats.indexSize / (1024*1024*1024)).toFixed(2) + " GB",
      totalSize: (afterStats.totalSize / (1024*1024*1024)).toFixed(2) + " GB",
      fragmentation: (afterStats.storageSize / afterStats.dataSize).toFixed(2)
    }
  }

  // Calcul des gains
  var storageSaved = beforeStats.storageSize - afterStats.storageSize
  var totalSaved = beforeStats.totalSize - afterStats.totalSize
  var fragmentationReduction = (beforeStats.storageSize / beforeStats.dataSize) -
                                (afterStats.storageSize / afterStats.dataSize)

  comparison.improvements = {
    storageSaved: (storageSaved / (1024*1024*1024)).toFixed(2) + " GB",
    storageSavedPercent: ((storageSaved / beforeStats.storageSize) * 100).toFixed(2) + "%",
    totalSaved: (totalSaved / (1024*1024*1024)).toFixed(2) + " GB",
    fragmentationReduction: fragmentationReduction.toFixed(2),
    success: storageSaved > 0 && fragmentationReduction > 0
  }

  return comparison
}

// Exemple d'utilisation
// var beforeStats = db.stats()
// ... exÃ©cuter compact ...
// var afterStats = db.stats()
// var comparison = compareBeforeAfter("production", beforeStats, afterStats)
// print(JSON.stringify(comparison, null, 2))
```

---

## Automatisation et intÃ©gration

### Script de monitoring pÃ©riodique

```bash
#!/bin/bash
# monitor_database_stats.sh
# Collecte pÃ©riodique des dbStats pour toutes les bases

MONGO_HOST="localhost:27017"
MONGO_USER="monitoring_user"
MONGO_PASS="password"
ALERT_THRESHOLD_FRAG=1.5
ALERT_THRESHOLD_DISK=80

# Fonction pour obtenir les stats de toutes les bases
get_all_stats() {
  mongosh "$MONGO_HOST" -u "$MONGO_USER" -p "$MONGO_PASS" --quiet --eval "
    var dbs = db.adminCommand({ listDatabases: 1 }).databases;
    var results = [];

    dbs.forEach(dbInfo => {
      if (['admin', 'config', 'local', 'monitoring'].includes(dbInfo.name)) return;

      var stats = db.getSiblingDB(dbInfo.name).stats(1024*1024);
      results.push({
        name: stats.db,
        dataSize: stats.dataSize,
        storageSize: stats.storageSize,
        totalSize: stats.totalSize,
        fragmentation: (stats.storageSize / stats.dataSize).toFixed(2),
        diskUsage: (stats.fsUsedSize / stats.fsTotalSize * 100).toFixed(2)
      });
    });

    print(JSON.stringify(results));
  "
}

# Obtenir les stats
STATS=$(get_all_stats)

# Analyser et alerter
echo "$STATS" | jq -r '.[] |
  select((.fragmentation | tonumber) > '"$ALERT_THRESHOLD_FRAG"' or
         (.diskUsage | tonumber) > '"$ALERT_THRESHOLD_DISK"') |
  "âš ï¸  ALERT: \(.name) - Fragmentation: \(.fragmentation)x, Disk: \(.diskUsage)%"'

# Enregistrer dans un fichier de log
echo "$(date): $STATS" >> /var/log/mongodb/dbstats.log

# Envoyer les mÃ©triques Ã  Prometheus (pushgateway)
# curl -X POST http://pushgateway:9091/metrics/job/mongodb_dbstats ...
```

---

## RÃ©sumÃ©

La commande `dbStats` est essentielle pour :

âœ… **Suivi de la croissance** : Planification de capacitÃ© et projections

âœ… **DÃ©tection de fragmentation** : Identification des besoins de compact

âœ… **Audit des index** : Ratio index/data, overhead

âœ… **Gestion du stockage** : Utilisation filesystem, espace disponible

âœ… **Comparaison multi-bases** : Priorisation des optimisations

âœ… **Monitoring historique** : Tendances et alerting

**MÃ©triques critiques** :
- `dataSize` / `storageSize` : Ratio de fragmentation
- `indexSize` / `dataSize` : Overhead des index
- `totalSize` : Taille totale (donnÃ©es + index)
- `fsUsedSize` / `fsTotalSize` : Utilisation du disque

**Bonnes pratiques** :
- Collecter pÃ©riodiquement (toutes les 5-15 minutes)
- Historiser pour analyse de tendance
- DÃ©finir des seuils d'alerte adaptÃ©s Ã  votre contexte
- Combiner avec `collStats` pour analyse dÃ©taillÃ©e
- Automatiser la dÃ©tection de fragmentation
- Planifier les opÃ©rations de compact selon les mÃ©triques

**Alertes recommandÃ©es** :
- Fragmentation > 1.5x â†’ Planifier compact
- Index/data ratio > 0.5 â†’ Auditer les index
- Disk usage > 85% â†’ Expansion urgente
- Croissance > 50%/mois â†’ RÃ©viser capacitÃ©

---


â­ï¸ [collStats](/13-monitoring-administration/02.3-collstats.md)
