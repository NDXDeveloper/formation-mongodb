üîù Retour au [Sommaire](/SOMMAIRE.md)

# 9.3.5 Delayed

## Introduction

Les **Delayed members** (membres retard√©s) sont des Secondaries sp√©cialis√©s qui maintiennent un √©tat historique des donn√©es en appliquant les op√©rations de l'Oplog avec un d√©lai temporel configurable. Cette fonctionnalit√© unique permet de cr√©er une "machine √† remonter le temps" au sein du Replica Set, offrant une protection contre les erreurs humaines, les suppressions accidentelles, et les corruptions de donn√©es qui se propagent via la r√©plication.

Un Delayed member avec un d√©lai de 4 heures, par exemple, refl√®te l'√©tat exact du dataset tel qu'il √©tait il y a 4 heures, offrant ainsi une fen√™tre de r√©cup√©ration pour corriger les erreurs avant qu'elles n'atteignent ce membre.

Cette section explore en profondeur le fonctionnement des Delayed members, leurs cas d'usage, leur configuration optimale, et les strat√©gies de r√©cup√©ration qu'ils permettent.

## D√©finition et Caract√©ristiques

### Propri√©t√©s Fondamentales

Un Delayed member poss√®de les caract√©ristiques suivantes :

**Ce qu'un Delayed Member FAIT** :
- R√©plique toutes les op√©rations depuis le Primary (ou une source via chaining)
- Applique les op√©rations de l'Oplog avec un d√©lai temporel fixe
- Maintient un √©tat historique coh√©rent des donn√©es
- Prot√®ge contre les erreurs humaines dans la fen√™tre de d√©lai
- Peut voter dans les √©lections (bien que g√©n√©ralement `votes: 0`)

**Ce qu'un Delayed Member NE FAIT PAS** :
- N'appara√Æt pas aux applications clientes (doit √™tre Hidden)
- Ne peut jamais devenir Primary (`priority: 0` obligatoire)
- Ne refl√®te jamais l'√©tat actuel des donn√©es (toujours en retard)
- Ne convient pas pour les lectures de production

### Configuration Obligatoire

Pour qu'un membre soit Delayed, il doit respecter les contraintes suivantes :

**Propri√©t√©s obligatoires** :
```javascript
{
  priority: 0,      // OBLIGATOIRE : Ne peut pas devenir Primary
  hidden: true,     // OBLIGATOIRE : Doit √™tre invisible
  slaveDelay: N     // D√©lai en secondes (ex: 3600 = 1 heure)
}
```

**Propri√©t√©s recommand√©es** :
```javascript
{
  votes: 0          // RECOMMAND√â : Ne pas participer au quorum
}
```

**Contraintes strictes** :
1. `slaveDelay > 0` ‚áí `priority: 0` (obligatoire)
2. `slaveDelay > 0` ‚áí `hidden: true` (obligatoire)
3. MongoDB rejette toute configuration violant ces r√®gles

**Validation** :
```javascript
// Tentative de configuration invalide
cfg.members[3] = {
  _id: 3,
  host: "delayed.example.com:27017",
  slaveDelay: 3600,
  hidden: false     // ERREUR
}
rs.reconfig(cfg)
// Error: BadValue: slaveDelay requires hidden=true
```

### M√©canisme du D√©lai

Le Delayed member applique les op√©rations en fonction du **timestamp de l'op√©ration**, pas du moment de r√©ception :

**Principe** :
```
T0 (14h00) : Primary √©crit op1 (timestamp: T0)
             Delayed member (delay: 4h) re√ßoit op1 imm√©diatement

T0 (14h00) : Delayed member v√©rifie : T0 + 4h = 18h00
             Heure actuelle : 14h00 < 18h00
             ‚Üí N'applique PAS encore op1

T1 (18h00) : Heure actuelle : 18h00 >= 18h00
             ‚Üí Applique op1 maintenant
```

**Impl√©mentation interne** :

```javascript
// Pseudo-code du Delayed member
function processOplogEntry(operation) {
  const opTimestamp = operation.ts.getTime()
  const delayMillis = slaveDelay * 1000
  const applyTime = opTimestamp + delayMillis

  while (Date.now() < applyTime) {
    sleep(100)  // Attendre
  }

  // Appliquer l'op√©ration maintenant
  applyOperation(operation)
  updateLastAppliedOpTime(operation.ts)
}
```

**Cons√©quence** : Le Delayed member est toujours exactement `slaveDelay` secondes en retard (pas plus, pas moins).

## Cas d'Usage D√©taill√©s

### 1. Protection Contre les Erreurs Humaines

**Probl√©matique** :

Les erreurs humaines sont la cause #1 de perte de donn√©es en production :
- Ex√©cution accidentelle de `db.collection.drop()`
- `deleteMany({})` sans filtre (suppression de toute la collection)
- `updateMany()` avec crit√®re erron√© (corruption de masse)
- Script de migration mal test√© appliqu√© en production

**Solution avec Delayed Member** :

Le Delayed member offre une fen√™tre de r√©cup√©ration avant que l'erreur ne se propage :

```javascript
// Configuration : Delayed member avec 4 heures de d√©lai
{
  _id: 3,
  host: "delayed.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 14400,  // 4 heures = 14400 secondes
  votes: 0,
  tags: { purpose: "point_in_time_recovery", delay: "4h" }
}
```

**Sc√©nario de r√©cup√©ration** :

```
T0 (14h00) : Erreur humaine
             DBA ex√©cute par erreur : db.users.drop()
             ‚Üí Collection users supprim√©e sur Primary
             ‚Üí Op√©ration r√©pliqu√©e vers Secondaries normaux

T1 (14h15) : D√©tection de l'erreur
             Monitoring alerte : collection users absente

T2 (14h20) : V√©rification du Delayed member
             √âtat du Delayed : Refl√®te T0 - 4h = 10h00
             Collection users existe encore !

T3 (14h25) : R√©cup√©ration
             1. Connexion au Delayed member
             2. Dump de la collection users
             3. Restauration sur le Primary

T4 (14h30) : Service restaur√©
             Collection users r√©tablie

T5 (18h00) : Le Delayed member applique drop()
             (Mais donn√©es d√©j√† r√©cup√©r√©es)
```

**Fen√™tre de r√©cup√©ration** : 4 heures dans cet exemple (configurable selon les besoins).

### 2. R√©cup√©ration Point-in-Time (PITR)

**Probl√©matique** :

Besoin de restaurer l'√©tat exact du dataset √† un moment pr√©cis dans le pass√© :
- Audit apr√®s incident de s√©curit√©
- Compliance r√©glementaire (RGPD, SOX, HIPAA)
- Investigation de bugs applicatifs
- Rollback de migration de donn√©es probl√©matique

**Solution avec Delayed Member** :

```javascript
// Plusieurs Delayed members avec d√©lais √©chelonn√©s
{
  _id: 3,
  host: "delayed-1h.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 3600,  // 1 heure
  votes: 0,
  tags: { delay: "1h" }
},
{
  _id: 4,
  host: "delayed-4h.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 14400,  // 4 heures
  votes: 0,
  tags: { delay: "4h" }
},
{
  _id: 5,
  host: "delayed-24h.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 86400,  // 24 heures
  votes: 0,
  tags: { delay: "24h" }
}
```

**Strat√©gie de r√©cup√©ration granulaire** :

```
Erreur d√©tect√©e √† T0 + 30 minutes :
  ‚Üí Utiliser delayed-1h (donn√©es √† T0 - 30 min disponibles)

Erreur d√©tect√©e √† T0 + 3 heures :
  ‚Üí Utiliser delayed-4h (donn√©es √† T0 - 1h disponibles)

Erreur d√©tect√©e le lendemain :
  ‚Üí Utiliser delayed-24h + backups traditionnels
```

### 3. Audit et Compliance

**Probl√©matique** :

Certaines industries requi√®rent la capacit√© de d√©montrer l'√©tat des donn√©es √† des moments pr√©cis :
- Finance : Audit des transactions
- Sant√© : Historique des dossiers patients (HIPAA)
- L√©gal : Pr√©servation de preuves (e-discovery)

**Solution avec Delayed Member** :

```javascript
// Delayed member pour compliance (7 jours)
{
  _id: 6,
  host: "compliance.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 604800,  // 7 jours = 604800 secondes
  votes: 0,
  tags: { purpose: "compliance", retention: "7days" }
}
```

**Processus d'audit** :

```javascript
// Script d'extraction pour audit
const moment = require('moment')
const MongoClient = require('mongodb').MongoClient

async function auditSnapshot(targetDate) {
  // Calculer le d√©lai n√©cessaire
  const now = moment()
  const target = moment(targetDate)
  const delayDays = now.diff(target, 'days')

  if (delayDays > 7) {
    throw new Error('Beyond delayed member retention, use backups')
  }

  // Connexion au Delayed member (7 jours)
  const client = new MongoClient(
    'mongodb://compliance.example.com:27017/?directConnection=true'
  )

  await client.connect()
  const db = client.db('production')

  // Le Delayed member refl√®te now - 7 jours
  // Si target = now - 5 jours, les donn√©es ne sont pas encore l√†
  // Si target = now - 7 jours, les donn√©es sont disponibles

  if (delayDays === 7) {
    // Extraction des donn√©es pour l'audit
    const transactions = await db.collection('transactions')
      .find({ timestamp: { $gte: target.toDate(), $lt: target.add(1, 'day').toDate() } })
      .toArray()

    // Sauvegarde pour audit
    fs.writeFileSync(
      `audit-${target.format('YYYY-MM-DD')}.json`,
      JSON.stringify(transactions, null, 2)
    )

    console.log(`Audit snapshot created: ${transactions.length} transactions`)
  }

  await client.close()
}
```

### 4. Protection Contre les Corruptions Logiques

**Probl√©matique** :

Les corruptions logiques (bugs applicatifs) se propagent via la r√©plication :
- Bug dans le code applicatif corrompt les donn√©es
- Corruption se r√©plique imm√©diatement vers tous les Secondaries
- Backups traditionnels peuvent aussi √™tre corrompus si pris apr√®s l'incident

**Solution avec Delayed Member** :

```
T0 (10h00) : D√©ploiement d'une version bugg√©e de l'app
             Bug : calcul erron√© des prix (√ó 100 au lieu de / 100)

T1 (10h00-14h00) : Corruption progressive
                    1000 produits/heure affect√©s
                    R√©plication imm√©diate vers Secondaries normaux

T2 (14h00) : D√©tection du bug
             Monitoring d√©tecte des prix aberrants

T3 (14h05) : Rollback de l'app
             Mais 4000 produits d√©j√† corrompus

T4 (14h10) : Delayed member (delay: 6h) v√©rifi√©
             √âtat : Refl√®te 08h00 (avant le d√©ploiement bugg√©)
             Donn√©es intactes

T5 (14h15-15h00) : R√©cup√©ration s√©lective
                    Extraction des prix corrects depuis Delayed member
                    Restauration sur Primary
```

**Script de r√©cup√©ration** :

```javascript
// restore_from_delayed.js
async function restoreCorruptedPrices() {
  // Connexion au Delayed member (donn√©es saines)
  const delayedClient = new MongoClient(
    'mongodb://delayed.example.com:27017/?directConnection=true'
  )

  // Connexion au Primary (donn√©es corrompues)
  const primaryClient = new MongoClient(
    'mongodb://primary.example.com:27017'
  )

  await delayedClient.connect()
  await primaryClient.connect()

  const delayedDB = delayedClient.db('ecommerce')
  const primaryDB = primaryClient.db('ecommerce')

  // Identifier les produits affect√©s (prix > 10000‚Ç¨ suspects)
  const corruptedProducts = await primaryDB.collection('products')
    .find({ price: { $gt: 10000 } })
    .toArray()

  console.log(`Found ${corruptedProducts.length} corrupted products`)

  // R√©cup√©rer les prix corrects depuis le Delayed member
  for (const product of corruptedProducts) {
    const correctProduct = await delayedDB.collection('products')
      .findOne({ _id: product._id })

    if (correctProduct) {
      // Restaurer le prix correct
      await primaryDB.collection('products').updateOne(
        { _id: product._id },
        { $set: { price: correctProduct.price } }
      )

      console.log(`Restored product ${product._id}: ${product.price} ‚Üí ${correctProduct.price}`)
    }
  }

  await delayedClient.close()
  await primaryClient.close()
}
```

### 5. Validation de Scripts de Migration

**Probl√©matique** :

Les scripts de migration de donn√©es sont risqu√©s :
- Erreurs de logique dans les transformations
- Effets de bord non pr√©vus
- Volume de donn√©es affect√©es mal estim√©

**Solution avec Delayed Member** :

```javascript
// Processus de validation

// √âtape 1 : Ex√©cuter la migration sur le Primary
await runMigrationScript()

// √âtape 2 : Attendre 1-2 heures

// √âtape 3 : V√©rifier les r√©sultats
const validationResults = await validateMigration()

// √âtape 4 : Si probl√®me d√©tect√©
if (!validationResults.success) {
  console.log('Migration issue detected, recovering from delayed member')

  // Le Delayed member (delay: 4h) n'a pas encore appliqu√© la migration
  // R√©cup√©ration possible
  await recoverFromDelayedMember()
}

// √âtape 5 : Si OK apr√®s 4 heures
// La migration sera appliqu√©e sur le Delayed member
// ‚Üí Validation compl√®te
```

## Configuration et D√©ploiement

### Configuration Standard

**Configuration recommand√©e** :

```javascript
// Delayed member avec 4 heures de d√©lai
{
  _id: 3,
  host: "delayed.example.com:27017",
  priority: 0,          // Ne peut pas devenir Primary
  hidden: true,         // Invisible aux applications
  slaveDelay: 14400,    // 4 heures en secondes
  votes: 0,             // Ne participe pas aux √©lections
  tags: {
    purpose: "delayed_recovery",
    delay_hours: "4",
    datacenter: "dr_site"
  }
}
```

**Ajout √† un Replica Set existant** :

```javascript
// √âtape 1 : Provisionner le serveur
// Installer MongoDB, configurer le stockage

// √âtape 2 : D√©marrer mongod
// mongod --replSet myReplicaSet --dbpath /data/delayed --port 27017

// √âtape 3 : Ajouter √† la configuration du Replica Set
cfg = rs.conf()
cfg.members.push({
  _id: 3,
  host: "delayed.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 14400,  // 4 heures
  votes: 0,
  tags: { delay: "4h" }
})
rs.reconfig(cfg)

// √âtape 4 : Surveiller l'initial sync
rs.status().members.find(m => m._id === 3)
// Attendre : STARTUP2 ‚Üí RECOVERING ‚Üí SECONDARY
```

**V√©rification** :

```javascript
// V√©rifier la configuration
rs.conf().members.find(m => m._id === 3)

{
  "_id": 3,
  "host": "delayed.example.com:27017",
  "arbiterOnly": false,
  "buildIndexes": true,
  "hidden": true,
  "priority": 0,
  "tags": { "delay": "4h" },
  "slaveDelay": NumberLong(14400),
  "votes": 0
}

// V√©rifier l'√©tat
rs.status().members.find(m => m._id === 3)

{
  "_id": 3,
  "name": "delayed.example.com:27017",
  "health": 1,
  "state": 2,
  "stateStr": "SECONDARY",
  "uptime": 3600,
  "optime": { "ts": Timestamp(...), "t": NumberLong(5) },
  "optimeDate": ISODate("2024-12-08T08:00:00Z"),  // 4h en retard
  "syncSourceHost": "primary.example.com:27017",
  "configVersion": 4
}
```

### Fichier de Configuration mongod.conf

```yaml
# /etc/mongod-delayed.conf

# Stockage
storage:
  dbPath: /var/lib/mongodb-delayed
  engine: wiredTiger
  wiredTiger:
    engineConfig:
      cacheSizeGB: 16  # Peut √™tre plus petit que production
      journalCompressor: snappy
    collectionConfig:
      blockCompressor: snappy

# R√©seau
net:
  port: 27017
  bindIp: 0.0.0.0

# R√©plication
replication:
  replSetName: myReplicaSet
  enableMajorityReadConcern: false  # Pas n√©cessaire pour delayed

# S√©curit√©
security:
  authorization: enabled
  keyFile: /etc/mongodb-keyfile

# TLS
net:
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/delayed.pem
    CAFile: /etc/ssl/ca.pem

# Logging (important pour tracer les op√©rations appliqu√©es)
systemLog:
  destination: file
  path: /var/log/mongodb/delayed.log
  logAppend: true
  verbosity: 0
  component:
    replication:
      verbosity: 1  # Plus de d√©tails sur la r√©plication

# Process Management
processManagement:
  fork: true
  pidFilePath: /var/run/mongodb/delayed.pid
```

### Configuration Multi-D√©lais

Pour une protection compl√®te, utiliser plusieurs d√©lais :

```javascript
rs.initiate({
  _id: "production",
  members: [
    // Production
    { _id: 0, host: "primary:27017", priority: 2 },
    { _id: 1, host: "secondary1:27017", priority: 1 },
    { _id: 2, host: "secondary2:27017", priority: 1 },

    // Delayed members avec d√©lais √©chelonn√©s
    {
      _id: 3,
      host: "delayed-1h:27017",
      priority: 0,
      hidden: true,
      slaveDelay: 3600,  // 1 heure
      votes: 0,
      tags: { delay: "1h", purpose: "quick_recovery" }
    },
    {
      _id: 4,
      host: "delayed-4h:27017",
      priority: 0,
      hidden: true,
      slaveDelay: 14400,  // 4 heures
      votes: 0,
      tags: { delay: "4h", purpose: "standard_recovery" }
    },
    {
      _id: 5,
      host: "delayed-24h:27017",
      priority: 0,
      hidden: true,
      slaveDelay: 86400,  // 24 heures
      votes: 0,
      tags: { delay: "24h", purpose: "extended_recovery" }
    }
  ]
})
```

**Strat√©gie de r√©cup√©ration** :
- **0-60 min apr√®s l'erreur** : Utiliser delayed-1h
- **1-4h apr√®s l'erreur** : Utiliser delayed-4h
- **4-24h apr√®s l'erreur** : Utiliser delayed-24h
- **> 24h** : Utiliser backups traditionnels

## Dimensionnement du D√©lai

### Choix de la Dur√©e de D√©lai

Le d√©lai optimal d√©pend de plusieurs facteurs :

#### Temps de D√©tection des Erreurs

**Analyse** :
```
Temps moyen de d√©tection :
  - Erreur √©vidente (collection dropped) : 5-15 minutes
  - Erreur subtile (corruption de donn√©es) : 30 minutes - 2 heures
  - Bug applicatif silencieux : Plusieurs heures √† jours
```

**Recommandation** :
```
D√©lai minimum = Temps d√©tection max √ó 2

Exemple :
  Temps d√©tection max : 2 heures
  D√©lai minimum : 4 heures
```

#### Fen√™tre de R√©cup√©ration Souhait√©e

**Sc√©narios** :

**Startup/PME** :
- D√©lai : 1-2 heures
- Justification : √âquipe r√©duite, d√©tection rapide essentielle
- Co√ªt : Minimis√© (1 seul Delayed member)

**Entreprise standard** :
- D√©lai : 4-8 heures
- Justification : Balance entre co√ªt et protection
- Configuration : 1-2 Delayed members

**Entreprise critique (finance, sant√©)** :
- D√©lais multiples : 1h, 4h, 24h, 7 jours
- Justification : Compliance, audit, protection maximale
- Co√ªt : √âlev√© mais justifi√©

#### Contraintes d'Oplog

Le d√©lai est limit√© par la taille de l'Oplog :

**Formule** :
```
D√©lai maximum = Oplog_Window - Marge_s√©curit√©

Exemple :
  Oplog Window : 48 heures
  Marge s√©curit√© : 12 heures
  D√©lai maximum : 36 heures
```

**V√©rification de l'Oplog Window** :
```javascript
db.getReplicationInfo()

{
  "logSizeMB": 10240,       // 10 GB
  "usedMB": 5120,
  "timeDiff": 172800,       // 48 heures en secondes
  "timeDiffHours": 48,      // Fen√™tre : 48 heures
  "tFirst": "...",
  "tLast": "...",
  "now": "..."
}
```

Si `slaveDelay > timeDiffHours`, le Delayed member ne peut pas rattraper et n√©cessitera un initial sync.

### Formule de Dimensionnement

**Calcul de l'Oplog pour Delayed Member** :

```
OplogSize (GB) = (Taux_√©criture (GB/h) √ó (D√©lai_max (h) + Fen√™tre_s√©curit√© (h))) √ó Facteur_s√©curit√©

Exemple :
  Taux d'√©criture : 5 GB/h
  D√©lai max : 24 heures
  Fen√™tre s√©curit√© : 24 heures (doubler pour marge)
  Facteur s√©curit√© : 2

  OplogSize = 5 √ó (24 + 24) √ó 2 = 480 GB
```

**V√©rification p√©riodique** :

```bash
#!/bin/bash
# check_oplog_delay_capacity.sh

DELAY_SECONDS=$(mongo --quiet --eval "rs.conf().members.find(m => m.slaveDelay > 0).slaveDelay")
OPLOG_WINDOW_SECONDS=$(mongo --quiet --eval "db.getReplicationInfo().timeDiff")

DELAY_HOURS=$((DELAY_SECONDS / 3600))
OPLOG_WINDOW_HOURS=$((OPLOG_WINDOW_SECONDS / 3600))

if [ $DELAY_HOURS -ge $((OPLOG_WINDOW_HOURS - 12)) ]; then
  echo "CRITICAL: Delay ($DELAY_HOURS h) too close to Oplog window ($OPLOG_WINDOW_HOURS h)"
  echo "Risk of Delayed member requiring full resync"
  exit 2
else
  echo "OK: Delay ($DELAY_HOURS h) within safe range (Oplog: $OPLOG_WINDOW_HOURS h)"
  exit 0
fi
```

## Sc√©narios de R√©cup√©ration D√©taill√©s

### Sc√©nario 1 : Suppression Accidentelle de Collection

**Incident** :
```javascript
// √Ä 14h00, ex√©cution accidentelle
db.orders.drop()
// Collection orders supprim√©e
```

**D√©tection** :
```javascript
// √Ä 14h15, monitoring alerte
// Collection orders absente
// 15 minutes apr√®s l'incident
```

**R√©cup√©ration** :

```javascript
// restore_dropped_collection.js

const { MongoClient } = require('mongodb')

async function restoreDroppedCollection() {
  const delayedClient = new MongoClient(
    'mongodb://delayed.example.com:27017/?directConnection=true'
  )
  const primaryClient = new MongoClient(
    'mongodb://primary.example.com:27017'
  )

  await delayedClient.connect()
  await primaryClient.connect()

  const delayedDB = delayedClient.db('production')
  const primaryDB = primaryClient.db('production')

  console.log('Starting recovery of orders collection...')

  // √âtape 1 : V√©rifier que la collection existe sur le Delayed member
  const collections = await delayedDB.listCollections({ name: 'orders' }).toArray()
  if (collections.length === 0) {
    throw new Error('Collection orders not found on delayed member')
  }

  console.log('‚úì Collection found on delayed member')

  // √âtape 2 : Compter les documents
  const docCount = await delayedDB.collection('orders').countDocuments()
  console.log(`‚úì Found ${docCount} documents to restore`)

  // √âtape 3 : Recr√©er la collection sur le Primary
  await primaryDB.createCollection('orders')
  console.log('‚úì Collection recreated on primary')

  // √âtape 4 : Copier les indexes
  const indexes = await delayedDB.collection('orders').indexes()
  for (const index of indexes) {
    if (index.name !== '_id_') {  // Skip default _id index
      delete index.v  // Remove version field
      delete index.ns  // Remove namespace field
      await primaryDB.collection('orders').createIndex(
        index.key,
        { name: index.name, ...index }
      )
      console.log(`‚úì Index ${index.name} recreated`)
    }
  }

  // √âtape 5 : Copier les documents par batches
  const batchSize = 1000
  const cursor = delayedDB.collection('orders').find().batchSize(batchSize)

  let processed = 0
  let batch = []

  while (await cursor.hasNext()) {
    const doc = await cursor.next()
    batch.push(doc)

    if (batch.length >= batchSize) {
      await primaryDB.collection('orders').insertMany(batch, { ordered: false })
      processed += batch.length
      console.log(`Progress: ${processed}/${docCount} documents`)
      batch = []
    }
  }

  // Dernier batch
  if (batch.length > 0) {
    await primaryDB.collection('orders').insertMany(batch, { ordered: false })
    processed += batch.length
  }

  console.log(`‚úì Recovery complete: ${processed} documents restored`)

  // √âtape 6 : Validation
  const restoredCount = await primaryDB.collection('orders').countDocuments()
  console.log(`‚úì Verification: ${restoredCount} documents in restored collection`)

  if (restoredCount !== docCount) {
    console.warn(`‚ö† Warning: Document count mismatch (expected ${docCount}, got ${restoredCount})`)
  }

  await delayedClient.close()
  await primaryClient.close()
}

restoreDroppedCollection().catch(console.error)
```

**Timeline compl√®te** :
```
14h00 : Incident (drop collection)
14h15 : D√©tection
14h20 : D√©but r√©cup√©ration
14h35 : Restauration termin√©e (15 min pour 1M documents)
14h40 : Validation et retour √† la normale

Temps total d'indisponibilit√© : 40 minutes
```

### Sc√©nario 2 : Corruption de Masse par Update

**Incident** :
```javascript
// √Ä 10h00, script de migration bugg√©
db.products.updateMany(
  {},  // Crit√®re vide = tous les documents !
  { $set: { price: 0 } }  // Erreur : prix √† 0 au lieu de mise √† jour s√©lective
)
// Tous les produits ont maintenant price: 0
```

**D√©tection** :
```javascript
// √Ä 10h30, alerte business
// Chiffre d'affaires = 0
// Investigation r√©v√®le tous les prix √† 0
```

**R√©cup√©ration s√©lective** :

```javascript
// restore_corrupted_prices.js

async function restoreCorruptedPrices() {
  const delayedClient = new MongoClient(
    'mongodb://delayed.example.com:27017/?directConnection=true'
  )
  const primaryClient = new MongoClient(
    'mongodb://primary.example.com:27017'
  )

  await delayedClient.connect()
  await primaryClient.connect()

  const delayedDB = delayedClient.db('ecommerce')
  const primaryDB = primaryClient.db('ecommerce')

  console.log('Restoring corrupted prices...')

  // √âtape 1 : Identifier les produits corrompus (price: 0)
  const corruptedProducts = await primaryDB.collection('products')
    .find({ price: 0 })
    .project({ _id: 1 })
    .toArray()

  console.log(`Found ${corruptedProducts.length} corrupted products`)

  // √âtape 2 : Restaurer les prix depuis le Delayed member
  let restored = 0
  let notFound = 0

  for (const product of corruptedProducts) {
    const correctProduct = await delayedDB.collection('products')
      .findOne({ _id: product._id }, { projection: { price: 1 } })

    if (correctProduct && correctProduct.price > 0) {
      await primaryDB.collection('products').updateOne(
        { _id: product._id },
        { $set: { price: correctProduct.price } }
      )
      restored++

      if (restored % 100 === 0) {
        console.log(`Progress: ${restored}/${corruptedProducts.length}`)
      }
    } else {
      notFound++
    }
  }

  console.log(`‚úì Restored ${restored} prices`)
  console.log(`‚ö† ${notFound} products not found or also had price=0`)

  await delayedClient.close()
  await primaryClient.close()
}
```

### Sc√©nario 3 : R√©cup√©ration Partielle par Timestamp

**Incident** :
```javascript
// Script de nettoyage ex√©cut√© avec mauvais param√®tre de date
// Intention : Supprimer les logs de test (avant 2024-01-01)
// R√©alit√© : Supprimer les logs de production (avant 2024-12-01)

db.logs.deleteMany({
  timestamp: { $lt: new Date('2024-12-01') }  // ERREUR : devait √™tre 2024-01-01
})
// Suppression de 11 mois de logs de production !
```

**R√©cup√©ration** :

```javascript
// restore_deleted_logs.js

async function restoreDeletedLogs() {
  const delayedClient = new MongoClient(
    'mongodb://delayed.example.com:27017/?directConnection=true'
  )
  const primaryClient = new MongoClient(
    'mongodb://primary.example.com:27017'
  )

  await delayedClient.connect()
  await primaryClient.connect()

  const delayedDB = delayedClient.db('application')
  const primaryDB = primaryClient.db('application')

  // R√©cup√©rer les logs supprim√©s (avant 2024-12-01)
  const deletedLogs = await delayedDB.collection('logs')
    .find({ timestamp: { $lt: new Date('2024-12-01') } })
    .toArray()

  console.log(`Recovering ${deletedLogs.length} deleted logs`)

  // R√©ins√©rer par batches
  const batchSize = 10000
  for (let i = 0; i < deletedLogs.length; i += batchSize) {
    const batch = deletedLogs.slice(i, i + batchSize)
    await primaryDB.collection('logs').insertMany(batch, { ordered: false })
    console.log(`Progress: ${Math.min(i + batchSize, deletedLogs.length)}/${deletedLogs.length}`)
  }

  console.log('‚úì Recovery complete')

  await delayedClient.close()
  await primaryClient.close()
}
```

## Architecture et Fonctionnement

### Flux de R√©plication avec D√©lai

```
Primary                          Delayed Member (delay: 4h)
   |                                    |
   | T0 (14h00) : Write op1             |
   |    OpTime: (t:5, ts:T0)            |
   |                                    |
   | ‚Üí Oplog entry cr√©√©e                |
   |                                    |
   |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> Tailable cursor r√©cup√®re op1
   |                                    |
   |                                    | T0 (14h00) : op1 re√ßue
   |                                    | Calcul : T0 + 4h = 18h00
   |                                    | Heure actuelle : 14h00
   |                                    | ‚Üí Stocke op1 en attente
   |                                    |
   | T1 (15h00) : Write op2             |
   |‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> op2 re√ßue, en attente (19h00)
   |                                    |
   | ...                                |
   |                                    |
   | T2 (18h00) : Autres op√©rations     | T2 (18h00) : Heure atteinte
   |                                    | ‚Üí Applique op1 maintenant
   |                                    | lastAppliedOpTime = T0
   |                                    |
```

### Gestion de la File d'Attente

Le Delayed member maintient une **file d'attente** des op√©rations en attente d'application :

**Structure interne** (conceptuelle) :
```javascript
// Pseudo-code interne MongoDB
class DelayedMemberQueue {
  constructor(delaySeconds) {
    this.delayMillis = delaySeconds * 1000
    this.queue = []  // Op√©rations en attente
  }

  async processIncomingOp(operation) {
    const applyTime = operation.ts.getTime() + this.delayMillis
    this.queue.push({ operation, applyTime })
    this.queue.sort((a, b) => a.applyTime - b.applyTime)
  }

  async processQueue() {
    while (true) {
      const now = Date.now()

      while (this.queue.length > 0 && this.queue[0].applyTime <= now) {
        const { operation } = this.queue.shift()
        await this.applyOperation(operation)
      }

      await sleep(100)  // V√©rifier toutes les 100ms
    }
  }
}
```

**Implication** : Plus le d√©lai est long, plus la m√©moire n√©cessaire pour stocker les op√©rations en attente est importante.

### Impact sur le Replication Lag

Le replication lag d'un Delayed member a deux composants :

**1. D√©lai configur√© (slaveDelay)** :
```
Lag intentionnel = slaveDelay
```

**2. Lag de r√©plication r√©el** :
```
Lag r√©el = D√©lai de transmission + D√©lai d'application
```

**Lag total** :
```
Lag total = slaveDelay + Lag r√©el

Exemple :
  slaveDelay = 4 heures = 14400 secondes
  Lag r√©el = 5 secondes (transmission + application)
  Lag total = 14405 secondes ‚âà 4 heures
```

**Monitoring** :
```javascript
rs.status().members.find(m => m.slaveDelay > 0)

{
  "optimeDate": ISODate("2024-12-08T08:00:05Z"),  // T0 - 4h + 5s
  "lastHeartbeat": ISODate("2024-12-08T12:00:10Z"),
  // Lag = 12:00:10 - 08:00:05 = ~4 heures
}
```

**Alerte** : Si `Lag r√©el > 1 minute`, investiguer (probl√®me de performance sur le Delayed member).

## Performance et Optimisations

### Dimensionnement Mat√©riel

Un Delayed member n'a pas besoin de ressources √©quivalentes au Primary :

**Recommandations** :

```
CPU : 4-8 cores (pas de lectures de production)
RAM : 32-64 GB (cache pour application Oplog)
Disque : HDD acceptable (SATA 7200 RPM)
        ou SSD √©conomique
        Capacit√© : √âquivalente au dataset + Oplog
R√©seau : 1 Gbps (suffisant)
```

**Justification** :
- Pas de requ√™tes de lecture (sauf r√©cup√©ration ponctuelle)
- Application des op√©rations Oplog moins critique (d√©j√† en retard volontairement)
- Co√ªt optimis√© (hardware moins premium)

### Optimisation du Stockage

**Compression agressive** :

```yaml
# mongod-delayed.conf
storage:
  wiredTiger:
    collectionConfig:
      blockCompressor: zstd  # Meilleur ratio (vs snappy)
    indexConfig:
      prefixCompression: true
```

**B√©n√©fice** : R√©duction de 30-50% de l'espace disque utilis√©.

**Indexes s√©lectifs** :

Le Delayed member peut avoir moins d'indexes :

```javascript
// Connexion directe au Delayed member
db.setProfilingLevel(0)  // D√©sactiver le profiler

// Supprimer les indexes rarement utilis√©s (pour √©conomiser espace)
db.collection.dropIndex("rarement_utilise")
```

**Attention** : Ne supprimer que les indexes qui ne sont PAS n√©cessaires pour l'application des op√©rations Oplog.

### Gestion des Ressources

**Limiter les ressources** (si co-localis√© ou sur hardware partag√©) :

```ini
# /etc/systemd/system/mongod-delayed.service
[Service]
CPUQuota=400%  # Max 4 cores sur serveur 16 cores
MemoryLimit=32G
IOWeight=100  # Priorit√© basse pour I/O
```

## Monitoring et Maintenance

### M√©triques Sp√©cifiques

**V√©rification du d√©lai effectif** :

```javascript
// check_delay.js
function checkDelayedMemberDelay() {
  const status = rs.status()
  const primary = status.members.find(m => m.state === 1)
  const delayed = status.members.find(m => m.slaveDelay > 0)

  if (!delayed) {
    console.log('No delayed member configured')
    return
  }

  const configuredDelay = delayed.slaveDelay
  const actualLag = (primary.optimeDate - delayed.optimeDate) / 1000

  console.log(`Configured delay: ${configuredDelay}s (${configuredDelay/3600}h)`)
  console.log(`Actual lag: ${actualLag.toFixed(2)}s (${(actualLag/3600).toFixed(2)}h)`)

  const difference = Math.abs(actualLag - configuredDelay)

  if (difference > 300) {  // 5 minutes de tol√©rance
    console.warn(`‚ö† Delay discrepancy: ${difference.toFixed(2)}s`)
    console.warn('Possible issues:')
    console.warn('  - Delayed member lagging behind')
    console.warn('  - Oplog too small')
    console.warn('  - Performance issues')
  } else {
    console.log(`‚úì Delay is accurate (¬±${difference.toFixed(2)}s)`)
  }
}

checkDelayedMemberDelay()
```

**V√©rification de la capacit√© de l'Oplog** :

```javascript
// check_oplog_capacity.js
function checkOplogCapacity() {
  const replInfo = db.getReplicationInfo()
  const status = rs.status()
  const delayed = status.members.find(m => m.slaveDelay > 0)

  if (!delayed) return

  const oplogWindowHours = replInfo.timeDiffHours
  const delayHours = delayed.slaveDelay / 3600
  const marginHours = oplogWindowHours - delayHours

  console.log(`Oplog window: ${oplogWindowHours}h`)
  console.log(`Delay: ${delayHours}h`)
  console.log(`Margin: ${marginHours}h`)

  if (marginHours < 12) {
    console.error(`‚ö† CRITICAL: Oplog margin < 12h`)
    console.error('Risk of delayed member requiring full resync')
    console.error('Recommendation: Increase Oplog size')
  } else if (marginHours < 24) {
    console.warn(`‚ö† WARNING: Oplog margin < 24h`)
  } else {
    console.log(`‚úì Oplog capacity sufficient`)
  }
}

checkOplogCapacity()
```

### Alerting

**Alertes critiques pour Delayed members** :

```yaml
# prometheus-alerts.yml
groups:
  - name: delayed_members
    rules:
      # Delayed member DOWN
      - alert: DelayedMemberDown
        expr: mongodb_mongod_replset_member_health{slaveDelay > 0} == 0
        for: 10m
        severity: critical
        annotations:
          summary: "Delayed member is DOWN"
          description: "Recovery window lost if member stays down"

      # D√©lai incorrectement appliqu√©
      - alert: DelayedMemberDelayIncorrect
        expr: |
          abs(
            (mongodb_mongod_replset_optime_date{state="PRIMARY"}
            - mongodb_mongod_replset_optime_date{slaveDelay > 0})
            - mongodb_mongod_replset_member_slave_delay
          ) > 600
        for: 15m
        severity: warning
        annotations:
          summary: "Delayed member delay discrepancy > 10 minutes"

      # Oplog insuffisant pour le d√©lai
      - alert: DelayedMemberOplogInsufficient
        expr: |
          (mongodb_mongod_replset_oplog_window_seconds
          - mongodb_mongod_replset_member_slave_delay) < 43200
        for: 1h
        severity: critical
        annotations:
          summary: "Oplog margin < 12h for delayed member"
          description: "Risk of requiring full resync"
```

### Proc√©dures de Maintenance

**Rolling restart avec Delayed member** :

```bash
#!/bin/bash
# rolling_restart_with_delayed.sh

echo "Step 1: Restart secondaries (except delayed)"
for host in secondary1 secondary2; do
  ssh $host "sudo systemctl restart mongod"
  sleep 60
done

echo "Step 2: Step down primary"
mongo --eval "rs.stepDown(120)"
sleep 30

echo "Step 3: Restart old primary (now secondary)"
ssh primary "sudo systemctl restart mongod"
sleep 60

echo "Step 4: Restart delayed member (last)"
ssh delayed "sudo systemctl restart mongod"

echo "‚úì Rolling restart complete"
```

**Pourquoi delayed en dernier ?**
- Minimise le risque de perte de la fen√™tre de r√©cup√©ration
- Si probl√®me lors du restart, les autres membres sont d√©j√† √† jour

## Limitations et Consid√©rations

### 1. Ne Remplace PAS les Backups Traditionnels

**Limitations critiques** :

**Corruption physique** :
- Delayed member r√©plique aussi les corruptions physiques (disque d√©faillant)
- Seuls les backups offline (mongodump, snapshots) prot√®gent

**Suppression malveillante** :
- Si un attaquant supprime volontairement toutes les donn√©es
- Le Delayed member appliquera aussi la suppression apr√®s le d√©lai
- Seuls les backups externes (hors cluster) prot√®gent

**Disasters majeurs** :
- Perte compl√®te du datacenter (incendie, inondation)
- Si le Delayed member est dans le m√™me datacenter
- Backups g√©ographiquement distribu√©s requis

**Recommandation** :

```
Strat√©gie compl√®te de protection :

1. Delayed members (1-24h)
   ‚Üí Protection contre erreurs humaines

2. Backups quotidiens (mongodump + snapshots)
   ‚Üí Protection contre corruptions, disasters
   ‚Üí R√©tention : 7-30 jours

3. Backups archivage (mensuel/trimestriel)
   ‚Üí Compliance, audit
   ‚Üí R√©tention : 1-7 ans
```

### 2. Fen√™tre de R√©cup√©ration Fixe

**Probl√®me** :

Le d√©lai est fixe : si l'erreur est d√©tect√©e apr√®s le d√©lai, la r√©cup√©ration est impossible via le Delayed member.

**Exemple** :
```
Delayed member : 4 heures
Erreur : Suppression accidentelle √† 10h00
D√©tection : 15h00 (5 heures apr√®s)

R√©sultat :
  Le Delayed member a d√©j√† appliqu√© la suppression √† 14h00
  R√©cup√©ration impossible via Delayed member
  ‚Üí Utiliser backups traditionnels
```

**Mitigation** : Multiples Delayed members avec d√©lais √©chelonn√©s.

### 3. Consommation de Ressources

**Co√ªt** :

Chaque Delayed member n√©cessite :
- Un serveur complet (ou VM)
- Stockage √©quivalent au dataset
- Oplog surdimensionn√© (d√©lai + marge)

**Exemple** :
```
Production : 3 membres √ó 1 TB = 3 TB
Delayed (1h) : 1 membre √ó 1 TB = 1 TB
Delayed (4h) : 1 membre √ó 1 TB = 1 TB
Delayed (24h) : 1 membre √ó 1 TB = 1 TB

Total : 6 TB (vs 3 TB sans delayed)
Surco√ªt : +100%
```

**Optimisation** : Partager un Delayed member entre plusieurs Replica Sets (si d√©ploiements multiples).

### 4. Complexit√© Op√©rationnelle

**Gestion** :

- Surveillance de multiples m√©triques (d√©lai effectif, Oplog capacity)
- Proc√©dures de r√©cup√©ration sp√©cifiques
- Documentation des d√©lais et proc√©dures
- Formation des √©quipes ops

**Formation requise** :

Les √©quipes doivent comprendre :
- Quand utiliser quel Delayed member
- Comment v√©rifier la disponibilit√© des donn√©es
- Proc√©dures de r√©cup√©ration par type d'incident

## Bonnes Pratiques

### 1. Dimensionner l'Oplog G√©n√©reusement

**Formule** :
```
OplogSize ‚â• Taux_√©criture √ó (D√©lai_max + Marge) √ó 2

Minimum : D√©lai_max √ó 2
Recommand√© : D√©lai_max √ó 3-4
```

**Exemple** :
```
Delayed member : 24 heures
Oplog minimum : 48 heures
Oplog recommand√© : 72-96 heures
```

### 2. Tester R√©guli√®rement les Proc√©dures de R√©cup√©ration

**Plan de test trimestriel** :

```bash
#!/bin/bash
# test_delayed_recovery.sh

echo "=== Delayed Member Recovery Test ==="
echo "Date: $(date)"
echo

# √âtape 1 : Cr√©er des donn√©es de test
echo "Step 1: Creating test data..."
mongo --eval "
  db.recovery_test.insertMany([
    { _id: 1, value: 'before', timestamp: new Date() },
    { _id: 2, value: 'before', timestamp: new Date() }
  ])
"

# √âtape 2 : Attendre 1 minute
echo "Step 2: Waiting 1 minute..."
sleep 60

# √âtape 3 : "Corrompre" les donn√©es
echo "Step 3: Simulating data corruption..."
mongo --eval "
  db.recovery_test.updateMany({}, { \$set: { value: 'corrupted' } })
"

# √âtape 4 : R√©cup√©ration depuis delayed member
echo "Step 4: Recovering from delayed member..."
# (Delayed member with 1h delay still has 'before' values)

mongo --host delayed.example.com --eval "
  db.recovery_test.find().forEach(doc => {
    db.getSiblingDB('test').recovery_test.replaceOne(
      { _id: doc._id },
      doc,
      { upsert: true }
    )
  })
" mongodb://primary.example.com

# √âtape 5 : V√©rification
echo "Step 5: Verification..."
mongo --eval "
  const results = db.recovery_test.find().toArray()
  results.forEach(doc => {
    if (doc.value !== 'before') {
      print('FAILED: Recovery did not work')
      quit(1)
    }
  })
  print('SUCCESS: Recovery test passed')
"

# Nettoyage
mongo --eval "db.recovery_test.drop()"
```

**Fr√©quence recommand√©e** : Trimestrielle (tous les 3 mois).

### 3. Documenter les Proc√©dures

**Template de documentation** :

```markdown
# Delayed Member Recovery Procedures

## Configuration

- **Delayed Member 1h**: delayed-1h.example.com:27017
  - Delay: 3600 seconds (1 hour)
  - Use case: Quick recovery (errors detected within 1 hour)

- **Delayed Member 4h**: delayed-4h.example.com:27017
  - Delay: 14400 seconds (4 hours)
  - Use case: Standard recovery (errors detected within 4 hours)

## Recovery Procedure

### 1. Assess the Incident

- Determine when the error occurred
- Calculate: Current time - Error time = Detection delay
- Select appropriate delayed member (delay > detection delay)

### 2. Verify Data Availability

```bash
# Check delayed member lag
mongo --host delayed-4h.example.com --eval "
  db.adminCommand({ replSetGetStatus: 1 })
"
```

### 3. Execute Recovery

See: `/opt/scripts/delayed_recovery/`
- `restore_dropped_collection.js`
- `restore_corrupted_data.js`
- `selective_restore.js`

### 4. Validate

- Count documents
- Verify data integrity
- Check application functionality

### 5. Document

- Update incident log
- Record recovery procedure used
- Note lessons learned
```

### 4. Utiliser votes: 0

**Justification** :

Un Delayed member avec `votes: 1` peut ralentir le write concern "majority" :

```
Configuration : P + S1 + S2 + D (Delayed 4h, votes: 1)

√âcriture avec w: "majority" :
  Primary √©crit (OpTime: 1000)
  S1 r√©plique (OpTime: 1000)
  S2 r√©plique (OpTime: 1000)
  D (Delayed) applique plus tard (OpTime: 996, 4h en retard)

  Quorum : 3/4
  Commit point = min(P, S1, S2) = 1000 (D ignor√© car trop en retard)

  Mais : Calcul de majorit√© compte D ‚Üí Complexit√© inutile
```

**Recommandation** : Toujours `votes: 0` pour Delayed members.

### 5. Combiner avec Hidden Members

Les Delayed members doivent √™tre Hidden, mais peuvent aussi servir d'autres fonctions :

```javascript
// Delayed member pour recovery + backup
{
  _id: 3,
  host: "delayed-backup.example.com:27017",
  priority: 0,
  hidden: true,
  slaveDelay: 14400,  // 4 heures
  votes: 0,
  tags: { purpose: "delayed_recovery_and_backup" }
}
```

**Script de backup sur Delayed member** :

```bash
#!/bin/bash
# backup_from_delayed.sh

# Avantage : Backup d'un √©tat coh√©rent (4h dans le pass√©)
# Pas de risque de capturer des donn√©es en cours de corruption

mongodump \
  --host delayed-backup.example.com:27017 \
  --out /backups/delayed-$(date +%Y%m%d-%H%M%S) \
  --gzip \
  --oplog
```

## Conclusion

Les **Delayed members** sont un outil puissant pour la protection contre les erreurs humaines et la r√©cup√©ration point-in-time dans MongoDB. Ils offrent une **fen√™tre de r√©cup√©ration** configurablecontre les suppressions accidentelles, les corruptions de donn√©es et les bugs applicatifs.

**Cas d'usage principaux** :
1. **Protection erreurs humaines** : R√©cup√©ration de donn√©es supprim√©es/corrompues
2. **Point-in-Time Recovery** : Restauration √† un √©tat pr√©cis dans le pass√©
3. **Audit et compliance** : Historique des donn√©es pour r√©glementations
4. **Validation de migrations** : V√©rification avant propagation d√©finitive

**Avantages cl√©s** :
- **Fen√™tre de r√©cup√©ration automatique** : Pas besoin de restaurer des backups
- **R√©cup√©ration rapide** : Connexion directe et copie s√©lective
- **Protection continue** : Toujours √† jour (avec le d√©lai configur√©)
- **Granularit√© fine** : R√©cup√©ration de collections/documents sp√©cifiques

**Limitations importantes** :
- **Ne remplace PAS les backups** : Corruptions physiques, disasters majeurs
- **Fen√™tre fixe** : Erreurs d√©tect√©es apr√®s le d√©lai irr√©alisables
- **Co√ªt** : Serveur et stockage suppl√©mentaires
- **Oplog surdimensionn√© requis** : D√©lai + marge substantielle

**Configuration recommand√©e** :
- **D√©lai** : 4-8 heures pour usage standard, 1-24h √©chelonn√© pour critique
- **Propri√©t√©s** : `priority: 0, hidden: true, votes: 0`
- **Oplog** : Minimum d√©lai √ó 2, recommand√© d√©lai √ó 3-4
- **Tests** : Proc√©dures de r√©cup√©ration test√©es trimestriellement

Les Delayed members sont particuli√®rement recommand√©s pour les syst√®mes de production o√π les erreurs humaines repr√©sentent un risque significatif. Combin√©s avec des backups traditionnels et une strat√©gie de monitoring robuste, ils forment une d√©fense en profondeur contre la perte de donn√©es.

‚è≠Ô∏è [√âlection du Primary](/09-replication/04-election-primary.md)
