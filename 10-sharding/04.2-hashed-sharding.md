ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 10.4.2 Hashed Sharding

## Introduction

Le **Hashed Sharding** (partitionnement par hachage) est une stratÃ©gie de sharding qui utilise une **fonction de hachage cryptographique** pour distribuer les documents entre les shards. Contrairement au Range Sharding oÃ¹ les chunks sont basÃ©s sur des plages de valeurs, le Hashed Sharding crÃ©e des chunks basÃ©s sur des plages de **valeurs hachÃ©es**, garantissant une distribution mathÃ©matiquement uniforme.

Cette approche Ã©limine complÃ¨tement les hotspots liÃ©s aux insertions monotones, au prix de l'efficacitÃ© des requÃªtes par plage. Cette section explore le fonctionnement interne, les optimisations et les cas d'usage idÃ©aux du Hashed Sharding.

## Principe de Fonctionnement DÃ©taillÃ©

### Fonction de Hachage MongoDB

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FONCTION DE HACHAGE INTERNE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// MongoDB utilise une fonction de hachage propriÃ©taire:
// hash(value) â†’ int64 dans range [-2^63, 2^63-1]

// PropriÃ©tÃ©s de la fonction:
// 1. DÃ©terministe: hash(X) retourne toujours la mÃªme valeur
// 2. Uniforme: Distribution statistiquement uniforme
// 3. Non-rÃ©versible: Impossible de retrouver valeur originale
// 4. Avalanche: Petite variation d'input â†’ grande variation d'output

// Exemples concrets:
hash("user-12345")  â†’ -4567891234567890123
hash("user-12346")  â†’ 8901234567890123456
hash("user-12347")  â†’ -1234567890123456789

// MÃªme des valeurs sÃ©quentielles â†’ hashes non-corrÃ©lÃ©s
hash(1)    â†’ -7842693339044312345
hash(2)    â†’ 3456789012345678901
hash(3)    â†’ -9012345678901234567
hash(4)    â†’ 5678901234567890123

// Visualisation de la distribution:
// Input (sÃ©quentiel):
// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...
// â†“ hash()
// Output (pseudo-alÃ©atoire):
// -7.8e18, 3.4e18, -9.0e18, 5.6e18, 1.2e18, ...

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Range Int64: -9,223,372,036,854,775,808           â”‚
â”‚               to                                   â”‚
â”‚               9,223,372,036,854,775,807            â”‚
â”‚                                                    â”‚
â”‚  Distribution uniforme sur tout le range           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CrÃ©ation des Chunks Hashed

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACTIVATION HASHED SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sh.shardCollection("app.users", { user_id: "hashed" })
//                                          ^^^^^^^^
//                                          Keyword "hashed"

// MongoDB crÃ©e automatiquement 2 chunks initiaux par shard:
// (Pour cluster de 3 shards = 6 chunks initiaux)

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 1                                            â”‚
// â”‚ min: { user_id: MinKey }                           â”‚
// â”‚ max: { user_id: NumberLong("-6148914691236517205") }
// â”‚ shard: shard-a                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 2                                            â”‚
// â”‚ min: { user_id: NumberLong("-6148914691236517205") }
// â”‚ max: { user_id: NumberLong("-3074457345618258602") }
// â”‚ shard: shard-a                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 3                                            â”‚
// â”‚ min: { user_id: NumberLong("-3074457345618258602") }
// â”‚ max: { user_id: NumberLong("0") }                  â”‚
// â”‚ shard: shard-b                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 4                                            â”‚
// â”‚ min: { user_id: NumberLong("0") }                  â”‚
// â”‚ max: { user_id: NumberLong("3074457345618258602") }â”‚
// â”‚ shard: shard-b                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 5                                            â”‚
// â”‚ min: { user_id: NumberLong("3074457345618258602") }â”‚
// â”‚ max: { user_id: NumberLong("6148914691236517205") }â”‚
// â”‚ shard: shard-c                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Chunk 6                                            â”‚
// â”‚ min: { user_id: NumberLong("6148914691236517205") }â”‚
// â”‚ max: { user_id: MaxKey }                           â”‚
// â”‚ shard: shard-c                                     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

// Avantage: Distribution immÃ©diate sur tous shards
// Pas besoin d'attendre splits/migrations
```

### Visualisation de la Distribution

```
Hashed Sharding: user_id
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Hash Range: -9,223,372,036,854,775,808 â”€â”€â”€â”€â”€â–º 9,223,372,036,854,775,807
            (MinKey)                          (MaxKey)

Distribution initiale (3 shards, 6 chunks):
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Chunk 1    â”‚  Chunk 2    â”‚  Chunk 3    â”‚  Chunk 4    â”‚  Chunk 5    â”‚  Chunk 6    â”‚
â”‚  Shard A    â”‚  Shard A    â”‚  Shard B    â”‚  Shard B    â”‚  Shard C    â”‚  Shard C    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Insertions (valeurs sÃ©quentielles 1, 2, 3, 4, 5, ...):
â†“ hash()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Chunk 1    â”‚  Chunk 2    â”‚  Chunk 3    â”‚  Chunk 4    â”‚  Chunk 5    â”‚  Chunk 6    â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚  â–ˆâ–ˆâ–ˆâ–ˆ       â”‚
â”‚  16.6%      â”‚  16.7%      â”‚  16.6%      â”‚  16.7%      â”‚  16.6%      â”‚  16.8%      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DISTRIBUTION PARFAITEMENT UNIFORME
(Garantie mathÃ©matique par la fonction de hash)

Comparaison avec Range Sharding (mÃªme shard key sÃ©quentielle):
Range:
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  100% des insertions dans le dernier chunk (MaxKey)                                 â”‚
â”‚  Hotspot permanent âŒ                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Hashed:
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 16.6%      â”‚ 16.7%    â”‚ 16.6%    â”‚ 16.7%    â”‚ 16.6%    â”‚ 16.8%    â”‚
â”‚ Uniforme âœ…â”‚          â”‚          â”‚          â”‚          â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Routage des RequÃªtes

### RequÃªtes Exactes (Optimal)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REQUÃŠTE AVEC VALEUR EXACTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

db.users.find({ user_id: "user-12345" })

// Mongos Logic:
// 1. Calcule hash("user-12345") â†’ -4567891234567890123
// 2. Consulte routing table:
//    Quel chunk contient hash = -4567891234567890123 ?
//    â†’ Chunk 1: [MinKey, -6148914691236517205)
//    Non, hash > max
//    â†’ Chunk 2: [-6148914691236517205, -3074457345618258602)
//    Oui! -6148... < -4567... < -3074...
//    â†’ Chunk 2 sur Shard A
// 3. Route UNIQUEMENT vers Shard A

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mongos  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ user_id = "user-12345"
     â”‚ hash â†’ -4567891234567890123
     â”‚
     â”‚ â”Œâ”€ Routing Table (hash ranges) â”€â”€â”€â”
     â”‚ â”‚ [MinKey, -6148...]  â†’ Shard A   â”‚
     â”‚ â”‚ [-6148.., -3074...] â†’ Shard A âœ“ â”‚
     â”‚ â”‚ [-3074.., 0]        â†’ Shard B   â”‚
     â”‚ â”‚ [0, 3074...]        â†’ Shard B   â”‚
     â”‚ â”‚ [3074..., 6148...]  â†’ Shard C   â”‚
     â”‚ â”‚ [6148..., MaxKey]   â†’ Shard C   â”‚
     â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shard A  â”‚  â”‚ Shard B  â”‚  â”‚ Shard C  â”‚
â”‚  âœ“âœ“âœ“âœ“    â”‚  â”‚          â”‚  â”‚          â”‚
â”‚ QUERIED  â”‚  â”‚          â”‚  â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Latence: ~5ms (1 shard uniquement)
Performance: â­â­â­â­â­ Optimal
```

### RequÃªtes $in (Partiellement CiblÃ©e)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REQUÃŠTE $in
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

db.users.find({
  user_id: { $in: ["user-1", "user-2", "user-3", "user-4"] }
})

// Mongos Logic:
// 1. Pour chaque valeur, calcule hash et trouve chunk:
//    hash("user-1") â†’ -7842...  â†’ Chunk 1 â†’ Shard A
//    hash("user-2") â†’ 3456...   â†’ Chunk 4 â†’ Shard B
//    hash("user-3") â†’ -9012...  â†’ Chunk 2 â†’ Shard A
//    hash("user-4") â†’ 5678...   â†’ Chunk 5 â†’ Shard C
//
// 2. Route vers Shards A, B, C (3 shards)
// 3. Merge rÃ©sultats

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mongos  â”‚
â””â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”˜
  â”‚      â”‚
  â–¼      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shard A  â”‚  â”‚ Shard B  â”‚  â”‚ Shard C  â”‚
â”‚  âœ“âœ“âœ“âœ“    â”‚  â”‚  âœ“âœ“âœ“âœ“    â”‚  â”‚  âœ“âœ“âœ“âœ“    â”‚
â”‚ user-1   â”‚  â”‚ user-2   â”‚  â”‚ user-4   â”‚
â”‚ user-3   â”‚  â”‚          â”‚  â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Performance:
â€¢ Nombre shards = min(valeurs distinctes, nb total shards)
â€¢ Avec 4 valeurs, 3 shards â†’ 3 shards interrogÃ©s
â€¢ Latence: ~15-20ms
â€¢ â­â­â­â­ Bon (meilleur que scatter-gather complet)
```

### RequÃªtes par Plage (Scatter-Gather Obligatoire)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REQUÃŠTE RANGE - LE POINT FAIBLE DU HASHED SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

db.users.find({
  user_id: { $gte: "user-10000", $lte: "user-20000" }
})

// ProblÃ¨me:
// Les valeurs sÃ©quentielles ont des hashes non-corrÃ©lÃ©s:
// hash("user-10000") â†’ -3456789012345678901  â†’ Chunk X
// hash("user-10001") â†’ 8901234567890123456   â†’ Chunk Y
// hash("user-10002") â†’ -1234567890123456789  â†’ Chunk Z
// ...
// hash("user-20000") â†’ 5678901234567890123   â†’ Chunk W

// Impossible de dÃ©terminer quels chunks contiennent la plage
// â†’ OBLIGÃ‰ d'interroger TOUS les shards

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mongos  â”‚
â””â”€â”¬â”€â”€â”¬â”€â”€â”€â”¬â”€â”˜
  â”‚  â”‚   â”‚ Broadcast Ã  tous shards
  â–¼  â–¼   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shard A  â”‚  â”‚ Shard B  â”‚  â”‚ Shard C  â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆ    â”‚  â”‚  â–ˆâ–ˆâ–ˆâ–ˆ    â”‚  â”‚  â–ˆâ–ˆâ–ˆâ–ˆ    â”‚
â”‚ QUERIED  â”‚  â”‚ QUERIED  â”‚  â”‚ QUERIED  â”‚
â”‚          â”‚  â”‚          â”‚  â”‚          â”‚
â”‚ Scan     â”‚  â”‚ Scan     â”‚  â”‚ Scan     â”‚
â”‚ TOUS     â”‚  â”‚ TOUS     â”‚  â”‚ TOUS     â”‚
â”‚ docs     â”‚  â”‚ docs     â”‚  â”‚ docs     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Latence: ~50-200ms (selon nb shards et volume)
Performance: â­ TrÃ¨s mauvais

Comparaison Range Sharding (mÃªme requÃªte):
â†’ CiblÃ© vers chunks dans la plage
â†’ 1-3 shards typiquement
â†’ Latence: ~10-15ms
â†’ â­â­â­â­â­ Optimal

CONCLUSION: Hashed Sharding inadaptÃ© pour range queries
```

### RequÃªtes Sans Shard Key (Scatter-Gather)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REQUÃŠTE SANS SHARD KEY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

db.users.find({ email: "john@example.com" })
// email n'est PAS la shard key

// Comportement identique Range ou Hashed:
// â†’ Scatter-gather sur tous shards
// â†’ Index secondaire aide mais ne change pas le routage

// Hashed Sharding n'a AUCUN avantage ici
// MÃªme performance mÃ©diocre que Range Sharding
```

## Garantie de Distribution Uniforme

### Preuve MathÃ©matique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DISTRIBUTION UNIFORME: GARANTIE MATHÃ‰MATIQUE          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PropriÃ©tÃ© de la fonction de hachage:
â€¢ Hash range: [-2^63, 2^63-1] = 18,446,744,073,709,551,616 valeurs
â€¢ Distribution uniforme: P(hash âˆˆ [a,b]) = (b-a) / hash_range

Pour N shards avec chunks Ã©gaux:
â€¢ Chaque shard couvre hash_range / N
â€¢ ProbabilitÃ© d'insertion dans shard i: 1/N
â€¢ ThÃ©orÃ¨me limite centrale: Distribution converge vers uniforme

Exemple avec 4 shards, 1M insertions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shard A: 250,234 docs (25.02%) â† Ã‰cart: +0.09%       â”‚
â”‚ Shard B: 249,891 docs (24.99%) â† Ã‰cart: -0.04%       â”‚
â”‚ Shard C: 250,105 docs (25.01%) â† Ã‰cart: +0.04%       â”‚
â”‚ Shard D: 249,770 docs (24.98%) â† Ã‰cart: -0.08%       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰cart maximum: 0.09% (nÃ©gligeable)
Ã‰cart moyen: 0.06%

Vs Range Sharding avec shard key monotone:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Shard A: 0 docs       (0%)    â† Idle                 â”‚
â”‚ Shard B: 0 docs       (0%)    â† Idle                 â”‚
â”‚ Shard C: 0 docs       (0%)    â† Idle                 â”‚
â”‚ Shard D: 1,000,000 docs (100%) â† Hotspot             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰cart maximum: 75% (catastrophique)
```

### Test de Distribution RÃ©elle

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCRIPT DE VALIDATION DE DISTRIBUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Collection avec hashed sharding
sh.shardCollection("test.distribution", { key: "hashed" })

// Insert 1M documents avec clÃ©s sÃ©quentielles
for (let i = 0; i < 1000000; i++) {
  db.distribution.insertOne({ key: i, data: "..." })
}

// Analyser distribution
db.getSiblingDB("config").chunks.aggregate([
  { $match: { ns: "test.distribution" } },
  {
    $lookup: {
      from: "shards",
      localField: "shard",
      foreignField: "_id",
      as: "shard_info"
    }
  },
  { $unwind: "$shard_info" },
  {
    $group: {
      _id: "$shard",
      chunks: { $sum: 1 }
    }
  }
])

// RÃ©sultat typique (4 shards):
[
  { _id: "shard-a", chunks: 21 },  // 20.59%
  { _id: "shard-b", chunks: 20 },  // 19.61%
  { _id: "shard-c", chunks: 21 },  // 20.59%
  { _id: "shard-d", chunks: 20 }   // 19.61%
]
// Total: 102 chunks
// Ã‰cart: < 1 chunk (< 1%)

// Compter documents par shard (via explain):
db.distribution.find().explain("executionStats").executionStats.executionStages
// shards:
//   shard-a: nReturned: 250,234
//   shard-b: nReturned: 249,891
//   shard-c: nReturned: 250,105
//   shard-d: nReturned: 249,770

// Distribution: 25.02%, 24.99%, 25.01%, 24.98%
// Ã‰cart max: 0.09% âœ… PARFAIT
```

## StratÃ©gies d'Optimisation

### StratÃ©gie 1 : PrÃ©-CrÃ©ation de Chunks (Hashed)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRE-SPLIT POUR HASHED SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Par dÃ©faut, MongoDB crÃ©e 2 chunks par shard
// Pour 10 shards: 20 chunks initiaux

// Pour gros volumes, augmenter:
sh.shardCollection("app.collection",
  { key: "hashed" },
  false,  // unique
  {
    numInitialChunks: 1024  // CrÃ©er 1024 chunks initiaux
  }
)

// Distribution rÃ©sultante:
// 1024 chunks rÃ©partis uniformÃ©ment sur 10 shards
// = ~102 chunks par shard immÃ©diatement

// Avantages:
// âœ… Pas de splits pendant bulk insert
// âœ… Meilleure parallÃ©lisation inserts
// âœ… Pas d'overhead balancer initial

// Calcul optimal de numInitialChunks:
numInitialChunks = CEIL(
  expected_data_size_GB / chunkSize_MB Ã— nb_shards Ã— 2
)

// Exemple:
// - 1 TB de donnÃ©es attendu
// - Chunk size: 128 MB
// - 10 shards
numInitialChunks = CEIL(1024 GB / 0.128 GB Ã— 10 Ã— 2)
                 = CEIL(8000 Ã— 10 Ã— 2)
                 = CEIL(160000)
                 = 160000

// âš ï¸ ATTENTION: numInitialChunks limitÃ© Ã  ~8192
// Si besoin plus: Laisser auto-split pendant insert
```

### StratÃ©gie 2 : Compound Hashed (MongoDB 4.4+)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOUND HASHED: MEILLEUR DES DEUX MONDES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ProblÃ¨me classique: IoT time-series
// - Besoin distribution uniforme (hashed)
// - Besoin range queries sur timestamp (range)

// Solution: Premier champ hashed, suivants range
sh.shardCollection("iot.metrics",
  { device_id: "hashed", timestamp: 1 }
)

// Fonctionnement:
// 1. device_id hachÃ© â†’ Distribution uniforme entre shards
// 2. Sur chaque shard, chunks organisÃ©s par timestamp

// Exemple de chunks:
// Shard A:
//   [hash(dev-001), 2024-12-01] to [hash(dev-001), 2024-12-02]
//   [hash(dev-001), 2024-12-02] to [hash(dev-001), 2024-12-03]
//   [hash(dev-042), 2024-12-01] to [hash(dev-042), 2024-12-02]
//   ...
// Shard B:
//   [hash(dev-017), 2024-12-01] to [hash(dev-017), 2024-12-02]
//   ...

// RequÃªte 1: Par device (excellent)
db.metrics.find({
  device_id: "dev-001",
  timestamp: { $gte: ISODate("2024-12-07") }
})
// â†’ hash(dev-001) â†’ 1 shard spÃ©cifique
// â†’ Range scan sur timestamp efficace
// Latence: ~5-10ms âœ…âœ…

// RequÃªte 2: Global par timestamp (scatter-gather)
db.metrics.find({
  timestamp: { $gte: ISODate("2024-12-07") }
})
// â†’ Tous shards (device_id manquant)
// â†’ Mais range scan efficace par shard
// Latence: ~30-50ms âš ï¸

// Insertions: Distribution parfaite
// Chaque device hachÃ© vers diffÃ©rent shard
// Pas de hotspot mÃªme avec timestamps monotones âœ…
```

### StratÃ©gie 3 : Index Secondaires pour Patterns Non-Hashed

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTIMISER REQUÃŠTES NON-SHARD-KEY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Shard key: { user_id: "hashed" }
sh.shardCollection("app.users", { user_id: "hashed" })

// RequÃªtes frÃ©quentes:
// 1. Par user_id: CiblÃ© âœ…
// 2. Par email: Scatter-gather âŒ

// Solution: Index secondaire sur email
db.users.createIndex({ email: 1 })

// Impact sur requÃªte par email:
db.users.find({ email: "john@example.com" })

// AVANT index:
// â†’ Scatter-gather avec collection scan
// â†’ TOUS documents de TOUS shards scannÃ©s
// â†’ Latence: 200-500ms âŒ

// APRÃˆS index:
// â†’ Scatter-gather avec index scan
// â†’ Index lookup rapide sur chaque shard
// â†’ Latence: 20-40ms âš ï¸ (meilleur mais toujours scatter)

// Note: Index ne change PAS le routage
// Toujours scatter-gather, mais scan plus rapide

// Pour vraiment optimiser:
// â†’ ConsidÃ©rer changer shard key si email est query principale
// â†’ Ou dupliquer email dans shard key (compound)
sh.shardCollection("app.users", { email: "hashed" })
```

### StratÃ©gie 4 : Batch Inserts ParallÃ¨les

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAXIMISER THROUGHPUT AVEC HASHED SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Hashed sharding distribue uniformÃ©ment
// â†’ ParallÃ©liser inserts pour utiliser tous shards

// âŒ MAUVAIS: Inserts sÃ©quentiels
for (let i = 0; i < 1000000; i++) {
  db.collection.insertOne({ user_id: i, ... })
}
// Un seul thread â†’ Utilise 1 connexion
// MÃªme si distribuÃ©, throughput limitÃ©

// âœ… BON: Inserts parallÃ¨les
const threads = 10  // 10 workers parallÃ¨les

async function insertWorker(start, end) {
  for (let i = start; i < end; i++) {
    await db.collection.insertOne({ user_id: i, ... })
  }
}

// Lancer 10 threads
const promises = []
const batchSize = Math.floor(1000000 / threads)

for (let t = 0; t < threads; t++) {
  const start = t * batchSize
  const end = (t + 1) * batchSize
  promises.push(insertWorker(start, end))
}

await Promise.all(promises)

// RÃ©sultat:
// - 10 connexions simultanÃ©es
// - Distribution sur tous shards
// - Throughput: 10Ã— plus rapide

// âœ… MEILLEUR: Bulk inserts parallÃ¨les
async function bulkInsertWorker(start, end, bulkSize) {
  for (let i = start; i < end; i += bulkSize) {
    const docs = []
    for (let j = 0; j < bulkSize && (i + j) < end; j++) {
      docs.push({ user_id: i + j, ... })
    }
    await db.collection.insertMany(docs, { ordered: false })
  }
}

// ordered: false â†’ Continue mÃªme si erreur sur 1 doc
// Throughput: 50-100Ã— plus rapide que inserts individuels
```

## Cas d'Usage DÃ©taillÃ©s

### Cas 1 : Session Store / Cache DistribuÃ©

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Sessions utilisateurs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Document structure:
{
  _id: ObjectId("..."),
  session_id: "sess-a1b2c3d4e5f6",
  user_id: 789012,
  created_at: ISODate("2024-12-08T10:30:00Z"),
  expires_at: ISODate("2024-12-08T11:30:00Z"),
  data: {
    cart: [...],
    preferences: {...}
  }
}

// Volume: 10M sessions actives, 100k creates/sec
// RequÃªtes: 100% par session_id (accÃ¨s alÃ©atoire)
// Pattern: Pas de range queries, pas de scans

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHARD KEY DESIGN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sh.shardCollection("app.sessions", { session_id: "hashed" })

// Justification:
// âœ… session_id gÃ©nÃ©rÃ© alÃ©atoirement (UUID v4)
// âœ… Hashed garantit distribution mÃªme si pattern change
// âœ… 100% accÃ¨s par clÃ© exacte (pas de range)
// âœ… Ã‰limine tout risque de hotspot

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// RequÃªte 1: RÃ©cupÃ©rer session (99% du trafic)
db.sessions.findOne({ session_id: "sess-a1b2c3d4e5f6" })

// Routage: CIBLÃ‰
// - hash(session_id) â†’ 1 chunk spÃ©cifique
// - 1 seul shard
// Latence: ~3-5ms âœ…âœ…

// RequÃªte 2: CrÃ©er session (100k/sec)
db.sessions.insertOne({ session_id: "sess-...", ... })

// Distribution: PARFAITE
// 100k inserts/sec rÃ©partis uniformÃ©ment:
// - Cluster 10 shards: 10k inserts/sec par shard
// - Chaque shard gÃ¨re sa part sans hotspot
// Throughput: LinÃ©aire avec nombre de shards âœ…âœ…

// RequÃªte 3: Supprimer sessions expirÃ©es (batch pÃ©riodique)
db.sessions.deleteMany({
  expires_at: { $lt: new Date() }
})

// Routage: SCATTER-GATHER
// - Tous shards interrogÃ©s
// - Mais opÃ©ration pÃ©riodique (toutes les 5 min)
// - Impact acceptable âš ï¸

// Optimisation TTL Index:
db.sessions.createIndex(
  { expires_at: 1 },
  { expireAfterSeconds: 0 }
)
// MongoDB supprime automatiquement
// Pas besoin de deleteMany manual
```

### Cas 2 : User Profile Store (High Volume)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Profils utilisateurs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Document structure:
{
  _id: ObjectId("..."),
  user_id: 12345678,
  username: "john_doe",
  email: "john@example.com",
  created_at: ISODate("2024-01-15"),
  profile: {
    name: "John Doe",
    avatar: "https://...",
    bio: "..."
  },
  stats: {
    posts: 1523,
    followers: 5432,
    following: 234
  }
}

// Volume: 500M users, croissance 10M/mois
// RequÃªtes:
// - 70%: Par user_id (profile view, update)
// - 20%: Par username (login, search)
// - 10%: Par email (password reset)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHARD KEY DESIGN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sh.shardCollection("social.users", { user_id: "hashed" })

// Justification:
// âœ… user_id auto-increment MAIS hashed Ã©limine hotspot
// âœ… 70% requÃªtes par user_id (ciblÃ©es)
// âŒ 30% requÃªtes nÃ©cessitent indexes secondaires

// Alternative considÃ©rÃ©e et rejetÃ©e:
// { user_id: 1 } (range) âŒ
// â†’ user_id auto-increment = hotspot permanent

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIGURATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Indexes secondaires pour autres patterns:
db.users.createIndex({ username: 1 }, { unique: true })
db.users.createIndex({ email: 1 }, { unique: true })
db.users.createIndex({ "stats.followers": -1 })

// Pre-split pour 500M users attendus:
sh.shardCollection("social.users",
  { user_id: "hashed" },
  false,
  { numInitialChunks: 4096 }  // 4096 chunks initiaux
)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// RequÃªte 1: Profile par user_id (70%)
db.users.findOne({ user_id: 12345678 })

// Routage: CIBLÃ‰ âœ…âœ…
// Latence: ~3ms

// RequÃªte 2: Login par username (20%)
db.users.findOne({ username: "john_doe" })

// Routage: SCATTER-GATHER âš ï¸
// Index secondaire amÃ©liore scan
// Latence: ~15-20ms (acceptable pour login)

// RequÃªte 3: Top users par followers (analytics)
db.users.find().sort({ "stats.followers": -1 }).limit(100)

// Routage: SCATTER-GATHER
// Index secondaire utilisÃ© sur chaque shard
// Merge top 100 de chaque shard
// Latence: ~50ms (acceptable pour analytics)

// Insertions (10M/mois = ~4 inserts/sec):
// Distribution: PARFAITE âœ…
// Aucun hotspot mÃªme avec user_id sÃ©quentiel
```

### Cas 3 : Distributed Locking / Coordination

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Verrous distribuÃ©s
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Document structure:
{
  _id: ObjectId("..."),
  resource_id: "order-processing-queue-1",
  locked_by: "worker-node-5",
  locked_at: ISODate("2024-12-08T10:30:00Z"),
  expires_at: ISODate("2024-12-08T10:35:00Z"),
  metadata: { ... }
}

// Volume: 1M resources, 10k lock operations/sec
// RequÃªtes: 100% par resource_id (acquire/release lock)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHARD KEY DESIGN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sh.shardCollection("coordination.locks",
  { resource_id: "hashed" }
)

// Justification:
// âœ… resource_id distribution inconnue a priori
// âœ… Hashed garantit pas de hotspot
// âœ… AccÃ¨s exclusivement par resource_id
// âœ… Latence critique (lock acquisition)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// OPÃ‰RATIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Acquire lock (findAndModify atomique):
db.locks.findAndModify({
  query: {
    resource_id: "order-processing-queue-1",
    $or: [
      { locked_by: null },
      { expires_at: { $lt: new Date() } }
    ]
  },
  update: {
    $set: {
      locked_by: "worker-node-5",
      locked_at: new Date(),
      expires_at: new Date(Date.now() + 300000) // +5 min
    }
  },
  new: true,
  upsert: false
})

// Routage: CIBLÃ‰ âœ…
// hash(resource_id) â†’ 1 shard
// Latence: ~5ms (critique pour locks)

// Release lock:
db.locks.updateOne(
  {
    resource_id: "order-processing-queue-1",
    locked_by: "worker-node-5"
  },
  { $set: { locked_by: null } }
)

// Routage: CIBLÃ‰ âœ…
// Latence: ~3ms

// Performance avec 10k operations/sec:
// 10 shards â†’ 1k ops/sec par shard
// Distribution uniforme garantie âœ…
// Pas de contention entre workers
```

## Anti-Patterns SpÃ©cifiques

### ðŸš« Anti-Pattern 1 : Hashed sur Workload Range-Heavy

```javascript
// âŒ ANTI-PATTERN CRITIQUE

// Collection: Time-series logs
sh.shardCollection("logs.events", { timestamp: "hashed" })

// RequÃªtes typiques:
db.events.find({
  timestamp: { $gte: ISODate("2024-12-07") }
})
// â†’ SCATTER-GATHER sur tous shards
// â†’ Latence: 100-200ms âŒ

db.events.find({
  timestamp: {
    $gte: ISODate("2024-12-07"),
    $lt: ISODate("2024-12-08")
  }
})
// â†’ SCATTER-GATHER encore âŒ
// â†’ Impossible de cibler par plage de timestamp

// Impact mesurÃ© sur 10 shards:
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 100% des requÃªtes â†’ scatter-gather             â”‚
// â”‚ Latence moyenne: 150ms                         â”‚
// â”‚ Network traffic: Ã— 10                          â”‚
// â”‚ CPU mongos: Ã©levÃ© (merge complexe)             â”‚
// â”‚                                                â”‚
// â”‚ Avec Range Sharding:                           â”‚
// â”‚ 80% des requÃªtes â†’ ciblÃ©es (1-2 shards)        â”‚
// â”‚ Latence moyenne: 15ms                          â”‚
// â”‚ â†’ 10Ã— plus rapide!                             â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Option 1: Range Sharding avec prÃ©fixe
sh.shardCollection("logs.events",
  { source: 1, timestamp: 1 }  // âœ…
)

// Option 2: Compound Hashed (MongoDB 4.4+)
sh.shardCollection("logs.events",
  { source: "hashed", timestamp: 1 }  // âœ…
)
```

### ðŸš« Anti-Pattern 2 : Hashed Index Inutile

```javascript
// âŒ ANTI-PATTERN

sh.shardCollection("app.data", { field: "hashed" })

// Plus tard, crÃ©er index hashed manuel:
db.data.createIndex({ field: "hashed" })

// ProblÃ¨me:
// 1. Index hashed DÃ‰JÃ€ crÃ©Ã© automatiquement par sharding
// 2. Duplication inutile
// 3. Overhead storage et maintenance

// VÃ©rifier indexes:
db.data.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: "_id_" },
  { v: 2, key: { field: "hashed" }, name: "field_hashed" },  // Auto-crÃ©Ã©
  { v: 2, key: { field: "hashed" }, name: "field_hashed_1" } // Duplicate âŒ
]

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// NE PAS crÃ©er index manuel sur shard key hashed
// DÃ©jÃ  gÃ©rÃ© automatiquement par MongoDB

// Si besoin index secondaire:
// CrÃ©er sur AUTRE champ
db.data.createIndex({ other_field: 1 })  // âœ…
```

### ðŸš« Anti-Pattern 3 : Hashed Compound InversÃ©

```javascript
// âŒ ANTI-PATTERN

// Intent: Time-series avec distribution
sh.shardCollection("metrics.data",
  { timestamp: 1, device_id: "hashed" }  // âŒ Ordre inversÃ©
)

// ProblÃ¨me:
// timestamp en prÃ©fixe (monotone)
// â†’ HOTSPOT sur chunk avec MaxKey
// â†’ Hashed sur device_id ne sert Ã  RIEN
// â†’ Pire des deux mondes

// Distribution rÃ©sultante:
// TOUS les inserts rÃ©cents â†’ MÃªme chunk
// Hash de device_id ne distribue PAS (pas en prÃ©fixe)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Hashed en PRÃ‰FIXE:
sh.shardCollection("metrics.data",
  { device_id: "hashed", timestamp: 1 }  // âœ… Correct
)

// Maintenant:
// device_id hachÃ© â†’ Distribution uniforme
// timestamp range â†’ Queries efficaces par device
```

### ðŸš« Anti-Pattern 4 : Tentative de Range Query sur Hashed

```javascript
// âŒ ANTI-PATTERN

sh.shardCollection("users.accounts", { user_id: "hashed" })

// Tentative d'optimiser range query:
db.accounts.find({
  user_id: { $gte: 1000, $lte: 2000 }
}).hint({ user_id: "hashed" })

// ProblÃ¨me:
// hint() ne change PAS le routage
// Toujours scatter-gather
// Index hashed ne PEUT PAS faire range scan

// De plus, erreur potentielle:
// $gte/$lte sur champ hashed compare HASHES, pas valeurs!
// hash(1000) = -7842693339044312345
// hash(1500) = 3456789012345678901
// hash(2000) = 5678901234567890123
//
// $gte: hash(1000), $lte: hash(2000)
// Ne retourne PAS les valeurs 1000-2000!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Si range queries nÃ©cessaires:
// 1. Changer pour Range Sharding
// 2. Ou accepter scatter-gather
// 3. Ou remodÃ©liser pour Ã©viter ranges
```

### ðŸš« Anti-Pattern 5 : Hashed sur ClÃ© avec Faible CardinalitÃ©

```javascript
// âŒ ANTI-PATTERN

sh.shardCollection("app.documents",
  { category: "hashed" }
)
// category: "electronics", "books", "clothing" (3 valeurs)

// ProblÃ¨me:
// Hashed distribue uniformÃ©ment... les 3 valeurs
// hash("electronics") â†’ Chunk A
// hash("books")       â†’ Chunk B
// hash("clothing")    â†’ Chunk C

// Maximum 3 chunks possibles
// â†’ Impossible de scale au-delÃ  de 3 shards
// â†’ Hashing INUTILE (mÃªme rÃ©sultat qu'avec range)

// Pire:
// Si 90% des docs sont "electronics"
// â†’ 90% des donnÃ©es sur Chunk A / Shard A
// â†’ DÃ©sÃ©quilibre massif

// Hashed ne rÃ©sout PAS problÃ¨me de faible cardinalitÃ©!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Compound avec haute cardinalitÃ©:
sh.shardCollection("app.documents",
  { category: 1, document_id: 1 }  // âœ…
)
// Ou:
sh.shardCollection("app.documents",
  { document_id: "hashed" }  // âœ… (si doc_id haute cardinalitÃ©)
)
```

## Comparaison Range vs Hashed

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         RANGE vs HASHED: TABLEAU COMPARATIF DÃ‰TAILLÃ‰         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Distribution Insertions                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
â”‚  Range:  âš ï¸âš ï¸ (DÃ©pend du pattern, risque hotspot)           â”‚
â”‚  Hashed: âœ…âœ…âœ… (Garantie mathÃ©matique uniforme)             â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Range Queries                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚  Range:  âœ…âœ…âœ… (Optimal, ciblÃ© sur plage)                   â”‚
â”‚  Hashed: âŒâŒ (Scatter-gather obligatoire)                   â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Point Queries (clÃ© exacte)                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚  Range:  âœ…âœ…âœ… (CiblÃ©, O(1))                                â”‚
â”‚  Hashed: âœ…âœ…âœ… (CiblÃ©, O(1))                                â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: $in Queries                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚  Range:  âœ…âœ… (Partiellement ciblÃ©)                          â”‚
â”‚  Hashed: âœ…âœ… (Partiellement ciblÃ©)                          â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Archivage par Plage                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚  Range:  âœ…âœ…âœ… (Drop chunks par plage facile)               â”‚
â”‚  Hashed: âŒâŒ (Impossible, dates mÃ©langÃ©es)                  â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: PredictabilitÃ© Localisation                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
â”‚  Range:  âœ…âœ…âœ… (Valeur â†’ chunk prÃ©visible)                  â”‚
â”‚  Hashed: âŒ (Hash opaque, non prÃ©visible)                    â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Overhead Metadata                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚  Range:  âš ï¸ (Variable selon splits)                         â”‚
â”‚  Hashed: âœ… (PrÃ©visible, split rÃ©gulier)                     â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: ComplexitÃ© OpÃ©rationnelle                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                           â”‚
â”‚  Range:  âš ï¸âš ï¸ (Monitoring hotspots requis)                  â”‚
â”‚  Hashed: âœ…âœ… (Set and forget)                               â”‚
â”‚                                                              â”‚
â”‚  CRITÃˆRE: Jumbo Chunks                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚  Range:  âš ï¸âš ï¸ (Risque si faible cardinalitÃ©)                â”‚
â”‚  Hashed: âœ… (Rare, distribution uniforme)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONCLUSION:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Choisir HASHED si:                                           â”‚
â”‚ âœ… Insertions high-volume monotones (timestamp, auto-incr)   â”‚
â”‚ âœ… RequÃªtes principalement par clÃ© exacte (90%+)             â”‚
â”‚ âœ… Pas de range queries critiques                            â”‚
â”‚ âœ… SimplicitÃ© opÃ©rationnelle prioritaire                     â”‚
â”‚                                                              â”‚
â”‚ Choisir RANGE si:                                            â”‚
â”‚ âœ… Range queries frÃ©quentes (30%+)                           â”‚
â”‚ âœ… Archivage par plage nÃ©cessaire                            â”‚
â”‚ âœ… Localisation prÃ©visible importante                        â”‚
â”‚ âœ… Insertions non-monotones ou avec prÃ©fixe                  â”‚
â”‚                                                              â”‚
â”‚ Choisir COMPOUND HASHED si:                                  â”‚
â”‚ âœ… Besoin distribution + range queries                       â”‚
â”‚ âœ… MongoDB 4.4+                                              â”‚
â”‚ âœ… Pattern IoT / time-series par entitÃ©                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Monitoring et Diagnostics

### MÃ©triques SpÃ©cifiques Hashed

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONITORING HASHED SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. VÃ‰RIFIER DISTRIBUTION (Devrait Ãªtre ~uniforme)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db.getSiblingDB("config").chunks.aggregate([
  { $match: { ns: "db.collection" } },
  { $group: { _id: "$shard", count: { $sum: 1 } } },
  { $sort: { count: -1 } }
])

// RÃ©sultat idÃ©al (4 shards):
[
  { _id: "shard-a", count: 251 },  // 25.1%
  { _id: "shard-b", count: 250 },  // 25.0%
  { _id: "shard-c", count: 249 },  // 24.9%
  { _id: "shard-d", count: 250 }   // 25.0%
]

// Alerte si Ã©cart > 5% (inhabituel pour hashed)

// 2. ANALYSER SCATTER-GATHER RATIO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰chantillonner requÃªtes rÃ©centes:
db.system.profile.aggregate([
  { $match: { ns: "db.collection", ts: { $gte: ISODate("...") } } },
  {
    $group: {
      _id: {
        targeted: { $cond: [{ $lte: ["$nShards", 2] }, "targeted", "scatter"] }
      },
      count: { $sum: 1 }
    }
  }
])

// RÃ©sultat:
[
  { _id: { targeted: "targeted" }, count: 150000 },   // 75%
  { _id: { targeted: "scatter" }, count: 50000 }      // 25%
]

// Pour Hashed Sharding optimal:
// - targeted devrait Ãªtre 80-90%+
// Si scatter > 30% â†’ ConsidÃ©rer si Hashed appropriÃ©

// 3. TAILLE DES CHUNKS (UniformitÃ©)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db.getSiblingDB("config").chunks.aggregate([
  { $match: { ns: "db.collection" } },
  {
    $group: {
      _id: null,
      avgSize: { $avg: "$estimatedDataSize" },
      stdDev: { $stdDevPop: "$estimatedDataSize" },
      minSize: { $min: "$estimatedDataSize" },
      maxSize: { $max: "$estimatedDataSize" }
    }
  }
])

// Hashed devrait avoir faible stdDev
// stdDev / avgSize < 0.2 (20%) = bon

// 4. JUMBO CHUNKS (Devrait Ãªtre 0)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db.getSiblingDB("config").chunks.countDocuments({
  ns: "db.collection",
  jumbo: true
})

// Hashed: jumbo chunks TRÃˆS RARES
// Si > 0 â†’ ProblÃ¨me (probablement faible cardinalitÃ©)
```

## RÃ©sumÃ©

Le **Hashed Sharding** offre une distribution parfaitement uniforme au prix de l'efficacitÃ© des range queries :

**Avantages :**
- âœ…âœ…âœ… Distribution uniforme garantie mathÃ©matiquement
- âœ…âœ… Ã‰limine complÃ¨tement hotspots monotones
- âœ…âœ… SimplicitÃ© opÃ©rationnelle (set and forget)
- âœ… PrÃ©visibilitÃ© des performances

**Limitations :**
- âŒâŒ Range queries â†’ scatter-gather obligatoire
- âŒ Archivage par plage impossible
- âŒ Localisation non prÃ©visible
- âš ï¸ NÃ©cessite haute cardinalitÃ©

**Cas d'usage idÃ©aux :**
- High-volume inserts avec clÃ©s monotones
- Session stores, caches distribuÃ©s
- User profiles avec accÃ¨s par ID
- Distributed locking
- 90%+ requÃªtes par clÃ© exacte

**Optimisations clÃ©s :**
1. Pre-splitting avec numInitialChunks
2. Compound hashed (MongoDB 4.4+) pour time-series
3. Index secondaires pour patterns non-shard-key
4. Batch inserts parallÃ¨les

**Anti-patterns critiques :**
- âŒ Hashed sur workload range-heavy
- âŒ Compound hashed inversÃ© (monotone en prÃ©fixe)
- âŒ Tentative range query sur hashed
- âŒ Hashed sur faible cardinalitÃ©

**Monitoring essentiel :**
- Distribution chunks (Ã©cart < 5%)
- Scatter-gather ratio (< 30% optimal)
- Jumbo chunks (objectif = 0)

Le Hashed Sharding excelle pour les workloads d'insertions massives avec accÃ¨s principalement par clÃ© exacte. La garantie de distribution uniforme en fait le choix par dÃ©faut pour Ã©liminer les hotspots, Ã  condition d'accepter le coÃ»t des scatter-gather pour les range queries.

---


â­ï¸ [Zone Sharding](/10-sharding/04.3-zone-sharding.md)
