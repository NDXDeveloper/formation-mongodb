ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 10.4.3 Zone Sharding

## Introduction

Le **Zone Sharding** (partitionnement par zone) est une stratÃ©gie avancÃ©e qui permet de **contrÃ´ler explicitement** la distribution des chunks en assignant des plages de valeurs de shard key Ã  des **zones logiques**, elles-mÃªmes mappÃ©es Ã  des shards spÃ©cifiques. Cette approche offre un contrÃ´le granulaire sur la localisation des donnÃ©es, essentiel pour la conformitÃ© gÃ©ographique (RGPD), l'optimisation de la latence, l'isolation multi-tenant et le tiering de stockage.

Le Zone Sharding se superpose au Range ou Hashed Sharding et ajoute une couche de politique de placement des donnÃ©es. Cette section explore en profondeur la configuration, les cas d'usage et les stratÃ©gies de gestion du Zone Sharding.

## Concepts Fondamentaux

### Architecture des Zones

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ARCHITECTURE ZONE SHARDING                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COUCHE 1: SHARDS PHYSIQUES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Shard A     â”‚  â”‚  Shard B     â”‚  â”‚  Shard C     â”‚
â”‚  (EU-Paris)  â”‚  â”‚ (US-Virginia)â”‚  â”‚(ASIA-Tokyo)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         â†‘                â†‘                â†‘
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
COUCHE 2: ZONES LOGIQUES (Tags)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Zone "EU"  â”‚  â”‚   Zone "US"  â”‚  â”‚  Zone "ASIA" â”‚
â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
â”‚ Tags:        â”‚  â”‚ Tags:        â”‚  â”‚ Tags:        â”‚
â”‚ - Shard A    â”‚  â”‚ - Shard B    â”‚  â”‚ - Shard C    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         â†‘                â†‘                â†‘
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
COUCHE 3: RANGES DE SHARD KEY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Collection: users                                    â”‚
â”‚ Shard Key: { country: 1, user_id: 1 }                â”‚
â”‚                                                      â”‚
â”‚ Zone Ranges:                                         â”‚
â”‚                                                      â”‚
â”‚ [FR, MinKey] to [FR, MaxKey]    â†’ Zone "EU"          â”‚
â”‚ [DE, MinKey] to [DE, MaxKey]    â†’ Zone "EU"          â”‚
â”‚ [IT, MinKey] to [IT, MaxKey]    â†’ Zone "EU"          â”‚
â”‚                                                      â”‚
â”‚ [US, MinKey] to [US, MaxKey]    â†’ Zone "US"          â”‚
â”‚ [CA, MinKey] to [CA, MaxKey]    â†’ Zone "US"          â”‚
â”‚                                                      â”‚
â”‚ [JP, MinKey] to [JP, MaxKey]    â†’ Zone "ASIA"        â”‚
â”‚ [CN, MinKey] to [CN, MaxKey]    â†’ Zone "ASIA"        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLUX DE DONNÃ‰ES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Document { country: "FR", user_id: 12345 }
    â†“
Range [FR, MinKey] to [FR, MaxKey]
    â†“
Zone "EU"
    â†“
Shard A (EU-Paris)
```

### Collections de Metadata

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// METADATA ZONE SHARDING DANS CONFIG.SHARDS ET CONFIG.TAGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. config.shards - Tags assignÃ©s aux shards
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db.getSiblingDB("config").shards.find().pretty()

{
  "_id": "shard-eu-paris-1",
  "host": "shard-eu-paris-1/mongo-eu-1:27018,...",
  "state": 1,
  "tags": ["EU", "premium"]  // â† Tags du shard
}

{
  "_id": "shard-us-virginia-1",
  "host": "shard-us-virginia-1/mongo-us-1:27018,...",
  "state": 1,
  "tags": ["US"]  // â† Tag du shard
}

// 2. config.tags - Ranges assignÃ©s aux zones
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db.getSiblingDB("config").tags.find().pretty()

{
  "_id": ObjectId("..."),
  "ns": "app.users",
  "tag": "EU",  // â† Nom de la zone
  "min": { "country": "FR", "user_id": MinKey },
  "max": { "country": "FR", "user_id": MaxKey }
}

{
  "_id": ObjectId("..."),
  "ns": "app.users",
  "tag": "EU",
  "min": { "country": "DE", "user_id": MinKey },
  "max": { "country": "DE", "user_id": MaxKey }
}

{
  "_id": ObjectId("..."),
  "ns": "app.users",
  "tag": "US",
  "min": { "country": "US", "user_id": MinKey },
  "max": { "country": "US", "user_id": MaxKey }
}

// 3. Lien Zones â†’ Shards
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Le balancer utilise ces metadata pour placer chunks:
//
// Chunk avec range [FR, 1000] to [FR, 2000]:
//   1. Recherche tag pour ce range dans config.tags
//      â†’ tag = "EU"
//   2. Recherche shards avec tag "EU" dans config.shards
//      â†’ shard-eu-paris-1
//   3. Place chunk sur shard-eu-paris-1
```

## Configuration ComplÃ¨te

### Ã‰tape 1 : CrÃ©er les Zones (Tags)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION ZONES - Ã‰TAPE PAR Ã‰TAPE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario: Application globale avec donnÃ©es utilisateurs
// 3 rÃ©gions: Europe, US, Asie

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. ASSIGNER TAGS AUX SHARDS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Zone Europe (2 shards pour HA)
sh.addShardToZone("shard-eu-paris-1", "EU")
sh.addShardToZone("shard-eu-frankfurt-1", "EU")

// Zone US (2 shards)
sh.addShardToZone("shard-us-virginia-1", "US")
sh.addShardToZone("shard-us-oregon-1", "US")

// Zone Asie (2 shards)
sh.addShardToZone("shard-asia-tokyo-1", "ASIA")
sh.addShardToZone("shard-asia-singapore-1", "ASIA")

// VÃ©rification:
sh.status()
// Output:
//   shards:
//     shard-eu-paris-1     tags: [ "EU" ]
//     shard-eu-frankfurt-1 tags: [ "EU" ]
//     shard-us-virginia-1  tags: [ "US" ]
//     ...

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2. DÃ‰FINIR RANGES POUR CHAQUE ZONE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Collection users avec shard key: { country: 1, user_id: 1 }
sh.shardCollection("app.users", { country: 1, user_id: 1 })

// Zone EU - Pays europÃ©ens
const euCountries = ["FR", "DE", "IT", "ES", "UK", "NL", "BE", "PT"]

euCountries.forEach(country => {
  sh.updateZoneKeyRange(
    "app.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    "EU"
  )
})

// Zone US - AmÃ©rique du Nord
const usCountries = ["US", "CA", "MX"]

usCountries.forEach(country => {
  sh.updateZoneKeyRange(
    "app.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    "US"
  )
})

// Zone ASIA - Asie-Pacifique
const asiaCountries = ["JP", "CN", "KR", "SG", "AU", "IN"]

asiaCountries.forEach(country => {
  sh.updateZoneKeyRange(
    "app.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    "ASIA"
  )
})

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3. VÃ‰RIFIER CONFIGURATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Lister toutes les zones:
db.getSiblingDB("config").tags.find({ ns: "app.users" }).pretty()

// VÃ©rifier distribution des chunks:
db.getSiblingDB("config").chunks.aggregate([
  { $match: { ns: "app.users" } },
  { $group: { _id: "$shard", count: { $sum: 1 } } }
])

// AprÃ¨s migration des chunks par le balancer:
// [
//   { _id: "shard-eu-paris-1", count: 35 },
//   { _id: "shard-eu-frankfurt-1", count: 33 },
//   { _id: "shard-us-virginia-1", count: 18 },
//   { _id: "shard-us-oregon-1", count: 16 },
//   { _id: "shard-asia-tokyo-1", count: 12 },
//   { _id: "shard-asia-singapore-1", count: 11 }
// ]
```

### Ã‰tape 2 : Gestion des Zones Orphelines

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GÃ‰RER PAYS NON ASSIGNÃ‰S Ã€ UNE ZONE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ProblÃ¨me: Nouveau pays "BR" (BrÃ©sil) non assignÃ©
// Document: { country: "BR", user_id: 123 }
// â†’ Va sur n'importe quel shard (pas de contrainte)

// Solution 1: Zone "GLOBAL" par dÃ©faut
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// CrÃ©er zone catch-all
sh.addShardToZone("shard-us-virginia-1", "GLOBAL")

// Assigner range catch-all (APRÃˆS zones spÃ©cifiques)
// âš ï¸ MinKey Ã  MaxKey capture tout ce qui n'est pas assignÃ©
sh.updateZoneKeyRange(
  "app.users",
  { country: MinKey, user_id: MinKey },
  { country: MaxKey, user_id: MaxKey },
  "GLOBAL"
)

// Ordre d'Ã©valuation par le balancer:
// 1. Ranges spÃ©cifiques (FR, DE, US, etc.) en premier
// 2. Range catch-all (MinKey-MaxKey) en dernier
// â†’ BR tombe dans catch-all â†’ Zone GLOBAL

// Solution 2: Zone "OTHER" explicite
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pour pays d'AmÃ©rique du Sud
sh.addShardToZone("shard-us-virginia-1", "LATAM")

const latamCountries = ["BR", "AR", "CL", "CO", "PE"]

latamCountries.forEach(country => {
  sh.updateZoneKeyRange(
    "app.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    "LATAM"
  )
})
```

### Ã‰tape 3 : Zones Multiples par Shard

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UN SHARD PEUT APPARTENIR Ã€ PLUSIEURS ZONES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario: Shard premium pour clients Enterprise

// Assigner shard Ã  plusieurs zones:
sh.addShardToZone("shard-premium-1", "EU")
sh.addShardToZone("shard-premium-1", "ENTERPRISE")

// RÃ©sultat:
db.getSiblingDB("config").shards.findOne({ _id: "shard-premium-1" })
{
  "_id": "shard-premium-1",
  "host": "...",
  "tags": ["EU", "ENTERPRISE"]  // â† Deux tags
}

// Utilisation:
// 1. Clients Enterprise EU â†’ Zone "ENTERPRISE"
sh.updateZoneKeyRange(
  "saas.data",
  { tenant_id: "enterprise-001", doc_id: MinKey },
  { tenant_id: "enterprise-001", doc_id: MaxKey },
  "ENTERPRISE"
)

// 2. Clients standard EU â†’ Zone "EU"
sh.updateZoneKeyRange(
  "saas.data",
  { tenant_id: "standard-001", doc_id: MinKey },
  { tenant_id: "standard-999", doc_id: MaxKey },
  "EU"
)

// Shard-premium-1 peut recevoir:
// - Chunks zone "EU" (clients standard)
// - Chunks zone "ENTERPRISE" (clients enterprise)
```

## Cas d'Usage DÃ©taillÃ©s

### Cas 1 : ConformitÃ© RGPD (RÃ©sidence des DonnÃ©es)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: DonnÃ©es personnelles utilisateurs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Contrainte RGPD:
// - DonnÃ©es citoyens EU doivent rester en EU
// - Transferts vers US interdits sans garanties

// Document structure:
{
  _id: ObjectId("..."),
  user_id: 123456,
  country: "FR",
  personal_data: {
    name: "Jean Dupont",
    email: "jean@example.fr",
    address: "..."
  },
  created_at: ISODate("2024-12-08")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIGURATION ZONES GÃ‰OGRAPHIQUES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Shards gÃ©ographiquement localisÃ©s:
// - shard-eu-paris-1, shard-eu-frankfurt-1 â†’ Europe
// - shard-us-virginia-1 â†’ USA (pour users US)

// Shard key: { country: 1, user_id: 1 }
sh.shardCollection("gdpr.users", { country: 1, user_id: 1 })

// Zone EU (RGPD)
sh.addShardToZone("shard-eu-paris-1", "GDPR-EU")
sh.addShardToZone("shard-eu-frankfurt-1", "GDPR-EU")

// Pays EU soumis RGPD (27 pays UE + UK/CH/NO)
const gdprCountries = [
  // UE-27
  "AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR",
  "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL",
  "PL", "PT", "RO", "SK", "SI", "ES", "SE",
  // Autres RGPD
  "UK", "CH", "NO", "IS", "LI"
]

gdprCountries.forEach(country => {
  sh.updateZoneKeyRange(
    "gdpr.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    "GDPR-EU"
  )
})

// Zone US
sh.addShardToZone("shard-us-virginia-1", "US")

sh.updateZoneKeyRange(
  "gdpr.users",
  { country: "US", user_id: MinKey },
  { country: "US", user_id: MaxKey },
  "US"
)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ‰RIFICATION CONFORMITÃ‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Audit: VÃ©rifier qu'aucune donnÃ©e EU n'est sur shard US
db.getSiblingDB("config").chunks.find({
  ns: "gdpr.users",
  shard: "shard-us-virginia-1",
  "min.country": { $in: gdprCountries }
})

// RÃ©sultat attendu: 0 chunks
// Si > 0 â†’ NON-CONFORMITÃ‰ RGPD!

// Script d'audit automatique:
function auditGDPRCompliance() {
  const violations = []

  const euShards = ["shard-eu-paris-1", "shard-eu-frankfurt-1"]
  const usShards = ["shard-us-virginia-1"]

  // VÃ©rifier qu'aucun chunk EU sur shard US
  usShards.forEach(shard => {
    const euChunksOnUS = db.getSiblingDB("config").chunks.find({
      ns: "gdpr.users",
      shard: shard,
      "min.country": { $in: gdprCountries }
    }).toArray()

    if (euChunksOnUS.length > 0) {
      violations.push({
        severity: "CRITICAL",
        shard: shard,
        chunks: euChunksOnUS.length,
        message: "EU data on US shard - GDPR violation"
      })
    }
  })

  if (violations.length === 0) {
    print("âœ… GDPR Compliance: OK")
  } else {
    print("âŒ GDPR Violations detected:")
    printjson(violations)
  }

  return violations
}

// ExÃ©cuter quotidiennement:
auditGDPRCompliance()
```

### Cas 2 : Multi-Tenant avec Isolation

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Documents SaaS multi-tenant
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Contraintes:
// - Whale tenants (> 1 TB) â†’ Shards dÃ©diÃ©s
// - Enterprise tenants â†’ Shards premium (SSD)
// - Standard tenants â†’ Shards partagÃ©s

// Document structure:
{
  _id: ObjectId("..."),
  tenant_id: "tenant-123",
  document_id: "doc-456",
  data: { ... }
}

// VolumÃ©trie:
// - BigCorp: 2 TB (whale)
// - MediumCorp: 500 GB (enterprise)
// - 1000+ petits tenants: < 10 GB chacun

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIGURATION TIERING MULTI-TENANT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Shard key: { tenant_id: 1, document_id: 1 }
sh.shardCollection("saas.documents",
  { tenant_id: 1, document_id: 1 }
)

// Tier 1: WHALE (Shards dÃ©diÃ©s)
sh.addShardToZone("shard-whale-bigcorp-1", "WHALE-BIGCORP")
sh.addShardToZone("shard-whale-bigcorp-2", "WHALE-BIGCORP")

sh.updateZoneKeyRange(
  "saas.documents",
  { tenant_id: "BigCorp", document_id: MinKey },
  { tenant_id: "BigCorp", document_id: MaxKey },
  "WHALE-BIGCORP"
)

// Tier 2: ENTERPRISE (Shards premium partagÃ©s)
sh.addShardToZone("shard-premium-1", "ENTERPRISE")
sh.addShardToZone("shard-premium-2", "ENTERPRISE")

// Liste tenants enterprise
const enterpriseTenants = [
  "MediumCorp", "TechStartup", "FinanceInc", "HealthCare"
]

enterpriseTenants.forEach(tenant => {
  sh.updateZoneKeyRange(
    "saas.documents",
    { tenant_id: tenant, document_id: MinKey },
    { tenant_id: tenant, document_id: MaxKey },
    "ENTERPRISE"
  )
})

// Tier 3: STANDARD (Shards standard partagÃ©s)
sh.addShardToZone("shard-standard-1", "STANDARD")
sh.addShardToZone("shard-standard-2", "STANDARD")
sh.addShardToZone("shard-standard-3", "STANDARD")

// Range catch-all pour petits tenants
sh.updateZoneKeyRange(
  "saas.documents",
  { tenant_id: "tenant-", document_id: MinKey },  // PrÃ©fixe commun
  { tenant_id: "tenant-~", document_id: MaxKey },
  "STANDARD"
)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BÃ‰NÃ‰FICES PAR TIER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// WHALE:
// âœ… Isolation complÃ¨te (pas d'impact noisy neighbor)
// âœ… Ressources dÃ©diÃ©es garanties
// âœ… SLA personnalisÃ© possible
// âœ… Tuning spÃ©cifique (indexes, cache)

// ENTERPRISE:
// âœ… Shards premium (SSD NVMe)
// âœ… Partage avec peers de mÃªme niveau
// âœ… Meilleure performance que standard
// âœ… SLA premium

// STANDARD:
// âœ… CoÃ»t optimisÃ© (shards partagÃ©s)
// âœ… Suffisant pour petits volumes
// âš ï¸ Peut subir impact whale si mal configurÃ©

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PROMOTION TENANT STANDARD â†’ ENTERPRISE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function promoteTenantToEnterprise(tenantId) {
  print(`Promoting ${tenantId} to Enterprise tier...`)

  // 1. CrÃ©er zone range pour ce tenant
  sh.updateZoneKeyRange(
    "saas.documents",
    { tenant_id: tenantId, document_id: MinKey },
    { tenant_id: tenantId, document_id: MaxKey },
    "ENTERPRISE"
  )

  // 2. Balancer migrera automatiquement chunks
  // vers shards premium (peut prendre heures/jours)

  print(`Migration initiated. Monitor with:`)
  print(`  db.getSiblingDB("config").chunks.find({ ns: "saas.documents", "min.tenant_id": "${tenantId}" })`)
}

// Utilisation:
promoteTenantToEnterprise("GrowingStartup")
```

### Cas 3 : Tiering Temporel (Hot/Warm/Cold)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Archives documentaires avec tiering
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Contraintes:
// - DonnÃ©es < 1 an: AccÃ¨s frÃ©quent (HOT) â†’ NVMe
// - DonnÃ©es 1-3 ans: AccÃ¨s modÃ©rÃ© (WARM) â†’ SSD
// - DonnÃ©es > 3 ans: Archives (COLD) â†’ HDD

// Document structure:
{
  _id: ObjectId("..."),
  year: 2024,
  month: 12,
  document_id: "doc-123",
  data: { ... },
  created_at: ISODate("2024-12-08")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIGURATION TIERING TEMPOREL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Shard key: { year: 1, month: 1, document_id: 1 }
sh.shardCollection("archive.documents",
  { year: 1, month: 1, document_id: 1 }
)

// Tier HOT: NVMe (annÃ©e courante)
sh.addShardToZone("shard-nvme-1", "HOT")
sh.addShardToZone("shard-nvme-2", "HOT")

const currentYear = 2024

for (let month = 1; month <= 12; month++) {
  sh.updateZoneKeyRange(
    "archive.documents",
    { year: currentYear, month: month, document_id: MinKey },
    { year: currentYear, month: month, document_id: MaxKey },
    "HOT"
  )
}

// Tier WARM: SSD (1-3 ans)
sh.addShardToZone("shard-ssd-1", "WARM")
sh.addShardToZone("shard-ssd-2", "WARM")

for (let year = 2021; year < currentYear; year++) {
  for (let month = 1; month <= 12; month++) {
    sh.updateZoneKeyRange(
      "archive.documents",
      { year: year, month: month, document_id: MinKey },
      { year: year, month: month, document_id: MaxKey },
      "WARM"
    )
  }
}

// Tier COLD: HDD (> 3 ans)
sh.addShardToZone("shard-hdd-1", "COLD")
sh.addShardToZone("shard-hdd-2", "COLD")

// Archives anciennes
sh.updateZoneKeyRange(
  "archive.documents",
  { year: MinKey, month: MinKey, document_id: MinKey },
  { year: 2021, month: 1, document_id: MinKey },
  "COLD"
)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ROTATION ANNUELLE AUTOMATISÃ‰E
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function rotateArchiveTiers() {
  const now = new Date()
  const currentYear = now.getFullYear()

  print(`=== Archive Tier Rotation ${currentYear} ===`)

  // 1. AnnÃ©e N-1 (HOT â†’ WARM)
  const lastYear = currentYear - 1

  print(`Moving year ${lastYear} from HOT to WARM...`)

  for (let month = 1; month <= 12; month++) {
    // Supprimer de HOT
    db.getSiblingDB("config").tags.deleteOne({
      ns: "archive.documents",
      tag: "HOT",
      min: { year: lastYear, month: month, document_id: MinKey }
    })

    // Ajouter Ã  WARM
    sh.updateZoneKeyRange(
      "archive.documents",
      { year: lastYear, month: month, document_id: MinKey },
      { year: lastYear, month: month, document_id: MaxKey },
      "WARM"
    )
  }

  // 2. AnnÃ©e N-4 (WARM â†’ COLD)
  const oldYear = currentYear - 4

  print(`Moving year ${oldYear} from WARM to COLD...`)

  for (let month = 1; month <= 12; month++) {
    // Supprimer de WARM
    db.getSiblingDB("config").tags.deleteOne({
      ns: "archive.documents",
      tag: "WARM",
      min: { year: oldYear, month: month, document_id: MinKey }
    })

    // Ajouter Ã  COLD
    sh.updateZoneKeyRange(
      "archive.documents",
      { year: oldYear, month: month, document_id: MinKey },
      { year: oldYear, month: month, document_id: MaxKey },
      "COLD"
    )
  }

  // 3. Ajouter annÃ©e N au HOT
  print(`Adding year ${currentYear} to HOT...`)

  for (let month = 1; month <= 12; month++) {
    sh.updateZoneKeyRange(
      "archive.documents",
      { year: currentYear, month: month, document_id: MinKey },
      { year: currentYear, month: month, document_id: MaxKey },
      "HOT"
    )
  }

  print(`Rotation complete. Balancer will migrate chunks.`)
  print(`Monitor: sh.status()`)
}

// ExÃ©cuter chaque 1er janvier:
// 0 0 1 1 * mongosh --eval "rotateArchiveTiers()"
```

### Cas 4 : Read/Write Splitting

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION: Analytics avec sÃ©paration read/write
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pattern: DonnÃ©es rÃ©centes (writes actifs) vs anciennes (reads only)

// Shard key: { date: 1, event_id: 1 }
sh.shardCollection("analytics.events",
  { date: 1, event_id: 1 }
)

// Zone WRITE: Derniers 7 jours (shards optimisÃ©s Ã©criture)
sh.addShardToZone("shard-write-1", "WRITE")
sh.addShardToZone("shard-write-2", "WRITE")

// Configuration shards write-optimized:
// - Write Concern: majority
// - WiredTiger cache: OptimisÃ© pour writes
// - Moins de read replicas

const today = new Date()
const sevenDaysAgo = new Date(today - 7 * 24 * 60 * 60 * 1000)

sh.updateZoneKeyRange(
  "analytics.events",
  { date: sevenDaysAgo, event_id: MinKey },
  { date: MaxKey, event_id: MaxKey },
  "WRITE"
)

// Zone READ: DonnÃ©es anciennes (shards optimisÃ©s lecture)
sh.addShardToZone("shard-read-1", "READ")
sh.addShardToZone("shard-read-2", "READ")
sh.addShardToZone("shard-read-3", "READ")

// Configuration shards read-optimized:
// - Plusieurs read replicas
// - WiredTiger cache: Plus gros (read-heavy)
// - Index covering queries

sh.updateZoneKeyRange(
  "analytics.events",
  { date: MinKey, event_id: MinKey },
  { date: sevenDaysAgo, event_id: MinKey },
  "READ"
)

// Migration automatique quotidienne:
function rotateLiveWindow() {
  const today = new Date()
  const sevenDaysAgo = new Date(today - 7 * 24 * 60 * 60 * 1000)

  // Update zone WRITE
  db.getSiblingDB("config").tags.updateOne(
    { ns: "analytics.events", tag: "WRITE" },
    { $set: {
      min: { date: sevenDaysAgo, event_id: MinKey }
    }}
  )

  // Chunks de J-7 migreront automatiquement de WRITE Ã  READ
}

// Cron quotidien: 0 1 * * * (1h du matin)
```

## StratÃ©gies AvancÃ©es

### StratÃ©gie 1 : Zone Sharding avec Hashed

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMBINER HASHED + ZONE SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ProblÃ¨me: Whale tenant avec distribution inÃ©gale

// Shard key: { tenant_id: "hashed" }
sh.shardCollection("saas.data", { tenant_id: "hashed" })

// Zones gÃ©ographiques malgrÃ© hashed:
// Note: hash(tenant_id) est dÃ©terministe
// â†’ MÃªme tenant_id â†’ toujours mÃªme hash

// Calculer hash range pour BigCorp:
const bigCorpHash = convertShardKeyToHashed("BigCorp")
// bigCorpHash = -3456789012345678901

// Assigner range de hash Ã  zone dÃ©diÃ©e:
sh.addShardToZone("shard-whale-1", "WHALE-BIGCORP")

sh.updateZoneKeyRange(
  "saas.data",
  { tenant_id: bigCorpHash },
  { tenant_id: bigCorpHash + 1 },  // Range d'un seul hash
  "WHALE-BIGCORP"
)

// Limitation: GranularitÃ© = 1 hash value
// Impossible de crÃ©er range continu de hashes
// â†’ Hashed + Zone rarement combinÃ©s
```

### StratÃ©gie 2 : Zones HiÃ©rarchiques

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZONES AVEC HIÃ‰RARCHIE / PRIORITÃ‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario: Enterprise client en EU

// Shard avec deux zones:
sh.addShardToZone("shard-eu-premium-1", "EU")
sh.addShardToZone("shard-eu-premium-1", "ENTERPRISE")

// Range spÃ©cifique (ENTERPRISE) prime sur range gÃ©nÃ©ral (EU):
sh.updateZoneKeyRange(
  "app.users",
  { tenant_id: "EnterpriseCorp", user_id: MinKey },
  { tenant_id: "EnterpriseCorp", user_id: MaxKey },
  "ENTERPRISE"  // Range spÃ©cifique
)

sh.updateZoneKeyRange(
  "app.users",
  { tenant_id: "tenant-", user_id: MinKey },
  { tenant_id: "tenant-~", user_id: MaxKey },
  "EU"  // Range gÃ©nÃ©ral
)

// RÃ©solution par le balancer:
// 1. VÃ©rifie ranges spÃ©cifiques d'abord (ENTERPRISE)
// 2. Puis ranges gÃ©nÃ©raux (EU)
//
// EnterpriseCorp:
//   - Match "ENTERPRISE" range â†’ Zone "ENTERPRISE"
//   - Shards avec tag "ENTERPRISE": shard-eu-premium-1 âœ“
//
// tenant-standard-001:
//   - Pas de match "ENTERPRISE"
//   - Match "EU" range â†’ Zone "EU"
//   - Shards avec tag "EU": shard-eu-premium-1, shard-eu-standard-1
//   - Balancer choisit le moins chargÃ©
```

### StratÃ©gie 3 : Zones Dynamiques (Auto-Scaling)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTO-SCALING AVEC ZONES DYNAMIQUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ScÃ©nario: Ajouter shard temporairement pour peak load

// Ã‰tat initial: 2 shards EU
sh.addShardToZone("shard-eu-1", "EU")
sh.addShardToZone("shard-eu-2", "EU")

// Peak load dÃ©tectÃ© (Black Friday, etc.)
// Script d'auto-scaling:

function scaleUpEUZone() {
  print("Scaling up EU zone...")

  // 1. Provisionner nouveau shard (cloud auto-scaling)
  const newShardId = provisionNewShard("eu-paris") // API cloud

  // 2. Ajouter au cluster
  sh.addShard(newShardId)

  // 3. Assigner Ã  zone EU
  sh.addShardToZone(newShardId, "EU")

  // 4. Balancer redistribue automatiquement
  // Chunks EU rÃ©partis sur 3 shards au lieu de 2

  print(`EU zone scaled to 3 shards. New shard: ${newShardId}`)
}

function scaleDownEUZone(shardToRemove) {
  print("Scaling down EU zone...")

  // 1. Retirer tag zone
  sh.removeShardFromZone(shardToRemove, "EU")

  // 2. Drainer shard
  sh.removeShard(shardToRemove)

  // 3. Balancer migre chunks vers autres shards EU

  // 4. Quand vide, dÃ©provisionner (cloud)

  print("EU zone scaled down.")
}

// DÃ©clenchement basÃ© sur mÃ©triques:
// - CPU > 80% sur tous shards EU pendant 30 min â†’ scaleUp
// - CPU < 30% pendant 2h ET > 2 shards â†’ scaleDown
```

### StratÃ©gie 4 : Validation de Configuration

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDER CONFIGURATION ZONES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function validateZoneConfiguration(ns) {
  print(`=== Validating Zone Configuration for ${ns} ===\n`)

  const issues = []

  // 1. VÃ©rifier que tous les tags ont des shards
  const tags = db.getSiblingDB("config").tags
    .distinct("tag", { ns: ns })

  tags.forEach(tag => {
    const shardsWithTag = db.getSiblingDB("config").shards
      .find({ tags: tag }).count()

    if (shardsWithTag === 0) {
      issues.push({
        severity: "ERROR",
        tag: tag,
        message: `No shards assigned to zone "${tag}"`
      })
    } else if (shardsWithTag === 1) {
      issues.push({
        severity: "WARNING",
        tag: tag,
        message: `Only 1 shard for zone "${tag}" - No HA`
      })
    }
  })

  // 2. VÃ©rifier chevauchement de ranges
  const ranges = db.getSiblingDB("config").tags
    .find({ ns: ns })
    .sort({ "min": 1 })
    .toArray()

  for (let i = 0; i < ranges.length - 1; i++) {
    const current = ranges[i]
    const next = ranges[i + 1]

    // Comparer max de current avec min de next
    if (bsonWoCompare(current.max, next.min) > 0) {
      issues.push({
        severity: "ERROR",
        message: `Range overlap detected between ${current.tag} and ${next.tag}`,
        range1: { min: current.min, max: current.max },
        range2: { min: next.min, max: next.max }
      })
    }
  }

  // 3. VÃ©rifier gaps (ranges non couverts)
  const shardKey = db.getSiblingDB("config").collections
    .findOne({ _id: ns }).key

  if (ranges.length > 0) {
    // VÃ©rifier si premier range commence Ã  MinKey
    if (ranges[0].min !== MinKey) {
      issues.push({
        severity: "WARNING",
        message: "Gap at beginning: No zone covers values < first range"
      })
    }

    // VÃ©rifier si dernier range finit Ã  MaxKey
    if (ranges[ranges.length - 1].max !== MaxKey) {
      issues.push({
        severity: "WARNING",
        message: "Gap at end: No zone covers values > last range"
      })
    }
  }

  // 4. Rapport
  if (issues.length === 0) {
    print("âœ… No issues found")
  } else {
    print(`âš ï¸  Found ${issues.length} issues:\n`)
    issues.forEach((issue, i) => {
      print(`${i + 1}. [${issue.severity}] ${issue.message}`)
      if (issue.range1) {
        print(`   Range 1: ${tojson(issue.range1)}`)
        print(`   Range 2: ${tojson(issue.range2)}`)
      }
      print("")
    })
  }

  return issues
}

// Utilisation:
validateZoneConfiguration("app.users")
```

## Anti-Patterns SpÃ©cifiques

### ğŸš« Anti-Pattern 1 : Zones Sans Monitoring

```javascript
// âŒ ANTI-PATTERN

// Configuration initiale:
sh.addShardToZone("shard-eu", "EU")
sh.addShardToZone("shard-us", "US")

// 6 mois plus tard... aucun monitoring

// ProblÃ¨me non dÃ©tectÃ©:
// - 90% des users sont US â†’ shard-us surchargÃ©
// - 10% des users sont EU â†’ shard-eu idle
// - DÃ©sÃ©quilibre massif

db.getSiblingDB("config").chunks.aggregate([
  { $match: { ns: "app.users" } },
  { $group: { _id: "$shard", count: { $sum: 1 } } }
])

// [
//   { _id: "shard-us", count: 850 },  // 94%
//   { _id: "shard-eu", count: 50 }    // 6%
// ]

// Impact:
// - shard-us: CPU 95%, saturÃ©
// - shard-eu: CPU 10%, sous-utilisÃ©
// - ROI infrastructure mÃ©diocre

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION: MONITORING CONTINU
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Dashboard avec alertes:

function monitorZoneBalance() {
  const stats = db.getSiblingDB("config").chunks.aggregate([
    { $match: { ns: "app.users" } },
    {
      $lookup: {
        from: "shards",
        localField: "shard",
        foreignField: "_id",
        as: "shard_info"
      }
    },
    { $unwind: "$shard_info" },
    { $unwind: "$shard_info.tags" },
    {
      $group: {
        _id: "$shard_info.tags",
        chunks: { $sum: 1 },
        shards: { $addToSet: "$shard" }
      }
    }
  ]).toArray()

  print("Zone Balance:")
  stats.forEach(zone => {
    print(`  ${zone._id}: ${zone.chunks} chunks across ${zone.shards.length} shards`)
  })

  // Alerter si dÃ©sÃ©quilibre > 30%
  const maxChunks = Math.max(...stats.map(z => z.chunks))
  const minChunks = Math.min(...stats.map(z => z.chunks))
  const imbalance = ((maxChunks - minChunks) / maxChunks) * 100

  if (imbalance > 30) {
    print(`âš ï¸  WARNING: Zone imbalance ${imbalance.toFixed(1)}%`)
    print(`   Consider: Adding shards to overloaded zone`)
  }
}

// ExÃ©cuter quotidiennement
```

### ğŸš« Anti-Pattern 2 : Zones Trop Granulaires

```javascript
// âŒ ANTI-PATTERN

// 1 zone par ville (des centaines)
sh.addShardToZone("shard-paris", "paris")
sh.addShardToZone("shard-lyon", "lyon")
sh.addShardToZone("shard-marseille", "marseille")
// ... 100+ villes

// ProblÃ¨mes:

// 1. Configuration cauchemardesque
sh.updateZoneKeyRange("app.users",
  { city: "Paris", user_id: MinKey },
  { city: "Paris", user_id: MaxKey },
  "paris"
)
// Ã— 100 fois...

// 2. Metadata explosion
db.getSiblingDB("config").tags.count()
// 850 zone ranges!

// 3. Balancer confusion
// Trop de dÃ©cisions Ã  prendre
// Performance dÃ©gradÃ©e

// 4. Maintenance impossible
// Ajouter nouvelle ville = configuration manuelle
// Erreurs frÃ©quentes

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION: ZONES AU NIVEAU RÃ‰GIONAL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// GranularitÃ© appropriÃ©e: Pays ou rÃ©gion
sh.addShardToZone("shard-eu-1", "EU")
sh.addShardToZone("shard-eu-2", "EU")

sh.updateZoneKeyRange("app.users",
  { country: "FR", user_id: MinKey },
  { country: "FR", user_id: MaxKey },
  "EU"
)

// RÃ¨gle empirique:
// Maximum 5-10 zones diffÃ©rentes
// Minimum 2 shards par zone (HA)
```

### ğŸš« Anti-Pattern 3 : Oublier les Gaps

```javascript
// âŒ ANTI-PATTERN

// Configuration partielle:
sh.updateZoneKeyRange("app.users",
  { country: "FR", user_id: MinKey },
  { country: "FR", user_id: MaxKey },
  "EU"
)

sh.updateZoneKeyRange("app.users",
  { country: "US", user_id: MinKey },
  { country: "US", user_id: MaxKey },
  "US"
)

// ProblÃ¨me: Que se passe-t-il pour "BR", "JP", "AU" ?
// â†’ Pas de zone assignÃ©e
// â†’ Va sur n'importe quel shard
// â†’ Peut violer contraintes gÃ©ographiques!

// Exemple:
db.users.insertOne({ country: "BR", user_id: 123, ... })
// â†’ Peut aller sur shard-eu OU shard-us (alÃ©atoire)
// â†’ Latence Ã©levÃ©e pour users brÃ©siliens
// â†’ DonnÃ©es hors zone gÃ©ographique

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION: ZONE CATCH-ALL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Option 1: Zone "GLOBAL" pour tout le reste
sh.addShardToZone("shard-global-1", "GLOBAL")

sh.updateZoneKeyRange("app.users",
  { country: MinKey, user_id: MinKey },
  { country: MaxKey, user_id: MaxKey },
  "GLOBAL"
)
// Ce range capture tout ce qui n'est pas assignÃ©

// Option 2: Lister TOUS les pays explicitement
const allCountries = [/* liste complÃ¨te ISO 3166 */]
allCountries.forEach(country => {
  const zone = getZoneForCountry(country)  // Fonction mapping
  sh.updateZoneKeyRange("app.users",
    { country: country, user_id: MinKey },
    { country: country, user_id: MaxKey },
    zone
  )
})
```

### ğŸš« Anti-Pattern 4 : Zone sur Shard Unique

```javascript
// âŒ ANTI-PATTERN

// 1 seul shard pour zone critique
sh.addShardToZone("shard-eu-1", "EU")
// Pas de second shard EU!

sh.updateZoneKeyRange("app.users",
  { country: "FR", user_id: MinKey },
  { country: "FR", user_id: MaxKey },
  "EU"
)

// ProblÃ¨mes:

// 1. SPOF (Single Point of Failure)
// Si shard-eu-1 down:
// - TOUS les users EU inaccessibles
// - Pas de failover possible
// - Downtime pour segment entier

// 2. Pas de HA
// - Maintenance = downtime
// - Upgrade = downtime

// 3. Pas de scaling
// - Charge augmente sur users EU
// - Impossible de scale (1 seul shard)
// - Bottleneck garanti

// 4. Pas de balancing intra-zone
// - Tous chunks EU sur mÃªme shard
// - Balancer ne peut pas Ã©quilibrer

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION: MINIMUM 2 SHARDS PAR ZONE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… Configuration appropriÃ©e:
sh.addShardToZone("shard-eu-paris-1", "EU")
sh.addShardToZone("shard-eu-frankfurt-1", "EU")

// Avantages:
// âœ… HA: Panne d'un shard â†’ autre prend le relai
// âœ… Maintenance sans downtime
// âœ… Balancing intra-zone possible
// âœ… Scaling: Ajouter 3Ã¨me shard si nÃ©cessaire

// Pour production critique:
sh.addShardToZone("shard-eu-paris-1", "EU")
sh.addShardToZone("shard-eu-frankfurt-1", "EU")
sh.addShardToZone("shard-eu-london-1", "EU")
// 3+ shards pour meilleure rÃ©silience
```

### ğŸš« Anti-Pattern 5 : Zone Sharding Sans Shard Key AppropriÃ©

```javascript
// âŒ ANTI-PATTERN

// Vouloir zones gÃ©ographiques mais:
sh.shardCollection("app.users", { user_id: "hashed" })
// Shard key: user_id hachÃ©

// Tenter de crÃ©er zones:
sh.updateZoneKeyRange("app.users",
  { user_id: hash("EU-*") },  // âŒ Impossible!
  { user_id: hash("EU-*") },
  "EU"
)

// ProblÃ¨me:
// Hash est opaque et non-sÃ©quentiel
// Impossible de dÃ©finir ranges significatifs
// Zone sharding ne fonctionne PAS avec hashed pur

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOLUTION: SHARD KEY COMPATIBLE ZONES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… Option 1: Range avec prÃ©fixe gÃ©ographique
sh.shardCollection("app.users",
  { country: 1, user_id: 1 }  // country en prÃ©fixe
)

// âœ… Option 2: Compound hashed (MongoDB 4.4+)
sh.shardCollection("app.users",
  { country: "hashed", user_id: 1 }
)
// Mais limitation: zones par hash value individuel
// Rarement pratique

// âœ… Option 3: Champ dÃ©diÃ© pour zone
sh.shardCollection("app.users",
  { data_region: 1, user_id: 1 }
)
// data_region: "EU", "US", "ASIA"
// Explicite et facile Ã  zoner
```

## Monitoring et Maintenance

### MÃ©triques Essentielles

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONITORING ZONE SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. DISTRIBUTION PAR ZONE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getZoneDistribution(ns) {
  return db.getSiblingDB("config").chunks.aggregate([
    { $match: { ns: ns } },
    {
      $lookup: {
        from: "shards",
        localField: "shard",
        foreignField: "_id",
        as: "shard_info"
      }
    },
    { $unwind: "$shard_info" },
    { $unwind: "$shard_info.tags" },
    {
      $group: {
        _id: "$shard_info.tags",
        chunks: { $sum: 1 },
        shards: { $addToSet: "$shard" }
      }
    },
    { $sort: { chunks: -1 } }
  ]).toArray()
}

// 2. VÃ‰RIFIER CONFORMITÃ‰ ZONES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function verifyZoneCompliance(ns, zone, expectedShards) {
  // VÃ©rifier qu'aucun chunk de la zone n'est hors zone
  const violations = db.getSiblingDB("config").chunks.aggregate([
    { $match: { ns: ns } },
    {
      $lookup: {
        from: "shards",
        localField: "shard",
        foreignField: "_id",
        as: "shard_info"
      }
    },
    { $unwind: "$shard_info" },
    {
      $lookup: {
        from: "tags",
        let: { chunk_min: "$min", chunk_max: "$max", chunk_ns: "$ns" },
        pipeline: [
          {
            $match: {
              $expr: {
                $and: [
                  { $eq: ["$ns", "$$chunk_ns"] },
                  { $eq: ["$tag", zone] }
                ]
              }
            }
          }
        ],
        as: "expected_zone"
      }
    },
    {
      $match: {
        $and: [
          { expected_zone: { $ne: [] } },  // Chunk devrait Ãªtre dans zone
          { "shard_info.tags": { $nin: [zone] } }  // Mais shard n'a pas le tag
        ]
      }
    }
  ]).toArray()

  if (violations.length > 0) {
    print(`âŒ Zone Compliance Violations: ${violations.length} chunks`)
    violations.forEach(v => {
      print(`  Chunk ${tojson(v.min)} â†’ ${tojson(v.max)}`)
      print(`  Should be in zone "${zone}" but on shard "${v.shard}"`)
    })
  } else {
    print(`âœ… Zone "${zone}": Compliant`)
  }

  return violations
}

// 3. MONITORING MIGRATIONS INTER-ZONES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function trackCrossZoneMigrations() {
  return db.getSiblingDB("config").changelog.aggregate([
    {
      $match: {
        what: "moveChunk.commit",
        time: { $gte: ISODate("2024-12-07T00:00:00Z") }
      }
    },
    {
      $lookup: {
        from: "shards",
        localField: "details.from",
        foreignField: "_id",
        as: "from_shard"
      }
    },
    {
      $lookup: {
        from: "shards",
        localField: "details.to",
        foreignField: "_id",
        as: "to_shard"
      }
    },
    { $unwind: "$from_shard" },
    { $unwind: "$to_shard" },
    {
      $project: {
        time: 1,
        ns: 1,
        from_zone: { $arrayElemAt: ["$from_shard.tags", 0] },
        to_zone: { $arrayElemAt: ["$to_shard.tags", 0] },
        cross_zone: {
          $ne: [
            { $arrayElemAt: ["$from_shard.tags", 0] },
            { $arrayElemAt: ["$to_shard.tags", 0] }
          ]
        }
      }
    },
    { $match: { cross_zone: true } },
    {
      $group: {
        _id: { from: "$from_zone", to: "$to_zone" },
        count: { $sum: 1 }
      }
    }
  ]).toArray()
}

// Alerte si migrations cross-zone frÃ©quentes
// â†’ Probable misconfiguration zones
```

### Dashboard Zones

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD COMPLET ZONE SHARDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateZoneDashboard(ns) {
  print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
  print(`Zone Sharding Dashboard: ${ns}`)
  print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

  // 1. Liste des zones configurÃ©es
  print("1. CONFIGURED ZONES")
  print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  const zones = db.getSiblingDB("config").tags
    .distinct("tag", { ns: ns })

  zones.forEach(zone => {
    const shards = db.getSiblingDB("config").shards
      .find({ tags: zone }, { _id: 1 })
      .toArray()
      .map(s => s._id)

    print(`  ${zone}: ${shards.length} shards (${shards.join(", ")})`)
  })
  print("")

  // 2. Distribution des chunks
  print("2. CHUNK DISTRIBUTION")
  print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  const dist = getZoneDistribution(ns)
  const totalChunks = dist.reduce((sum, z) => sum + z.chunks, 0)

  dist.forEach(zone => {
    const pct = ((zone.chunks / totalChunks) * 100).toFixed(1)
    print(`  ${zone._id}: ${zone.chunks} chunks (${pct}%)`)
  })
  print(`  Total: ${totalChunks} chunks\n`)

  // 3. Balance score
  print("3. BALANCE SCORE")
  print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  const maxChunks = Math.max(...dist.map(z => z.chunks))
  const minChunks = Math.min(...dist.map(z => z.chunks))
  const imbalance = ((maxChunks - minChunks) / maxChunks) * 100

  if (imbalance < 10) {
    print(`  âœ… Excellent (${imbalance.toFixed(1)}% imbalance)`)
  } else if (imbalance < 20) {
    print(`  âš ï¸  Acceptable (${imbalance.toFixed(1)}% imbalance)`)
  } else {
    print(`  âŒ Poor (${imbalance.toFixed(1)}% imbalance)`)
  }
  print("")

  // 4. Violations de conformitÃ©
  print("4. COMPLIANCE CHECK")
  print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  let totalViolations = 0
  zones.forEach(zone => {
    const violations = verifyZoneCompliance(ns, zone)
    totalViolations += violations.length
  })

  if (totalViolations === 0) {
    print("  âœ… All zones compliant")
  }
  print("")

  // 5. Migrations rÃ©centes
  print("5. RECENT MIGRATIONS (Last 24h)")
  print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  const migrations = db.getSiblingDB("config").changelog.find({
    ns: ns,
    what: "moveChunk.commit",
    time: { $gte: ISODate("2024-12-07T00:00:00Z") }
  }).count()

  print(`  Total migrations: ${migrations}`)

  const crossZone = trackCrossZoneMigrations()
  if (crossZone.length > 0) {
    print("  âš ï¸  Cross-zone migrations detected:")
    crossZone.forEach(m => {
      print(`    ${m._id.from} â†’ ${m._id.to}: ${m.count} chunks`)
    })
  } else {
    print("  âœ… No cross-zone migrations")
  }

  print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
}

// Utilisation:
generateZoneDashboard("app.users")
```

## RÃ©sumÃ©

Le **Zone Sharding** offre un contrÃ´le prÃ©cis de la distribution des donnÃ©es :

**Concepts clÃ©s :**
- Zones logiques = Tags assignÃ©s aux shards
- Ranges de shard key assignÃ©s aux zones
- Balancer respecte les contraintes de zones

**Cas d'usage principaux :**
1. **ConformitÃ© RGPD** : DonnÃ©es EU restent en EU
2. **Multi-tenant** : Isolation whale tenants
3. **Tiering** : HOT/WARM/COLD par Ã¢ge
4. **Read/Write splitting** : Shards spÃ©cialisÃ©s

**Configuration :**
- `sh.addShardToZone(shard, zone)`
- `sh.updateZoneKeyRange(ns, min, max, zone)`
- Minimum 2 shards par zone (HA)

**StratÃ©gies avancÃ©es :**
- Zones hiÃ©rarchiques (prioritÃ©s)
- Zones dynamiques (auto-scaling)
- Rotation automatique (tiering temporel)
- Validation configuration

**Anti-patterns critiques :**
- âŒ Zones sans monitoring (dÃ©sÃ©quilibre)
- âŒ Zones trop granulaires (100+ zones)
- âŒ Oublier les gaps (pays non assignÃ©s)
- âŒ Zone sur shard unique (SPOF)
- âŒ Shard key incompatible (hashed pur)

**Monitoring essentiel :**
- Distribution par zone (Ã©cart < 20%)
- ConformitÃ© (violations = 0)
- Migrations cross-zone (minimales)
- Balance intra-zone

**Best practices :**
- 5-10 zones maximum (simplicitÃ©)
- 2+ shards par zone (HA)
- Zone catch-all pour gaps
- Validation rÃ©guliÃ¨re
- Dashboard monitoring

Le Zone Sharding est la stratÃ©gie la plus complexe mais la plus puissante pour contrÃ´ler prÃ©cisÃ©ment oÃ¹ les donnÃ©es sont stockÃ©es. Essentiel pour conformitÃ© rÃ©glementaire, optimisation latence et isolation multi-tenant.

---


â­ï¸ [Chunks et balancing](/10-sharding/05-chunks-balancing.md)
