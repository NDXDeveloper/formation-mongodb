ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.4 Queryable Encryption

## Introduction

Queryable Encryption est la fonctionnalitÃ© la plus avancÃ©e de chiffrement dans MongoDB, introduite en version 6.0 (GA en 7.0). Elle rÃ©sout la limitation majeure de CSFLE classique : **l'impossibilitÃ© de rechercher efficacement sur des champs chiffrÃ©s avec l'algorithme Random**.

Queryable Encryption combine la sÃ©curitÃ© maximale du chiffrement alÃ©atoire cÃ´tÃ© client avec la capacitÃ© de recherche, offrant ainsi :
- **Chiffrement cÃ´tÃ© client** (les donnÃ©es ne quittent jamais l'application en clair)
- **Protection contre les administrateurs** (comme CSFLE)
- **Recherche sur donnÃ©es chiffrÃ©es** (nouveautÃ© majeure)
- **SÃ©curitÃ© cryptographique avancÃ©e** (pas d'analyse de frÃ©quence possible)

### Ã‰volution depuis CSFLE

```
CSFLE Deterministic          â†’    Queryable Encryption
â”œâ”€ Recherche possible         â†’    âœ“ Recherche possible
â”œâ”€ SÃ©curitÃ© moindre           â†’    âœ“ SÃ©curitÃ© maximale
â”œâ”€ Analyse de frÃ©quence       â†’    âœ— Impossible
â””â”€ Patterns visibles          â†’    âœ— Aucun pattern
```

### ProblÃ¨me rÃ©solu

Avec CSFLE classique, vous deviez choisir :

```
CSFLE Random (avant Queryable Encryption)
â”œâ”€ SÃ©curitÃ© maximale
â””â”€ âœ— Pas de recherche possible
    â””â”€ db.users.find({ ssn: "123-45-6789" })  // NE FONCTIONNE PAS

CSFLE Deterministic
â”œâ”€ Recherche possible
â”‚   â””â”€ db.users.find({ ssn: "123-45-6789" })  // Fonctionne
â””â”€ âš ï¸ SÃ©curitÃ© moindre
    â”œâ”€ MÃªme valeur = mÃªme chiffrÃ©
    â””â”€ Analyse de frÃ©quence possible
```

Avec Queryable Encryption :

```
Queryable Encryption
â”œâ”€ âœ“ SÃ©curitÃ© maximale (chiffrement alÃ©atoire)
â”œâ”€ âœ“ Recherche possible (via index tokens)
â”œâ”€ âœ— Aucune analyse de frÃ©quence possible
â””â”€ âœ— Aucun pattern visible
    â””â”€ db.users.find({ ssn: "123-45-6789" })  // FONCTIONNE !
```

## Architecture et fonctionnement

### Concepts clÃ©s

Queryable Encryption repose sur plusieurs innovations cryptographiques :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Encrypted Search Indexes (Index Tokens)                     â”‚
â”‚     â€¢ Index chiffrÃ© stockÃ© sÃ©parÃ©ment des donnÃ©es               â”‚
â”‚     â€¢ Permet la recherche sans rÃ©vÃ©ler les valeurs              â”‚
â”‚     â€¢ BasÃ© sur des tokens cryptographiques                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Structured Encryption                                       â”‚
â”‚     â€¢ Algorithme cryptographique avancÃ©                         â”‚
â”‚     â€¢ Pas de deterministic encryption                           â”‚
â”‚     â€¢ Recherche via tokens, pas via valeur chiffrÃ©e             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Metadata Collection                                         â”‚
â”‚     â€¢ Collection auxiliaire pour les mÃ©tadonnÃ©es de recherche   â”‚
â”‚     â€¢ Invisible pour l'utilisateur final                        â”‚
â”‚     â€¢ GÃ©rÃ©e automatiquement par MongoDB                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Architecture dÃ©taillÃ©e

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Application                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Queryable Encryption Library                             â”‚  â”‚
â”‚  â”‚  â€¢ GÃ©nÃ¨re les index tokens                                â”‚  â”‚
â”‚  â”‚  â€¢ Chiffre les donnÃ©es                                    â”‚  â”‚
â”‚  â”‚  â€¢ Transforme les requÃªtes                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
                  Query: { ssn: "123-45-6789" }
                              â†“
         Transformation en tokens + requÃªte chiffrÃ©e
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      MongoDB Server                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Collection principale (patients)                         â”‚  â”‚
â”‚  â”‚  {                                                        â”‚  â”‚
â”‚  â”‚    _id: ObjectId("..."),                                  â”‚  â”‚
â”‚  â”‚    name: "John Doe",                                      â”‚  â”‚
â”‚  â”‚    ssn: BinData(6, "encrypted..."),  // Valeur chiffrÃ©e   â”‚  â”‚
â”‚  â”‚    __safeContent__: [                // Index tokens      â”‚  â”‚
â”‚  â”‚      BinData(6, "token1..."),                             â”‚  â”‚
â”‚  â”‚      BinData(6, "token2...")                              â”‚  â”‚
â”‚  â”‚    ]                                                      â”‚  â”‚
â”‚  â”‚  }                                                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Metadata Collection (enxcol_.patients.esc)               â”‚  â”‚
â”‚  â”‚  â€¢ Index tokens pour la recherche                         â”‚  â”‚
â”‚  â”‚  â€¢ Compteurs d'Ã©tat                                       â”‚  â”‚
â”‚  â”‚  â€¢ MÃ©tadonnÃ©es cryptographiques                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Collections auxiliaires

Queryable Encryption crÃ©e automatiquement des collections de mÃ©tadonnÃ©es :

```javascript
// Pour une collection "patients", MongoDB crÃ©e :

// 1. Collection principale
hospital.patients

// 2. Equality State Collection (ESC)
// Stocke l'Ã©tat des index pour les requÃªtes d'Ã©galitÃ©
enxcol_.hospital.patients.esc

// 3. Equality Compaction Collection (ECOC)
// Optimisation des index (compaction)
enxcol_.hospital.patients.ecoc

// 4. Anchor Padding Collection (APC) - MongoDB 7.0+
// AmÃ©lioration des performances
enxcol_.hospital.patients.apc
```

### Flux de recherche

```
Application : db.users.find({ ssn: "123-45-6789" })
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Queryable Encryption Library                                â”‚
â”‚     â€¢ DÃ©tecte que "ssn" est un champ indexÃ©                     â”‚
â”‚     â€¢ GÃ©nÃ¨re des tokens de recherche pour "123-45-6789"         â”‚
â”‚     â€¢ Tokens = f(value, key, salt, counter)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Transformation de la requÃªte                                â”‚
â”‚     Original : { ssn: "123-45-6789" }                           â”‚
â”‚     TransformÃ© : { __safeContent__: { $in: [token1, token2] } } â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. ExÃ©cution cÃ´tÃ© serveur                                      â”‚
â”‚     â€¢ MongoDB recherche les tokens dans __safeContent__         â”‚
â”‚     â€¢ Trouve les documents correspondants                       â”‚
â”‚     â€¢ Retourne les donnÃ©es chiffrÃ©es                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. DÃ©chiffrement cÃ´tÃ© client                                   â”‚
â”‚     â€¢ L'application dÃ©chiffre les valeurs                       â”‚
â”‚     â€¢ Retourne : { ssn: "123-45-6789" }                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Types de requÃªtes supportÃ©es

### Equality Queries (Ã‰galitÃ©)

**SupportÃ©** : RequÃªtes d'Ã©galitÃ© exacte.

```javascript
// âœ… SupportÃ©
db.users.find({ ssn: "123-45-6789" })
db.users.findOne({ email: "john@example.com" })
db.users.find({ accountNumber: "ACC123456" })

// âœ… SupportÃ© : $in avec valeurs multiples
db.users.find({
  ssn: { $in: ["123-45-6789", "987-65-4321"] }
})

// âœ… SupportÃ© : AgrÃ©gation simple
db.users.aggregate([
  { $match: { ssn: "123-45-6789" } }
])
```

### RequÃªtes NON supportÃ©es

```javascript
// âŒ Range queries
db.users.find({ age: { $gt: 30 } })
db.users.find({ salary: { $gte: 50000, $lte: 100000 } })

// âŒ Pattern matching
db.users.find({ ssn: /^123/ })
db.users.find({ email: { $regex: "@example.com$" } })

// âŒ Text search
db.users.find({ $text: { $search: "medical condition" } })

// âŒ Array operations
db.users.find({ tags: "sensitive" })
db.users.find({ tags: { $all: ["tag1", "tag2"] } })

// âŒ Sorting sur champs chiffrÃ©s
db.users.find({}).sort({ ssn: 1 })

// âŒ AgrÃ©gations complexes
db.users.aggregate([
  { $group: { _id: "$ssn", count: { $sum: 1 } } }
])
```

### Limitations importantes

```
Queryable Encryption supporte UNIQUEMENT :
â”œâ”€ RequÃªtes d'Ã©galitÃ© exacte (find, findOne)
â”œâ”€ OpÃ©rateur $in avec liste de valeurs
â”œâ”€ AgrÃ©gation $match avec Ã©galitÃ©
â””â”€ Pas de range, regex, sort, ou agrÃ©gations complexes

Workaround pour les autres cas :
â”œâ”€ Stocker des mÃ©tadonnÃ©es en clair pour le tri/filtrage
â”œâ”€ Utiliser des champs non chiffrÃ©s pour les range queries
â””â”€ Faire le filtering cÃ´tÃ© application aprÃ¨s dÃ©chiffrement
```

## Configuration et implÃ©mentation

### PrÃ©requis

```
Requis :
â”œâ”€ MongoDB 6.0+ (GA en 7.0+)
â”œâ”€ MongoDB Enterprise ou Atlas
â”œâ”€ Driver avec support Queryable Encryption :
â”‚  â”œâ”€ Node.js 4.15+ / 5.0+
â”‚  â”œâ”€ Python 4.5+
â”‚  â”œâ”€ Java 4.10+
â”‚  â”œâ”€ C# 2.20+
â”‚  â””â”€ Go 1.12+
â”œâ”€ BibliothÃ¨que libmongocrypt 1.8+
â””â”€ crypt_shared library (ou mongocryptd)
```

### CrÃ©ation des encryption keys

```javascript
// create-qe-keys.js
const { MongoClient } = require('mongodb');
const { ClientEncryption } = require('mongodb-client-encryption');

async function createQueryableEncryptionKeys() {
  const keyVaultNamespace = 'encryption.__keyVault';
  const keyVaultClient = new MongoClient(connectionString);

  await keyVaultClient.connect();

  const encryption = new ClientEncryption(keyVaultClient, {
    keyVaultNamespace,
    kmsProviders: {
      aws: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
      }
    }
  });

  try {
    // CrÃ©er une clÃ© pour Queryable Encryption
    const keyId = await encryption.createDataKey('aws', {
      masterKey: {
        key: 'arn:aws:kms:us-east-1:123456789012:key/abcd-1234',
        region: 'us-east-1'
      },
      keyAltNames: ['queryable-ssn-key']
    });

    console.log('Queryable Encryption Key ID:', keyId.toString('base64'));

    // Note : Contrairement Ã  CSFLE, pas besoin de spÃ©cifier
    // un algorithme spÃ©cial lors de la crÃ©ation de la clÃ©

  } finally {
    await keyVaultClient.close();
  }
}

createQueryableEncryptionKeys().catch(console.error);
```

### SchÃ©ma de chiffrement

```javascript
// encryption-schema.js
const encryptedFieldsMap = {
  'hospital.patients': {
    fields: [
      {
        path: 'ssn',
        bsonType: 'string',
        queries: {
          queryType: 'equality',  // Active l'indexation pour recherche
          contention: 8  // Facteur de contention (sÃ©curitÃ© vs performance)
        }
      },
      {
        path: 'creditCard.number',
        bsonType: 'string',
        queries: {
          queryType: 'equality',
          contention: 4
        }
      },
      {
        path: 'medicalRecord.diagnosis',
        bsonType: 'string'
        // Pas de "queries" = chiffrement sans recherche (plus performant)
      }
    ]
  }
};

module.exports = { encryptedFieldsMap };
```

**ParamÃ¨tres importants** :

```javascript
// queryType : Type de recherche supportÃ©
queryType: 'equality'  // Actuellement, seul 'equality' est supportÃ©

// contention : Facteur de sÃ©curitÃ© vs performance
contention: 0-32
â”œâ”€ Valeur basse (1-4) : Plus performant, moins sÃ©curisÃ©
â”œâ”€ Valeur moyenne (8) : Ã‰quilibre recommandÃ©
â””â”€ Valeur haute (16-32) : Plus sÃ©curisÃ©, moins performant

// Impact du contention factor :
// Chaque valeur gÃ©nÃ¨re N tokens (N = contention factor)
// Plus de tokens = plus difficile l'analyse de frÃ©quence
// Mais aussi plus d'espace disque et de latence
```

### ImplÃ©mentation complÃ¨te (Node.js)

```javascript
// app.js - Application avec Queryable Encryption
const { MongoClient } = require('mongodb');
const { encryptedFieldsMap } = require('./encryption-schema');

// Configuration KMS
const kmsProviders = {
  aws: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
  }
};

const keyVaultNamespace = 'encryption.__keyVault';
const connectionString = 'mongodb://mongodb.example.com:27017';

// Client avec Queryable Encryption
async function createQueryableClient() {
  const client = new MongoClient(connectionString, {
    autoEncryption: {
      keyVaultNamespace,
      kmsProviders,
      encryptedFieldsMap,
      extraOptions: {
        cryptSharedLibPath: '/usr/local/lib/mongo_crypt_v1.so'
        // Ou mongocryptdSpawnPath si crypt_shared n'est pas disponible
      }
    }
  });

  await client.connect();
  return client;
}

// CrÃ©ation de la collection avec Queryable Encryption
async function createEncryptedCollection() {
  const client = new MongoClient(connectionString);
  await client.connect();

  try {
    const db = client.db('hospital');

    // CrÃ©er la collection avec les champs chiffrÃ©s
    // MongoDB crÃ©era automatiquement les collections auxiliaires
    await db.createCollection('patients', {
      encryptedFields: encryptedFieldsMap['hospital.patients']
    });

    console.log('Collection created with Queryable Encryption');

    // VÃ©rifier les collections crÃ©Ã©es
    const collections = await db.listCollections().toArray();
    console.log('Collections:', collections.map(c => c.name));
    // Output :
    // - patients (collection principale)
    // - enxcol_.hospital.patients.esc
    // - enxcol_.hospital.patients.ecoc

  } finally {
    await client.close();
  }
}

// Utilisation
async function main() {
  const client = await createQueryableClient();

  try {
    const db = client.db('hospital');
    const patients = db.collection('patients');

    // Insertion avec chiffrement automatique
    const insertResult = await patients.insertOne({
      name: 'John Doe',
      dateOfBirth: new Date('1980-01-15'),
      ssn: '123-45-6789',  // Sera chiffrÃ© + indexÃ© pour recherche
      creditCard: {
        number: '4111-1111-1111-1111',  // Sera chiffrÃ© + indexÃ©
        expiry: '12/25'  // NON chiffrÃ©
      },
      medicalRecord: {
        diagnosis: 'Hypertension',  // ChiffrÃ© SANS index (pas de recherche)
        medication: 'Lisinopril'
      },
      contactEmail: 'john@example.com'  // NON chiffrÃ©
    });

    console.log('Patient inserted:', insertResult.insertedId);

    // âœ… Recherche par SSN (fonctionne car indexÃ©)
    const foundBySSN = await patients.findOne({ ssn: '123-45-6789' });
    console.log('Found by SSN:', foundBySSN);
    // Les valeurs chiffrÃ©es sont automatiquement dÃ©chiffrÃ©es

    // âœ… Recherche par carte bancaire
    const foundByCard = await patients.findOne({
      'creditCard.number': '4111-1111-1111-1111'
    });
    console.log('Found by card:', foundByCard);

    // âŒ Recherche par diagnosis ne fonctionne pas
    // (champ chiffrÃ© mais pas indexÃ©)
    const notFound = await patients.findOne({
      'medicalRecord.diagnosis': 'Hypertension'
    });
    console.log('Found by diagnosis:', notFound);  // null

    // Workaround : RÃ©cupÃ©rer tous les documents et filtrer cÃ´tÃ© client
    const allPatients = await patients.find({}).toArray();
    const filteredPatients = allPatients.filter(
      p => p.medicalRecord.diagnosis === 'Hypertension'
    );
    console.log('Filtered locally:', filteredPatients.length);

  } finally {
    await client.close();
  }
}

main().catch(console.error);
```

### ImplÃ©mentation Python (PyMongo)

```python
# app.py - Python avec Queryable Encryption
from pymongo import MongoClient
from pymongo.encryption import ClientEncryption
from pymongo.encryption_options import AutoEncryptionOpts
import os

# Configuration KMS
kms_providers = {
    'aws': {
        'accessKeyId': os.environ['AWS_ACCESS_KEY_ID'],
        'secretAccessKey': os.environ['AWS_SECRET_ACCESS_KEY']
    }
}

key_vault_namespace = 'encryption.__keyVault'
connection_string = 'mongodb://mongodb.example.com:27017'

# SchÃ©ma de chiffrement
encrypted_fields_map = {
    'hospital.patients': {
        'fields': [
            {
                'path': 'ssn',
                'bsonType': 'string',
                'queries': {
                    'queryType': 'equality',
                    'contention': 8
                }
            },
            {
                'path': 'creditCard.number',
                'bsonType': 'string',
                'queries': {
                    'queryType': 'equality',
                    'contention': 4
                }
            }
        ]
    }
}

# Client avec Queryable Encryption
def create_queryable_client():
    auto_encryption_opts = AutoEncryptionOpts(
        kms_providers,
        key_vault_namespace,
        encrypted_fields_map=encrypted_fields_map,
        crypt_shared_lib_path='/usr/local/lib/mongo_crypt_v1.so'
    )

    client = MongoClient(
        connection_string,
        auto_encryption_opts=auto_encryption_opts
    )

    return client

# CrÃ©ation de la collection
def create_encrypted_collection():
    client = MongoClient(connection_string)
    db = client['hospital']

    # CrÃ©er avec Queryable Encryption
    db.create_collection(
        'patients',
        encryptedFields=encrypted_fields_map['hospital.patients']
    )

    print('Collection created with Queryable Encryption')
    client.close()

# Utilisation
def main():
    client = create_queryable_client()

    try:
        db = client['hospital']
        patients = db['patients']

        # Insertion
        result = patients.insert_one({
            'name': 'Jane Smith',
            'ssn': '987-65-4321',  # ChiffrÃ© + indexÃ©
            'creditCard': {
                'number': '5500-0000-0000-0004',  # ChiffrÃ© + indexÃ©
                'expiry': '06/26'
            },
            'email': 'jane@example.com'
        })

        print(f'Inserted: {result.inserted_id}')

        # Recherche par SSN (fonctionne)
        patient = patients.find_one({'ssn': '987-65-4321'})
        print(f'Found patient: {patient["name"]}')

    finally:
        client.close()

if __name__ == '__main__':
    main()
```

### ImplÃ©mentation Java

```java
// QueryableEncryptionExample.java
import com.mongodb.AutoEncryptionSettings;
import com.mongodb.ClientEncryptionSettings;
import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.BsonDocument;
import org.bson.Document;

import java.util.HashMap;
import java.util.Map;

public class QueryableEncryptionExample {

    private static final String CONNECTION_STRING = "mongodb://localhost:27017";
    private static final String KEY_VAULT_NAMESPACE = "encryption.__keyVault";

    public static void main(String[] args) {
        // Configuration KMS
        Map<String, Map<String, Object>> kmsProviders = new HashMap<>();
        Map<String, Object> awsConfig = new HashMap<>();
        awsConfig.put("accessKeyId", System.getenv("AWS_ACCESS_KEY_ID"));
        awsConfig.put("secretAccessKey", System.getenv("AWS_SECRET_ACCESS_KEY"));
        kmsProviders.put("aws", awsConfig);

        // SchÃ©ma de chiffrement
        String encryptedFieldsJson = "{"
            + "  'fields': ["
            + "    {"
            + "      'path': 'ssn',"
            + "      'bsonType': 'string',"
            + "      'queries': {"
            + "        'queryType': 'equality',"
            + "        'contention': 8"
            + "      }"
            + "    }"
            + "  ]"
            + "}";

        Map<String, BsonDocument> encryptedFieldsMap = new HashMap<>();
        encryptedFieldsMap.put(
            "hospital.patients",
            BsonDocument.parse(encryptedFieldsJson)
        );

        // Configuration Auto-Encryption
        AutoEncryptionSettings autoEncryptionSettings = AutoEncryptionSettings.builder()
            .keyVaultNamespace(KEY_VAULT_NAMESPACE)
            .kmsProviders(kmsProviders)
            .encryptedFieldsMap(encryptedFieldsMap)
            .extraOptions(new HashMap<String, Object>() {{
                put("cryptSharedLibPath", "/usr/local/lib/mongo_crypt_v1.so");
            }})
            .build();

        // Client MongoDB
        MongoClientSettings clientSettings = MongoClientSettings.builder()
            .applyConnectionString(new ConnectionString(CONNECTION_STRING))
            .autoEncryptionSettings(autoEncryptionSettings)
            .build();

        MongoClient client = MongoClients.create(clientSettings);

        // Utilisation
        MongoDatabase database = client.getDatabase("hospital");
        MongoCollection<Document> collection = database.getCollection("patients");

        // Insertion
        Document patient = new Document()
            .append("name", "Alice Johnson")
            .append("ssn", "111-22-3333")  // Sera chiffrÃ© + indexÃ©
            .append("age", 42);

        collection.insertOne(patient);
        System.out.println("Patient inserted");

        // Recherche
        Document found = collection.find(
            new Document("ssn", "111-22-3333")
        ).first();

        System.out.println("Found patient: " + found.toJson());

        client.close();
    }
}
```

## Performance et optimisation

### Impact sur les performances

Queryable Encryption a un impact significatif sur les performances :

```
OpÃ©ration                â”‚ Sans QE â”‚ Avec QE â”‚ Overhead
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Insert (1 indexed field) â”‚ 5ms     â”‚ 50ms    â”‚ +900%
Insert (3 indexed fields)â”‚ 5ms     â”‚ 120ms   â”‚ +2300%
Find by indexed field    â”‚ 3ms     â”‚ 25ms    â”‚ +733%
Find by _id              â”‚ 2ms     â”‚ 3ms     â”‚ +50%
Update                   â”‚ 8ms     â”‚ 80ms    â”‚ +900%
Bulk insert (100 docs)   â”‚ 180ms   â”‚ 4500ms  â”‚ +2400%
```

**Facteurs d'impact** :

```
1. Contention factor
   â”œâ”€ contention: 1  â†’ 1 token par valeur (rapide, moins sÃ©curisÃ©)
   â”œâ”€ contention: 8  â†’ 8 tokens par valeur (Ã©quilibre)
   â””â”€ contention: 32 â†’ 32 tokens par valeur (lent, trÃ¨s sÃ©curisÃ©)

2. Nombre de champs indexÃ©s
   â”œâ”€ Chaque champ indexÃ© = gÃ©nÃ©ration de tokens
   â””â”€ Linear scaling : 3 champs = 3x le temps

3. Collections auxiliaires
   â”œâ”€ ESC, ECOC, APC = Ã©critures multiples
   â””â”€ Maintenance pÃ©riodique requise (compaction)

4. Taille des documents
   â”œâ”€ Overhead fixe + proportionnel Ã  la taille
   â””â”€ Documents > 100KB = impact plus important
```

### Optimisations

#### 1. Choisir le bon contention factor

```javascript
// Analyse risque vs performance
const contentionFactors = {
  // DonnÃ©es trÃ¨s sensibles + faible volume
  high_security: {
    contention: 16,
    useCase: 'SSN, carte bancaire (< 10K req/jour)',
    security: 'Maximum',
    performance: 'Faible'
  },

  // Ã‰quilibre (recommandÃ©)
  balanced: {
    contention: 8,
    useCase: 'DonnÃ©es sensibles (usage normal)',
    security: 'Ã‰levÃ©e',
    performance: 'Moyenne'
  },

  // Volume Ã©levÃ©
  high_volume: {
    contention: 4,
    useCase: 'Recherche frÃ©quente (> 100K req/jour)',
    security: 'Bonne',
    performance: 'Meilleure'
  },

  // DÃ©veloppement uniquement
  dev_only: {
    contention: 1,
    useCase: 'Tests de dÃ©veloppement',
    security: 'âš ï¸ Faible',
    performance: 'Optimale'
  }
};
```

#### 2. N'indexer que les champs nÃ©cessaires

```javascript
// âŒ Mauvais : Tout indexer
const badSchema = {
  fields: [
    { path: 'ssn', queries: { queryType: 'equality' } },
    { path: 'creditCard', queries: { queryType: 'equality' } },
    { path: 'passport', queries: { queryType: 'equality' } },
    { path: 'driverLicense', queries: { queryType: 'equality' } },
    { path: 'diagnosis', queries: { queryType: 'equality' } }
    // Overhead massif !
  ]
};

// âœ… Bon : SÃ©lectif
const goodSchema = {
  fields: [
    // IndexÃ© : Champs utilisÃ©s pour la recherche
    { path: 'ssn', queries: { queryType: 'equality', contention: 8 } },
    { path: 'accountNumber', queries: { queryType: 'equality', contention: 4 } },

    // Non indexÃ© : Champs sensibles mais pas de recherche nÃ©cessaire
    { path: 'creditCard', bsonType: 'string' },  // Pas de queries
    { path: 'diagnosis', bsonType: 'string' }    // Pas de queries
  ]
};
```

#### 3. Compaction rÃ©guliÃ¨re

Les collections de mÃ©tadonnÃ©es (ESC, ECOC) grossissent avec le temps et nÃ©cessitent une compaction :

```javascript
// compact-metadata.js
async function compactMetadata() {
  const client = new MongoClient(connectionString);
  await client.connect();

  try {
    const db = client.db('hospital');

    // Compacter les mÃ©tadonnÃ©es pour une collection
    await db.command({
      compactStructuredEncryptionData: 'patients',
      compactionTokens: {
        // Tokens gÃ©nÃ©rÃ©s par ClientEncryption
      }
    });

    console.log('Metadata compacted successfully');

  } finally {
    await client.close();
  }
}

// Ã€ exÃ©cuter pÃ©riodiquement :
// - Collections Ã  fort volume : Hebdomadaire
// - Collections normales : Mensuel
// - Collections Ã  faible volume : Trimestriel
```

**Automatisation avec cron** :

```bash
#!/bin/bash
# compact-qe-weekly.sh

# ExÃ©cuter chaque dimanche Ã  2h du matin
# 0 2 * * 0 /usr/local/bin/compact-qe-weekly.sh

node /app/scripts/compact-metadata.js >> /var/log/qe-compaction.log 2>&1
```

#### 4. Monitoring et alerting

```javascript
// monitor-qe-performance.js
async function monitorQEPerformance() {
  const client = new MongoClient(connectionString);
  await client.connect();

  try {
    const db = client.db('hospital');

    // 1. Taille des collections de mÃ©tadonnÃ©es
    const escStats = await db.command({
      collStats: 'enxcol_.hospital.patients.esc'
    });

    const ecocStats = await db.command({
      collStats: 'enxcol_.hospital.patients.ecoc'
    });

    console.log('ESC size:', (escStats.size / 1024 / 1024).toFixed(2), 'MB');
    console.log('ECOC size:', (ecocStats.size / 1024 / 1024).toFixed(2), 'MB');

    // Alerte si taille > seuil
    const MAX_SIZE_MB = 1000;
    if (escStats.size / 1024 / 1024 > MAX_SIZE_MB) {
      console.warn('âš ï¸ ESC collection requires compaction');
      // Envoyer une alerte (PagerDuty, Slack, etc.)
    }

    // 2. Performance des requÃªtes
    const slowQueries = await db.command({
      profile: -1,  // RÃ©cupÃ©rer les slow queries
      filter: { ns: 'hospital.patients', millis: { $gt: 100 } }
    });

    console.log('Slow QE queries:', slowQueries);

  } finally {
    await client.close();
  }
}

// ExÃ©cuter toutes les heures
setInterval(monitorQEPerformance, 3600000);
```

### Dimensionnement

**Recommandations matÃ©rielles** :

```
Configuration minimale :
â”œâ”€ CPU : 8 cores (QE est CPU-intensif)
â”œâ”€ RAM : 16 GB (cache des tokens)
â”œâ”€ Storage : SSD NVMe obligatoire
â””â”€ IOPS : 5000+ provisionnÃ©s

Configuration recommandÃ©e :
â”œâ”€ CPU : 16+ cores
â”œâ”€ RAM : 32 GB
â”œâ”€ Storage : NVMe avec > 10K IOPS
â””â”€ Network : 10 Gbps

Estimation stockage :
â”œâ”€ Collection principale : Taille normale + 20%
â”œâ”€ ESC : ~50% de la taille de la collection principale
â”œâ”€ ECOC : ~10% de la taille de la collection principale
â””â”€ APC (7.0+) : ~5% de la taille de la collection principale

Exemple pour 100 GB de donnÃ©es :
â”œâ”€ Patients : 120 GB (donnÃ©es + overhead)
â”œâ”€ ESC : 60 GB
â”œâ”€ ECOC : 12 GB
â”œâ”€ APC : 6 GB
â””â”€ Total : ~200 GB
```

## Limitations et considÃ©rations

### Limitations techniques

```
1. Types de requÃªtes
   âœ“ Ã‰galitÃ© exacte uniquement
   âœ— Range queries ($gt, $lt, etc.)
   âœ— Regex / Pattern matching
   âœ— Text search
   âœ— Sorting sur champs chiffrÃ©s

2. Index
   âœ“ Index automatique via tokens
   âœ— Index MongoDB classiques (pas compatibles)
   âœ— Index composÃ©s sur champs chiffrÃ©s

3. AgrÃ©gations
   âœ“ $match avec Ã©galitÃ© simple
   âœ— $group sur champs chiffrÃ©s
   âœ— $lookup avec champs chiffrÃ©s
   âœ— $facet, $bucket, etc.

4. Change Streams
   âœ“ Fonctionnent mais :
   âœ— Pas de filtres sur champs chiffrÃ©s

5. Transactions
   âœ“ SupportÃ©es
   âš ï¸ Impact performance augmentÃ©

6. Taille
   âœ“ Documents < 2 MB recommandÃ©
   âœ— Documents > 16 MB (limite BSON)
```

### Cas d'usage inappropriÃ©s

```
âŒ Ne PAS utiliser Queryable Encryption pour :

1. Analytics et reporting
   â†’ Range queries et agrÃ©gations nÃ©cessaires
   â†’ Utiliser des vues dÃ©rivÃ©es avec donnÃ©es masquÃ©es

2. Full-text search
   â†’ Text search impossible sur champs chiffrÃ©s
   â†’ Utiliser Atlas Search sur champs non sensibles

3. DonnÃ©es avec relations complexes
   â†’ $lookup difficile avec champs chiffrÃ©s
   â†’ Repenser le modÃ¨le de donnÃ©es

4. Sorting requis sur champs sensibles
   â†’ Impossible de trier sur champs chiffrÃ©s
   â†’ Stocker un hash pour le tri

5. Volume trÃ¨s Ã©levÃ© (> 1M writes/jour)
   â†’ Overhead trop important
   â†’ ConsidÃ©rer CSFLE Deterministic si acceptable

6. Contraintes de latence strictes (< 10ms)
   â†’ QE ajoute 20-50ms de latence
   â†’ Pas adaptÃ© aux APIs haute performance
```

### Cas d'usage appropriÃ©s

```
âœ… Utiliser Queryable Encryption pour :

1. DonnÃ©es PCI-DSS (cartes bancaires)
   â””â”€ Recherche par numÃ©ro de carte nÃ©cessaire
   â””â”€ Protection maximale requise

2. DonnÃ©es HIPAA (santÃ©)
   â””â”€ Recherche par patient ID, SSN
   â””â”€ ConformitÃ© rÃ©glementaire

3. Informations personnelles identifiables (PII)
   â””â”€ SSN, passeport, permis de conduire
   â””â”€ Recherche par identifiant

4. DonnÃ©es financiÃ¨res sensibles
   â””â”€ NumÃ©ros de compte
   â””â”€ IBAN, SWIFT codes

5. SystÃ¨mes Ã  haute sÃ©curitÃ©
   â””â”€ Gouvernement, dÃ©fense
   â””â”€ Zero-trust architecture

6. Multi-tenant avec isolation stricte
   â””â”€ Tenant ID chiffrÃ©
   â””â”€ Recherche par tenant
```

## Migration vers Queryable Encryption

### Depuis CSFLE classique

```javascript
// migration-csfle-to-qe.js
const { MongoClient, ClientEncryption } = require('mongodb');

async function migrateCsfleToQE() {
  // Client CSFLE (ancien)
  const csfleClient = await createCSFLEClient();

  // Client QE (nouveau)
  const qeClient = await createQueryableClient();

  try {
    await csfleClient.connect();
    await qeClient.connect();

    const csfleDb = csfleClient.db('hospital');
    const qeDb = qeClient.db('hospital');

    const csfleCollection = csfleDb.collection('patients');
    const qeCollection = qeDb.collection('patients_qe');

    // CrÃ©er la nouvelle collection avec QE
    await qeDb.createCollection('patients_qe', {
      encryptedFields: encryptedFieldsMap['hospital.patients']
    });

    // Migrer les donnÃ©es
    let migrated = 0;
    const cursor = csfleCollection.find({});

    while (await cursor.hasNext()) {
      const doc = await cursor.next();

      // Les champs seront automatiquement dÃ©chiffrÃ©s (CSFLE)
      // puis re-chiffrÃ©s avec QE lors de l'insertion
      await qeCollection.insertOne(doc);

      migrated++;

      if (migrated % 1000 === 0) {
        console.log(`Migrated ${migrated} documents`);
      }
    }

    console.log(`Migration complete: ${migrated} documents`);

    // VÃ©rification
    const qeCount = await qeCollection.countDocuments();
    const csfleCount = await csfleCollection.countDocuments();

    if (qeCount === csfleCount) {
      console.log('âœ“ Count verification passed');

      // Renommer les collections
      // await csfleCollection.rename('patients_backup');
      // await qeCollection.rename('patients');
    } else {
      console.error('âœ— Count mismatch!');
    }

  } finally {
    await csfleClient.close();
    await qeClient.close();
  }
}

migrateCsfleToQE().catch(console.error);
```

### Depuis donnÃ©es non chiffrÃ©es

```javascript
// migration-plaintext-to-qe.js
async function migratePlaintextToQE() {
  const plainClient = new MongoClient(connectionString);
  const qeClient = await createQueryableClient();

  try {
    await plainClient.connect();
    await qeClient.connect();

    const plainDb = plainClient.db('hospital');
    const qeDb = qeClient.db('hospital');

    const plainCollection = plainDb.collection('patients');
    const qeCollection = qeDb.collection('patients_encrypted');

    // CrÃ©er la collection avec QE
    await qeDb.createCollection('patients_encrypted', {
      encryptedFields: encryptedFieldsMap['hospital.patients']
    });

    // StratÃ©gie : Dual-write pendant la migration
    // 1. Ã‰crire dans les deux collections
    // 2. Lire depuis la nouvelle (QE)
    // 3. AprÃ¨s migration complÃ¨te, supprimer l'ancienne

    // Migration batch par batch
    const batchSize = 1000;
    let skip = 0;
    let total = 0;

    while (true) {
      const batch = await plainCollection
        .find({})
        .skip(skip)
        .limit(batchSize)
        .toArray();

      if (batch.length === 0) break;

      // Insertion avec chiffrement
      await qeCollection.insertMany(batch);

      total += batch.length;
      skip += batchSize;

      console.log(`Migrated ${total} documents`);

      // Throttling pour ne pas surcharger
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    console.log(`Migration complete: ${total} documents`);

  } finally {
    await plainClient.close();
    await qeClient.close();
  }
}

migratePlaintextToQE().catch(console.error);
```

## Troubleshooting

### Erreur : "Encrypted index operation failed"

```javascript
// Diagnostic
// 1. VÃ©rifier que les collections de mÃ©tadonnÃ©es existent
db.getCollectionNames().filter(name => name.startsWith('enxcol_'))

// Output attendu :
// [
//   "enxcol_.hospital.patients.esc",
//   "enxcol_.hospital.patients.ecoc",
//   "enxcol_.hospital.patients.apc"  // MongoDB 7.0+
// ]

// 2. VÃ©rifier les index
db.enxcol_.hospital.patients.esc.getIndexes()

// 3. Si collections manquantes, recrÃ©er la collection
db.patients.drop()
db.createCollection('patients', {
  encryptedFields: encryptedFieldsMap['hospital.patients']
})
```

### Erreur : "Contention factor mismatch"

```javascript
// Cause : Le contention factor dans le schÃ©ma ne correspond pas
// Ã  celui utilisÃ© lors de la crÃ©ation de la collection

// Solution : VÃ©rifier la configuration
db.patients.stats({ indexDetails: true })

// RecrÃ©er si nÃ©cessaire
db.patients.drop()
db.createCollection('patients', {
  encryptedFields: {
    fields: [
      {
        path: 'ssn',
        bsonType: 'string',
        queries: {
          queryType: 'equality',
          contention: 8  // Doit correspondre Ã  la crÃ©ation
        }
      }
    ]
  }
})
```

### Performance dÃ©gradÃ©e

```javascript
// 1. VÃ©rifier la taille des collections de mÃ©tadonnÃ©es
const escSize = db.enxcol_.hospital.patients.esc.stats().size
const ecocSize = db.enxcol_.hospital.patients.ecoc.stats().size

console.log('ESC:', (escSize / 1024 / 1024).toFixed(2), 'MB')
console.log('ECOC:', (ecocSize / 1024 / 1024).toFixed(2), 'MB')

// Si taille > 1 GB, compacter
await db.command({
  compactStructuredEncryptionData: 'patients'
})

// 2. VÃ©rifier le contention factor
// Si contention trop Ã©levÃ© (> 16), considÃ©rer de le rÃ©duire

// 3. Profiler les requÃªtes
db.setProfilingLevel(2)
db.system.profile.find({ ns: 'hospital.patients' }).sort({ ts: -1 })

// 4. VÃ©rifier les ressources systÃ¨me
// CPU > 80% ? Augmenter les cores
// RAM > 90% ? Augmenter la mÃ©moire
// IOPS maxed out ? Utiliser storage plus rapide
```

### Erreur : "crypt_shared library not found"

```bash
# Installation de crypt_shared (recommandÃ© vs mongocryptd)

# Ubuntu/Debian
wget https://downloads.mongodb.com/linux/mongo_crypt_shared_v1-ubuntu2004-x86_64-enterprise-6.0.0.tgz
tar -xvf mongo_crypt_shared_v1-ubuntu2004-x86_64-enterprise-6.0.0.tgz
sudo cp lib/mongo_crypt_v1.so /usr/local/lib/

# VÃ©rifier l'installation
ls -lh /usr/local/lib/mongo_crypt_v1.so

# Configuration dans l'application
const autoEncryptionOpts = {
  keyVaultNamespace,
  kmsProviders,
  encryptedFieldsMap,
  extraOptions: {
    cryptSharedLibPath: '/usr/local/lib/mongo_crypt_v1.so'
  }
}
```

## Bonnes pratiques de production

### Checklist de dÃ©ploiement

```
â˜ Architecture
  â˜ MongoDB 7.0+ (GA pour Queryable Encryption)
  â˜ KMS configurÃ© (AWS KMS, Azure, GCP)
  â˜ crypt_shared library installÃ©e
  â˜ Collections de mÃ©tadonnÃ©es planifiÃ©es (ESC, ECOC, APC)

â˜ SchÃ©ma de chiffrement
  â˜ Uniquement les champs nÃ©cessaires indexÃ©s
  â˜ Contention factor appropriÃ© (8 recommandÃ©)
  â˜ Tests de performance rÃ©alisÃ©s
  â˜ Documentation des champs chiffrÃ©s

â˜ Performance
  â˜ Dimensionnement appropriÃ© (CPU, RAM, IOPS)
  â˜ Monitoring des mÃ©tadonnÃ©es configurÃ©
  â˜ Compaction planifiÃ©e (hebdo/mensuel)
  â˜ Alertes sur taille ESC/ECOC

â˜ SÃ©curitÃ©
  â˜ Credentials KMS sÃ©curisÃ©s
  â˜ AccÃ¨s aux collections de mÃ©tadonnÃ©es restreint
  â˜ Audit logging activÃ©
  â˜ Backup du Key Vault

â˜ OpÃ©rationnel
  â˜ Runbook de troubleshooting
  â˜ ProcÃ©dure de compaction documentÃ©e
  â˜ Tests de restauration
  â˜ Plan de disaster recovery

â˜ Application
  â˜ Gestion d'erreurs robuste
  â˜ Fallback pour requÃªtes non supportÃ©es
  â˜ Logging appropriÃ©
  â˜ Retry logic pour timeouts
```

### Configuration de rÃ©fÃ©rence

```javascript
// production-config.js
const productionConfig = {
  // Connection MongoDB
  connection: {
    uri: 'mongodb://mongodb.prod.example.com:27017',
    options: {
      maxPoolSize: 100,
      minPoolSize: 20,
      maxIdleTimeMS: 30000,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 30000
    }
  },

  // Queryable Encryption
  autoEncryption: {
    keyVaultNamespace: 'encryption.__keyVault',

    kmsProviders: {
      aws: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
        sessionToken: process.env.AWS_SESSION_TOKEN  // Si IAM role
      }
    },

    encryptedFieldsMap: {
      'hospital.patients': {
        fields: [
          {
            path: 'ssn',
            bsonType: 'string',
            queries: {
              queryType: 'equality',
              contention: 8  // Ã‰quilibre sÃ©curitÃ©/performance
            }
          },
          {
            path: 'accountNumber',
            bsonType: 'string',
            queries: {
              queryType: 'equality',
              contention: 4  // Recherche frÃ©quente
            }
          },
          {
            path: 'creditCard.number',
            bsonType: 'string'
            // Pas de queries = chiffrÃ© mais pas indexÃ©
          }
        ]
      }
    },

    extraOptions: {
      cryptSharedLibPath: '/usr/local/lib/mongo_crypt_v1.so',
      // Timeouts appropriÃ©s pour production
      cryptSharedLibTimeoutMS: 5000
    }
  },

  // Monitoring
  monitoring: {
    slowQueryThreshold: 100,  // ms
    metadataCompactionThreshold: 1024,  // MB
    alerting: {
      enabled: true,
      channels: ['pagerduty', 'slack']
    }
  }
};

module.exports = { productionConfig };
```

### Maintenance planifiÃ©e

```bash
#!/bin/bash
# qe-maintenance.sh - Maintenance hebdomadaire

echo "=== Queryable Encryption Maintenance ==="
date

# 1. VÃ©rifier la taille des mÃ©tadonnÃ©es
echo "Checking metadata size..."
node scripts/check-metadata-size.js

# 2. Compacter si nÃ©cessaire
echo "Compacting metadata..."
node scripts/compact-metadata.js

# 3. VÃ©rifier la santÃ© des index
echo "Verifying indexes..."
node scripts/verify-indexes.js

# 4. Backup du Key Vault
echo "Backing up Key Vault..."
mongodump --uri="mongodb://..." --db=encryption --collection=__keyVault \
  --out=/backup/keyvault-$(date +%Y%m%d)

# 5. Rapport de performance
echo "Generating performance report..."
node scripts/qe-performance-report.js

echo "Maintenance complete"
```

## Comparaison finale : CSFLE vs Queryable Encryption

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          CSFLE
â”‚
â”‚  DÃ©terministe                        Random
â”‚  â”œâ”€ Recherche : âœ“                    â”œâ”€ Recherche : âœ—
â”‚  â”œâ”€ SÃ©curitÃ© : âš ï¸                    â”œâ”€ SÃ©curitÃ© : âœ“âœ“
â”‚  â”œâ”€ Performance : âœ“âœ“                 â”œâ”€ Performance : âœ“âœ“
â”‚  â””â”€ Use case : Lookup frÃ©quent       â””â”€ Use case : DonnÃ©es
â”‚                                              trÃ¨s sensibles
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Queryable Encryption
â”‚
â”‚  â”œâ”€ Recherche : âœ“ (via tokens)
â”‚  â”œâ”€ SÃ©curitÃ© : âœ“âœ“ (alÃ©atoire)
â”‚  â”œâ”€ Performance : âš ï¸ (overhead important)
â”‚  â””â”€ Use case : Besoin de recherche + sÃ©curitÃ© max
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| CritÃ¨re | CSFLE Deterministic | CSFLE Random | Queryable Encryption |
|---------|---------------------|--------------|----------------------|
| **Recherche d'Ã©galitÃ©** | âœ… Oui | âŒ Non | âœ… Oui |
| **SÃ©curitÃ© maximale** | âš ï¸ Moindre | âœ… Oui | âœ… Oui |
| **Pattern analysis** | âš ï¸ Possible | âœ… Impossible | âœ… Impossible |
| **Performance insert** | +200% | +200% | +900% |
| **Performance find** | +150% | +100% | +700% |
| **Overhead stockage** | +20% | +20% | +100% |
| **ComplexitÃ©** | Moyenne | Moyenne | Ã‰levÃ©e |
| **Version MongoDB** | 4.2+ | 4.2+ | 6.0+ (GA 7.0+) |
| **Maintenance** | Minimale | Minimale | Compaction rÃ©guliÃ¨re |

## Conclusion

Queryable Encryption reprÃ©sente l'Ã©tat de l'art du chiffrement dans MongoDB, offrant un compromis unique entre sÃ©curitÃ© maximale et capacitÃ© de recherche. C'est la seule solution qui permet de rechercher sur des donnÃ©es chiffrÃ©es de maniÃ¨re alÃ©atoire, Ã©liminant ainsi le risque d'analyse de frÃ©quence.

**Points clÃ©s** :

1. **SÃ©curitÃ© ultime** : Chiffrement alÃ©atoire cÃ´tÃ© client avec capacitÃ© de recherche
2. **Architecture complexe** : Index tokens, collections de mÃ©tadonnÃ©es, compaction
3. **Impact performance** : +900% sur insertions, +700% sur recherches
4. **Cas d'usage spÃ©cifiques** : PCI-DSS, HIPAA avec besoin de recherche
5. **Maintenance requise** : Compaction rÃ©guliÃ¨re des mÃ©tadonnÃ©es

**Quand utiliser Queryable Encryption** :

```
âœ… Oui si :
â”œâ”€ DonnÃ©es hautement sensibles (PCI, HIPAA)
â”œâ”€ Besoin de recherche par Ã©galitÃ©
â”œâ”€ Budget performance disponible
â”œâ”€ Expertise technique prÃ©sente
â””â”€ Volume < 100K insertions/jour

âŒ Non si :
â”œâ”€ Range queries nÃ©cessaires
â”œâ”€ Contraintes de latence strictes (< 10ms)
â”œâ”€ Volume trÃ¨s Ã©levÃ© (> 1M ops/jour)
â”œâ”€ Budget limitÃ© (matÃ©riel)
â””â”€ CSFLE Deterministic suffit
```

Queryable Encryption est l'aboutissement de la stratÃ©gie de dÃ©fense en profondeur de MongoDB, combinant TLS, Encryption at Rest, et chiffrement cÃ´tÃ© client pour une protection maximale des donnÃ©es sensibles.

---

**Ressources complÃ©mentaires** :
- MongoDB Manual : Queryable Encryption
- Cryptographic Foundations of Queryable Encryption (whitepaper)
- Performance Tuning Guide for Queryable Encryption
- NIST Post-Quantum Cryptography Standards

â­ï¸ [Audit](/11-securite/06-audit.md)
