üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.2.1 SCRAM (Salted Challenge Response Authentication Mechanism)

## Introduction

SCRAM (Salted Challenge Response Authentication Mechanism) est le m√©canisme d'authentification par d√©faut de MongoDB depuis la version 3.0. C'est un protocole standardis√© (RFC 5802) qui permet une authentification s√©curis√©e par mot de passe sans transmettre le mot de passe en clair sur le r√©seau, m√™me lors de l'authentification initiale.

MongoDB supporte deux variantes de SCRAM :
- **SCRAM-SHA-1** : Version historique (d√©pr√©ci√© depuis MongoDB 4.0)
- **SCRAM-SHA-256** : Version moderne et recommand√©e (d√©faut depuis MongoDB 4.0)

## Fonctionnement Technique de SCRAM

### Principes Fondamentaux

SCRAM repose sur plusieurs concepts cryptographiques :

1. **Challenge-Response** : Le serveur envoie un d√©fi que le client doit r√©soudre
2. **Salting** : Utilisation d'un salt al√©atoire pour chaque utilisateur
3. **Hashing it√©ratif** : Application r√©p√©t√©e de la fonction de hachage (PBKDF2)
4. **Proof mutuel** : Client et serveur se prouvent mutuellement leur identit√©

### Protocole d'Authentification D√©taill√©

```
CLIENT                                          SERVER
  |                                               |
  |--- 1. Client Hello (username) --------------->|
  |    "n,,n=user,r=clientNonce"                  |
  |                                               |
  |                                Generate serverNonce
  |                                Retrieve salt & iterationCount
  |                                               |
  |<-- 2. Server Challenge (salt, iteration) -----|
  |    "r=clientNonce+serverNonce,s=salt,i=iter"  |
  |                                               |
  Compute:                                        |
    SaltedPassword = PBKDF2(password, salt, iter) |
    ClientKey = HMAC(SaltedPassword, "Client Key")|
    StoredKey = SHA256(ClientKey)                 |
    AuthMessage = msg1 + msg2 + msg3              |
    ClientSignature = HMAC(StoredKey, AuthMessage)|
    ClientProof = ClientKey XOR ClientSignature   |
  |                                               |
  |--- 3. Client Proof -------------------------->|
  |    "c=biws,r=nonce,p=clientProof"             |
  |                                               |
  |                                Verify ClientProof
  |                                Generate ServerSignature
  |                                               |
  |<-- 4. Server Verification --------------------|
  |    "v=serverSignature"                        |
  |                                               |
  Verify serverSignature                          |
  |                                               |
  |============ AUTHENTICATED ====================|
```

### D√©tails Cryptographiques

#### SCRAM-SHA-256 (Recommand√©)

**Fonction de hachage** : SHA-256 (256 bits)
**PBKDF2** : Password-Based Key Derivation Function 2
**Iterations par d√©faut** : 15,000

**Formules math√©matiques** :

```
SaltedPassword := PBKDF2-SHA256(password, salt, iterations)
ClientKey      := HMAC-SHA256(SaltedPassword, "Client Key")
StoredKey      := SHA256(ClientKey)
ServerKey      := HMAC-SHA256(SaltedPassword, "Server Key")

# Pendant l'authentification
AuthMessage       := ClientFirstMsg + ServerFirstMsg + ClientFinalMsg
ClientSignature   := HMAC-SHA256(StoredKey, AuthMessage)
ClientProof       := ClientKey XOR ClientSignature

ServerSignature   := HMAC-SHA256(ServerKey, AuthMessage)
```

#### SCRAM-SHA-1 (D√©pr√©ci√©)

**Fonction de hachage** : SHA-1 (160 bits)
**Iterations par d√©faut** : 10,000
**Statut** : D√©pr√©ci√© depuis MongoDB 4.0, √† √©viter

**‚ö†Ô∏è Vuln√©rabilit√©s de SHA-1** :
- Collisions d√©montr√©es (2017, SHAttered attack)
- Force r√©duite (160 bits vs 256 bits)
- Non recommand√© pour nouveaux d√©ploiements

## Configuration et Activation

### Activation de SCRAM dans MongoDB

#### Configuration de Base

```yaml
# /etc/mongod.conf
security:
  authorization: enabled
  # SCRAM est activ√© par d√©faut, pas de configuration suppl√©mentaire n√©cessaire
```

#### V√©rification de la Configuration

```javascript
// V√©rifier les m√©canismes disponibles
db.serverStatus().security.authentication.mechanisms

// R√©sultat attendu:
[
  "SCRAM-SHA-1",
  "SCRAM-SHA-256"
]
```

### Cr√©ation d'Utilisateurs avec SCRAM

#### Utilisateur Simple (SCRAM-SHA-256 uniquement)

```javascript
use admin

db.createUser({
  user: "appuser",
  pwd: passwordPrompt(),  // Demande interactive du mot de passe
  roles: [
    { role: "readWrite", db: "myapp" }
  ],
  mechanisms: ["SCRAM-SHA-256"]  // Force SCRAM-SHA-256 uniquement
})
```

**Recommandation** : Toujours sp√©cifier `mechanisms: ["SCRAM-SHA-256"]` pour nouveaux utilisateurs afin d'√©viter SCRAM-SHA-1.

#### Utilisateur avec Mot de Passe Robuste

```javascript
use admin

// Fonction de g√©n√©ration de mot de passe robuste
function generateSecurePassword(length = 32) {
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
  let password = "";
  const crypto = require('crypto');

  for (let i = 0; i < length; i++) {
    const randomIndex = crypto.randomInt(0, charset.length);
    password += charset[randomIndex];
  }

  return password;
}

// Cr√©er utilisateur avec mot de passe s√©curis√©
db.createUser({
  user: "secure_appuser",
  pwd: generateSecurePassword(32),  // Mot de passe de 32 caract√®res
  roles: [
    { role: "readWrite", db: "myapp" }
  ],
  mechanisms: ["SCRAM-SHA-256"],
  passwordDigestor: "server"  // Hachage c√¥t√© serveur (d√©faut)
})
```

#### Utilisateur avec Restrictions d'Acc√®s

```javascript
use admin

db.createUser({
  user: "webapp_production",
  pwd: passwordPrompt(),
  roles: [
    { role: "readWrite", db: "production_db" }
  ],
  mechanisms: ["SCRAM-SHA-256"],

  // Restrictions r√©seau
  authenticationRestrictions: [
    {
      // N'autorise que depuis le r√©seau applicatif
      clientSource: ["10.0.2.0/24", "10.0.3.0/24"],

      // N'autorise que vers les instances MongoDB sp√©cifiques
      serverAddress: ["10.0.1.100", "10.0.1.101", "10.0.1.102"]
    }
  ]
})
```

### Gestion des Utilisateurs Existants

#### Lister les Utilisateurs et leurs M√©canismes

```javascript
// Lister tous les utilisateurs avec leurs m√©canismes
use admin
db.system.users.find({}, {
  user: 1,
  db: 1,
  mechanisms: 1,
  "credentials.SCRAM-SHA-1": { $exists: 1 },
  "credentials.SCRAM-SHA-256": { $exists: 1 }
}).pretty()

// R√©sultat exemple:
{
  "_id" : "admin.olduser",
  "user" : "olduser",
  "db" : "admin",
  "mechanisms" : [ "SCRAM-SHA-1", "SCRAM-SHA-256" ],
  "credentials" : {
    "SCRAM-SHA-1" : { ... },
    "SCRAM-SHA-256" : { ... }
  }
}
```

#### Mettre √† Jour les M√©canismes d'un Utilisateur

```javascript
// Forcer SCRAM-SHA-256 uniquement pour un utilisateur existant
use admin

db.updateUser("olduser", {
  mechanisms: ["SCRAM-SHA-256"]  // Retire SCRAM-SHA-1
})

// V√©rification
db.getUser("olduser", { showCredentials: true })
```

#### Changer le Mot de Passe

```javascript
use admin

// M√©thode 1 : Interactive
db.changeUserPassword("appuser", passwordPrompt())

// M√©thode 2 : Programmatique
db.updateUser("appuser", {
  pwd: "NewSecurePassword123!"
})

// M√©thode 3 : Avec script automatis√©
const username = "appuser";
const newPassword = generateSecurePassword(32);

db.updateUser(username, { pwd: newPassword });

// Stocker dans un gestionnaire de secrets
// await vault.write(`mongodb/passwords/${username}`, { password: newPassword });
```

## Stockage des Credentials SCRAM

### Structure dans admin.system.users

MongoDB stocke les credentials SCRAM dans la collection `admin.system.users` :

```javascript
// Visualiser un utilisateur (avec credentials)
use admin
db.system.users.findOne({ user: "appuser" })

// Structure compl√®te:
{
  _id: "admin.appuser",
  userId: UUID("..."),
  user: "appuser",
  db: "admin",

  // Credentials SCRAM-SHA-256
  credentials: {
    "SCRAM-SHA-256": {
      // Nombre d'it√©rations PBKDF2
      iterationCount: NumberInt(15000),

      // Salt unique (Base64)
      salt: "qA7fG8D5hY2pN1kL3mO9rT6vB4cE0wZ8",

      // StoredKey = SHA256(ClientKey)
      storedKey: "R3c4K8mN5hY7pL2qT9vB6wZ0xJ1aD4fG8sE3nM7oI5uY1cV0bX2kT4jL9pR6wQ8z",

      // ServerKey pour v√©rification mutuelle
      serverKey: "D5fG8hY1kL3mN7pQ9rT2vB4wZ6xA0cE8jK1lM3nO5sU7vY9aC1bD3eF5gH7iJ9k"
    }
  },

  mechanisms: ["SCRAM-SHA-256"],

  roles: [
    { role: "readWrite", db: "myapp" }
  ],

  authenticationRestrictions: [ ... ]
}
```

### S√©curit√© du Stockage

**Points importants** :

1. **Le mot de passe n'est jamais stock√©** : Seules les d√©rivations cryptographiques sont conserv√©es
2. **Salt unique** : Chaque utilisateur a un salt al√©atoire diff√©rent
3. **Iterations √©lev√©es** : 15,000 it√©rations ralentissent les attaques par bruteforce
4. **StoredKey ‚â† Password** : Impossible de retrouver le mot de passe √† partir du StoredKey

**Calcul de s√©curit√©** :

```
Temps de bruteforce (15,000 it√©rations) :
- GPU moderne : ~50,000 hashs/seconde
- Pour un password de 12 caract√®res (alphanum√©riques + symboles) :
  - Espace : 95^12 ‚âà 5.4 √ó 10^23 combinaisons
  - Temps : ~342 millions d'ann√©es

Comparaison sans PBKDF2 (1 it√©ration) :
- GPU moderne : ~10 milliards hashs/seconde
- Temps : ~1,7 millions d'ann√©es
```

**Protection** : Le fichier `admin.system.users` doit √™tre prot√©g√© :
- Acc√®s limit√© au syst√®me (backup encryption)
- Permissions MongoDB strictes
- Audit des acc√®s

## Connexion avec SCRAM

### Connection Strings

#### Format Standard

```javascript
// SCRAM-SHA-256 explicite
mongodb://username:password@host:27017/database?authMechanism=SCRAM-SHA-256&authSource=admin

// SCRAM automatique (n√©gociation)
mongodb://username:password@host:27017/database?authSource=admin

// Replica Set
mongodb://username:password@host1:27017,host2:27017,host3:27017/database?replicaSet=rs0&authSource=admin&authMechanism=SCRAM-SHA-256

// Avec options TLS
mongodb://username:password@host:27017/database?authMechanism=SCRAM-SHA-256&authSource=admin&tls=true&tlsCAFile=/etc/ssl/ca.pem
```

#### Format SRV

```javascript
// MongoDB Atlas / DNS Seedlist
mongodb+srv://username:password@cluster.mongodb.net/database?authSource=admin&authMechanism=SCRAM-SHA-256
```

### Connexion avec les Drivers

#### Node.js (MongoDB Driver)

```javascript
const { MongoClient } = require('mongodb');

// Option 1 : URI compl√®te
const uri = "mongodb://user:pass@localhost:27017/mydb?authMechanism=SCRAM-SHA-256&authSource=admin";

const client = new MongoClient(uri, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  maxPoolSize: 50
});

// Option 2 : Credentials s√©par√©s
const client = new MongoClient("mongodb://localhost:27017", {
  auth: {
    username: process.env.MONGO_USER,
    password: process.env.MONGO_PASS
  },
  authSource: 'admin',
  authMechanism: 'SCRAM-SHA-256',
  maxPoolSize: 50
});

async function connect() {
  try {
    await client.connect();
    console.log("Connected with SCRAM-SHA-256");

    const db = client.db("mydb");
    // Op√©rations...
  } catch (err) {
    console.error("Authentication failed:", err);
  } finally {
    await client.close();
  }
}

connect();
```

#### Python (PyMongo)

```python
from pymongo import MongoClient
from pymongo.auth import SCRAM_SHA_256
import os

# Option 1 : URI
uri = f"mongodb://{os.getenv('MONGO_USER')}:{os.getenv('MONGO_PASS')}@localhost:27017/mydb?authMechanism=SCRAM-SHA-256&authSource=admin"
client = MongoClient(uri)

# Option 2 : Param√®tres
client = MongoClient(
    'localhost',
    27017,
    username=os.getenv('MONGO_USER'),
    password=os.getenv('MONGO_PASS'),
    authSource='admin',
    authMechanism='SCRAM-SHA-256',
    maxPoolSize=50
)

# Test de connexion
try:
    client.admin.command('ping')
    print("Connected with SCRAM-SHA-256")
except Exception as e:
    print(f"Authentication failed: {e}")
```

#### Java (MongoDB Java Driver)

```java
import com.mongodb.MongoClientSettings;
import com.mongodb.MongoCredential;
import com.mongodb.ServerAddress;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.ConnectionString;

// Option 1 : Connection String
String uri = "mongodb://user:pass@localhost:27017/mydb?authMechanism=SCRAM-SHA-256&authSource=admin";
MongoClient client = MongoClients.create(uri);

// Option 2 : MongoCredential
MongoCredential credential = MongoCredential.createScramSha256Credential(
    "user",
    "admin",
    "password".toCharArray()
);

MongoClientSettings settings = MongoClientSettings.builder()
    .applyToClusterSettings(builder ->
        builder.hosts(Arrays.asList(new ServerAddress("localhost", 27017))))
    .credential(credential)
    .build();

MongoClient client = MongoClients.create(settings);
```

#### Go (mongo-go-driver)

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // Option 1 : URI
    uri := fmt.Sprintf(
        "mongodb://%s:%s@localhost:27017/mydb?authMechanism=SCRAM-SHA-256&authSource=admin",
        os.Getenv("MONGO_USER"),
        os.Getenv("MONGO_PASS"),
    )

    client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect(ctx)

    // Option 2 : Credential
    credential := options.Credential{
        AuthMechanism: "SCRAM-SHA-256",
        AuthSource:    "admin",
        Username:      os.Getenv("MONGO_USER"),
        Password:      os.Getenv("MONGO_PASS"),
    }

    clientOpts := options.Client().
        ApplyURI("mongodb://localhost:27017").
        SetAuth(credential)

    client, err = mongo.Connect(ctx, clientOpts)

    // Test connexion
    err = client.Ping(ctx, nil)
    if err != nil {
        log.Fatal("Authentication failed:", err)
    }

    fmt.Println("Connected with SCRAM-SHA-256")
}
```

## Migration SCRAM-SHA-1 vers SCRAM-SHA-256

### Pourquoi Migrer ?

**Raisons de s√©curit√©** :
- SHA-1 est consid√©r√© cryptographiquement faible
- SCRAM-SHA-256 offre une s√©curit√© sup√©rieure (256 bits vs 160 bits)
- MongoDB 4.0+ recommande SCRAM-SHA-256 comme d√©faut
- Conformit√© aux standards de s√©curit√© modernes

### Strat√©gie de Migration

#### Phase 1 : Audit des Utilisateurs

```javascript
// Script d'audit : identifier les utilisateurs avec SCRAM-SHA-1
use admin

const usersWithSHA1 = db.system.users.find({
  "credentials.SCRAM-SHA-1": { $exists: true }
}).toArray();

print(`Utilisateurs avec SCRAM-SHA-1 : ${usersWithSHA1.length}`);

usersWithSHA1.forEach(user => {
  print(`- ${user.user}@${user.db}`);
  print(`  M√©canismes : ${user.mechanisms.join(', ')}`);
});
```

#### Phase 2 : G√©n√©ration de Rapport

```javascript
// G√©n√©rer un rapport d√©taill√©
function auditSCRAMUsers() {
  const report = {
    timestamp: new Date(),
    totalUsers: 0,
    sha1Only: [],
    sha256Only: [],
    both: [],
    recommendations: []
  };

  db.system.users.find().forEach(user => {
    report.totalUsers++;

    const hasSHA1 = user.credentials && user.credentials["SCRAM-SHA-1"];
    const hasSHA256 = user.credentials && user.credentials["SCRAM-SHA-256"];

    const userInfo = {
      username: `${user.user}@${user.db}`,
      mechanisms: user.mechanisms || []
    };

    if (hasSHA1 && !hasSHA256) {
      report.sha1Only.push(userInfo);
      report.recommendations.push(
        `CRITICAL: ${userInfo.username} utilise uniquement SCRAM-SHA-1`
      );
    } else if (!hasSHA1 && hasSHA256) {
      report.sha256Only.push(userInfo);
    } else if (hasSHA1 && hasSHA256) {
      report.both.push(userInfo);
      report.recommendations.push(
        `WARNING: ${userInfo.username} utilise les deux m√©canismes`
      );
    }
  });

  return report;
}

const report = auditSCRAMUsers();
printjson(report);
```

#### Phase 3 : Migration Progressive

**M√©thode 1 : Mise √† jour utilisateur par utilisateur**

```javascript
use admin

// Pour chaque utilisateur, mettre √† jour les m√©canismes
db.getUsers().forEach(user => {
  if (user.mechanisms.includes("SCRAM-SHA-1")) {
    print(`Migrating user: ${user.user}`);

    // Option A : Ajouter SCRAM-SHA-256 tout en gardant SHA-1 temporairement
    db.updateUser(user.user, {
      mechanisms: ["SCRAM-SHA-1", "SCRAM-SHA-256"]
    });

    print(`  ‚úì ${user.user} supports now both SHA-1 and SHA-256`);
  }
});

// Apr√®s v√©rification que tous les clients fonctionnent avec SHA-256...
// Retirer SCRAM-SHA-1
db.getUsers().forEach(user => {
  if (user.mechanisms.includes("SCRAM-SHA-1")) {
    print(`Removing SHA-1 from: ${user.user}`);

    db.updateUser(user.user, {
      mechanisms: ["SCRAM-SHA-256"]
    });

    print(`  ‚úì ${user.user} now uses only SHA-256`);
  }
});
```

**M√©thode 2 : Forcer le changement de mot de passe**

```javascript
use admin

// Forcer changement de password = r√©g√©n√©ration des credentials
function migrateUserToSHA256(username) {
  // G√©n√©rer un nouveau mot de passe temporaire
  const tempPassword = generateSecurePassword(32);

  db.updateUser(username, {
    pwd: tempPassword,
    mechanisms: ["SCRAM-SHA-256"]
  });

  print(`User ${username} migrated to SCRAM-SHA-256`);
  print(`Temporary password: ${tempPassword}`);
  print(`IMPORTANT: Notify user to change password immediately`);

  return tempPassword;
}

// Migrer tous les utilisateurs
db.getUsers().forEach(user => {
  if (user.mechanisms.includes("SCRAM-SHA-1")) {
    const tempPass = migrateUserToSHA256(user.user);
    // Envoyer email/notification √† l'utilisateur...
  }
});
```

#### Phase 4 : V√©rification Post-Migration

```javascript
// V√©rifier qu'aucun utilisateur n'a plus SCRAM-SHA-1
use admin

const legacyUsers = db.system.users.find({
  mechanisms: "SCRAM-SHA-1"
}).toArray();

if (legacyUsers.length === 0) {
  print("‚úÖ Migration compl√®te : Aucun utilisateur avec SCRAM-SHA-1");
} else {
  print("‚ùå Migration incompl√®te :");
  legacyUsers.forEach(user => {
    print(`  - ${user.user}@${user.db}`);
  });
}
```

### Script Automatis√© de Migration

```bash
#!/bin/bash
# migrate-scram.sh

MONGO_HOST="localhost:27017"
MONGO_USER="admin"
MONGO_PASS="adminpass"

echo "=== SCRAM Migration Script ==="
echo "Phase 1: Audit"

mongosh "mongodb://${MONGO_USER}:${MONGO_PASS}@${MONGO_HOST}/admin?authSource=admin" <<EOF
  const users = db.system.users.find({
    "credentials.SCRAM-SHA-1": { \$exists: true }
  }).toArray();

  print(\`Found \${users.length} users with SCRAM-SHA-1\`);

  users.forEach(user => {
    print(\`- \${user.user}@\${user.db}\`);
  });
EOF

echo ""
read -p "Continue with migration? (y/n) " -n 1 -r
echo

if [[ $REPLY =~ ^[Yy]$ ]]; then
  echo "Phase 2: Migration"

  mongosh "mongodb://${MONGO_USER}:${MONGO_PASS}@${MONGO_HOST}/admin?authSource=admin" <<EOF
    db.getUsers().forEach(user => {
      if (user.mechanisms && user.mechanisms.includes("SCRAM-SHA-1")) {
        print(\`Migrating \${user.user}...\`);

        db.updateUser(user.user, {
          mechanisms: ["SCRAM-SHA-256"]
        });

        print(\`  ‚úì \${user.user} migrated\`);
      }
    });

    print("Migration complete!");
EOF
fi

echo "=== Migration Finished ==="
```

## Performance et Scalabilit√©

### Impact des Iterations PBKDF2

Le nombre d'it√©rations PBKDF2 affecte directement :
- **S√©curit√©** : Plus d'it√©rations = plus difficile √† brute-forcer
- **Performance** : Plus d'it√©rations = authentification plus lente

#### Benchmarks

```javascript
// Test de performance des it√©rations
const crypto = require('crypto');

function benchmarkPBKDF2(iterations) {
  const start = Date.now();

  for (let i = 0; i < 100; i++) {
    crypto.pbkdf2Sync(
      'password',
      'salt',
      iterations,
      32,
      'sha256'
    );
  }

  const end = Date.now();
  const avgTime = (end - start) / 100;

  return avgTime;
}

// R√©sultats (ms par authentification)
console.log("Iterations | Avg Time");
console.log("10,000     | " + benchmarkPBKDF2(10000).toFixed(2) + " ms");
console.log("15,000     | " + benchmarkPBKDF2(15000).toFixed(2) + " ms");
console.log("20,000     | " + benchmarkPBKDF2(20000).toFixed(2) + " ms");
console.log("50,000     | " + benchmarkPBKDF2(50000).toFixed(2) + " ms");

// R√©sultats typiques sur CPU moderne :
// 10,000  | 8-10 ms
// 15,000  | 12-15 ms (d√©faut MongoDB)
// 20,000  | 16-20 ms
// 50,000  | 40-50 ms
```

#### Recommandations

| Environnement | Iterations Recommand√©es | Justification |
|---------------|------------------------|---------------|
| **Production standard** | 15,000 (d√©faut) | Bon √©quilibre s√©curit√©/performance |
| **Haute s√©curit√©** | 20,000 - 30,000 | Applications financi√®res, sant√© |
| **Haute performance** | 10,000 | Si milliers d'auth/seconde n√©cessaires |
| **D√©veloppement** | 10,000 | Acc√©l√©rer les tests |

**‚ö†Ô∏è Note** : Les iterations ne sont pas configurables directement dans MongoDB (valeur fixe de 15,000 pour SHA-256).

### Connection Pooling

SCRAM b√©n√©ficie du connection pooling car l'authentification n'est effectu√©e qu'√† l'√©tablissement de la connexion.

```javascript
// Node.js : Configuration du pool
const client = new MongoClient(uri, {
  maxPoolSize: 100,        // Max connexions simultan√©es
  minPoolSize: 10,         // Connexions pr√©-√©tablies
  maxIdleTimeMS: 30000,    // Fermeture apr√®s 30s d'inactivit√©
  waitQueueTimeoutMS: 5000 // Timeout si pool satur√©
});

// Avec un pool de 100 connexions :
// - 100 authentifications initiales
// - Puis r√©utilisation des connexions authentifi√©es
// - Authentification amortie sur toutes les requ√™tes
```

### Scalabilit√© Horizontale

SCRAM est stateless et scale naturellement :

```
Load Balancer
      |
      ‚îú‚îÄ‚îÄ‚îÄ App Server 1 ‚Üí MongoDB (pool de 50 conn)
      |                   ‚Üì SCRAM auth √ó 50
      |
      ‚îú‚îÄ‚îÄ‚îÄ App Server 2 ‚Üí MongoDB (pool de 50 conn)
      |                   ‚Üì SCRAM auth √ó 50
      |
      ‚îî‚îÄ‚îÄ‚îÄ App Server 3 ‚Üí MongoDB (pool de 50 conn)
                          ‚Üì SCRAM auth √ó 50

Total: 150 connexions authentifi√©es, r√©utilisables
```

**Avantages** :
- Pas de session server-side √† partager
- Chaque serveur applicatif est ind√©pendant
- Scale lin√©airement avec le nombre de serveurs

## S√©curit√© Avanc√©e

### Politique de Mots de Passe

MongoDB ne fournit pas de validation de politique de mots de passe nativement. Impl√©mentation au niveau applicatif :

```javascript
// Validation de mot de passe robuste
function validatePassword(password) {
  const errors = [];

  // Longueur minimale
  if (password.length < 16) {
    errors.push("Le mot de passe doit contenir au moins 16 caract√®res");
  }

  // Complexit√©
  if (!/[a-z]/.test(password)) {
    errors.push("Le mot de passe doit contenir au moins une minuscule");
  }
  if (!/[A-Z]/.test(password)) {
    errors.push("Le mot de passe doit contenir au moins une majuscule");
  }
  if (!/[0-9]/.test(password)) {
    errors.push("Le mot de passe doit contenir au moins un chiffre");
  }
  if (!/[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]/.test(password)) {
    errors.push("Le mot de passe doit contenir au moins un caract√®re sp√©cial");
  }

  // Pas de mots du dictionnaire (basique)
  const commonPasswords = [
    "password", "123456", "admin", "mongodb", "database"
  ];
  if (commonPasswords.some(common => password.toLowerCase().includes(common))) {
    errors.push("Le mot de passe ne doit pas contenir de mots communs");
  }

  return {
    valid: errors.length === 0,
    errors: errors
  };
}

// Utilisation lors de la cr√©ation d'utilisateur
const newPassword = generateSecurePassword(24);
const validation = validatePassword(newPassword);

if (validation.valid) {
  db.createUser({
    user: "newuser",
    pwd: newPassword,
    roles: [{ role: "readWrite", db: "myapp" }],
    mechanisms: ["SCRAM-SHA-256"]
  });
} else {
  print("Password validation failed:");
  validation.errors.forEach(err => print("  - " + err));
}
```

### Rotation Automatis√©e des Credentials

```javascript
// Script de rotation de mots de passe
class PasswordRotationManager {
  constructor(db, vaultClient) {
    this.db = db;
    this.vault = vaultClient;
  }

  async rotatePassword(username, database = "admin") {
    try {
      // 1. G√©n√©rer nouveau mot de passe
      const newPassword = this.generateSecurePassword(32);

      // 2. Valider le mot de passe
      const validation = validatePassword(newPassword);
      if (!validation.valid) {
        throw new Error("Generated password failed validation");
      }

      // 3. Mettre √† jour dans MongoDB
      this.db.getSiblingDB(database).updateUser(username, {
        pwd: newPassword
      });

      // 4. Stocker dans Vault
      await this.vault.write(`mongodb/passwords/${username}`, {
        password: newPassword,
        rotatedAt: new Date().toISOString(),
        rotatedBy: "automated-rotation"
      });

      // 5. Logger l'op√©ration
      this.db.getSiblingDB("audit").passwordRotations.insertOne({
        username: username,
        database: database,
        timestamp: new Date(),
        success: true
      });

      // 6. Notifier (optionnel)
      await this.notify(`Password rotated for ${username}`);

      return { success: true, username: username };

    } catch (error) {
      // Logger l'√©chec
      this.db.getSiblingDB("audit").passwordRotations.insertOne({
        username: username,
        database: database,
        timestamp: new Date(),
        success: false,
        error: error.message
      });

      throw error;
    }
  }

  generateSecurePassword(length) {
    // Impl√©mentation de g√©n√©ration s√©curis√©e
    const crypto = require('crypto');
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
    let password = "";

    for (let i = 0; i < length; i++) {
      const randomIndex = crypto.randomInt(0, charset.length);
      password += charset[randomIndex];
    }

    return password;
  }

  async notify(message) {
    // Impl√©mentation de notification (Slack, email, etc.)
    console.log(`[NOTIFICATION] ${message}`);
  }
}

// Utilisation
const rotationManager = new PasswordRotationManager(db, vaultClient);

// Rotation planifi√©e (tous les 90 jours)
const usersToRotate = ["app_user_1", "app_user_2", "batch_service"];

for (const user of usersToRotate) {
  await rotationManager.rotatePassword(user);
}
```

### D√©tection des Tentatives de Bruteforce

```javascript
// Monitoring des √©checs d'authentification
function detectBruteforce(timeWindowMinutes = 5, maxAttempts = 10) {
  const now = new Date();
  const timeWindow = new Date(now.getTime() - timeWindowMinutes * 60000);

  // Depuis les logs (n√©cessite audit logging)
  const failedAttempts = db.getSiblingDB("admin").system.auditlog.aggregate([
    {
      $match: {
        atype: "authenticate",
        result: { $ne: 0 },  // 0 = success
        ts: { $gte: timeWindow }
      }
    },
    {
      $group: {
        _id: {
          user: "$param.user",
          clientSource: "$remote.ip"
        },
        count: { $sum: 1 },
        attempts: { $push: "$ts" }
      }
    },
    {
      $match: {
        count: { $gte: maxAttempts }
      }
    }
  ]).toArray();

  if (failedAttempts.length > 0) {
    print("‚ö†Ô∏è ALERTE: Tentatives de bruteforce d√©tect√©es:");
    failedAttempts.forEach(attempt => {
      print(`  - User: ${attempt._id.user}`);
      print(`    IP: ${attempt._id.clientSource}`);
      print(`    Attempts: ${attempt.count} in ${timeWindowMinutes} minutes`);
    });

    // Actions automatiques:
    // 1. Bloquer temporairement l'IP au firewall
    // 2. Notifier l'√©quipe de s√©curit√©
    // 3. Forcer changement de mot de passe si compromission suspect√©e
  }

  return failedAttempts;
}

// Ex√©cuter p√©riodiquement (cron job)
setInterval(() => {
  detectBruteforce(5, 10);
}, 60000); // V√©rifier toutes les minutes
```

## Troubleshooting SCRAM

### Probl√®mes Courants

#### 1. "Authentication failed" avec SCRAM

**Sympt√¥mes** :
```
MongoServerError: Authentication failed.
code: 18
codeName: AuthenticationFailed
```

**Causes et Solutions** :

```javascript
// Cause 1 : Mauvais mot de passe
// Solution : V√©rifier et r√©initialiser
use admin
db.updateUser("username", { pwd: "correct_password" });

// Cause 2 : Mauvais authSource
// Mauvais:
mongodb://user:pass@host/db

// Correct:
mongodb://user:pass@host/db?authSource=admin

// Cause 3 : Utilisateur n'existe pas
use admin
db.getUser("username");  // null si n'existe pas

// Cause 4 : M√©canisme non support√©
db.getUser("username", { showCredentials: true });
// V√©rifier que "SCRAM-SHA-256" est dans mechanisms

// Cause 5 : Restrictions r√©seau
db.getUser("username");
// V√©rifier authenticationRestrictions
```

#### 2. "SCRAM-SHA-1 authentication failed"

**Probl√®me** : Client tente d'utiliser SHA-1 alors que l'utilisateur supporte uniquement SHA-256.

**Solution** :

```javascript
// V√©rifier les m√©canismes de l'utilisateur
use admin
db.getUser("username", { showCredentials: true });

// Si n√©cessaire, ajouter SHA-1 temporairement
db.updateUser("username", {
  mechanisms: ["SCRAM-SHA-1", "SCRAM-SHA-256"]
});

// Ou mettre √† jour le driver client pour supporter SHA-256
```

#### 3. Performance d√©grad√©e lors de l'authentification

**Diagnostic** :

```javascript
// Mesurer le temps d'authentification
const start = Date.now();

db.auth("username", "password");

const duration = Date.now() - start;
print(`Authentication took: ${duration}ms`);

// Si > 100ms, investiguer:
// - Charge CPU du serveur
// - Latence r√©seau
// - Nombre d'it√©rations (fixe √† 15,000)
```

**Solutions** :
- Optimiser le connection pooling c√¥t√© client
- R√©duire le nombre de reconnexions
- V√©rifier la charge serveur

#### 4. "Cannot use mechanism SCRAM-SHA-256"

**Cause** : Driver trop ancien ne supportant pas SHA-256.

**Solution** : Mettre √† jour le driver MongoDB.

| Driver | Version Minimale SCRAM-SHA-256 |
|--------|-------------------------------|
| Node.js | 3.1+ |
| Python (PyMongo) | 3.6+ |
| Java | 3.7+ |
| Go | 1.0+ |
| C# | 2.7+ |

### Diagnostic Avanc√©

```javascript
// Script de diagnostic complet
function diagnoseSCRAMAuth(username, database = "admin") {
  print("=== SCRAM Authentication Diagnostic ===\n");

  // 1. V√©rifier l'existence de l'utilisateur
  print("1. Checking user existence...");
  const user = db.getSiblingDB(database).getUser(username);

  if (!user) {
    print(`   ‚ùå User '${username}' does not exist in database '${database}'`);
    return;
  }
  print(`   ‚úÖ User exists`);

  // 2. V√©rifier les m√©canismes
  print("\n2. Checking authentication mechanisms...");
  print(`   Mechanisms: ${user.mechanisms.join(', ')}`);

  if (user.mechanisms.includes("SCRAM-SHA-256")) {
    print(`   ‚úÖ SCRAM-SHA-256 supported`);
  } else {
    print(`   ‚ö†Ô∏è  SCRAM-SHA-256 NOT supported`);
  }

  // 3. V√©rifier les credentials
  print("\n3. Checking credentials...");
  const userWithCreds = db.getSiblingDB(database).getUser(username, {
    showCredentials: true
  });

  if (userWithCreds.credentials["SCRAM-SHA-256"]) {
    const creds = userWithCreds.credentials["SCRAM-SHA-256"];
    print(`   ‚úÖ SCRAM-SHA-256 credentials present`);
    print(`   Iterations: ${creds.iterationCount}`);
    print(`   Salt length: ${creds.salt.length} chars`);
  }

  // 4. V√©rifier les r√¥les
  print("\n4. Checking roles...");
  user.roles.forEach(role => {
    print(`   - ${role.role}@${role.db}`);
  });

  // 5. V√©rifier les restrictions
  print("\n5. Checking authentication restrictions...");
  if (user.authenticationRestrictions &&
      user.authenticationRestrictions.length > 0) {
    user.authenticationRestrictions.forEach(restriction => {
      if (restriction.clientSource) {
        print(`   Client sources: ${restriction.clientSource.join(', ')}`);
      }
      if (restriction.serverAddress) {
        print(`   Server addresses: ${restriction.serverAddress.join(', ')}`);
      }
    });
  } else {
    print(`   No restrictions`);
  }

  // 6. Tester l'authentification (n√©cessite le mot de passe)
  print("\n6. Test authentication:");
  print(`   Use: db.getSiblingDB("${database}").auth("${username}", "password")`);

  print("\n=== Diagnostic Complete ===");
}

// Utilisation
diagnoseSCRAMAuth("myuser", "admin");
```

## Bonnes Pratiques de Production

### Checklist SCRAM pour Production

- [ ] **Utiliser uniquement SCRAM-SHA-256**
  - Supprimer SCRAM-SHA-1 de tous les utilisateurs
  - V√©rifier avec `db.getUsers()` que mechanisms = ["SCRAM-SHA-256"]

- [ ] **Mots de passe robustes**
  - Minimum 16 caract√®res
  - M√©lange majuscules, minuscules, chiffres, symboles
  - Pas de mots du dictionnaire
  - G√©n√©rer avec des outils cryptographiques s√©curis√©s

- [ ] **Ne jamais hardcoder les credentials**
  - Variables d'environnement minimum
  - Gestionnaire de secrets (Vault, AWS Secrets Manager) recommand√©
  - Rotation automatis√©e

- [ ] **Restrictions d'authentification**
  - Limiter les IP sources autoris√©es
  - Restreindre aux bases/serveurs n√©cessaires

- [ ] **Connection pooling optimis√©**
  - Configurer maxPoolSize appropri√© (50-100)
  - Activer minPoolSize pour connexions pr√©-√©tablies

- [ ] **Monitoring**
  - Surveiller les √©checs d'authentification
  - Alertes sur tentatives de bruteforce
  - Audit logs activ√©s

- [ ] **Documentation**
  - Inventaire des utilisateurs √† jour
  - Propri√©taires et usage de chaque compte
  - Proc√©dures de rotation

- [ ] **Backups**
  - admin.system.users inclus dans les backups
  - Backups chiffr√©s
  - Proc√©dure de restauration test√©e

### Configuration Recommand√©e

```yaml
# /etc/mongod.conf - Production SCRAM

# Authentification
security:
  authorization: enabled
  # Pour replica set:
  keyFile: /etc/mongodb/keyfile

# Audit (Enterprise)
auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.log
  filter: '{
    "atype": {
      "$in": [
        "authenticate",
        "authCheck",
        "createUser",
        "dropUser",
        "updateUser",
        "grantRolesToUser",
        "revokeRolesFromUser"
      ]
    }
  }'

# Logging
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    accessControl:
      verbosity: 1  # Log auth events
```

## Comparaison avec Autres M√©canismes

| Crit√®re | SCRAM-SHA-256 | x.509 | LDAP | Kerberos |
|---------|---------------|-------|------|----------|
| **Complexit√© setup** | ‚≠ê Tr√®s simple | ‚≠ê‚≠ê‚≠ê Complexe | ‚≠ê‚≠ê Moyenne | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s complexe |
| **Gestion passwords** | MongoDB | N/A | LDAP Server | KDC |
| **R√©vocation** | Imm√©diate | Via CRL | Imm√©diate | Via KDC |
| **SSO** | ‚ùå Non | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **Infrastructure** | Aucune | PKI/CA | Serveur LDAP | KDC |
| **Performance** | Excellent | Excellent | Bon | Bon |
| **S√©curit√© r√©seau** | N√©cessite TLS | TLS int√©gr√© | N√©cessite TLS | Chiffr√© natif |
| **Id√©al pour** | Apps standard | M2M, haute s√©cu | Entreprise AD | Legacy enterprise |

## Conclusion

SCRAM-SHA-256 est le m√©canisme d'authentification par d√©faut de MongoDB pour de bonnes raisons :

**Avantages** :
- ‚úÖ Simple √† configurer et g√©rer
- ‚úÖ Aucune infrastructure externe requise
- ‚úÖ S√©curit√© cryptographique robuste
- ‚úÖ Performance excellente
- ‚úÖ Disponible en Community Edition
- ‚úÖ Standardis√© (RFC 5802)

**Limitations** :
- ‚ùå Pas de SSO natif
- ‚ùå Gestion des utilisateurs d√©centralis√©e
- ‚ùå N√©cessite gestion manuelle des passwords
- ‚ùå Pas de r√©vocation centrale

**Recommandations finales** :
1. Utiliser **SCRAM-SHA-256 uniquement** (supprimer SHA-1)
2. Combiner avec **TLS** pour protection compl√®te
3. Impl√©menter **rotation automatis√©e** des credentials
4. Activer **audit logs** pour tra√ßabilit√©
5. Configurer **restrictions r√©seau** sur les utilisateurs
6. Documenter et surveiller l'usage

Pour les environnements n√©cessitant SSO ou int√©gration avec infrastructure existante, consid√©rer LDAP ou x.509 comme alternatives.

---

**Prochaines Sections** :
- **11.2.2** : x.509 - Authentification par certificats
- **11.2.3** : LDAP - Int√©gration Active Directory
- **11.2.4** : Kerberos - Authentification enterprise

‚è≠Ô∏è [x.509](/11-securite/02.2-x509.md)
