üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.2.3 LDAP (Lightweight Directory Access Protocol)

## Introduction

LDAP (Lightweight Directory Access Protocol) est un protocole standard d'acc√®s aux services d'annuaire qui permet √† MongoDB Enterprise d'int√©grer l'authentification avec des syst√®mes d'annuaire externes comme Active Directory (Microsoft), OpenLDAP, ou d'autres impl√©mentations LDAP compatibles. Cette int√©gration permet une gestion centralis√©e des utilisateurs et un Single Sign-On (SSO) dans les environnements d'entreprise.

### Pr√©requis

**‚ö†Ô∏è Important** : L'authentification LDAP n√©cessite **MongoDB Enterprise Edition**. Cette fonctionnalit√© n'est pas disponible dans la version Community.

### Cas d'Usage

- **Centralisation de la gestion des utilisateurs** : Un seul annuaire pour toute l'entreprise
- **Single Sign-On (SSO)** : M√™mes credentials pour toutes les applications
- **Conformit√©** : Respect des politiques de s√©curit√© d'entreprise
- **Int√©gration existante** : Utilisation d'Active Directory d√©j√† en place
- **Groupes et r√¥les** : Mapping automatique des groupes LDAP vers r√¥les MongoDB
- **Rotation automatique** : Changements de mots de passe g√©r√©s centralement

### Avantages de LDAP

| Avantage | Description |
|----------|-------------|
| **Gestion centralis√©e** | Un seul point de gestion pour tous les utilisateurs |
| **SSO** | Authentification unique pour toutes les applications |
| **Politiques de s√©curit√©** | Complexit√© des mots de passe, expiration, verrouillage |
| **Audit centralis√©** | Tra√ßabilit√© dans l'annuaire LDAP |
| **Groupes** | Gestion des permissions par groupes |
| **Int√©gration enterprise** | Compatible avec infrastructure existante |
| **Scaling** | G√®re des milliers d'utilisateurs facilement |

## Architecture LDAP/MongoDB

### Vue d'Ensemble

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      CLIENT                                 ‚îÇ
‚îÇ  ‚Ä¢ Application / Utilisateur                                ‚îÇ
‚îÇ  ‚Ä¢ Credentials (username + password)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ 1. Connection request
                            ‚îÇ    (username + password)
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MONGODB SERVER                             ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  2. Forward credentials to LDAP                       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚îÇ LDAP Bind request              ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ         3. LDAP Query Server                    ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ            (bindMethod: simple/sasl)            ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               LDAP/ACTIVE DIRECTORY SERVER                  ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  4. Authenticate user                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Verify password                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Check account status (locked, expired, etc.)    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚îÇ Success                        ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  5. Query user attributes                             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Group memberships                               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Distinguished Name (DN)                         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Other attributes                                ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ Return user info + groups
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MONGODB SERVER                             ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  6. Map LDAP groups to MongoDB roles                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Query MongoDB role mapping                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Apply appropriate permissions                   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  7. Create authenticated session                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Cache user info                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     - Grant access based on roles                     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚ñº
                    ‚úÖ Access granted
```

### Composants de l'Architecture

#### 1. Client MongoDB

- Application ou utilisateur final
- Fournit username et password LDAP
- Utilise le m√©canisme d'authentification `PLAIN`

#### 2. MongoDB Server (Enterprise)

- Re√ßoit les credentials
- Forward vers le serveur LDAP
- Effectue le mapping des groupes vers les r√¥les
- G√®re la session authentifi√©e

#### 3. LDAP Query Server

- Serveur LDAP/AD interrog√© par MongoDB
- Peut √™tre configur√© avec failover (multiples serveurs)
- Authentifie l'utilisateur et retourne ses attributs

#### 4. User-to-DN Mapping

- Transforme le username en Distinguished Name (DN)
- Utilise une query LDAP ou une transformation directe
- N√©cessaire pour localiser l'utilisateur dans l'annuaire

#### 5. Authorization Query

- Query LDAP pour r√©cup√©rer les groupes de l'utilisateur
- Mapping des groupes LDAP vers r√¥les MongoDB
- D√©finit les permissions accord√©es

## Configuration Active Directory

### Structure Active Directory Recommand√©e

```
DC=company,DC=com
‚îÇ
‚îú‚îÄ‚îÄ OU=Users
‚îÇ   ‚îú‚îÄ‚îÄ CN=John Doe
‚îÇ   ‚îú‚îÄ‚îÄ CN=Jane Smith
‚îÇ   ‚îî‚îÄ‚îÄ CN=MongoDB Service Account
‚îÇ
‚îú‚îÄ‚îÄ OU=Groups
‚îÇ   ‚îú‚îÄ‚îÄ CN=MongoDB-Admins
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Members: John Doe
‚îÇ   ‚îú‚îÄ‚îÄ CN=MongoDB-ReadWrite-Production
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Members: Jane Smith, John Doe
‚îÇ   ‚îú‚îÄ‚îÄ CN=MongoDB-Read-Analytics
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Members: Analytics Team
‚îÇ   ‚îî‚îÄ‚îÄ CN=MongoDB-Backup-Service
‚îÇ       ‚îî‚îÄ‚îÄ Members: Backup Service Account
‚îÇ
‚îî‚îÄ‚îÄ OU=Service Accounts
    ‚îî‚îÄ‚îÄ CN=mongodb-ldap-bind
```

### Cr√©ation des Groupes AD

```powershell
# PowerShell - Cr√©ation des groupes MongoDB dans Active Directory

# Cr√©er l'OU pour les groupes MongoDB
New-ADOrganizationalUnit -Name "MongoDB Groups" -Path "OU=Groups,DC=company,DC=com"

# Cr√©er les groupes de s√©curit√©
New-ADGroup -Name "MongoDB-Admins" `
  -GroupScope Global `
  -GroupCategory Security `
  -Path "OU=MongoDB Groups,OU=Groups,DC=company,DC=com" `
  -Description "MongoDB Database Administrators"

New-ADGroup -Name "MongoDB-ReadWrite-Production" `
  -GroupScope Global `
  -GroupCategory Security `
  -Path "OU=MongoDB Groups,OU=Groups,DC=company,DC=com" `
  -Description "Read/Write access to production databases"

New-ADGroup -Name "MongoDB-Read-Analytics" `
  -GroupScope Global `
  -GroupCategory Security `
  -Path "OU=MongoDB Groups,OU=Groups,DC=company,DC=com" `
  -Description "Read-only access to analytics databases"

New-ADGroup -Name "MongoDB-Backup-Service" `
  -GroupScope Global `
  -GroupCategory Security `
  -Path "OU=MongoDB Groups,OU=Groups,DC=company,DC=com" `
  -Description "Backup and restore operations"

# Ajouter des membres aux groupes
Add-ADGroupMember -Identity "MongoDB-Admins" -Members "john.doe"
Add-ADGroupMember -Identity "MongoDB-ReadWrite-Production" -Members "jane.smith", "john.doe"
```

### Compte de Service pour LDAP Bind

MongoDB a besoin d'un compte de service pour interroger l'annuaire LDAP.

```powershell
# Cr√©er le compte de service
New-ADUser -Name "mongodb-ldap-bind" `
  -UserPrincipalName "mongodb-ldap-bind@company.com" `
  -Path "OU=Service Accounts,DC=company,DC=com" `
  -AccountPassword (ConvertTo-SecureString "ComplexP@ssw0rd123!" -AsPlainText -Force) `
  -Enabled $true `
  -PasswordNeverExpires $true `
  -CannotChangePassword $true `
  -Description "Service account for MongoDB LDAP queries"

# Accorder les permissions de lecture sur l'annuaire
# (par d√©faut, "Authenticated Users" peuvent lire l'AD)

# Pour des permissions plus restreintes, cr√©er une d√©l√©gation sp√©cifique
# dsacls "DC=company,DC=com" /G "mongodb-ldap-bind@company.com:GR"
```

**Permissions minimales requises** :
- Lecture des attributs utilisateur (memberOf, distinguishedName, sAMAccountName)
- Pas besoin d'√©criture
- Pas besoin d'admin

### V√©rification de la Configuration AD

```powershell
# V√©rifier qu'un utilisateur existe et ses groupes
Get-ADUser -Identity "john.doe" -Properties MemberOf | Select-Object Name, MemberOf

# V√©rifier le compte de service
Get-ADUser -Identity "mongodb-ldap-bind" -Properties *

# Tester l'authentification LDAP
$credential = Get-Credential -UserName "john.doe@company.com"
# Essayer de se connecter √† un contr√¥leur de domaine
```

## Configuration MongoDB Enterprise avec LDAP

### Configuration de Base (Standalone)

```yaml
# /etc/mongod.conf

# Network
net:
  bindIp: 0.0.0.0
  port: 27017

# Security
security:
  authorization: enabled

  # Configuration LDAP
  ldap:
    # Serveurs LDAP (avec failover)
    servers: "ldap01.company.com,ldap02.company.com"

    # Port LDAP (389 standard, 636 pour LDAPS)
    port: 389

    # M√©thode de bind (simple ou sasl)
    bind:
      method: "simple"

      # Query DN: compte de service pour les queries LDAP
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"

      # Mot de passe du compte de service (√† s√©curiser via fichier externe)
      queryPassword: "ComplexP@ssw0rd123!"

    # Transport s√©curis√© (tls ou none)
    transportSecurity: tls

    # Validation du certificat serveur LDAP
    # tls:
    #   CAFile: /etc/ssl/certs/ca-bundle.crt
    #   certificateKeyFile: /etc/ssl/mongodb-ldap.pem

    # User-to-DN mapping
    userToDNMapping:
      '[
        {
          match: "(.+)",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        }
      ]'

    # Authorization query pour r√©cup√©rer les groupes
    authz:
      queryTemplate: >
        {USER}?memberOf?base

    # Timeout des queries LDAP (ms)
    timeoutMS: 10000

# Logging
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    accessControl:
      verbosity: 2
```

### Configuration avec LDAPS (LDAP over TLS)

```yaml
# /etc/mongod.conf - Configuration LDAPS s√©curis√©e

security:
  authorization: enabled
  ldap:
    servers: "ldaps://ldap01.company.com,ldaps://ldap02.company.com"
    port: 636  # Port LDAPS standard

    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"
      queryPassword: "ComplexP@ssw0rd123!"

    # Activer TLS
    transportSecurity: tls

    # Configuration TLS
    tls:
      # Certificat CA pour valider le serveur LDAP
      CAFile: /etc/ssl/certs/company-ca.pem

      # Certificat client (optionnel, pour authentification mutuelle)
      # certificateKeyFile: /etc/ssl/mongodb-ldap-client.pem

      # Valider le certificat serveur
      allowInvalidCertificates: false
      allowInvalidHostnames: false

    userToDNMapping:
      '[
        {
          match: "(.+)@company\\.com",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        },
        {
          match: "(.+)",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        }
      ]'

    authz:
      queryTemplate: "{USER}?memberOf?base"
```

### Configuration Avanc√©e avec SASL

Pour Active Directory, la m√©thode SASL (avec Kerberos) peut √™tre utilis√©e.

```yaml
security:
  authorization: enabled
  ldap:
    servers: "ldap.company.com"

    bind:
      # SASL avec Kerberos
      method: "sasl"
      saslMechanisms: "GSSAPI"

      # Query user avec Kerberos principal
      queryUser: "mongodb-ldap-bind@COMPANY.COM"

    transportSecurity: tls

    userToDNMapping:
      '[
        {
          match: "(.+)@COMPANY.COM",
          ldapQuery: "OU=Users,DC=company,DC=com??sub?(userPrincipalName={0})"
        }
      ]'

    authz:
      queryTemplate: "{USER}?memberOf?base"

# Configuration Kerberos
setParameter:
  authenticationMechanisms: GSSAPI,SCRAM-SHA-256
```

### Configuration Replica Set avec LDAP

```yaml
# /etc/mongod.conf - Membre Replica Set

net:
  bindIp: 0.0.0.0
  port: 27017

security:
  authorization: enabled

  # Authentification interne du replica set (keyFile)
  keyFile: /etc/mongodb/keyfile

  # Configuration LDAP pour les clients externes
  ldap:
    servers: "ldap01.company.com,ldap02.company.com"
    port: 636

    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"
      queryPassword: "ComplexP@ssw0rd123!"

    transportSecurity: tls
    tls:
      CAFile: /etc/ssl/certs/company-ca.pem

    userToDNMapping:
      '[
        {
          match: "(.+)",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        }
      ]'

    authz:
      queryTemplate: "{USER}?memberOf?base"

replication:
  replSetName: rs0

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
```

**Note importante** : L'authentification interne du replica set utilise toujours un keyFile ou x.509, pas LDAP.

## User-to-DN Mapping

Le mapping username ‚Üí Distinguished Name est critique pour localiser l'utilisateur dans l'annuaire LDAP.

### Transformation Simple

```yaml
userToDNMapping:
  '[
    {
      match: "(.+)",
      substitution: "CN={0},OU=Users,DC=company,DC=com"
    }
  ]'
```

**Exemple** :
- Input: `john.doe`
- Output: `CN=john.doe,OU=Users,DC=company,DC=com`

### Transformation avec Domaine

```yaml
userToDNMapping:
  '[
    {
      match: "(.+)@company\\.com",
      substitution: "CN={0},OU=Users,DC=company,DC=com"
    }
  ]'
```

**Exemple** :
- Input: `john.doe@company.com`
- Output: `CN=john.doe,OU=Users,DC=company,DC=com`

### Query LDAP Dynamique

Pour des structures AD complexes o√π les utilisateurs sont dans diff√©rentes OUs :

```yaml
userToDNMapping:
  '[
    {
      match: "(.+)",
      ldapQuery: "DC=company,DC=com??sub?(sAMAccountName={0})"
    }
  ]'
```

Cette query recherche dans tout l'arbre LDAP un utilisateur avec le `sAMAccountName` correspondant.

### Multiples Mappings

```yaml
userToDNMapping:
  '[
    {
      match: "admin-(.+)",
      substitution: "CN={0},OU=Admins,DC=company,DC=com"
    },
    {
      match: "svc-(.+)",
      substitution: "CN={0},OU=Service Accounts,DC=company,DC=com"
    },
    {
      match: "(.+)",
      substitution: "CN={0},OU=Users,DC=company,DC=com"
    }
  ]'
```

Le premier pattern qui match est utilis√©.

## Authorization et Mapping des R√¥les

### Cr√©ation des Utilisateurs LDAP dans MongoDB

Les utilisateurs LDAP doivent √™tre cr√©√©s dans la base `$external` :

```javascript
// Se connecter en tant qu'admin local
mongosh --port 27017 -u admin -p --authenticationDatabase admin

// Cr√©er un utilisateur LDAP individuel
db.getSiblingDB("$external").createUser({
  user: "CN=john.doe,OU=Users,DC=company,DC=com",
  roles: [
    { role: "readWrite", db: "production" },
    { role: "read", db: "analytics" }
  ]
})

// V√©rifier
db.getSiblingDB("$external").getUser("CN=john.doe,OU=Users,DC=company,DC=com")
```

### Mapping de Groupes LDAP vers R√¥les MongoDB

Plus efficace que de cr√©er chaque utilisateur individuellement :

```javascript
// Mapper un groupe LDAP entier vers des r√¥les MongoDB
db.getSiblingDB("$external").createRole({
  role: "CN=MongoDB-ReadWrite-Production,OU=MongoDB Groups,OU=Groups,DC=company,DC=com",
  privileges: [],
  roles: [
    { role: "readWrite", db: "production" },
    { role: "read", db: "reference_data" }
  ]
})

// Mapper groupe admin
db.getSiblingDB("$external").createRole({
  role: "CN=MongoDB-Admins,OU=MongoDB Groups,OU=Groups,DC=company,DC=com",
  privileges: [],
  roles: [
    { role: "dbAdminAnyDatabase", db: "admin" },
    { role: "readWriteAnyDatabase", db: "admin" },
    { role: "userAdminAnyDatabase", db: "admin" },
    { role: "clusterAdmin", db: "admin" }
  ]
})

// Mapper groupe lecture seule
db.getSiblingDB("$external").createRole({
  role: "CN=MongoDB-Read-Analytics,OU=MongoDB Groups,OU=Groups,DC=company,DC=com",
  privileges: [],
  roles: [
    { role: "read", db: "analytics" },
    { role: "read", db: "reporting" }
  ]
})
```

**‚ö†Ô∏è Important** : Le nom du r√¥le doit correspondre **exactement** au DN du groupe LDAP.

### Authorization Query Template

La query LDAP pour r√©cup√©rer les groupes :

```yaml
authz:
  # Format: {USER}?attributs?scope
  queryTemplate: "{USER}?memberOf?base"
```

**Composants** :
- `{USER}` : Remplac√© par le DN de l'utilisateur
- `memberOf` : Attribut AD contenant les groupes
- `base` : Scope de recherche (base, one, sub)

**Exemple de r√©sultat** :
```
memberOf: CN=MongoDB-Admins,OU=MongoDB Groups,OU=Groups,DC=company,DC=com
memberOf: CN=MongoDB-ReadWrite-Production,OU=MongoDB Groups,OU=Groups,DC=company,DC=com
memberOf: CN=All Users,OU=Groups,DC=company,DC=com
```

MongoDB cherche ensuite des r√¥les correspondants dans `$external`.

### R√¥les Personnalis√©s Complexes

```javascript
// Cr√©er un r√¥le personnalis√© avec privil√®ges granulaires
db.getSiblingDB("$external").createRole({
  role: "CN=MongoDB-DataScientists,OU=MongoDB Groups,OU=Groups,DC=company,DC=com",
  privileges: [
    {
      resource: { db: "analytics", collection: "" },
      actions: ["find", "aggregate"]
    },
    {
      resource: { db: "ml_models", collection: "training_data" },
      actions: ["find", "insert", "update"]
    }
  ],
  roles: [
    { role: "read", db: "reference_data" }
  ]
})
```

## Connexion Client avec LDAP

### Connection String

```javascript
// Format de base
mongodb://username:password@host:27017/database?authMechanism=PLAIN&authSource=$external

// Avec replica set
mongodb://john.doe:password@mongo1:27017,mongo2:27017,mongo3:27017/production?replicaSet=rs0&authMechanism=PLAIN&authSource=$external

// Avec TLS
mongodb://john.doe:password@mongo1:27017/production?authMechanism=PLAIN&authSource=$external&tls=true&tlsCAFile=/etc/ssl/ca.pem
```

**‚ö†Ô∏è Important** :
- `authMechanism=PLAIN` : Obligatoire pour LDAP
- `authSource=$external` : Obligatoire pour authentification externe
- Username : Peut √™tre le CN complet ou simplement le username selon le mapping

### Node.js

```javascript
const { MongoClient } = require('mongodb');

// Option 1: URI avec credentials
const uri = "mongodb://john.doe:SecurePassword123!@mongo1:27017,mongo2:27017,mongo3:27017/production?replicaSet=rs0&authMechanism=PLAIN&authSource=$external&tls=true";

const client = new MongoClient(uri, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  maxPoolSize: 50
});

// Option 2: Credentials depuis environnement
const username = process.env.MONGO_USER;  // john.doe
const password = process.env.MONGO_PASS;

const uri2 = `mongodb://${encodeURIComponent(username)}:${encodeURIComponent(password)}@mongo1:27017,mongo2:27017,mongo3:27017/production?replicaSet=rs0`;

const client2 = new MongoClient(uri2, {
  authMechanism: 'PLAIN',
  authSource: '$external',
  tls: true,
  tlsCAFile: '/etc/ssl/ca.pem',
  maxPoolSize: 50
});

async function connect() {
  try {
    await client.connect();
    console.log("‚úÖ Connected with LDAP authentication");

    const db = client.db("production");
    // Op√©rations...
  } catch (err) {
    console.error("‚ùå LDAP authentication failed:", err);
  } finally {
    await client.close();
  }
}

connect();
```

### Python

```python
from pymongo import MongoClient
from urllib.parse import quote_plus
import os

# Credentials depuis environnement
username = os.getenv('MONGO_USER')  # john.doe
password = os.getenv('MONGO_PASS')

# Encoder les credentials
username_encoded = quote_plus(username)
password_encoded = quote_plus(password)

# URI avec LDAP
uri = f"mongodb://{username_encoded}:{password_encoded}@mongo1:27017,mongo2:27017,mongo3:27017/production?replicaSet=rs0&authMechanism=PLAIN&authSource=$external&tls=true"

# Connexion
client = MongoClient(
    uri,
    tlsCAFile='/etc/ssl/ca.pem',
    maxPoolSize=50
)

# Ou avec param√®tres s√©par√©s
client = MongoClient(
    ['mongo1:27017', 'mongo2:27017', 'mongo3:27017'],
    username=username,
    password=password,
    authSource='$external',
    authMechanism='PLAIN',
    replicaSet='rs0',
    tls=True,
    tlsCAFile='/etc/ssl/ca.pem'
)

# Test
try:
    client.admin.command('ping')
    print("‚úÖ Connected with LDAP authentication")
except Exception as e:
    print(f"‚ùå LDAP authentication failed: {e}")
```

### Java

```java
import com.mongodb.MongoClientSettings;
import com.mongodb.MongoCredential;
import com.mongodb.ServerAddress;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;

import javax.net.ssl.SSLContext;
import java.util.Arrays;

// Credentials
String username = System.getenv("MONGO_USER");
String password = System.getenv("MONGO_PASS");

// LDAP credential avec m√©canisme PLAIN
MongoCredential credential = MongoCredential.createPlainCredential(
    username,
    "$external",
    password.toCharArray()
);

// Configuration
MongoClientSettings settings = MongoClientSettings.builder()
    .credential(credential)
    .applyToSslSettings(builder ->
        builder.enabled(true)
               .invalidHostNameAllowed(false))
    .applyToClusterSettings(builder ->
        builder.hosts(Arrays.asList(
            new ServerAddress("mongo1", 27017),
            new ServerAddress("mongo2", 27017),
            new ServerAddress("mongo3", 27017)
        ))
        .requiredReplicaSetName("rs0"))
    .build();

// Connexion
MongoClient mongoClient = MongoClients.create(settings);

// Test
try {
    mongoClient.getDatabase("admin").runCommand(new Document("ping", 1));
    System.out.println("‚úÖ Connected with LDAP authentication");
} catch (Exception e) {
    System.err.println("‚ùå LDAP authentication failed: " + e.getMessage());
}
```

### Go

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    // Credentials depuis environnement
    username := os.Getenv("MONGO_USER")
    password := os.Getenv("MONGO_PASS")

    // Credential LDAP
    credential := options.Credential{
        AuthMechanism: "PLAIN",
        AuthSource:    "$external",
        Username:      username,
        Password:      password,
    }

    // Options client
    clientOpts := options.Client().
        ApplyURI("mongodb://mongo1:27017,mongo2:27017,mongo3:27017/?replicaSet=rs0").
        SetAuth(credential).
        SetTLSConfig(&tls.Config{
            InsecureSkipVerify: false,
        })

    // Connexion
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    client, err := mongo.Connect(ctx, clientOpts)
    if err != nil {
        log.Fatal("Connection error:", err)
    }
    defer client.Disconnect(ctx)

    // Test
    err = client.Ping(ctx, nil)
    if err != nil {
        log.Fatal("‚ùå LDAP authentication failed:", err)
    }

    fmt.Println("‚úÖ Connected with LDAP authentication")
}
```

## Haute Disponibilit√© et Failover

### Configuration Multi-LDAP

```yaml
security:
  ldap:
    # Multiples serveurs LDAP pour haute disponibilit√©
    servers: "ldap01.company.com,ldap02.company.com,ldap03.company.com"
    port: 636

    # Timeout pour essayer le serveur suivant
    timeoutMS: 5000

    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"
      queryPassword: "ComplexP@ssw0rd123!"

    transportSecurity: tls

    # MongoDB essaiera les serveurs dans l'ordre jusqu'√† succ√®s
```

**Comportement** :
1. MongoDB essaie `ldap01.company.com`
2. Si timeout ou erreur ‚Üí essaie `ldap02.company.com`
3. Si timeout ou erreur ‚Üí essaie `ldap03.company.com`
4. Si tous √©chouent ‚Üí authentification √©choue

### Monitoring des Serveurs LDAP

```bash
#!/bin/bash
# check-ldap-servers.sh

LDAP_SERVERS=("ldap01.company.com" "ldap02.company.com" "ldap03.company.com")
LDAP_PORT=636
BIND_DN="CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"
BIND_PASSWORD="ComplexP@ssw0rd123!"

for SERVER in "${LDAP_SERVERS[@]}"; do
  echo "Testing $SERVER..."

  # Test de connexion LDAPS
  timeout 5 openssl s_client -connect "$SERVER:$LDAP_PORT" -showcerts </dev/null 2>/dev/null

  if [ $? -eq 0 ]; then
    echo "  ‚úÖ TLS connection OK"

    # Test LDAP bind
    ldapsearch -x -H "ldaps://$SERVER:$LDAP_PORT" \
      -D "$BIND_DN" \
      -w "$BIND_PASSWORD" \
      -b "DC=company,DC=com" \
      -s base "(objectClass=*)" \
      2>&1 | grep -q "result: 0 Success"

    if [ $? -eq 0 ]; then
      echo "  ‚úÖ LDAP bind OK"
    else
      echo "  ‚ùå LDAP bind FAILED"
    fi
  else
    echo "  ‚ùå TLS connection FAILED"
  fi

  echo ""
done
```

### Cache LDAP dans MongoDB

MongoDB met en cache les r√©sultats des queries LDAP pour am√©liorer les performances :

```yaml
setParameter:
  # Dur√©e du cache des informations LDAP (secondes)
  ldapUserCacheInvalidationInterval: 30
```

**Impact** :
- Authentifications plus rapides (pas de query LDAP √† chaque connexion)
- Changements de groupes LDAP pris en compte apr√®s 30 secondes max
- R√©duire pour changements plus rapides (impact performance)
- Augmenter pour meilleure performance (moins de queries LDAP)

## S√©curisation du Mot de Passe Query

### Utilisation d'un Fichier Externe

Au lieu de mettre le password en clair dans mongod.conf :

```yaml
# /etc/mongod.conf
security:
  ldap:
    servers: "ldap.company.com"
    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"

      # R√©f√©rence √† un fichier contenant le password
      queryPassword: "<path:/etc/mongodb/ldap-password>"
```

```bash
# /etc/mongodb/ldap-password
ComplexP@ssw0rd123!
```

```bash
# Permissions s√©curis√©es
chmod 400 /etc/mongodb/ldap-password
chown mongodb:mongodb /etc/mongodb/ldap-password
```

### Int√©gration avec HashiCorp Vault

```bash
#!/bin/bash
# start-mongod-with-vault.sh

# R√©cup√©rer le password depuis Vault
LDAP_PASSWORD=$(vault kv get -field=password secret/mongodb/ldap-bind)

# √âcrire temporairement dans un fichier
echo "$LDAP_PASSWORD" > /tmp/ldap-password
chmod 400 /tmp/ldap-password
chown mongodb:mongodb /tmp/ldap-password

# D√©marrer MongoDB avec le fichier
mongod --config /etc/mongod.conf

# Nettoyer apr√®s arr√™t
trap "rm -f /tmp/ldap-password" EXIT
```

### Variables d'Environnement (MongoDB 4.4+)

```yaml
# /etc/mongod.conf
security:
  ldap:
    servers: "ldap.company.com"
    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"

      # Utiliser une variable d'environnement
      queryPassword: "<env:MONGO_LDAP_PASSWORD>"
```

```bash
# /etc/systemd/system/mongod.service.d/override.conf
[Service]
Environment="MONGO_LDAP_PASSWORD=ComplexP@ssw0rd123!"

# Ou charger depuis un fichier
EnvironmentFile=/etc/mongodb/ldap.env
```

## Troubleshooting LDAP

### Probl√®mes Courants

#### 1. "LDAP authentication failed"

**Diagnostic** :

```bash
# Tester la connexion LDAP manuellement
ldapsearch -x -H "ldaps://ldap.company.com:636" \
  -D "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com" \
  -w "ComplexP@ssw0rd123!" \
  -b "CN=john.doe,OU=Users,DC=company,DC=com" \
  -s base "(objectClass=*)"

# V√©rifier le user-to-DN mapping
# Input: john.doe
# Expected DN: CN=john.doe,OU=Users,DC=company,DC=com
```

**Causes courantes** :
- User-to-DN mapping incorrect
- Utilisateur n'existe pas dans AD
- Compte AD verrouill√© ou expir√©
- Mot de passe incorrect
- Serveur LDAP inaccessible

#### 2. "LDAP server unreachable"

```bash
# Tester la connectivit√© r√©seau
nc -zv ldap.company.com 636

# Tester TLS
openssl s_client -connect ldap.company.com:636

# V√©rifier les logs MongoDB
tail -f /var/log/mongodb/mongod.log | grep -i ldap

# V√©rifier les logs AD (sur le contr√¥leur de domaine)
# Event Viewer ‚Üí Security ‚Üí Filter: Event ID 4625 (failed logon)
```

#### 3. "User authenticated but has no roles"

```javascript
// V√©rifier l'utilisateur dans $external
use $external
db.getUser("CN=john.doe,OU=Users,DC=company,DC=com")

// V√©rifier les groupes LDAP de l'utilisateur
// Via ldapsearch:
ldapsearch -x -H ldaps://ldap.company.com:636 \
  -D "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com" \
  -w "password" \
  -b "CN=john.doe,OU=Users,DC=company,DC=com" \
  -s base memberOf

// V√©rifier que les r√¥les correspondent aux groupes
use $external
db.getRoles({ showBuiltinRoles: false })

// Cr√©er le mapping si manquant
db.getSiblingDB("$external").createRole({
  role: "CN=MongoDB-Users,OU=Groups,DC=company,DC=com",
  privileges: [],
  roles: [{ role: "readWrite", db: "myapp" }]
})
```

#### 4. Probl√®mes de Performance

```javascript
// V√©rifier les temps de r√©ponse LDAP
db.getSiblingDB("admin").runCommand({
  ldapStatus: 1
})

// Augmenter le cache si beaucoup de queries
db.adminCommand({
  setParameter: 1,
  ldapUserCacheInvalidationInterval: 300  // 5 minutes
})
```

### Script de Diagnostic Complet

```bash
#!/bin/bash
# diagnose-ldap.sh

echo "=== MongoDB LDAP Diagnostic ==="

# 1. Configuration MongoDB
echo -e "\n1. MongoDB LDAP Configuration:"
grep -A 30 "ldap:" /etc/mongod.conf

# 2. Test connectivit√© serveurs LDAP
echo -e "\n2. LDAP Server Connectivity:"
LDAP_SERVERS=$(grep "servers:" /etc/mongod.conf | cut -d'"' -f2)
IFS=',' read -ra SERVERS <<< "$LDAP_SERVERS"

for SERVER in "${SERVERS[@]}"; do
  echo "  Testing $SERVER..."
  timeout 5 nc -zv "$SERVER" 636 2>&1 | grep -q "succeeded"
  if [ $? -eq 0 ]; then
    echo "    ‚úÖ Connection OK"
  else
    echo "    ‚ùå Connection FAILED"
  fi
done

# 3. Test LDAP bind
echo -e "\n3. LDAP Bind Test:"
BIND_DN=$(grep "queryUser:" /etc/mongod.conf | cut -d'"' -f2)
BIND_PASS=$(grep "queryPassword:" /etc/mongod.conf | cut -d'"' -f2)

ldapsearch -x -H "ldaps://${SERVERS[0]}:636" \
  -D "$BIND_DN" \
  -w "$BIND_PASS" \
  -b "DC=company,DC=com" \
  -s base "(objectClass=*)" \
  2>&1 | grep -q "result: 0 Success"

if [ $? -eq 0 ]; then
  echo "  ‚úÖ LDAP bind successful"
else
  echo "  ‚ùå LDAP bind FAILED"
fi

# 4. Test user lookup
echo -e "\n4. User Lookup Test:"
TEST_USER="john.doe"
USER_DN="CN=$TEST_USER,OU=Users,DC=company,DC=com"

ldapsearch -x -H "ldaps://${SERVERS[0]}:636" \
  -D "$BIND_DN" \
  -w "$BIND_PASS" \
  -b "$USER_DN" \
  -s base "(objectClass=*)" \
  2>&1 | grep -q "numEntries: 1"

if [ $? -eq 0 ]; then
  echo "  ‚úÖ User $TEST_USER found in LDAP"

  # Afficher les groupes
  echo "  Groups:"
  ldapsearch -x -H "ldaps://${SERVERS[0]}:636" \
    -D "$BIND_DN" \
    -w "$BIND_PASS" \
    -b "$USER_DN" \
    -s base memberOf | grep "memberOf:"
else
  echo "  ‚ùå User $TEST_USER NOT found in LDAP"
fi

# 5. MongoDB logs
echo -e "\n5. Recent LDAP Errors in MongoDB Logs:"
grep -i "ldap" /var/log/mongodb/mongod.log | tail -20

echo -e "\n=== End Diagnostic ==="
```

### Augmentation de la Verbosit√©

```javascript
// Activer le debug LDAP dans MongoDB
db.setLogLevel(2, "accessControl")

// Via mongod.conf
systemLog:
  component:
    accessControl:
      verbosity: 2

// Logs d√©taill√©s appara√Ætront dans mongod.log
```

## Monitoring et Audit

### M√©triques Importantes

```javascript
// V√©rifier le statut LDAP
db.adminCommand({ serverStatus: 1 }).ldap

// R√©sultat:
{
  "ldap": {
    "connectionStatus": "connected",
    "lastBindTime": ISODate("2024-12-08T10:30:00Z"),
    "bindDuration": 45,  // ms
    "lastQueryTime": ISODate("2024-12-08T10:30:01Z"),
    "queryDuration": 120  // ms
  }
}
```

### Script de Monitoring

```python
#!/usr/bin/env python3
# monitor-ldap-auth.py

from pymongo import MongoClient
import time
import json

def check_ldap_health(client):
    """V√©rifie la sant√© de l'authentification LDAP"""
    try:
        status = client.admin.command('serverStatus')

        if 'ldap' not in status:
            return {
                'status': 'error',
                'message': 'LDAP not configured'
            }

        ldap_status = status['ldap']

        # V√©rifier les temps de r√©ponse
        bind_duration = ldap_status.get('bindDuration', 0)
        query_duration = ldap_status.get('queryDuration', 0)

        health = {
            'status': 'healthy',
            'connection': ldap_status.get('connectionStatus'),
            'bind_duration_ms': bind_duration,
            'query_duration_ms': query_duration,
            'last_bind': ldap_status.get('lastBindTime'),
            'warnings': []
        }

        # Alertes si latence √©lev√©e
        if bind_duration > 1000:
            health['warnings'].append(f'High bind latency: {bind_duration}ms')

        if query_duration > 2000:
            health['warnings'].append(f'High query latency: {query_duration}ms')

        if health['warnings']:
            health['status'] = 'degraded'

        return health

    except Exception as e:
        return {
            'status': 'error',
            'message': str(e)
        }

def main():
    # Connexion admin pour monitoring
    client = MongoClient(
        'mongodb://admin:password@localhost:27017',
        authSource='admin'
    )

    while True:
        health = check_ldap_health(client)
        print(json.dumps(health, indent=2, default=str))

        # Alerter si probl√®me
        if health['status'] != 'healthy':
            # Envoyer alerte (Slack, email, PagerDuty, etc.)
            print("‚ö†Ô∏è LDAP health issue detected!")

        time.sleep(60)  # V√©rifier toutes les minutes

if __name__ == '__main__':
    main()
```

### Audit des Authentifications

```yaml
# /etc/mongod.conf - Activer l'audit (Enterprise)

auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.log

  # Filtrer les √©v√©nements LDAP
  filter: '{
    "atype": {
      "$in": [
        "authenticate",
        "authCheck"
      ]
    },
    "param.mechanism": "PLAIN"
  }'
```

Analyse des logs d'audit :

```bash
# Compter les authentifications LDAP r√©ussies/√©chou√©es
cat /var/log/mongodb/audit.log | jq -r 'select(.atype=="authenticate" and .param.mechanism=="PLAIN") | .result' | sort | uniq -c

# Utilisateurs LDAP les plus actifs
cat /var/log/mongodb/audit.log | jq -r 'select(.atype=="authenticate" and .param.mechanism=="PLAIN" and .result==0) | .param.user' | sort | uniq -c | sort -rn | head -20

# √âchecs d'authentification par utilisateur
cat /var/log/mongodb/audit.log | jq -r 'select(.atype=="authenticate" and .param.mechanism=="PLAIN" and .result!=0) | .param.user' | sort | uniq -c | sort -rn
```

## Automatisation et CI/CD

### Ansible Playbook

```yaml
# playbooks/configure-mongodb-ldap.yml
---
- name: Configure MongoDB with LDAP authentication
  hosts: mongodb_servers
  become: yes

  vars:
    ldap_servers: "ldap01.company.com,ldap02.company.com"
    ldap_bind_dn: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"
    ldap_bind_password: "{{ vault_ldap_password }}"

  tasks:
    - name: Install MongoDB Enterprise
      apt:
        name: mongodb-enterprise
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Create LDAP password file
      copy:
        content: "{{ ldap_bind_password }}"
        dest: /etc/mongodb/ldap-password
        owner: mongodb
        group: mongodb
        mode: '0400'
      no_log: true

    - name: Configure mongod.conf with LDAP
      template:
        src: templates/mongod-ldap.conf.j2
        dest: /etc/mongod.conf
        owner: mongodb
        group: mongodb
        mode: '0644'
      notify: restart mongod

    - name: Ensure MongoDB is started
      systemd:
        name: mongod
        state: started
        enabled: yes

    - name: Wait for MongoDB to be ready
      wait_for:
        port: 27017
        delay: 5
        timeout: 30

  handlers:
    - name: restart mongod
      systemd:
        name: mongod
        state: restarted
```

**Template** :

```jinja2
{# templates/mongod-ldap.conf.j2 #}
net:
  bindIp: 0.0.0.0
  port: 27017

security:
  authorization: enabled
  ldap:
    servers: "{{ ldap_servers }}"
    port: 636
    bind:
      method: "simple"
      queryUser: "{{ ldap_bind_dn }}"
      queryPassword: "<path:/etc/mongodb/ldap-password>"
    transportSecurity: tls
    userToDNMapping:
      '[
        {
          match: "(.+)",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        }
      ]'
    authz:
      queryTemplate: "{USER}?memberOf?base"
    timeoutMS: 10000

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
```

### Terraform (MongoDB Atlas)

MongoDB Atlas ne supporte pas LDAP directement, mais supporte OIDC qui peut s'int√©grer avec Azure AD.

```hcl
# atlas-ldap-integration.tf (via OIDC)

resource "mongodbatlas_federated_settings_identity_provider" "azure_ad" {
  federation_settings_id = var.federation_settings_id
  name                   = "AzureAD-SSO"

  associated_domains     = ["company.com"]
  sso_debug_enabled      = true
  status                 = "ACTIVE"

  issuer_uri            = "https://sts.windows.net/${var.azure_tenant_id}/"
  request_binding       = "HTTP-POST"
  response_signature_algorithm = "SHA-256"

  # Azure AD SAML configuration
  sso_url              = "https://login.microsoftonline.com/${var.azure_tenant_id}/saml2"
}
```

## Bonnes Pratiques de Production

### Checklist LDAP

- [ ] **Infrastructure LDAP**
  - [ ] Multiples serveurs LDAP configur√©s (HA)
  - [ ] LDAPS (port 636) activ√© partout
  - [ ] Certificats TLS valides
  - [ ] Monitoring des serveurs LDAP

- [ ] **Compte de Service**
  - [ ] Compte d√©di√© pour MongoDB
  - [ ] Password fort, non-expirant
  - [ ] Permissions minimales (lecture seule)
  - [ ] Password stock√© dans gestionnaire de secrets

- [ ] **Configuration MongoDB**
  - [ ] `transportSecurity: tls` activ√©
  - [ ] Certificats CA configur√©s
  - [ ] Timeout appropri√© (5-10 secondes)
  - [ ] Cache LDAP configur√©

- [ ] **User-to-DN Mapping**
  - [ ] Test√© avec utilisateurs r√©els
  - [ ] G√®re tous les formats de username
  - [ ] Query LDAP optimis√©e

- [ ] **Authorization**
  - [ ] Groupes LDAP cr√©√©s et document√©s
  - [ ] Mapping groupes ‚Üí r√¥les test√©
  - [ ] Principe du moindre privil√®ge appliqu√©
  - [ ] R√¥les personnalis√©s si n√©cessaire

- [ ] **S√©curit√©**
  - [ ] Pas de password en clair dans config
  - [ ] Audit activ√© (Enterprise)
  - [ ] Monitoring des √©checs d'auth
  - [ ] Alertes sur anomalies

- [ ] **Documentation**
  - [ ] Architecture document√©e
  - [ ] Groupes LDAP et leurs permissions
  - [ ] Proc√©dures de troubleshooting
  - [ ] Contacts AD/LDAP

- [ ] **Tests**
  - [ ] Authentification test√©e en staging
  - [ ] Failover LDAP test√©
  - [ ] Latence mesur√©e
  - [ ] Proc√©dure de rollback d√©finie

### Configuration Recommand√©e (Production)

```yaml
# /etc/mongod.conf - Production LDAP

net:
  bindIp: 0.0.0.0
  port: 27017
  maxIncomingConnections: 10000

security:
  authorization: enabled

  ldap:
    # Multiples serveurs pour HA
    servers: "ldap01.company.com,ldap02.company.com,ldap03.company.com"
    port: 636

    bind:
      method: "simple"
      queryUser: "CN=mongodb-ldap-bind,OU=Service Accounts,DC=company,DC=com"

      # Password depuis fichier externe (Vault id√©alement)
      queryPassword: "<path:/etc/mongodb/ldap-password>"

    # LDAPS obligatoire
    transportSecurity: tls
    tls:
      CAFile: /etc/ssl/certs/company-ca.pem
      allowInvalidCertificates: false
      allowInvalidHostnames: false

    # User mapping
    userToDNMapping:
      '[
        {
          match: "(.+)@company\\.com",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        },
        {
          match: "(.+)",
          substitution: "CN={0},OU=Users,DC=company,DC=com"
        }
      ]'

    # Authorization query
    authz:
      queryTemplate: "{USER}?memberOf?base"

    # Timeout raisonnable
    timeoutMS: 8000

# Cache LDAP (5 minutes)
setParameter:
  ldapUserCacheInvalidationInterval: 300

# Audit (Enterprise)
auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.log
  filter: '{
    "$or": [
      { "atype": "authenticate", "param.mechanism": "PLAIN" },
      { "atype": "authCheck" },
      { "atype": "createUser" },
      { "atype": "dropUser" }
    ]
  }'

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  logRotate: reopen
  component:
    accessControl:
      verbosity: 1

replication:
  replSetName: rs0

storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: true
```

## Conclusion

L'authentification LDAP offre une int√©gration puissante avec les infrastructures d'entreprise existantes.

**Avantages** :
- ‚úÖ Gestion centralis√©e des utilisateurs
- ‚úÖ Single Sign-On (SSO)
- ‚úÖ Int√©gration avec Active Directory
- ‚úÖ Politiques de s√©curit√© centralis√©es
- ‚úÖ Groupes et mapping automatique
- ‚úÖ Audit centralis√©

**D√©fis** :
- ‚ùå N√©cessite MongoDB Enterprise
- ‚ùå D√©pendance sur infrastructure LDAP
- ‚ùå Latence r√©seau potentielle
- ‚ùå Complexit√© de configuration
- ‚ùå Debugging plus difficile

**Recommandations finales** :
1. Utiliser LDAP pour **environnements enterprise** avec AD existant
2. Configurer **haute disponibilit√©** (multiples serveurs LDAP)
3. Activer **LDAPS** syst√©matiquement
4. Impl√©menter **monitoring** robuste
5. Tester le **failover** r√©guli√®rement
6. Documenter le **mapping** groupes ‚Üí r√¥les
7. S√©curiser le **compte de service**
8. Activer l'**audit** pour conformit√©

LDAP est id√©al pour les grandes organisations avec des centaines ou milliers d'utilisateurs et une infrastructure Active Directory mature.

---

**Prochaine Section** :
- **11.2.4** : Kerberos - Authentification enterprise hautement s√©curis√©e

‚è≠Ô∏è [Kerberos](/11-securite/02.4-kerberos.md)
