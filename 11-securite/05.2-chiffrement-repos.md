üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.2 Chiffrement au repos (Encryption at Rest)

## Introduction

Le chiffrement au repos prot√®ge les donn√©es MongoDB stock√©es sur le disque contre l'acc√®s non autoris√© en cas de vol physique des serveurs, de compromission du stockage, ou d'acc√®s illicite au syst√®me de fichiers. Cette protection est distincte du chiffrement en transit (TLS/SSL) qui prot√®ge les donn√©es pendant leur transmission r√©seau.

MongoDB Enterprise offre un chiffrement natif int√©gr√© au moteur de stockage WiredTiger, permettant un chiffrement transparent des donn√©es avec un impact minimal sur les performances. Cette fonctionnalit√© est essentielle pour la conformit√© r√©glementaire (RGPD, HIPAA, PCI-DSS) et constitue une couche de d√©fense critique dans une strat√©gie de s√©curit√© en profondeur.

### Diff√©rence avec le chiffrement en transit

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Chiffrement en Transit                   ‚îÇ
‚îÇ  Protection : Donn√©es pendant la transmission r√©seau        ‚îÇ
‚îÇ  Technologie : TLS/SSL                                      ‚îÇ
‚îÇ  Port√©e : Client ‚Üî Serveur, Serveur ‚Üî Serveur               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
                    [Donn√©es en m√©moire]
                    Non chiffr√©es en RAM
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Chiffrement au Repos                     ‚îÇ
‚îÇ  Protection : Donn√©es stock√©es sur disque                   ‚îÇ
‚îÇ  Technologie : AES-256-GCM (WiredTiger)                     ‚îÇ
‚îÇ  Port√©e : Fichiers de donn√©es, journaux, snapshots          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
                    [Fichiers sur disque]
                    Chiffr√©s avec AES-256
```

### Menaces adress√©es

Le chiffrement au repos prot√®ge contre :

1. **Vol physique du mat√©riel**
   - Serveurs vol√©s dans un datacenter
   - Disques durs d√©rob√©s
   - Backup tapes perdues ou vol√©es

2. **Acc√®s non autoris√© au stockage**
   - Compromission du syst√®me de fichiers
   - Montage de volumes par un attaquant
   - Acc√®s root malveillant au serveur

3. **D√©commissionnement inappropri√©**
   - Disques non effac√©s avant recyclage
   - Serveurs revendus sans suppression s√©curis√©e
   - Stockage cloud non nettoy√©

4. **Snapshots et backups non s√©curis√©s**
   - Snapshots de volumes accessibles
   - Backups stock√©s sans protection
   - Archives anciennes oubli√©es

### Ce que le chiffrement au repos NE prot√®ge PAS

**Important** : Le chiffrement au repos ne prot√®ge pas contre :

```
‚úó Acc√®s via MongoDB authentifi√©
  ‚Üí Un utilisateur avec credentials valides peut lire les donn√©es

‚úó Compromission de l'application
  ‚Üí Si l'application est compromise, les donn√©es sont accessibles

‚úó Injection SQL/NoSQL
  ‚Üí Les requ√™tes malicieuses fonctionnent normalement

‚úó Administrateur MongoDB malveillant
  ‚Üí Un DBA avec acc√®s peut toujours lire les donn√©es
  ‚Üí Pour cela, utiliser CSFLE (section 11.5.3)

‚úó Donn√©es en m√©moire
  ‚Üí La RAM contient des donn√©es non chiffr√©es
  ‚Üí Cold boot attacks possibles (rare)
```

## Architecture du chiffrement WiredTiger

### Fonctionnement interne

MongoDB utilise le moteur de stockage WiredTiger avec chiffrement transparent :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Application / Client                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        mongod Process                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              WiredTiger Cache (RAM)                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ              Donn√©es NON chiffr√©es                     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                              ‚Üì                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ           WiredTiger Encryption Layer                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ           ‚Ä¢ AES-256-GCM                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ           ‚Ä¢ Database Key chiffre chaque fichier        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ           ‚Ä¢ Master Key chiffre Database Keys           ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Filesystem (Disk)                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  collection-xxx.wt      (CHIFFR√â)                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  index-xxx.wt          (CHIFFR√â)                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  WiredTiger.wt         (CHIFFR√â)                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  journal/*.journal     (CHIFFR√â)                       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Hi√©rarchie des cl√©s

MongoDB utilise une architecture de cl√©s √† deux niveaux :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Master Key (Encryption Key)                                ‚îÇ
‚îÇ  ‚Ä¢ Stock√©e dans un Key Management System externe            ‚îÇ
‚îÇ  ‚Ä¢ Ne quitte JAMAIS le KMS (KMIP, AWS KMS, etc.)            ‚îÇ
‚îÇ  ‚Ä¢ Utilis√©e pour chiffrer les Database Keys                 ‚îÇ
‚îÇ  ‚Ä¢ Rotation possible sans re-chiffrer les donn√©es           ‚îÇ
‚îÇ  ‚Ä¢ Algorithme : AES-256-GCM                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ chiffre/d√©chiffre
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Database Keys (Internal Keys)                              ‚îÇ
‚îÇ  ‚Ä¢ Une cl√© unique par fichier WiredTiger                    ‚îÇ
‚îÇ  ‚Ä¢ G√©n√©r√©es al√©atoirement par MongoDB                       ‚îÇ
‚îÇ  ‚Ä¢ Stock√©es chiffr√©es dans les m√©tadonn√©es du fichier       ‚îÇ
‚îÇ  ‚Ä¢ Chiffr√©es par la Master Key                              ‚îÇ
‚îÇ  ‚Ä¢ Algorithme : AES-256-GCM                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ chiffre/d√©chiffre
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Data Files (.wt files)                                     ‚îÇ
‚îÇ  ‚Ä¢ collection-xxx.wt                                        ‚îÇ
‚îÇ  ‚Ä¢ index-xxx.wt                                             ‚îÇ
‚îÇ  ‚Ä¢ WiredTiger.wt (catalogue)                                ‚îÇ
‚îÇ  ‚Ä¢ journal/*.journal                                        ‚îÇ
‚îÇ  ‚Ä¢ Chiffr√©s bloc par bloc (AES-256-GCM)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantages de cette architecture** :

1. **Rotation de la Master Key sans downtime**
   - Seules les Database Keys doivent √™tre re-chiffr√©es
   - Les donn√©es elles-m√™mes ne sont pas touch√©es
   - Op√©ration rapide (quelques secondes)

2. **Performance optimale**
   - Database Keys en cache en m√©moire
   - Pas d'appel au KMS pour chaque op√©ration
   - Le KMS n'est sollicit√© qu'au d√©marrage de mongod

3. **S√©curit√© renforc√©e**
   - La Master Key ne quitte jamais le KMS
   - Compromission d'un fichier ne compromet pas les autres
   - Audit centralis√© via le KMS

### Algorithme de chiffrement

MongoDB utilise **AES-256-GCM** (Advanced Encryption Standard - Galois/Counter Mode) :

```
Caract√©ristiques :
‚îú‚îÄ Taille de cl√© : 256 bits
‚îú‚îÄ Mode : GCM (Galois/Counter Mode)
‚îú‚îÄ Authenticated Encryption (AEAD)
‚îÇ  ‚îî‚îÄ Chiffrement + Authentification = Protection contre la modification
‚îú‚îÄ Performance : Excellente avec AES-NI
‚îî‚îÄ Standard : FIPS 140-2 compliant
```

**GCM vs autres modes** :

| Mode | Authentification | Performance | Parall√©lisable | Recommandation |
|------|------------------|-------------|----------------|----------------|
| **GCM** | ‚úÖ Oui | Excellent | ‚úÖ Oui | **Production** |
| CBC | ‚ùå Non | Bon | ‚ùå Non | √âviter |
| CTR | ‚ùå Non | Excellent | ‚úÖ Oui | √âviter (pas d'auth) |
| ECB | ‚ùå Non | Excellent | ‚úÖ Oui | ‚ùå Non s√©curis√© |

## Options de gestion des cl√©s

### Option 1 : KMIP (Key Management Interoperability Protocol)

**Recommand√© pour la production enterprise.**

KMIP est un protocole standardis√© pour la gestion centralis√©e des cl√©s cryptographiques.

#### Serveurs KMIP compatibles

```
Enterprise KMS Solutions :
‚îú‚îÄ HashiCorp Vault Enterprise
‚îú‚îÄ Thales CipherTrust Manager (anciennement Vormetric)
‚îú‚îÄ AWS CloudHSM
‚îú‚îÄ Gemalto (Thales) SafeNet KeySecure
‚îú‚îÄ IBM Security Guardium Key Lifecycle Manager
‚îú‚îÄ Townsend Security Alliance Key Manager
‚îú‚îÄ Fortanix DSM (Data Security Manager)
‚îî‚îÄ HyTrust KeyControl

Cloud-Native :
‚îú‚îÄ AWS KMS + CloudHSM (via KMIP)
‚îú‚îÄ Azure Key Vault (via plugin)
‚îî‚îÄ Google Cloud KMS (via plugin)
```

#### Configuration KMIP avec HashiCorp Vault

**√âtape 1 : Configuration de Vault**

```bash
#!/bin/bash
# setup-vault-kmip.sh

# Activer le secrets engine KMIP (Enterprise uniquement)
vault secrets enable kmip

# Configurer le listener KMIP
vault write kmip/config \
  listen_addrs=0.0.0.0:5696 \
  tls_ca_key_type=rsa \
  tls_ca_key_bits=4096

# Cr√©er un scope pour MongoDB
vault write -f kmip/scope/mongodb

# Cr√©er un r√¥le pour les serveurs MongoDB
vault write kmip/scope/mongodb/role/mongodb-server \
  operation_all=true

# G√©n√©rer un certificat client pour MongoDB
vault write -format=json \
  kmip/scope/mongodb/role/mongodb-server/credential/generate \
  format=pem > mongodb-kmip-credentials.json

# Extraire le certificat et la cl√©
cat mongodb-kmip-credentials.json | jq -r .data.certificate > mongodb-kmip-client.pem
cat mongodb-kmip-credentials.json | jq -r .data.private_key >> mongodb-kmip-client.pem
cat mongodb-kmip-credentials.json | jq -r .data.ca_chain[] > vault-ca.pem

echo "KMIP credentials generated:"
echo "  Client cert: mongodb-kmip-client.pem"
echo "  CA cert: vault-ca.pem"
```

**√âtape 2 : Configuration MongoDB**

```yaml
# mongod.conf
storage:
  dbPath: /data/mongodb
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      # Activer le chiffrement
      cacheSizeGB: 8
      journalCompressor: snappy
    collectionConfig:
      blockCompressor: snappy

security:
  # Activer le chiffrement au repos
  enableEncryption: true
  # Configuration KMIP
  kmip:
    # Serveur KMIP (Vault)
    serverName: vault.company.com
    port: 5696
    # Certificats pour l'authentification client
    clientCertificateFile: /etc/ssl/mongodb/kmip/mongodb-kmip-client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/vault-ca.pem
    # Identifiant de la cl√© principale
    keyIdentifier: "mongodb-prod-master-key-2024"
    # Timeout de connexion (ms)
    connectTimeout: 5000
    # Timeout pour les op√©rations (ms)
    connectRetry: 3

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    storage:
      verbosity: 1  # Logger les op√©rations de chiffrement
```

**√âtape 3 : D√©marrage et validation**

```bash
#!/bin/bash
# start-mongodb-encrypted.sh

# D√©marrer MongoDB
systemctl start mongod

# Attendre le d√©marrage
sleep 5

# V√©rifier que le chiffrement est actif
mongosh --eval "
  var status = db.serverStatus();
  if (status.encryptionAtRest && status.encryptionAtRest.encryptionEnabled) {
    print('‚úì Encryption at Rest is ENABLED');
    print('  Key Store: ' + status.encryptionAtRest.keyStore);
    if (status.encryptionAtRest.keyId) {
      print('  Key ID: ' + status.encryptionAtRest.keyId);
    }
  } else {
    print('‚úó Encryption at Rest is DISABLED');
  }
"

# V√©rifier les logs pour les erreurs KMIP
tail -n 50 /var/log/mongodb/mongod.log | grep -i "kmip\|encryption"
```

#### Configuration KMIP avec AWS CloudHSM

```yaml
# mongod.conf - AWS CloudHSM via KMIP
security:
  enableEncryption: true
  kmip:
    serverName: cloudhsm-kmip.us-east-1.amazonaws.com
    port: 5696
    clientCertificateFile: /opt/cloudhsm/etc/customerCA.crt
    serverCAFile: /opt/cloudhsm/etc/customerCA.crt
    keyIdentifier: "mongodb-prod-hsm-key"
    connectTimeout: 10000
    connectRetry: 3
    # CloudHSM n√©cessite des timeouts plus √©lev√©s
    serverConnectionTimeout: 60000
```

### Option 2 : Local Key File (D√©veloppement uniquement)

**‚ö†Ô∏è INTERDIRE EN PRODUCTION** - Pour test et d√©veloppement uniquement.

```yaml
# mongod.conf - LOCAL KEYFILE (DEV ONLY)
security:
  enableEncryption: true
  encryptionKeyFile: /secure/mongodb-keyfile

storage:
  dbPath: /data/mongodb
  journal:
    enabled: true
```

**G√©n√©ration du keyfile** :

```bash
#!/bin/bash
# generate-local-keyfile.sh - DEV ONLY

# Cr√©er un keyfile al√©atoire (32 bytes pour AES-256)
openssl rand -base64 32 > /secure/mongodb-keyfile

# Permissions strictes
chmod 400 /secure/mongodb-keyfile
chown mongodb:mongodb /secure/mongodb-keyfile

echo "‚ö†Ô∏è  WARNING: Local keyfile created for DEV ONLY"
echo "   File: /secure/mongodb-keyfile"
echo "   DO NOT USE IN PRODUCTION"
```

**Limitations critiques** :

```
‚úó Cl√© stock√©e en clair sur le disque
  ‚Üí Si le disque est compromis, la cl√© l'est aussi

‚úó Aucun audit des acc√®s √† la cl√©
  ‚Üí Impossible de savoir qui a acc√©d√© √† la cl√©

‚úó Pas de rotation automatique
  ‚Üí Rotation manuelle complexe et risqu√©e

‚úó Pas de backup s√©curis√©
  ‚Üí Comment sauvegarder la cl√© en toute s√©curit√© ?

‚úó Non conforme aux standards
  ‚Üí PCI-DSS, HIPAA, SOC2 interdisent cette approche
```

### Option 3 : Cloud Provider KMS (via plugins)

#### AWS KMS (via plugin)

MongoDB ne supporte pas directement AWS KMS pour Encryption at Rest, mais vous pouvez utiliser :

1. **AWS EBS Encryption** (recommand√© pour MongoDB sur AWS)
2. **LUKS avec AWS KMS** pour la gestion des cl√©s
3. **AWS CloudHSM** avec KMIP

**Exemple : EBS Encryption (transparent)**

```bash
# Cr√©er un volume EBS chiffr√©
aws ec2 create-volume \
  --availability-zone us-east-1a \
  --size 100 \
  --encrypted \
  --kms-key-id arn:aws:kms:us-east-1:123456789012:key/abcd-1234 \
  --volume-type gp3

# Attacher au serveur MongoDB
aws ec2 attach-volume \
  --volume-id vol-xxxxx \
  --instance-id i-xxxxx \
  --device /dev/sdf

# Monter et utiliser
mkfs.ext4 /dev/sdf
mount /dev/sdf /data/mongodb
chown -R mongodb:mongodb /data/mongodb
```

#### Azure Disk Encryption

```bash
# Cr√©er un disque manag√© chiffr√© avec Azure Key Vault
az disk create \
  --resource-group mongodb-prod-rg \
  --name mongodb-data-disk \
  --size-gb 100 \
  --sku Premium_LRS \
  --encryption-type EncryptionAtRestWithPlatformAndCustomerKeys \
  --disk-encryption-set /subscriptions/.../diskEncryptionSets/mongodb-des

# Attacher au VM
az vm disk attach \
  --resource-group mongodb-prod-rg \
  --vm-name mongodb-prod-01 \
  --name mongodb-data-disk
```

## Configuration par architecture

### Standalone avec KMIP

```yaml
# /etc/mongod.conf - Standalone avec Encryption at Rest
storage:
  dbPath: /data/mongodb
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 12
      journalCompressor: snappy
    collectionConfig:
      blockCompressor: snappy

security:
  authorization: enabled
  enableEncryption: true
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    keyIdentifier: "mongodb-standalone-prod-2024"
    connectTimeout: 5000

net:
  port: 27017
  bindIp: 10.0.1.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/server.pem
    CAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
```

### Replica Set avec KMIP

**Important** : Tous les membres du Replica Set doivent avoir acc√®s √† la m√™me Master Key.

#### Configuration Primary

```yaml
# /etc/mongod-rs1-primary.conf
storage:
  dbPath: /data/mongodb/rs1
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 12

security:
  authorization: enabled
  enableEncryption: true
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/rs1-primary-client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    # M√äME cl√© pour tous les membres du Replica Set
    keyIdentifier: "mongodb-rs1-shared-key-2024"
    connectTimeout: 5000

replication:
  replSetName: rs1

net:
  port: 27017
  bindIp: 10.0.1.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/rs1-primary.pem
    CAFile: /etc/ssl/mongodb/ca.pem
    clusterFile: /etc/ssl/mongodb/rs1-primary.pem
    clusterCAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-rs1-primary.log
  logAppend: true
```

#### Configuration Secondaries (identique sauf certificats)

```yaml
# /etc/mongod-rs1-secondary1.conf
storage:
  dbPath: /data/mongodb/rs1
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 12

security:
  authorization: enabled
  enableEncryption: true
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/rs1-secondary1-client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    # M√äME keyIdentifier que le Primary
    keyIdentifier: "mongodb-rs1-shared-key-2024"
    connectTimeout: 5000

replication:
  replSetName: rs1

net:
  port: 27017
  bindIp: 10.0.1.11  # IP diff√©rente
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/rs1-secondary1.pem
    CAFile: /etc/ssl/mongodb/ca.pem
    clusterFile: /etc/ssl/mongodb/rs1-secondary1.pem
    clusterCAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-rs1-secondary1.log
  logAppend: true
```

### Sharded Cluster avec KMIP

Dans un cluster shard√©, vous pouvez choisir :

**Option A : Cl√© unique pour tout le cluster** (plus simple)
- Tous les composants (config servers, shards) utilisent la m√™me Master Key
- Simplifie la gestion
- Augmente le blast radius en cas de compromission

**Option B : Cl√©s diff√©rentes par composant** (plus s√©curis√©)
- Config Servers : `mongodb-config-key-2024`
- Shard 1 : `mongodb-shard1-key-2024`
- Shard 2 : `mongodb-shard2-key-2024`
- R√©duit le blast radius
- Gestion plus complexe

#### Config Servers

```yaml
# /etc/mongod-config-01.conf
sharding:
  clusterRole: configsvr

replication:
  replSetName: configRS

storage:
  dbPath: /data/mongodb/config
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 4

security:
  authorization: enabled
  enableEncryption: true
  clusterAuthMode: x509
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/config-01-client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    keyIdentifier: "mongodb-config-servers-key-2024"
    connectTimeout: 5000

net:
  port: 27019
  bindIp: 10.0.2.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/config-01.pem
    CAFile: /etc/ssl/mongodb/ca.pem
    clusterFile: /etc/ssl/mongodb/config-01.pem
    clusterCAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-config-01.log
  logAppend: true
```

#### Shards

```yaml
# /etc/mongod-shard1-01.conf
sharding:
  clusterRole: shardsvr

replication:
  replSetName: shard1RS

storage:
  dbPath: /data/mongodb/shard1
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 16

security:
  authorization: enabled
  enableEncryption: true
  clusterAuthMode: x509
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/shard1-01-client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    keyIdentifier: "mongodb-shard1-key-2024"  # Cl√© sp√©cifique au shard
    connectTimeout: 5000

net:
  port: 27018
  bindIp: 10.0.3.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/shard1-01.pem
    CAFile: /etc/ssl/mongodb/ca.pem
    clusterFile: /etc/ssl/mongodb/shard1-01.pem
    clusterCAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-shard1-01.log
  logAppend: true
```

#### Mongos (pas de chiffrement car pas de stockage)

```yaml
# /etc/mongos.conf
sharding:
  configDB: configRS/config-01.company.com:27019,config-02.company.com:27019,config-03.company.com:27019

security:
  clusterAuthMode: x509

net:
  port: 27017
  bindIp: 10.0.4.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/mongos-01.pem
    CAFile: /etc/ssl/mongodb/ca.pem
    clusterFile: /etc/ssl/mongodb/mongos-01.pem
    clusterCAFile: /etc/ssl/mongodb/ca.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongos-01.log
  logAppend: true
```

## Migration vers Encryption at Rest

### Strat√©gie 1 : Nouvelle installation (recommand√©)

**Sc√©nario** : D√©ploiement d'un nouveau cluster MongoDB.

```bash
#!/bin/bash
# deploy-encrypted-cluster.sh

# 1. Pr√©parer la configuration KMIP
# (certificats, cl√©s, etc.)

# 2. Cr√©er mongod.conf avec encryption activ√©e (voir exemples ci-dessus)

# 3. Initialiser un nouveau dbPath vide
mkdir -p /data/mongodb-encrypted
chown -R mongodb:mongodb /data/mongodb-encrypted

# 4. D√©marrer MongoDB avec encryption
systemctl start mongod

# 5. V√©rifier que le chiffrement est actif
mongosh --eval "db.serverStatus().encryptionAtRest"

# 6. Migrer les donn√©es depuis l'ancien cluster (si applicable)
# Via mongodump/mongorestore ou initial sync d'un Replica Set
```

### Strat√©gie 2 : Migration Rolling (Replica Set)

**Sc√©nario** : Cluster en production, migration sans downtime.

```bash
#!/bin/bash
# rolling-migration-to-encrypted.sh

# PR√âREQUIS :
# - Replica Set avec au moins 3 membres
# - Backup complet r√©cent
# - Maintenance window (bien que sans downtime complet)

echo "=== Phase 1 : Pr√©parer la configuration ==="

# Cr√©er la configuration avec encryption pour chaque n≈ìud
# /etc/mongod-encrypted.conf

echo "=== Phase 2 : Migrer le Secondary 1 ==="

# Sur Secondary 1 :
# 1. Arr√™ter le membre
ssh mongodb-rs1-secondary1 "systemctl stop mongod"

# 2. Sauvegarder les anciennes donn√©es (au cas o√π)
ssh mongodb-rs1-secondary1 "mv /data/mongodb /data/mongodb.backup"

# 3. Cr√©er un nouveau dbPath vide
ssh mongodb-rs1-secondary1 "mkdir -p /data/mongodb && chown mongodb:mongodb /data/mongodb"

# 4. Appliquer la nouvelle configuration avec encryption
ssh mongodb-rs1-secondary1 "cp /etc/mongod-encrypted.conf /etc/mongod.conf"

# 5. D√©marrer avec encryption activ√©e
# Initial sync va se faire automatiquement depuis le Primary
ssh mongodb-rs1-secondary1 "systemctl start mongod"

# 6. Attendre que le membre soit √† jour
while ! mongosh --host mongodb-rs1-secondary1 --eval "rs.status()" | grep -q "SECONDARY"; do
  echo "Waiting for Secondary 1 to catch up..."
  sleep 30
done

echo "‚úì Secondary 1 migrated successfully"

echo "=== Phase 3 : Migrer le Secondary 2 ==="

# R√©p√©ter les m√™mes √©tapes pour Secondary 2
# ...

echo "‚úì Secondary 2 migrated successfully"

echo "=== Phase 4 : Migrer le Primary ==="

# 1. Step down le Primary
mongosh --eval "rs.stepDown(60)"

# 2. Attendre l'√©lection d'un nouveau Primary
sleep 10

# 3. L'ancien Primary est maintenant Secondary
# R√©p√©ter les √©tapes de migration

echo "‚úì Primary migrated successfully"

echo "=== Phase 5 : Validation ==="

# V√©rifier que tous les membres sont chiffr√©s
for host in mongodb-rs1-01 mongodb-rs1-02 mongodb-rs1-03; do
  echo "Checking $host..."
  mongosh --host $host --eval "
    var status = db.serverStatus().encryptionAtRest;
    if (status.encryptionEnabled) {
      print('‚úì Encryption ENABLED on ' + '$host');
    } else {
      print('‚úó Encryption DISABLED on ' + '$host');
    }
  "
done

echo "=== Migration complete ==="
```

### Strat√©gie 3 : Snapshot et restauration (Standalone)

**Sc√©nario** : Serveur standalone, downtime acceptable.

```bash
#!/bin/bash
# migrate-standalone-to-encrypted.sh

echo "=== Standalone Migration to Encryption at Rest ==="

# 1. Backup complet
echo "Step 1: Creating backup..."
mongodump --uri="mongodb://admin:password@localhost:27017" --out=/backup/pre-encryption

# 2. Arr√™ter MongoDB
echo "Step 2: Stopping MongoDB..."
systemctl stop mongod

# 3. Sauvegarder les anciennes donn√©es
echo "Step 3: Backing up old dbPath..."
mv /data/mongodb /data/mongodb.unencrypted

# 4. Cr√©er un nouveau dbPath
echo "Step 4: Creating new encrypted dbPath..."
mkdir -p /data/mongodb
chown mongodb:mongodb /data/mongodb

# 5. Activer encryption dans la configuration
echo "Step 5: Enabling encryption in config..."
cat > /etc/mongod.conf <<'EOF'
storage:
  dbPath: /data/mongodb
  journal:
    enabled: true

security:
  authorization: enabled
  enableEncryption: true
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    keyIdentifier: "mongodb-standalone-prod-2024"

net:
  port: 27017
  bindIp: 127.0.0.1

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
EOF

# 6. D√©marrer MongoDB avec encryption
echo "Step 6: Starting MongoDB with encryption..."
systemctl start mongod

# Attendre le d√©marrage
sleep 10

# 7. Restaurer les donn√©es (elles seront chiffr√©es automatiquement)
echo "Step 7: Restoring data (will be encrypted)..."
mongorestore --uri="mongodb://admin:password@localhost:27017" /backup/pre-encryption

# 8. Valider
echo "Step 8: Validating encryption..."
mongosh --eval "
  var status = db.serverStatus().encryptionAtRest;
  if (status.encryptionEnabled) {
    print('‚úì Encryption is ENABLED');
    print('  Key Store: ' + status.keyStore);
    print('  Key ID: ' + status.keyId);
  } else {
    print('‚úó Encryption is DISABLED - MIGRATION FAILED');
    process.exit(1);
  }
"

echo "=== Migration complete ==="
echo "‚ö†Ô∏è  Don't forget to securely delete: /data/mongodb.unencrypted"
```

## Performance et optimisation

### Impact sur les performances

Benchmarks typiques avec Encryption at Rest :

```
Op√©ration            ‚îÇ Sans encryption ‚îÇ Avec encryption ‚îÇ Overhead
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Insert (1K docs)     ‚îÇ 45ms            ‚îÇ 51ms            ‚îÇ +13%
Find (indexed)       ‚îÇ 2.5ms           ‚îÇ 2.9ms           ‚îÇ +16%
Find (full scan)     ‚îÇ 180ms           ‚îÇ 208ms           ‚îÇ +15%
Update (indexed)     ‚îÇ 8ms             ‚îÇ 9.5ms           ‚îÇ +19%
Aggregation pipeline ‚îÇ 340ms           ‚îÇ 398ms           ‚îÇ +17%
Index build          ‚îÇ 12.3s           ‚îÇ 14.8s           ‚îÇ +20%
```

**Facteurs d'impact** :

1. **CPU** : +10-20% d'utilisation
2. **I/O** : L√©g√®re augmentation (op√©rations de chiffrement/d√©chiffrement)
3. **M√©moire** : Minimal (cache identique)
4. **Latence** : +10-15% en moyenne

### Optimisations recommand√©es

#### 1. Support mat√©riel AES-NI

```bash
# V√©rifier le support AES-NI
grep -m1 -o aes /proc/cpuinfo

# Si pr√©sent, MongoDB l'utilise automatiquement
# Performance : jusqu'√† 5x plus rapide

# V√©rifier l'utilisation effective
openssl speed -evp aes-256-gcm
```

#### 2. Augmentation du cache WiredTiger

```yaml
# mongod.conf
storage:
  wiredTiger:
    engineConfig:
      # Sans encryption : 50% de la RAM
      # Avec encryption : 60-70% de la RAM
      cacheSizeGB: 12  # Pour un serveur avec 20 GB RAM
```

**R√®gle de calcul** :

```bash
# Serveur avec 32 GB RAM
# Sans encryption : cache = 16 GB (50%)
# Avec encryption : cache = 20-22 GB (62-69%)

# Formule recommand√©e :
cache_size = (total_ram - 2GB_os - 1GB_overhead) * 0.65
```

#### 3. Compression compl√©mentaire

```yaml
# mongod.conf - Optimal pour chiffrement + compression
storage:
  wiredTiger:
    engineConfig:
      journalCompressor: snappy  # Compression du journal
    collectionConfig:
      blockCompressor: snappy    # Compression des collections

# Alternatives :
# - zstd : Meilleur ratio mais plus CPU
# - snappy : Bon compromis (recommand√© avec encryption)
# - zlib : Ancien, √©viter
# - none : Pas de compression
```

**Impact combin√© chiffrement + compression** :

```
                     ‚îÇ Taille ‚îÇ CPU    ‚îÇ I/O
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Pas de compression   ‚îÇ 100%   ‚îÇ +15%   ‚îÇ 100%
Snappy               ‚îÇ 60%    ‚îÇ +18%   ‚îÇ 60%
Zstd                 ‚îÇ 45%    ‚îÇ +25%   ‚îÇ 45%
```

#### 4. Dimensionnement I/O

Avec Encryption at Rest, privil√©gier :

```
Stockage recommand√© :
‚îú‚îÄ SSD/NVMe obligatoire (pas de HDD)
‚îú‚îÄ IOPS provisionn√©es : +30% vs sans encryption
‚îú‚îÄ Latence cible : < 10ms (95th percentile)
‚îî‚îÄ Bande passante : +20% vs sans encryption

AWS :
‚îú‚îÄ EBS gp3 : 3000 IOPS baseline (ajustable)
‚îú‚îÄ io2 : Pour charges critiques
‚îî‚îÄ Instance storage : Optimal mais √©ph√©m√®re

Azure :
‚îú‚îÄ Premium SSD : Minimum
‚îî‚îÄ Ultra Disk : Pour charges extr√™mes

GCP :
‚îî‚îÄ SSD persistent disk : Standard
```

## Alternatives au chiffrement natif MongoDB

### Option 1 : Chiffrement au niveau filesystem (LUKS)

**Avantages** :
- Fonctionne avec MongoDB Community (pas besoin d'Enterprise)
- Transparent pour MongoDB
- Prot√®ge √©galement les logs, binaires, etc.

**Inconv√©nients** :
- Performance l√©g√®rement moins bonne que le chiffrement natif
- Gestion des cl√©s plus complexe
- Pas de rotation de cl√©s sans downtime

#### Configuration LUKS sur Linux

```bash
#!/bin/bash
# setup-luks-mongodb.sh

DEVICE="/dev/sdb"
MOUNT_POINT="/data/mongodb"

# 1. Installer les outils n√©cessaires
apt-get install -y cryptsetup

# 2. Initialiser LUKS sur le device
cryptsetup luksFormat $DEVICE

# Entrer une passphrase forte
# ‚ö†Ô∏è En production, utiliser un key file avec gestion automatis√©e

# 3. Ouvrir le volume chiffr√©
cryptsetup luksOpen $DEVICE mongodb_encrypted

# 4. Cr√©er un filesystem
mkfs.ext4 /dev/mapper/mongodb_encrypted

# 5. Monter
mkdir -p $MOUNT_POINT
mount /dev/mapper/mongodb_encrypted $MOUNT_POINT
chown -R mongodb:mongodb $MOUNT_POINT

# 6. Ajouter √† /etc/fstab pour montage automatique
echo "/dev/mapper/mongodb_encrypted $MOUNT_POINT ext4 defaults 0 2" >> /etc/fstab

# 7. Configuration du d√©verrouillage automatique au boot
# Cr√©er un keyfile
dd if=/dev/urandom of=/root/mongodb-luks.key bs=1024 count=4
chmod 400 /root/mongodb-luks.key

# Ajouter le keyfile √† LUKS
cryptsetup luksAddKey $DEVICE /root/mongodb-luks.key

# Configurer crypttab
echo "mongodb_encrypted $DEVICE /root/mongodb-luks.key luks" >> /etc/crypttab

# 8. D√©marrer MongoDB normalement
systemctl start mongod
```

#### Int√©gration avec AWS KMS

```bash
#!/bin/bash
# luks-with-aws-kms.sh

# Utiliser AWS KMS pour chiffrer le keyfile LUKS
aws kms encrypt \
  --key-id arn:aws:kms:us-east-1:123456789012:key/abcd-1234 \
  --plaintext fileb:///root/mongodb-luks.key \
  --output text \
  --query CiphertextBlob | base64 -d > /root/mongodb-luks.key.encrypted

# Script de d√©verrouillage au d√©marrage
cat > /usr/local/bin/unlock-mongodb-volume.sh <<'EOF'
#!/bin/bash
# D√©chiffrer le keyfile avec AWS KMS
aws kms decrypt \
  --ciphertext-blob fileb:///root/mongodb-luks.key.encrypted \
  --output text \
  --query Plaintext | base64 -d > /tmp/mongodb-luks.key

# D√©verrouiller le volume
cryptsetup luksOpen /dev/sdb mongodb_encrypted --key-file /tmp/mongodb-luks.key

# Nettoyer
shred -u /tmp/mongodb-luks.key

# Monter
mount /dev/mapper/mongodb_encrypted /data/mongodb
EOF

chmod +x /usr/local/bin/unlock-mongodb-volume.sh

# Cr√©er un service systemd
cat > /etc/systemd/system/mongodb-volume-unlock.service <<'EOF'
[Unit]
Description=Unlock MongoDB encrypted volume with AWS KMS
Before=mongod.service
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/unlock-mongodb-volume.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable mongodb-volume-unlock.service
```

### Option 2 : Chiffrement au niveau cloud provider

#### AWS EBS Encryption

```bash
#!/bin/bash
# create-encrypted-ebs-mongodb.sh

# Cr√©er un volume EBS chiffr√© avec KMS
VOLUME_ID=$(aws ec2 create-volume \
  --availability-zone us-east-1a \
  --size 100 \
  --volume-type gp3 \
  --iops 3000 \
  --throughput 125 \
  --encrypted \
  --kms-key-id arn:aws:kms:us-east-1:123456789012:key/abcd-1234 \
  --tag-specifications 'ResourceType=volume,Tags=[{Key=Name,Value=mongodb-data},{Key=Environment,Value=production}]' \
  --query 'VolumeId' \
  --output text)

echo "Created encrypted volume: $VOLUME_ID"

# Attendre que le volume soit disponible
aws ec2 wait volume-available --volume-ids $VOLUME_ID

# Attacher au serveur MongoDB
aws ec2 attach-volume \
  --volume-id $VOLUME_ID \
  --instance-id i-xxxxx \
  --device /dev/sdf

# Sur le serveur, formatter et monter
# Le chiffrement est transparent
sudo mkfs.ext4 /dev/sdf
sudo mkdir -p /data/mongodb
sudo mount /dev/sdf /data/mongodb
sudo chown -R mongodb:mongodb /data/mongodb

# Ajouter au fstab
echo "/dev/sdf /data/mongodb ext4 defaults,nofail 0 2" | sudo tee -a /etc/fstab
```

**Avantages AWS EBS Encryption** :
- Transparent pour MongoDB
- Gestion des cl√©s via AWS KMS
- Rotation automatique des cl√©s
- Snapshots automatiquement chiffr√©s
- Performance native (pas d'overhead d√©tectable)

#### Azure Disk Encryption

```bash
# Cr√©er un disque manag√© chiffr√©
az disk create \
  --resource-group mongodb-prod-rg \
  --name mongodb-data-disk \
  --size-gb 100 \
  --sku Premium_LRS \
  --encryption-type EncryptionAtRestWithCustomerKey \
  --disk-encryption-set /subscriptions/.../mongodb-des \
  --location eastus

# Attacher au VM
az vm disk attach \
  --resource-group mongodb-prod-rg \
  --vm-name mongodb-prod-01 \
  --name mongodb-data-disk

# Configuration automatique du chiffrement
```

### Comparaison des approches

| Approche | Licence | Performance | Gestion cl√©s | Rotation | Conformit√© |
|----------|---------|-------------|--------------|----------|-----------|
| **MongoDB Native** | Enterprise | Excellente | KMIP | Simple | ‚úÖ‚úÖ‚úÖ |
| **LUKS** | Gratuit | Bonne | Manuelle/KMS | Complexe | ‚úÖ‚úÖ |
| **EBS/Azure Disk** | Cloud | Excellente | Automatique | Automatique | ‚úÖ‚úÖ‚úÖ |
| **Aucun** | - | Meilleure | N/A | N/A | ‚ùå |

**Recommandation** :

```
Production Enterprise :
‚îî‚îÄ MongoDB Native Encryption (KMIP) + EBS/Azure Disk Encryption
   ‚Üí Defense in depth

Production Standard :
‚îî‚îÄ EBS/Azure Disk Encryption
   ‚Üí Simplifi√©, performant, conforme

D√©veloppement :
‚îî‚îÄ Aucun chiffrement ou local keyfile
   ‚Üí Simplicit√©
```

## Backup et restauration avec encryption

### Backup d'une base chiffr√©e

```bash
#!/bin/bash
# backup-encrypted-mongodb.sh

BACKUP_DIR="/backup/mongodb/$(date +%Y%m%d_%H%M%S)"
MONGO_URI="mongodb://backup-user:password@mongodb.prod.company.com:27017/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca.pem"

# 1. Cr√©er le backup avec mongodump
# Les donn√©es sont d√©chiffr√©es lors de l'export
mongodump --uri="$MONGO_URI" --out="$BACKUP_DIR"

# 2. Les fichiers du backup sont NON chiffr√©s !
# Il FAUT les chiffrer pour le stockage

# Option A : Chiffrer avec GPG
tar czf - "$BACKUP_DIR" | gpg --encrypt --recipient backup@company.com > "$BACKUP_DIR.tar.gz.gpg"

# Option B : Chiffrer avec OpenSSL
tar czf - "$BACKUP_DIR" | openssl enc -aes-256-cbc -salt -pbkdf2 -out "$BACKUP_DIR.tar.gz.enc" -pass file:/secure/backup-password

# Option C : Utiliser le chiffrement du stockage cloud
# S3 avec SSE-KMS
aws s3 cp "$BACKUP_DIR.tar.gz" \
  s3://mongodb-backups/$(date +%Y%m%d)/ \
  --sse aws:kms \
  --sse-kms-key-id arn:aws:kms:us-east-1:123456789012:key/abcd-1234

# 3. Nettoyer le backup non chiffr√©
shred -u -n 3 "$BACKUP_DIR"/*.bson
rm -rf "$BACKUP_DIR"

echo "Backup completed: $BACKUP_DIR.tar.gz.enc"
```

### Restauration

```bash
#!/bin/bash
# restore-encrypted-mongodb.sh

ENCRYPTED_BACKUP="/backup/mongodb/20241208_120000.tar.gz.enc"
MONGO_URI="mongodb://admin:password@mongodb.prod.company.com:27017/?tls=true"

# 1. D√©chiffrer le backup
openssl enc -aes-256-cbc -d -pbkdf2 -in "$ENCRYPTED_BACKUP" -pass file:/secure/backup-password | tar xzf -

# 2. Restaurer avec mongorestore
# Les donn√©es seront automatiquement chiffr√©es par MongoDB
mongorestore --uri="$MONGO_URI" --dir="/tmp/backup-extracted"

# 3. Nettoyer
rm -rf /tmp/backup-extracted

echo "Restore completed"
```

### Snapshots avec encryption

#### Snapshot d'un volume chiffr√©

```bash
# AWS : Snapshot d'un volume EBS chiffr√©
# Le snapshot h√©rite du chiffrement du volume source
aws ec2 create-snapshot \
  --volume-id vol-xxxxx \
  --description "MongoDB backup $(date +%Y%m%d)" \
  --tag-specifications 'ResourceType=snapshot,Tags=[{Key=Name,Value=mongodb-snapshot},{Key=Encrypted,Value=true}]'

# Le snapshot est automatiquement chiffr√© avec la m√™me cl√© KMS

# Restauration depuis snapshot
SNAPSHOT_ID="snap-xxxxx"

# Cr√©er un nouveau volume depuis le snapshot
aws ec2 create-volume \
  --availability-zone us-east-1a \
  --snapshot-id $SNAPSHOT_ID \
  --volume-type gp3 \
  --encrypted  # Optionnel, h√©rit√© du snapshot

# Attacher et monter comme d'habitude
```

## Rotation de la Master Key

### Pourquoi faire une rotation ?

1. **Conformit√©** : PCI-DSS, HIPAA exigent une rotation r√©guli√®re
2. **S√©curit√©** : R√©duire l'exposition en cas de compromission
3. **Best practices** : Rotation annuelle ou trimestrielle recommand√©e

### Processus de rotation avec KMIP

```bash
#!/bin/bash
# rotate-mongodb-master-key.sh

# ATTENTION : Ce script n√©cessite un arr√™t/red√©marrage de MongoDB
# Pour un Replica Set, faire un rolling restart

MONGO_HOST="mongodb.prod.company.com"
MONGO_PORT="27017"
OLD_KEY_ID="mongodb-prod-key-2024-q3"
NEW_KEY_ID="mongodb-prod-key-2024-q4"

echo "=== Master Key Rotation ==="
echo "Old Key: $OLD_KEY_ID"
echo "New Key: $NEW_KEY_ID"

# 1. Cr√©er la nouvelle cl√© dans le KMIP/KMS
echo "Step 1: Creating new key in KMIP..."
# Via l'interface du KMS ou API

# 2. Pour un Replica Set, faire un rolling restart
# Commencer par un Secondary

echo "Step 2: Rotating Secondary 1..."
ssh mongodb-rs1-secondary1 <<'EOF'
  # Arr√™ter MongoDB
  systemctl stop mongod

  # Mettre √† jour la configuration
  sed -i 's/mongodb-prod-key-2024-q3/mongodb-prod-key-2024-q4/g' /etc/mongod.conf

  # Red√©marrer avec la nouvelle cl√©
  # MongoDB va re-chiffrer les Database Keys avec la nouvelle Master Key
  systemctl start mongod
EOF

# 3. Attendre que le membre soit synchronis√©
while ! mongosh --host mongodb-rs1-secondary1 --eval "rs.status()" | grep -q "SECONDARY"; do
  echo "Waiting for Secondary 1..."
  sleep 10
done
echo "‚úì Secondary 1 rotated"

# 4. R√©p√©ter pour Secondary 2
echo "Step 3: Rotating Secondary 2..."
# ... (m√™me processus)

# 5. Step down le Primary et le faire en dernier
echo "Step 4: Rotating Primary (with stepdown)..."
mongosh --eval "rs.stepDown(60)"
sleep 10

# Rotation du Primary (maintenant Secondary)
# ... (m√™me processus)

echo "=== Rotation complete ==="

# 6. V√©rifier que tous les membres utilisent la nouvelle cl√©
for host in mongodb-rs1-01 mongodb-rs1-02 mongodb-rs1-03; do
  mongosh --host $host --eval "
    var status = db.serverStatus().encryptionAtRest;
    print('Host: $host');
    print('  Key ID: ' + status.keyId);
  "
done
```

### Rotation sans red√©marrage (MongoDB 4.2+)

MongoDB 4.2+ supporte la rotation √† chaud avec la commande `rotateMasterKey` :

```javascript
// Connexion au serveur
mongosh "mongodb://mongodb.prod.company.com:27017"

// Rotation de la Master Key
db.adminCommand({
  rotateMasterKey: 1
})

// Output :
// {
//   "ok": 1,
//   "message": "Master key rotated successfully"
// }

// V√©rifier la nouvelle cl√©
db.serverStatus().encryptionAtRest
// {
//   "encryptionEnabled": true,
//   "keyStore": "KMIP",
//   "keyId": "mongodb-prod-key-2024-q4"  // Nouvelle cl√©
// }
```

**Configuration pour supporter la rotation √† chaud** :

```yaml
# mongod.conf
security:
  enableEncryption: true
  kmip:
    serverName: vault.company.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/kmip/client.pem
    serverCAFile: /etc/ssl/mongodb/kmip/ca.pem
    keyIdentifier: "mongodb-prod-key-2024-q3"
    # Permettre la rotation √† chaud
    rotateMasterKey: true  # Important !
```

## Monitoring et validation

### V√©rification de l'√©tat du chiffrement

```javascript
// Connexion √† MongoDB
mongosh "mongodb://admin:password@mongodb.prod.company.com:27017"

// V√©rifier l'√©tat global
var status = db.serverStatus();

if (status.encryptionAtRest) {
  print("Encryption at Rest Status:");
  print("  Enabled: " + status.encryptionAtRest.encryptionEnabled);
  print("  Key Store: " + status.encryptionAtRest.keyStore);
  if (status.encryptionAtRest.keyId) {
    print("  Key ID: " + status.encryptionAtRest.keyId);
  }
  if (status.encryptionAtRest.keyVaultFile) {
    print("  Key Vault File: " + status.encryptionAtRest.keyVaultFile);
  }
} else {
  print("Encryption at Rest is NOT configured");
}

// Exemple de sortie :
// Encryption at Rest Status:
//   Enabled: true
//   Key Store: KMIP
//   Key ID: mongodb-prod-key-2024-q4
```

### V√©rification des fichiers sur disque

```bash
#!/bin/bash
# verify-disk-encryption.sh

DBPATH="/data/mongodb"

echo "=== Verifying Disk Encryption ==="

# 1. V√©rifier qu'on ne peut pas lire les donn√©es en clair
echo "Checking for cleartext data in .wt files..."

# Chercher des patterns de donn√©es en clair (attention, faux positifs possibles)
if strings $DBPATH/collection-*.wt | grep -q "mongodb\|user\|password"; then
  echo "‚ö†Ô∏è  WARNING: Potential cleartext data found!"
  echo "   This could be a false positive or encryption is not active."
else
  echo "‚úì No obvious cleartext patterns found (good sign)"
fi

# 2. V√©rifier la pr√©sence de m√©tadonn√©es WiredTiger
if file $DBPATH/collection-*.wt | grep -q "data"; then
  echo "‚úì WiredTiger files present"
else
  echo "‚úó No WiredTiger files found"
fi

# 3. V√©rifier les permissions
echo ""
echo "File permissions:"
ls -lah $DBPATH/*.wt | head -5

# 4. Taille des fichiers (les fichiers chiffr√©s sont l√©g√®rement plus gros)
echo ""
echo "Sample file sizes:"
du -h $DBPATH/collection-*.wt | head -5
```

### Script de monitoring continu

```python
#!/usr/bin/env python3
# monitor-encryption-status.py

from pymongo import MongoClient
from datetime import datetime
import json
import sys

def check_encryption_status(uri):
    """V√©rifie l'√©tat du chiffrement sur tous les membres d'un cluster"""

    try:
        client = MongoClient(uri)

        # Pour un Replica Set, v√©rifier tous les membres
        if 'replicaSet' in uri:
            rs_status = client.admin.command('replSetGetStatus')
            members = rs_status['members']

            print(f"=== Encryption Status Report - {datetime.now()} ===\n")

            for member in members:
                host = member['name']
                state = member['stateStr']

                print(f"Member: {host} ({state})")

                try:
                    # Connexion directe au membre
                    member_client = MongoClient(host)
                    server_status = member_client.admin.command('serverStatus')

                    if 'encryptionAtRest' in server_status:
                        enc = server_status['encryptionAtRest']

                        if enc.get('encryptionEnabled'):
                            print(f"  ‚úì Encryption: ENABLED")
                            print(f"    Key Store: {enc.get('keyStore', 'N/A')}")
                            print(f"    Key ID: {enc.get('keyId', 'N/A')}")
                        else:
                            print(f"  ‚úó Encryption: DISABLED")
                            return False
                    else:
                        print(f"  ‚úó Encryption: NOT CONFIGURED")
                        return False

                    member_client.close()

                except Exception as e:
                    print(f"  ‚úó Error checking member: {e}")
                    return False

                print()

            client.close()
            return True

        else:
            # Standalone
            server_status = client.admin.command('serverStatus')

            if 'encryptionAtRest' in server_status:
                enc = server_status['encryptionAtRest']

                print(f"=== Encryption Status - {datetime.now()} ===")
                print(f"Enabled: {enc.get('encryptionEnabled')}")
                print(f"Key Store: {enc.get('keyStore', 'N/A')}")
                print(f"Key ID: {enc.get('keyId', 'N/A')}")

                return enc.get('encryptionEnabled', False)
            else:
                print("Encryption at Rest not configured")
                return False

    except Exception as e:
        print(f"Error: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: monitor-encryption-status.py <mongodb_uri>")
        sys.exit(1)

    uri = sys.argv[1]

    if check_encryption_status(uri):
        print("\n‚úì All checks passed")
        sys.exit(0)
    else:
        print("\n‚úó Encryption issues detected")
        sys.exit(1)
```

## Troubleshooting

### Erreur : "KMIP server connection failed"

```bash
# Diagnostics
# 1. V√©rifier la connectivit√© r√©seau
telnet vault.company.com 5696

# 2. V√©rifier les certificats KMIP
openssl s_client -connect vault.company.com:5696 \
  -cert /etc/ssl/mongodb/kmip/client.pem \
  -CAfile /etc/ssl/mongodb/kmip/ca.pem

# 3. V√©rifier les logs MongoDB
tail -f /var/log/mongodb/mongod.log | grep -i kmip

# 4. Tester avec un timeout plus long
# Dans mongod.conf :
security:
  kmip:
    connectTimeout: 30000  # 30 secondes au lieu de 5
```

### Erreur : "Failed to decrypt database key"

**Cause** : La Master Key a chang√© ou est inaccessible.

```bash
# Solution 1 : Restaurer l'ancienne Master Key dans le KMIP

# Solution 2 : Si backup disponible, restaurer depuis backup

# Solution 3 : Si aucun backup, les donn√©es sont perdues
# C'est pourquoi les backups r√©guliers sont CRITIQUES
```

### MongoDB ne d√©marre pas apr√®s activation encryption

```bash
# V√©rifier les logs
journalctl -u mongod -n 100

# Erreurs communes :
# 1. "WiredTiger error: encryption not configured"
#    ‚Üí Le dbPath contient des donn√©es non chiffr√©es
#    Solution : Migrer les donn√©es ou utiliser un dbPath vide

# 2. "KMIP key not found"
#    ‚Üí Le keyIdentifier n'existe pas dans le KMIP
#    Solution : Cr√©er la cl√© ou corriger le keyIdentifier

# 3. "Permission denied on encryption key file"
#    ‚Üí Mauvaises permissions sur le keyfile
#    Solution : chmod 400 et chown mongodb:mongodb
```

### Performance d√©grad√©e apr√®s activation

```bash
# 1. V√©rifier l'utilisation CPU
top -p $(pgrep mongod)

# Si CPU > 80%, v√©rifier :
# - Support AES-NI
grep aes /proc/cpuinfo

# - Cache WiredTiger trop petit
# Augmenter √† 60-70% de la RAM

# 2. V√©rifier les I/O
iostat -x 5

# Si await > 20ms :
# - Utiliser SSD/NVMe
# - Augmenter les IOPS provisionn√©es
# - V√©rifier les autres charges sur le disque

# 3. Profiler les requ√™tes
db.setProfilingLevel(1, { slowms: 100 })
db.system.profile.find().sort({ ts: -1 }).limit(10).pretty()
```

## Bonnes pratiques de production

### Checklist de d√©ploiement

```
‚òê Planification
  ‚òê √âvaluer l'impact performance (benchmarks)
  ‚òê Choisir la solution de gestion des cl√©s (KMIP recommand√©)
  ‚òê Documenter la proc√©dure de r√©cup√©ration en cas de perte de cl√©s
  ‚òê Pr√©voir une fen√™tre de maintenance (m√™me pour rolling migration)

‚òê Gestion des cl√©s
  ‚òê Master Key stock√©e dans un KMS externe (JAMAIS sur le m√™me serveur)
  ‚òê Backup s√©curis√© de la Master Key
  ‚òê Proc√©dure de rotation document√©e et test√©e
  ‚òê Acc√®s √† la Master Key strictement contr√¥l√© et audit√©

‚òê Configuration
  ‚òê Utiliser KMIP (pas de local keyfile en production)
  ‚òê Certificats KMIP valides et renouvel√©s
  ‚òê Timeouts appropri√©s pour environnement cloud
  ‚òê Configuration identique sur tous les membres du Replica Set

‚òê Tests
  ‚òê V√©rifier que les fichiers sur disque sont chiffr√©s
  ‚òê Tester la rotation de cl√©s
  ‚òê Tester la restauration depuis backup
  ‚òê Benchmarks de performance vs sans encryption

‚òê Monitoring
  ‚òê Alertes si encryption devient d√©sactiv√©e
  ‚òê Monitoring de la connectivit√© au KMIP/KMS
  ‚òê Logs d'audit des acc√®s aux cl√©s
  ‚òê M√©triques de performance (CPU, I/O)

‚òê Backups
  ‚òê Backups chiffr√©s (donn√©es + Master Key backup s√©par√©ment)
  ‚òê Tests de restauration r√©guliers
  ‚òê Backups stock√©s dans un emplacement s√©curis√©
  ‚òê Retention policy document√©e

‚òê Documentation
  ‚òê Proc√©dure de r√©cup√©ration en cas de perte de cl√©s
  ‚òê Contacts d'urgence (√©quipe KMS, MongoDB support)
  ‚òê Inventaire des cl√©s (Key ID, date de cr√©ation, rotation)
  ‚òê Runbook de troubleshooting
```

### R√©cup√©ration en cas de perte de Master Key

**Sc√©nario catastrophe** : La Master Key est perdue ou inaccessible.

```
Impact :
‚îú‚îÄ Les donn√©es existantes sont IRR√âCUP√âRABLES
‚îú‚îÄ MongoDB ne peut pas d√©marrer
‚îî‚îÄ Seule solution : Restauration depuis backup

Pr√©vention (CRITIQUE) :
‚îú‚îÄ Backup r√©gulier de la Master Key
‚îÇ  ‚îî‚îÄ Stockage s√©par√© et s√©curis√©
‚îú‚îÄ Multi-r√©gion pour le KMS
‚îÇ  ‚îî‚îÄ Pas de point de d√©faillance unique
‚îú‚îÄ Tests de restauration mensuels
‚îî‚îÄ Documentation √† jour des proc√©dures
```

**Proc√©dure de r√©cup√©ration** :

```bash
#!/bin/bash
# disaster-recovery-lost-key.sh

echo "=== DISASTER RECOVERY: Lost Master Key ==="
echo "‚ö†Ô∏è  Current data is UNRECOVERABLE without the Master Key"
echo ""

# √âtape 1 : Essayer de r√©cup√©rer la Master Key depuis les backups
echo "Step 1: Attempting to recover Master Key from backups..."
# Restaurer depuis le coffre-fort d'urgence
# Contacter l'√©quipe KMS

# Si r√©cup√©ration r√©ussie :
# Red√©marrer MongoDB normalement

# Si √©chec :
echo "Step 2: Master Key recovery failed. Proceeding with data restoration..."

# 1. Cr√©er une nouvelle Master Key
NEW_KEY_ID="mongodb-prod-recovery-$(date +%Y%m%d)"
echo "Creating new Master Key: $NEW_KEY_ID"
# Via l'interface du KMS

# 2. Nouveau dbPath vide avec nouvelle cl√©
rm -rf /data/mongodb/*
mkdir -p /data/mongodb
chown mongodb:mongodb /data/mongodb

# 3. Mettre √† jour la configuration
sed -i "s/keyIdentifier: .*/keyIdentifier: \"$NEW_KEY_ID\"/g" /etc/mongod.conf

# 4. D√©marrer MongoDB avec nouveau dbPath
systemctl start mongod

# 5. Restaurer depuis le dernier backup
echo "Restoring from last backup..."
LAST_BACKUP="/backup/mongodb-backup-20241207.tar.gz.enc"

openssl enc -d -aes-256-cbc -pbkdf2 -in "$LAST_BACKUP" -pass file:/secure/backup-password | tar xzf -

mongorestore --uri="mongodb://localhost:27017" --dir=/tmp/backup-extracted

# 6. V√©rifier l'int√©grit√© des donn√©es
mongosh --eval "
  db.adminCommand({ dbStats: 1 });
  db.collection.countDocuments({});
"

echo "=== Recovery complete ==="
echo "‚ö†Ô∏è  Data loss: Everything since last backup"
```

### Politique de rotation des cl√©s

```
Fr√©quence de rotation recommand√©e :

Standard :
‚îú‚îÄ Master Key : Annuelle
‚îú‚îÄ Database Keys : Pas de rotation n√©cessaire
‚îÇ  ‚îî‚îÄ Rotation automatique lors de la rotation de la Master Key
‚îî‚îÄ Certificats KMIP : Annuelle

PCI-DSS :
‚îú‚îÄ Master Key : Trimestrielle (90 jours)
‚îî‚îÄ Audit : Tous les acc√®s logg√©s

HIPAA :
‚îú‚îÄ Master Key : Annuelle minimum
‚îî‚îÄ Apr√®s tout incident de s√©curit√© : Imm√©diate

Best Practice :
‚îú‚îÄ Rotation planifi√©e : √âviter les rotations d'urgence
‚îú‚îÄ Tests : Tester la proc√©dure tous les 6 mois
‚îî‚îÄ Documentation : Maintenir √† jour apr√®s chaque rotation
```

## Conclusion

Le chiffrement au repos avec MongoDB Enterprise offre une protection robuste contre l'acc√®s non autoris√© aux donn√©es stock√©es sur disque. Points cl√©s √† retenir :

1. **KMIP est obligatoire pour la production** - Ne jamais utiliser local keyfile
2. **Hi√©rarchie des cl√©s** - Master Key (KMS) ‚Üí Database Keys ‚Üí Data
3. **Performance** - Impact de 10-20%, optimisable avec AES-NI et cache appropri√©
4. **Alternatives** - EBS/Azure encryption pour simplicit√©, LUKS pour MongoDB Community
5. **Backups critiques** - Master Key ET donn√©es doivent √™tre sauvegard√©es s√©par√©ment
6. **Rotation r√©guli√®re** - Conformit√© et s√©curit√© exigent des rotations planifi√©es

Le chiffrement au repos est une couche essentielle mais **ne remplace pas** :
- TLS/SSL pour le chiffrement en transit
- CSFLE pour prot√©ger contre les administrateurs malveillants
- Une strat√©gie de s√©curit√© globale (RBAC, audit, monitoring)

Pour une protection maximale, combinez encryption at rest + TLS + CSFLE + contr√¥les d'acc√®s stricts.

---

**Prochaine section** : 11.5.3 Client-Side Field Level Encryption (CSFLE) pour le chiffrement au niveau des champs avec protection contre les administrateurs.

‚è≠Ô∏è [Client-Side Field Level Encryption (CSFLE)](/11-securite/05.3-csfle.md)
