üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.1 Chiffrement en transit (TLS/SSL)

## Introduction

Le chiffrement en transit prot√®ge les donn√©es pendant leur transmission sur le r√©seau entre les diff√©rents composants d'une infrastructure MongoDB. Sans cette protection, un attaquant ayant acc√®s au r√©seau peut intercepter et lire toutes les communications, incluant les identifiants d'authentification, les requ√™tes et les donn√©es sensibles.

TLS (Transport Layer Security), successeur de SSL (Secure Sockets Layer), est le protocole standard de l'industrie pour s√©curiser les communications r√©seau. MongoDB supporte TLS depuis sa version 2.4, avec des am√©liorations continues dans chaque version majeure.

## Flux de communications √† s√©curiser

### Architecture standalone

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         TLS/SSL          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client     ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ñ∂‚îÇ   mongod     ‚îÇ
‚îÇ Application  ‚îÇ    Chiffrement requis    ‚îÇ  (Standalone)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Architecture Replica Set

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         TLS/SSL          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client     ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ñ∂‚îÇ   Primary    ‚îÇ
‚îÇ Application  ‚îÇ                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
                                                 ‚îÇ Replication
                                                 ‚îÇ (TLS requis)
                                                 ‚ñº
                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ  Secondary 1 ‚îÇ  Secondary 2 ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Architecture Sharded Cluster

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         TLS/SSL
‚îÇ   Client     ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ñ∂ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Application  ‚îÇ                           ‚îÇ    mongos    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                  ‚îÇ
                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                              ‚ñº TLS               ‚ñº TLS               ‚ñº TLS
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Shard 1    ‚îÇ    ‚îÇ   Shard 2    ‚îÇ    ‚îÇ Config Srv   ‚îÇ
                    ‚îÇ (Replica Set)‚îÇ    ‚îÇ (Replica Set)‚îÇ    ‚îÇ (Replica Set)‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Tous ces flux doivent √™tre chiffr√©s en production.**

## Concepts fondamentaux de TLS

### Handshake TLS

Le processus d'√©tablissement d'une connexion s√©curis√©e :

```
Client                                              Serveur
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ ClientHello (versions TLS, cipher suites) ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ ServerHello (version choisie, cipher) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ Certificate (certificat serveur) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ ServerHelloDone ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ ClientKeyExchange ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ ChangeCipherSpec ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ Finished ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ ChangeCipherSpec ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ Finished ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
  ‚îÇ                                                    ‚îÇ
  ‚îÇ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Application Data (chiffr√©e) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÇ
```

**Dur√©e typique** : 1-2 RTT (Round-Trip Time), soit 2-20ms selon la latence r√©seau.

### Cha√Æne de certificats

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Root CA (Certificate Authority)                    ‚îÇ
‚îÇ  ‚Ä¢ Auto-sign√©e                                      ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e de vie : 10-20 ans                         ‚îÇ
‚îÇ  ‚Ä¢ Stock√©e offline (coffre-fort)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ signe
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Intermediate CA                                    ‚îÇ
‚îÇ  ‚Ä¢ Sign√©e par Root CA                               ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e de vie : 5-10 ans                          ‚îÇ
‚îÇ  ‚Ä¢ Utilis√©e pour signer les certificats serveur     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ signe
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Server Certificate (Leaf Certificate)              ‚îÇ
‚îÇ  ‚Ä¢ CN=mongodb.production.company.com                ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e de vie : 1 an (recommand√©)                 ‚îÇ
‚îÇ  ‚Ä¢ Utilis√© par mongod/mongos                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Composants d'un certificat X.509

```
Subject (Identit√©)
‚îú‚îÄ CN (Common Name) : mongodb01.prod.company.com
‚îú‚îÄ O (Organization) : Company Inc.
‚îú‚îÄ OU (Organizational Unit) : IT Department
‚îú‚îÄ L (Locality) : Paris
‚îú‚îÄ ST (State) : √éle-de-France
‚îî‚îÄ C (Country) : FR

Issuer (√âmetteur)
‚îî‚îÄ CN : Company Intermediate CA

Validity
‚îú‚îÄ Not Before : 2024-01-01 00:00:00 UTC
‚îî‚îÄ Not After : 2025-01-01 23:59:59 UTC

Subject Alternative Name (SAN) - Critique pour MongoDB
‚îú‚îÄ DNS : mongodb01.prod.company.com
‚îú‚îÄ DNS : mongodb01
‚îú‚îÄ DNS : *.prod.company.com
‚îî‚îÄ IP : 10.0.1.10

Key Usage
‚îú‚îÄ Digital Signature
‚îú‚îÄ Key Encipherment
‚îî‚îÄ (Server Authentication)

Extended Key Usage
‚îú‚îÄ TLS Web Server Authentication
‚îî‚îÄ TLS Web Client Authentication (pour mTLS)
```

## G√©n√©ration des certificats

### Option 1 : OpenSSL (Auto-sign√© pour DEV/TEST uniquement)

#### √âtape 1 : Cr√©er une CA racine

```bash
#!/bin/bash
# create-mongodb-ca.sh

# Cr√©er le r√©pertoire de travail
mkdir -p /tmp/mongodb-ssl-ca
cd /tmp/mongodb-ssl-ca

# 1. G√©n√©rer la cl√© priv√©e de la CA (4096 bits pour s√©curit√© renforc√©e)
openssl genrsa -aes256 -out ca-key.pem 4096
# Entrer un mot de passe fort et le sauvegarder

# 2. G√©n√©rer le certificat auto-sign√© de la CA (valide 10 ans)
openssl req -new -x509 -days 3650 -key ca-key.pem -out ca-cert.pem \
  -subj "/C=FR/ST=Ile-de-France/L=Paris/O=Company Inc/OU=IT/CN=Company MongoDB CA"

# 3. V√©rifier le certificat
openssl x509 -in ca-cert.pem -text -noout
```

#### √âtape 2 : Cr√©er un certificat serveur

```bash
#!/bin/bash
# create-server-cert.sh

HOSTNAME="mongodb01.prod.company.com"
INTERNAL_IP="10.0.1.10"

# 1. G√©n√©rer la cl√© priv√©e du serveur
openssl genrsa -out server-key.pem 2048

# 2. Cr√©er une demande de signature de certificat (CSR)
openssl req -new -key server-key.pem -out server-csr.pem \
  -subj "/C=FR/ST=Ile-de-France/L=Paris/O=Company Inc/OU=IT/CN=${HOSTNAME}"

# 3. Cr√©er le fichier de configuration pour les SANs
cat > san.cnf <<EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = FR
ST = Ile-de-France
L = Paris
O = Company Inc
OU = IT
CN = ${HOSTNAME}

[v3_req]
keyUsage = keyEncipherment, dataEncipherment, digitalSignature
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = ${HOSTNAME}
DNS.2 = mongodb01
DNS.3 = localhost
IP.1 = ${INTERNAL_IP}
IP.2 = 127.0.0.1
EOF

# 4. Signer le CSR avec la CA (valide 1 an)
openssl x509 -req -in server-csr.pem \
  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \
  -out server-cert.pem -days 365 \
  -extensions v3_req -extfile san.cnf

# 5. V√©rifier le certificat g√©n√©r√©
openssl x509 -in server-cert.pem -text -noout | grep -A 1 "Subject Alternative Name"

# 6. Cr√©er le fichier PEM combin√© (MongoDB n√©cessite cl√© + cert dans un fichier)
cat server-key.pem server-cert.pem > server-combined.pem

# 7. D√©finir les permissions appropri√©es
chmod 400 server-key.pem server-combined.pem
chmod 444 server-cert.pem ca-cert.pem

echo "Certificat serveur cr√©√© : server-combined.pem"
echo "CA certificate : ca-cert.pem"
```

#### √âtape 3 : Cr√©er un certificat client (pour mTLS)

```bash
#!/bin/bash
# create-client-cert.sh

CLIENT_NAME="app-backend"

# 1. G√©n√©rer la cl√© priv√©e du client
openssl genrsa -out client-key.pem 2048

# 2. Cr√©er le CSR pour le client
openssl req -new -key client-key.pem -out client-csr.pem \
  -subj "/C=FR/ST=Ile-de-France/L=Paris/O=Company Inc/OU=Applications/CN=${CLIENT_NAME}"

# 3. Configuration pour certificat client
cat > client-san.cnf <<EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = FR
ST = Ile-de-France
L = Paris
O = Company Inc
OU = Applications
CN = ${CLIENT_NAME}

[v3_req]
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
EOF

# 4. Signer le certificat client
openssl x509 -req -in client-csr.pem \
  -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial \
  -out client-cert.pem -days 365 \
  -extensions v3_req -extfile client-san.cnf

# 5. Cr√©er le fichier PEM combin√© pour le client
cat client-key.pem client-cert.pem > client-combined.pem

chmod 400 client-key.pem client-combined.pem
chmod 444 client-cert.pem

echo "Certificat client cr√©√© : client-combined.pem"
```

### Option 2 : Let's Encrypt (pour environnements publics)

**‚ö†Ô∏è Limitations** :
- Certificats valides 90 jours (renouvellement fr√©quent)
- Requiert que le serveur soit accessible depuis Internet
- Rate limits (50 certificats/domaine/semaine)
- Pas adapt√© pour les r√©seaux priv√©s

```bash
#!/bin/bash
# letsencrypt-mongodb.sh

# Installation de certbot
apt-get update
apt-get install -y certbot

# G√©n√©ration du certificat (mode standalone)
# MongoDB doit √™tre arr√™t√© temporairement ou utiliser un port diff√©rent
certbot certonly --standalone \
  --non-interactive \
  --agree-tos \
  --email admin@company.com \
  -d mongodb.company.com

# Certificats g√©n√©r√©s dans :
# /etc/letsencrypt/live/mongodb.company.com/

# Cr√©er le fichier combin√© pour MongoDB
cat /etc/letsencrypt/live/mongodb.company.com/privkey.pem \
    /etc/letsencrypt/live/mongodb.company.com/cert.pem \
    > /etc/ssl/mongodb/mongodb-letsencrypt.pem

chmod 400 /etc/ssl/mongodb/mongodb-letsencrypt.pem

# Configuration du renouvellement automatique
cat > /etc/cron.daily/mongodb-cert-renew <<'EOF'
#!/bin/bash
certbot renew --quiet --deploy-hook "systemctl restart mongod"
EOF

chmod +x /etc/cron.daily/mongodb-cert-renew
```

### Option 3 : CA d'entreprise (Production recommand√©e)

Utiliser une PKI (Public Key Infrastructure) d'entreprise :

**Avantages** :
- Conformit√© avec les politiques de s√©curit√©
- Int√©gration avec les syst√®mes existants
- Rotation centralis√©e
- Audit et tra√ßabilit√©

**Solutions courantes** :
- Microsoft Active Directory Certificate Services (AD CS)
- HashiCorp Vault PKI
- AWS Certificate Manager Private CA
- Smallstep CA
- Venafi

#### Exemple avec HashiCorp Vault

```bash
#!/bin/bash
# vault-mongodb-cert.sh

# Assumer que Vault est configur√© avec PKI

# 1. Activer le PKI engine
vault secrets enable pki
vault secrets tune -max-lease-ttl=87600h pki

# 2. G√©n√©rer le certificat racine
vault write pki/root/generate/internal \
  common_name="Company MongoDB CA" \
  ttl=87600h

# 3. Configurer les URLs
vault write pki/config/urls \
  issuing_certificates="https://vault.company.com:8200/v1/pki/ca" \
  crl_distribution_points="https://vault.company.com:8200/v1/pki/crl"

# 4. Cr√©er un r√¥le pour MongoDB
vault write pki/roles/mongodb \
  allowed_domains="prod.company.com" \
  allow_subdomains=true \
  max_ttl="8760h" \
  key_usage="DigitalSignature,KeyEncipherment" \
  ext_key_usage="ServerAuth,ClientAuth"

# 5. G√©n√©rer un certificat pour un serveur MongoDB
vault write pki/issue/mongodb \
  common_name="mongodb01.prod.company.com" \
  alt_names="mongodb01,localhost" \
  ip_sans="10.0.1.10,127.0.0.1" \
  ttl="8760h"

# Output : certificate, issuing_ca, private_key
# Assembler dans un fichier PEM
```

## Configuration de MongoDB avec TLS/SSL

### Mode 1 : allowTLS (Migration progressive)

Permet les connexions TLS et non-TLS simultan√©ment.

**‚ö†Ô∏è Usage** : Uniquement pour la p√©riode de migration. **Ne jamais utiliser en production stable.**

```yaml
# mongod.conf
net:
  port: 27017
  bindIp: 0.0.0.0
  tls:
    mode: allowTLS
    certificateKeyFile: /etc/ssl/mongodb/server-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
```

**Processus de migration** :

```bash
# Phase 1 : Activer allowTLS sur tous les serveurs
# Red√©marrer un par un (rolling restart)

# Phase 2 : Migrer les clients vers TLS
# Connexion avec TLS : mongodb://host:27017/?tls=true
# Connexion sans TLS : mongodb://host:27017/ (encore accept√©e)

# Phase 3 : V√©rifier que tous les clients utilisent TLS
db.serverStatus().connections
db.runCommand({ connectionStatus: 1 })

# Phase 4 : Passer en mode requireTLS
# Modifier mongod.conf : mode: requireTLS
# Rolling restart

# Phase 5 : Valider
# Tentative de connexion sans TLS doit √©chouer
```

### Mode 2 : preferTLS (Non recommand√©)

Le serveur pr√©f√®re TLS mais accepte les connexions non-TLS.

**‚ö†Ô∏è Ne pas utiliser en production.**

### Mode 3 : requireTLS (Production)

**Toutes** les connexions doivent utiliser TLS. Mode obligatoire pour la production.

```yaml
# mongod.conf - Configuration production
net:
  port: 27017
  bindIp: 10.0.1.10  # IP interne, pas 0.0.0.0
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/server-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    # Options de s√©curit√© renforc√©e
    allowConnectionsWithoutCertificates: false  # Exiger certificat client (mTLS)
    allowInvalidCertificates: false
    allowInvalidHostnames: false
    # D√©sactiver les protocoles faibles
    disabledProtocols: TLS1_0,TLS1_1
    # Limiter aux cipher suites modernes
    clusterAuthMode: x509  # Pour authentification inter-n≈ìuds

security:
  authorization: enabled
  clusterAuthMode: x509  # Important pour Replica Set/Sharding

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    network:
      verbosity: 1  # Logger les connexions TLS
```

### Configuration des cipher suites

MongoDB supporte la configuration des cipher suites pour un contr√¥le fin de la cryptographie.

```yaml
# mongod.conf - Cipher suites recommand√©es
net:
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/server-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    disabledProtocols: TLS1_0,TLS1_1
    # Ordre de pr√©f√©rence des cipher suites
    # Format OpenSSL cipher string
    cipherConfig: >-
      ECDHE-ECDSA-AES256-GCM-SHA384:
      ECDHE-RSA-AES256-GCM-SHA384:
      ECDHE-ECDSA-AES128-GCM-SHA256:
      ECDHE-RSA-AES128-GCM-SHA256
```

**Crit√®res de s√©lection** :

```
Priorit√© 1 : Forward Secrecy (ECDHE)
‚îú‚îÄ ECDHE : Elliptic Curve Diffie-Hellman Ephemeral
‚îî‚îÄ G√©n√®re une nouvelle cl√© de session pour chaque connexion

Priorit√© 2 : Algorithme de chiffrement moderne
‚îú‚îÄ AES-256-GCM ou AES-128-GCM (Galois/Counter Mode)
‚îú‚îÄ Meilleure performance que CBC
‚îî‚îÄ Protection contre padding oracle attacks

Priorit√© 3 : Fonction de hachage robuste
‚îú‚îÄ SHA384 ou SHA256
‚îî‚îÄ √âviter SHA1 (d√©pr√©ci√©e)

√Ä √âVITER :
‚úó RC4 (cass√©)
‚úó 3DES (faible)
‚úó MD5 (cass√©)
‚úó NULL (pas de chiffrement)
‚úó EXPORT (faible par design)
```

**V√©rification de la configuration** :

```bash
# Tester la connexion TLS avec OpenSSL
openssl s_client -connect mongodb.prod.company.com:27017 \
  -CAfile /etc/ssl/mongodb/ca-cert.pem \
  -showcerts \
  -state

# Output important :
# SSL-Session:
#     Protocol  : TLSv1.3
#     Cipher    : TLS_AES_256_GCM_SHA384
#     Session-ID: ...
#     Master-Key: ...
#     Start Time: ...
#     Timeout   : ...
#     Verify return code: 0 (ok)
```

## Configuration par architecture

### Replica Set avec TLS

#### Configuration des membres

Chaque membre du Replica Set doit avoir :
1. Son propre certificat serveur (CN diff√©rent)
2. Acc√®s √† la CA commune
3. Configuration identique du mode TLS

**mongod.conf pour Primary (mongodb-rs1-01.prod.company.com)** :

```yaml
# /etc/mongod-rs1-01.conf
net:
  port: 27017
  bindIp: 10.0.1.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/rs1-01-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    allowInvalidHostnames: false
    clusterFile: /etc/ssl/mongodb/rs1-01-combined.pem  # M√™me fichier pour cluster auth
    clusterCAFile: /etc/ssl/mongodb/ca-cert.pem

security:
  authorization: enabled
  clusterAuthMode: x509

replication:
  replSetName: rs1

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-rs1-01.log
  logAppend: true
```

**mongod.conf pour Secondary 1 (mongodb-rs1-02.prod.company.com)** :

```yaml
# /etc/mongod-rs1-02.conf
net:
  port: 27017
  bindIp: 10.0.1.11
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/rs1-02-combined.pem  # Diff√©rent
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    allowInvalidHostnames: false
    clusterFile: /etc/ssl/mongodb/rs1-02-combined.pem
    clusterCAFile: /etc/ssl/mongodb/ca-cert.pem

security:
  authorization: enabled
  clusterAuthMode: x509

replication:
  replSetName: rs1

systemLog:
  destination: file
  path: /var/log/mongodb/mongod-rs1-02.log
  logAppend: true
```

#### Initialisation du Replica Set avec TLS

```javascript
// Connexion au Primary avec TLS
mongosh "mongodb://10.0.1.10:27017/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/admin-client.pem"

// Initialiser le Replica Set
rs.initiate({
  _id: "rs1",
  members: [
    {
      _id: 0,
      host: "mongodb-rs1-01.prod.company.com:27017",
      priority: 2  // Primary pr√©f√©r√©
    },
    {
      _id: 1,
      host: "mongodb-rs1-02.prod.company.com:27017",
      priority: 1
    },
    {
      _id: 2,
      host: "mongodb-rs1-03.prod.company.com:27017",
      priority: 1
    }
  ]
})

// V√©rifier le statut
rs.status()

// V√©rifier que tous les membres utilisent TLS
db.serverStatus().connections
```

#### Cr√©ation d'utilisateurs avec authentification x509

```javascript
// Cr√©er un utilisateur admin avec authentification x509
use $external
db.runCommand({
  createUser: "CN=admin,OU=IT,O=Company Inc,L=Paris,ST=Ile-de-France,C=FR",
  roles: [
    { role: "root", db: "admin" }
  ]
})

// Cr√©er un utilisateur applicatif
db.runCommand({
  createUser: "CN=app-backend,OU=Applications,O=Company Inc,L=Paris,ST=Ile-de-France,C=FR",
  roles: [
    { role: "readWrite", db: "production" }
  ]
})

// Connexion avec certificat client
mongosh "mongodb://mongodb-rs1-01.prod.company.com:27017/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/app-client.pem&authMechanism=MONGODB-X509&authSource=$external"
```

### Sharded Cluster avec TLS

Architecture compl√®te avec TLS sur tous les composants.

#### 1. Config Servers (Replica Set)

```yaml
# /etc/mongod-config-01.conf
sharding:
  clusterRole: configsvr

replication:
  replSetName: configRS

net:
  port: 27019
  bindIp: 10.0.2.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/config-01-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    clusterFile: /etc/ssl/mongodb/config-01-combined.pem
    clusterCAFile: /etc/ssl/mongodb/ca-cert.pem

security:
  authorization: enabled
  clusterAuthMode: x509
```

#### 2. Shards (Replica Sets)

```yaml
# /etc/mongod-shard1-01.conf
sharding:
  clusterRole: shardsvr

replication:
  replSetName: shard1RS

net:
  port: 27018
  bindIp: 10.0.3.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/shard1-01-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    clusterFile: /etc/ssl/mongodb/shard1-01-combined.pem
    clusterCAFile: /etc/ssl/mongodb/ca-cert.pem

security:
  authorization: enabled
  clusterAuthMode: x509
```

#### 3. Mongos (Query Router)

```yaml
# /etc/mongos.conf
sharding:
  configDB: configRS/config-01.prod.company.com:27019,config-02.prod.company.com:27019,config-03.prod.company.com:27019

net:
  port: 27017
  bindIp: 10.0.4.10
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/mongos-01-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    clusterFile: /etc/ssl/mongodb/mongos-01-combined.pem
    clusterCAFile: /etc/ssl/mongodb/ca-cert.pem

security:
  clusterAuthMode: x509

systemLog:
  destination: file
  path: /var/log/mongodb/mongos-01.log
  logAppend: true
```

#### D√©marrage du cluster shard√©

```bash
#!/bin/bash
# deploy-sharded-cluster-tls.sh

# 1. D√©marrer les Config Servers
mongod -f /etc/mongod-config-01.conf
mongod -f /etc/mongod-config-02.conf
mongod -f /etc/mongod-config-03.conf

# 2. Initialiser le Replica Set des Config Servers
mongosh "mongodb://10.0.2.10:27019/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/admin-client.pem" --eval '
rs.initiate({
  _id: "configRS",
  configsvr: true,
  members: [
    { _id: 0, host: "config-01.prod.company.com:27019" },
    { _id: 1, host: "config-02.prod.company.com:27019" },
    { _id: 2, host: "config-03.prod.company.com:27019" }
  ]
})
'

# 3. D√©marrer les Shards
mongod -f /etc/mongod-shard1-01.conf
mongod -f /etc/mongod-shard1-02.conf
mongod -f /etc/mongod-shard1-03.conf

# 4. Initialiser les Replica Sets des Shards
mongosh "mongodb://10.0.3.10:27018/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/admin-client.pem" --eval '
rs.initiate({
  _id: "shard1RS",
  members: [
    { _id: 0, host: "shard1-01.prod.company.com:27018" },
    { _id: 1, host: "shard1-02.prod.company.com:27018" },
    { _id: 2, host: "shard1-03.prod.company.com:27018" }
  ]
})
'

# 5. D√©marrer mongos
mongos -f /etc/mongos.conf

# 6. Ajouter les shards au cluster
mongosh "mongodb://10.0.4.10:27017/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/admin-client.pem" --eval '
sh.addShard("shard1RS/shard1-01.prod.company.com:27018")
sh.addShard("shard2RS/shard2-01.prod.company.com:27018")
'

# 7. V√©rifier le statut
mongosh "mongodb://10.0.4.10:27017/?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/admin-client.pem" --eval 'sh.status()'
```

## Mutual TLS (mTLS) - Authentification bidirectionnelle

Le mTLS ajoute une couche de s√©curit√© en exigeant que **le client** prouve √©galement son identit√© avec un certificat.

### Cas d'usage

- Environnements zero-trust
- Microservices communication
- Conformit√© r√©glementaire stricte (secteur bancaire, sant√©)
- Pr√©vention des attaques de clients non autoris√©s

### Configuration serveur pour mTLS

```yaml
# mongod.conf
net:
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb/server-combined.pem
    CAFile: /etc/ssl/mongodb/ca-cert.pem
    # Exiger un certificat client valide
    allowConnectionsWithoutCertificates: false  # ‚Üê Cl√© pour mTLS
    # Valider strictement le certificat client
    allowInvalidCertificates: false
    allowInvalidHostnames: false

security:
  authorization: enabled
  # Mapping du DN du certificat aux utilisateurs MongoDB
  clusterAuthMode: x509
```

### Connexion client avec mTLS

```bash
# Connexion mongosh avec certificat client
mongosh "mongodb://mongodb.prod.company.com:27017/admin?tls=true&tlsCAFile=/etc/ssl/mongodb/ca-cert.pem&tlsCertificateKeyFile=/etc/ssl/mongodb/client-combined.pem&authMechanism=MONGODB-X509&authSource=\$external"

# Connection string format d√©taill√©
mongodb://mongodb.prod.company.com:27017/admin?
  tls=true
  &tlsCAFile=/etc/ssl/mongodb/ca-cert.pem
  &tlsCertificateKeyFile=/etc/ssl/mongodb/client-combined.pem
  &authMechanism=MONGODB-X509
  &authSource=$external
```

### Exemples de code applicatif avec mTLS

#### Node.js (Driver officiel)

```javascript
const { MongoClient } = require('mongodb');
const fs = require('fs');

const client = new MongoClient('mongodb://mongodb.prod.company.com:27017', {
  tls: true,
  tlsCAFile: '/etc/ssl/mongodb/ca-cert.pem',
  tlsCertificateKeyFile: '/etc/ssl/mongodb/app-client-combined.pem',
  authMechanism: 'MONGODB-X509',
  authSource: '$external',
  // Options suppl√©mentaires
  tlsAllowInvalidCertificates: false,
  tlsAllowInvalidHostnames: false,
  serverSelectionTimeoutMS: 5000
});

async function connect() {
  try {
    await client.connect();
    console.log('Connected successfully with mTLS');

    const db = client.db('production');
    const collection = db.collection('users');

    const doc = await collection.findOne({});
    console.log(doc);
  } catch (err) {
    console.error('Connection error:', err);
  } finally {
    await client.close();
  }
}

connect();
```

#### Python (PyMongo)

```python
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure

client = MongoClient(
    'mongodb.prod.company.com',
    27017,
    tls=True,
    tlsCAFile='/etc/ssl/mongodb/ca-cert.pem',
    tlsCertificateKeyFile='/etc/ssl/mongodb/app-client-combined.pem',
    authMechanism='MONGODB-X509',
    authSource='$external',
    tlsAllowInvalidCertificates=False,
    tlsAllowInvalidHostnames=False,
    serverSelectionTimeoutMS=5000
)

try:
    # Test de connexion
    client.admin.command('ping')
    print("Connected successfully with mTLS")

    db = client['production']
    collection = db['users']

    doc = collection.find_one()
    print(doc)

except ConnectionFailure as e:
    print(f"Connection failed: {e}")
finally:
    client.close()
```

#### Java (Driver officiel)

```java
import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoDatabase;

import javax.net.ssl.SSLContext;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.security.KeyStore;

public class MongoDBmTLSExample {
    public static void main(String[] args) throws Exception {
        // Charger le truststore (CA)
        KeyStore trustStore = KeyStore.getInstance("JKS");
        trustStore.load(
            new FileInputStream("/etc/ssl/mongodb/truststore.jks"),
            "changeit".toCharArray()
        );
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm()
        );
        tmf.init(trustStore);

        // Charger le keystore (certificat client)
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        keyStore.load(
            new FileInputStream("/etc/ssl/mongodb/client.p12"),
            "changeit".toCharArray()
        );
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm()
        );
        kmf.init(keyStore, "changeit".toCharArray());

        // Cr√©er le SSLContext
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

        // Configuration du client MongoDB
        MongoClientSettings settings = MongoClientSettings.builder()
            .applyConnectionString(
                new ConnectionString("mongodb://mongodb.prod.company.com:27017/?authMechanism=MONGODB-X509&authSource=$external")
            )
            .applyToSslSettings(builder ->
                builder.enabled(true)
                       .context(sslContext)
                       .invalidHostNameAllowed(false)
            )
            .build();

        try (MongoClient mongoClient = MongoClients.create(settings)) {
            MongoDatabase database = mongoClient.getDatabase("production");
            System.out.println("Connected successfully with mTLS");

            // Op√©rations sur la base de donn√©es...
        }
    }
}
```

#### Go (Driver officiel)

```go
package main

import (
    "context"
    "crypto/tls"
    "crypto/x509"
    "fmt"
    "io/ioutil"
    "log"
    "time"

    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    // Charger le certificat CA
    caCert, err := ioutil.ReadFile("/etc/ssl/mongodb/ca-cert.pem")
    if err != nil {
        log.Fatal(err)
    }
    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    // Charger le certificat client
    clientCert, err := tls.LoadX509KeyPair(
        "/etc/ssl/mongodb/client-cert.pem",
        "/etc/ssl/mongodb/client-key.pem",
    )
    if err != nil {
        log.Fatal(err)
    }

    // Configuration TLS
    tlsConfig := &tls.Config{
        RootCAs:            caCertPool,
        Certificates:       []tls.Certificate{clientCert},
        InsecureSkipVerify: false,
    }

    // Options du client MongoDB
    clientOpts := options.Client().
        ApplyURI("mongodb://mongodb.prod.company.com:27017/?authMechanism=MONGODB-X509&authSource=$external").
        SetTLSConfig(tlsConfig).
        SetServerSelectionTimeout(5 * time.Second)

    // Connexion
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    client, err := mongo.Connect(ctx, clientOpts)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect(ctx)

    // Test de connexion
    err = client.Ping(ctx, nil)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Connected successfully with mTLS")

    // Op√©rations sur la base de donn√©es...
    collection := client.Database("production").Collection("users")
    var result map[string]interface{}
    err = collection.FindOne(ctx, map[string]interface{}{}).Decode(&result)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(result)
}
```

## Troubleshooting TLS/SSL

### Erreurs courantes et r√©solutions

#### 1. "SSL routines:tls_process_server_certificate:certificate verify failed"

**Cause** : Le certificat serveur ne peut pas √™tre v√©rifi√© par le client.

**Diagnostics** :

```bash
# V√©rifier la cha√Æne de certificats
openssl s_client -connect mongodb.prod.company.com:27017 \
  -CAfile /etc/ssl/mongodb/ca-cert.pem \
  -showcerts

# V√©rifier les dates de validit√©
openssl x509 -in /etc/ssl/mongodb/server-cert.pem -noout -dates

# V√©rifier le CN et les SANs
openssl x509 -in /etc/ssl/mongodb/server-cert.pem -noout -text | grep -A 1 "Subject:"
openssl x509 -in /etc/ssl/mongodb/server-cert.pem -noout -text | grep -A 1 "Subject Alternative Name"
```

**Solutions** :

```bash
# 1. V√©rifier que la CA est correcte
# 2. V√©rifier que le certificat n'est pas expir√©
# 3. R√©g√©n√©rer le certificat si n√©cessaire

# 4. Temporairement (DEV uniquement) : d√©sactiver la validation
mongosh "mongodb://host:27017/?tls=true&tlsAllowInvalidCertificates=true"
```

#### 2. "Hostname/IP does not match certificate's altnames"

**Cause** : Le hostname utilis√© pour la connexion ne correspond pas au CN ou aux SANs du certificat.

**Diagnostics** :

```bash
# V√©rifier les SANs du certificat
openssl x509 -in /etc/ssl/mongodb/server-cert.pem -noout -text | grep -A 1 "Subject Alternative Name"

# Output attendu :
# X509v3 Subject Alternative Name:
#     DNS:mongodb01.prod.company.com, DNS:mongodb01, IP Address:10.0.1.10
```

**Solutions** :

1. R√©g√©n√©rer le certificat avec les bons SANs
2. Utiliser le hostname qui correspond au certificat
3. Ajouter le hostname au fichier `/etc/hosts` si n√©cessaire

```bash
# /etc/hosts
10.0.1.10    mongodb01.prod.company.com mongodb01
```

#### 3. "Connection refused" avec TLS

**Cause** : Le serveur n'√©coute pas avec TLS ou le port est bloqu√©.

**Diagnostics** :

```bash
# V√©rifier que MongoDB √©coute
netstat -tlnp | grep :27017

# Tester la connexion TCP
telnet mongodb.prod.company.com 27017

# V√©rifier le handshake TLS
openssl s_client -connect mongodb.prod.company.com:27017

# V√©rifier les logs MongoDB
tail -f /var/log/mongodb/mongod.log | grep -i tls
```

**Solutions** :

```bash
# V√©rifier la configuration
grep -A 10 "^net:" /etc/mongod.conf

# S'assurer que le mode TLS est activ√©
# net:
#   tls:
#     mode: requireTLS

# Red√©marrer MongoDB
systemctl restart mongod
```

#### 4. "No client certificate provided"

**Cause** : mTLS est activ√© mais le client ne fournit pas de certificat.

**Solution** :

```bash
# Fournir le certificat client
mongosh "mongodb://host:27017/?tls=true&tlsCAFile=/path/to/ca.pem&tlsCertificateKeyFile=/path/to/client.pem"
```

#### 5. "Certificate chain verification failed"

**Cause** : La cha√Æne de certificats est incompl√®te.

**Solution** :

```bash
# Le fichier server-combined.pem doit contenir dans l'ordre :
# 1. Cl√© priv√©e du serveur
# 2. Certificat du serveur
# 3. Certificat(s) interm√©diaire(s)
# 4. (Optionnel) Certificat racine

cat server-key.pem server-cert.pem intermediate-ca.pem > server-combined.pem
```

#### 6. Performances d√©grad√©es apr√®s activation de TLS

**Diagnostics** :

```bash
# V√©rifier que AES-NI est support√© et utilis√©
lscpu | grep aes
openssl speed aes-256-gcm

# V√©rifier la cipher suite n√©goci√©e
openssl s_client -connect mongodb.prod.company.com:27017 | grep "Cipher"

# Monitorer la charge CPU
top -p $(pgrep mongod)
```

**Solutions** :

1. Utiliser des cipher suites avec AES-GCM
2. Augmenter les ressources CPU
3. Activer le connection pooling c√¥t√© client
4. Consid√©rer TLS session resumption

### Outils de diagnostic

#### Script de validation TLS complet

```bash
#!/bin/bash
# mongodb-tls-check.sh

MONGO_HOST="mongodb.prod.company.com"
MONGO_PORT="27017"
CA_FILE="/etc/ssl/mongodb/ca-cert.pem"
SERVER_CERT="/etc/ssl/mongodb/server-combined.pem"

echo "=== MongoDB TLS Validation ==="
echo

# 1. Test de connectivit√©
echo "1. Testing connectivity..."
if nc -zv $MONGO_HOST $MONGO_PORT 2>&1 | grep -q succeeded; then
    echo "‚úì Port $MONGO_PORT is open"
else
    echo "‚úó Cannot connect to port $MONGO_PORT"
    exit 1
fi
echo

# 2. Test TLS handshake
echo "2. Testing TLS handshake..."
if echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT -CAfile $CA_FILE 2>&1 | grep -q "Verify return code: 0"; then
    echo "‚úì TLS handshake successful"
else
    echo "‚úó TLS handshake failed"
    echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT -CAfile $CA_FILE 2>&1 | grep "Verify return code"
fi
echo

# 3. V√©rifier le protocole TLS
echo "3. Checking TLS protocol..."
PROTOCOL=$(echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT 2>&1 | grep "Protocol" | awk '{print $3}')
echo "Protocol: $PROTOCOL"
if [[ "$PROTOCOL" =~ "TLSv1.2" ]] || [[ "$PROTOCOL" =~ "TLSv1.3" ]]; then
    echo "‚úì Using secure TLS version"
else
    echo "‚ö† Warning: Using outdated TLS version"
fi
echo

# 4. V√©rifier la cipher suite
echo "4. Checking cipher suite..."
CIPHER=$(echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT 2>&1 | grep "Cipher" | awk -F: '{print $2}' | tr -d ' ')
echo "Cipher: $CIPHER"
if [[ "$CIPHER" =~ "GCM" ]] && [[ "$CIPHER" =~ "ECDHE" ]]; then
    echo "‚úì Using strong cipher with Forward Secrecy"
else
    echo "‚ö† Warning: Cipher could be improved"
fi
echo

# 5. V√©rifier le certificat serveur
echo "5. Checking server certificate..."
EXPIRY=$(echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT 2>&1 | openssl x509 -noout -enddate | cut -d= -f2)
EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s)
NOW_EPOCH=$(date +%s)
DAYS_LEFT=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))

echo "Certificate expires: $EXPIRY"
echo "Days until expiration: $DAYS_LEFT"

if [ $DAYS_LEFT -gt 30 ]; then
    echo "‚úì Certificate is valid"
elif [ $DAYS_LEFT -gt 0 ]; then
    echo "‚ö† Warning: Certificate expires soon"
else
    echo "‚úó Certificate is expired!"
fi
echo

# 6. V√©rifier les SANs
echo "6. Checking Subject Alternative Names..."
echo "Q" | openssl s_client -connect $MONGO_HOST:$MONGO_PORT 2>&1 | \
  openssl x509 -noout -text | \
  grep -A 1 "Subject Alternative Name"
echo

# 7. Test de connexion MongoDB
echo "7. Testing MongoDB connection with TLS..."
if mongosh "mongodb://$MONGO_HOST:$MONGO_PORT/?tls=true&tlsCAFile=$CA_FILE" \
  --eval "db.adminCommand('ping')" 2>&1 | grep -q "ok: 1"; then
    echo "‚úì MongoDB connection successful"
else
    echo "‚úó MongoDB connection failed"
fi
echo

echo "=== Validation Complete ==="
```

## Bonnes pratiques de production

### 1. Gestion des certificats

```bash
# Structure des r√©pertoires recommand√©e
/etc/ssl/mongodb/
‚îú‚îÄ‚îÄ ca/
‚îÇ   ‚îú‚îÄ‚îÄ ca-cert.pem          # Certificat CA (lisible par tous)
‚îÇ   ‚îî‚îÄ‚îÄ ca-key.pem           # Cl√© CA (offline, backup s√©curis√©)
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ mongodb01-combined.pem  # Certificat + cl√© serveur
‚îÇ   ‚îú‚îÄ‚îÄ mongodb02-combined.pem
‚îÇ   ‚îî‚îÄ‚îÄ mongodb03-combined.pem
‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îú‚îÄ‚îÄ admin-combined.pem      # Certificat admin
‚îÇ   ‚îî‚îÄ‚îÄ app-backend-combined.pem
‚îî‚îÄ‚îÄ archive/
    ‚îî‚îÄ‚îÄ expired/
        ‚îî‚îÄ‚îÄ old-certificates/

# Permissions appropri√©es
chmod 400 /etc/ssl/mongodb/server/*.pem
chmod 400 /etc/ssl/mongodb/client/*.pem
chmod 444 /etc/ssl/mongodb/ca/ca-cert.pem
chown mongodb:mongodb /etc/ssl/mongodb/server/*.pem
```

### 2. Rotation automatis√©e des certificats

```bash
#!/bin/bash
# rotate-mongodb-cert.sh

CERT_FILE="/etc/ssl/mongodb/server/mongodb01-combined.pem"
NEW_CERT="/tmp/mongodb01-new-combined.pem"
DAYS_BEFORE_EXPIRY=30

# V√©rifier l'expiration
EXPIRY=$(openssl x509 -in $CERT_FILE -noout -enddate | cut -d= -f2)
EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s)
NOW_EPOCH=$(date +%s)
DAYS_LEFT=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))

if [ $DAYS_LEFT -gt $DAYS_BEFORE_EXPIRY ]; then
    echo "Certificate still valid for $DAYS_LEFT days. No rotation needed."
    exit 0
fi

echo "Certificate expires in $DAYS_LEFT days. Starting rotation..."

# 1. G√©n√©rer un nouveau certificat
# (via votre PKI / Vault / Let's Encrypt)
# vault write pki/issue/mongodb common_name="mongodb01.prod.company.com" ...

# 2. Valider le nouveau certificat
if ! openssl x509 -in $NEW_CERT -noout -checkend 0; then
    echo "ERROR: New certificate is invalid"
    exit 1
fi

# 3. Backup de l'ancien certificat
cp $CERT_FILE /etc/ssl/mongodb/archive/mongodb01-$(date +%Y%m%d).pem

# 4. Installer le nouveau certificat
cp $NEW_CERT $CERT_FILE
chmod 400 $CERT_FILE
chown mongodb:mongodb $CERT_FILE

# 5. Recharger MongoDB (sans downtime avec Replica Set)
systemctl reload mongod

# 6. V√©rifier que MongoDB utilise le nouveau certificat
sleep 5
if systemctl is-active --quiet mongod; then
    echo "‚úì Certificate rotated successfully"
else
    echo "‚úó MongoDB failed to restart"
    # Rollback
    cp /etc/ssl/mongodb/archive/mongodb01-$(date +%Y%m%d).pem $CERT_FILE
    systemctl restart mongod
    exit 1
fi
```

### 3. Monitoring des certificats

```python
#!/usr/bin/env python3
# monitor-mongodb-certs.py

import OpenSSL
import datetime
import sys

def check_certificate(cert_file, warning_days=30, critical_days=7):
    """V√©rifie l'expiration d'un certificat"""
    try:
        with open(cert_file, 'r') as f:
            cert_data = f.read()

        cert = OpenSSL.crypto.load_certificate(
            OpenSSL.crypto.FILETYPE_PEM,
            cert_data
        )

        # Date d'expiration
        expiry_date = datetime.datetime.strptime(
            cert.get_notAfter().decode('ascii'),
            '%Y%m%d%H%M%SZ'
        )

        # Jours restants
        days_left = (expiry_date - datetime.datetime.now()).days

        # Statut
        if days_left < 0:
            status = "CRITICAL"
            message = f"EXPIRED {abs(days_left)} days ago"
            exit_code = 2
        elif days_left < critical_days:
            status = "CRITICAL"
            message = f"Expires in {days_left} days"
            exit_code = 2
        elif days_left < warning_days:
            status = "WARNING"
            message = f"Expires in {days_left} days"
            exit_code = 1
        else:
            status = "OK"
            message = f"Valid for {days_left} days"
            exit_code = 0

        # CN du certificat
        subject = cert.get_subject()
        cn = subject.CN

        print(f"{status}: Certificate for {cn} - {message}")
        return exit_code

    except Exception as e:
        print(f"ERROR: Failed to check certificate: {str(e)}")
        return 3

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: monitor-mongodb-certs.py <certificate_file>")
        sys.exit(3)

    cert_file = sys.argv[1]
    exit_code = check_certificate(cert_file)
    sys.exit(exit_code)
```

### 4. Checklist de d√©ploiement TLS

```
‚òê G√©n√©ration des certificats
  ‚òê CA root cr√©√©e et s√©curis√©e (offline backup)
  ‚òê Certificats serveur g√©n√©r√©s avec SANs appropri√©s
  ‚òê Certificats clients g√©n√©r√©s (si mTLS)
  ‚òê Dur√©e de validit√© appropri√©e (1 an recommand√©)

‚òê Installation des certificats
  ‚òê Fichiers PEM combin√©s correctement (key + cert)
  ‚òê Permissions correctes (400 pour cl√©s priv√©es)
  ‚òê Ownership correct (mongodb:mongodb)
  ‚òê CA accessible √† tous les composants

‚òê Configuration MongoDB
  ‚òê Mode TLS d√©fini (requireTLS en production)
  ‚òê Protocoles faibles d√©sactiv√©s (TLS 1.0, 1.1)
  ‚òê Cipher suites modernes configur√©es
  ‚òê clusterAuthMode d√©fini (x509)
  ‚òê Configuration identique sur tous les membres (Replica Set)

‚òê Tests de validation
  ‚òê Handshake TLS r√©ussi
  ‚òê Connexion MongoDB fonctionnelle
  ‚òê Authentification x509 op√©rationnelle
  ‚òê R√©plication fonctionnelle (si Replica Set)
  ‚òê Sharding op√©rationnel (si cluster shard√©)

‚òê Monitoring et maintenance
  ‚òê Alertes configur√©es (expiration certificats)
  ‚òê Processus de rotation document√©
  ‚òê Backup des certificats
  ‚òê Runbook de troubleshooting

‚òê Documentation
  ‚òê Inventaire des certificats
  ‚òê Proc√©dures de renouvellement
  ‚òê Contacts et escalade
  ‚òê Disaster recovery plan
```

### 5. Politique de renouvellement

**Fr√©quence recommand√©e** :

| Type de certificat | Dur√©e de validit√© | Renouvellement |
|--------------------|-------------------|----------------|
| CA Root | 10-20 ans | Avant expiration |
| CA Intermediate | 5-10 ans | 1 an avant expiration |
| Server Certificate | 1 an | 30 jours avant expiration |
| Client Certificate | 1 an | 30 jours avant expiration |

**Automation recommand√©e** :
- Let's Encrypt : certbot avec hooks
- Vault : Rotation automatique avec consul-template
- ACME : acme.sh avec hooks personnalis√©s

## Conclusion

Le chiffrement en transit avec TLS/SSL est la premi√®re ligne de d√©fense pour prot√©ger les communications MongoDB. Une impl√©mentation correcte n√©cessite :

1. **Certificats valides** issus d'une CA de confiance
2. **Configuration stricte** avec requireTLS et protocoles modernes
3. **Monitoring continu** de l'expiration des certificats
4. **Processus de rotation** automatis√© et test√©
5. **mTLS** pour les environnements √† haute s√©curit√©

La complexit√© de la mise en place est compens√©e par une s√©curit√© significativement am√©lior√©e et la conformit√© avec les standards de l'industrie. Dans les environnements de production, TLS/SSL n'est pas optionnel ‚Äî c'est une exigence fondamentale.

**Prochaines √©tapes** : Combiner TLS avec Encryption at Rest (section 11.5.2) et CSFLE (section 11.5.3) pour une protection en profondeur compl√®te.

---

**Ressources compl√©mentaires** :
- MongoDB Manual : TLS/SSL Configuration
- OpenSSL Documentation
- RFC 8446 : The Transport Layer Security (TLS) Protocol Version 1.3
- NIST Guidelines for TLS Implementation

‚è≠Ô∏è [Chiffrement au repos](/11-securite/05.2-chiffrement-repos.md)
