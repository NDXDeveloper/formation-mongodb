üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.2.2 x.509 Certificate Authentication

## Introduction

L'authentification par certificat x.509 est un m√©canisme d'authentification avanc√© qui utilise des certificats num√©riques bas√©s sur une infrastructure √† cl√©s publiques (PKI) pour v√©rifier l'identit√© des clients et des serveurs MongoDB. Contrairement √† SCRAM qui repose sur des mots de passe, x.509 utilise la cryptographie asym√©trique pour fournir une authentification forte sans jamais transmettre de secrets partag√©s sur le r√©seau.

### Cas d'Usage Privil√©gi√©s

- **Haute s√©curit√©** : Environnements n√©cessitant une authentification forte
- **Machine-to-Machine (M2M)** : Communication entre services sans intervention humaine
- **√âlimination des mots de passe** : Conformit√© avec politiques "passwordless"
- **Authentification mutuelle** : Client et serveur se prouvent mutuellement leur identit√©
- **R√©vocation granulaire** : Possibilit√© de r√©voquer des certificats individuels via CRL
- **Conformit√©** : Standards de s√©curit√© exigeants (PCI-DSS, HIPAA, SOC2)

### Avantages de x.509

| Avantage | Description |
|----------|-------------|
| **Pas de mots de passe** | √âlimine les risques li√©s aux mots de passe faibles ou vol√©s |
| **Authentification mutuelle** | Client et serveur v√©rifient mutuellement leur identit√© |
| **R√©vocation centralis√©e** | Invalidation de certificats via CRL ou OCSP |
| **Int√©gration PKI** | S'int√®gre dans infrastructure de s√©curit√© existante |
| **Non-r√©pudiation** | Signatures num√©riques tra√ßables |
| **Expiration automatique** | Certificats avec dur√©e de vie limit√©e |
| **Scalabilit√©** | D√©ploiement automatis√© avec outils PKI |

## Fondamentaux de la PKI (Public Key Infrastructure)

### Architecture PKI

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ROOT CA (Certificate Authority)          ‚îÇ
‚îÇ  ‚Ä¢ Certificat auto-sign√©                                    ‚îÇ
‚îÇ  ‚Ä¢ Cl√© priv√©e hautement s√©curis√©e (offline)                 ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e de vie: 10-20 ans                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                            ‚îÇ Signe
                            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              INTERMEDIATE CA (optionnel mais recommand√©)    ‚îÇ
‚îÇ  ‚Ä¢ Certificat sign√© par Root CA                             ‚îÇ
‚îÇ  ‚Ä¢ Cl√© priv√©e s√©curis√©e (peut √™tre online)                  ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e de vie: 5-10 ans                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   SERVER CERTIFICATES     ‚îÇ  ‚îÇ   CLIENT CERTIFICATES    ‚îÇ
‚îÇ  ‚Ä¢ mongod instances       ‚îÇ  ‚îÇ  ‚Ä¢ Applications          ‚îÇ
‚îÇ  ‚Ä¢ mongos routers         ‚îÇ  ‚îÇ  ‚Ä¢ Utilisateurs          ‚îÇ
‚îÇ  ‚Ä¢ CN = hostname          ‚îÇ  ‚îÇ  ‚Ä¢ CN = username         ‚îÇ
‚îÇ  ‚Ä¢ Dur√©e: 1-2 ans         ‚îÇ  ‚îÇ  ‚Ä¢ Dur√©e: 1-2 ans        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Composants de la PKI

#### 1. Root Certificate Authority (Root CA)

- **R√¥le** : Autorit√© de confiance racine
- **S√©curit√©** : Cl√© priv√©e stock√©e offline (HSM recommand√©)
- **Usage** : Signe les certificats interm√©diaires ou leaf
- **Dur√©e de vie** : 10-20 ans

#### 2. Intermediate Certificate Authority (Intermediate CA)

- **R√¥le** : Autorit√© interm√©diaire pour isolation de s√©curit√©
- **Avantage** : Root CA reste offline, Intermediate CA peut √™tre online
- **Usage** : Signe les certificats serveur et client
- **Dur√©e de vie** : 5-10 ans

#### 3. Server Certificates (Leaf Certificates)

- **R√¥le** : Identifie les serveurs MongoDB
- **CN (Common Name)** : FQDN du serveur (ex: mongodb01.production.internal)
- **SAN (Subject Alternative Names)** : Noms alternatifs (IP, autres hostnames)
- **Usage** : TLS encryption + authentification serveur
- **Dur√©e de vie** : 1-2 ans

#### 4. Client Certificates (Leaf Certificates)

- **R√¥le** : Identifie les clients (applications, utilisateurs)
- **CN (Common Name)** : Identifiant utilisateur MongoDB
- **Usage** : Authentification client vers serveur
- **Dur√©e de vie** : 1-2 ans

### Concepts Cl√©s x.509

#### Distinguished Name (DN)

Le DN identifie de mani√®re unique le propri√©taire du certificat :

```
CN=mongodb01.production.internal
OU=Database Infrastructure
O=MyCompany Inc
L=Paris
ST=Ile-de-France
C=FR
```

Composants :
- **CN** (Common Name) : Nom principal (hostname pour serveur, username pour client)
- **OU** (Organizational Unit) : D√©partement/√©quipe
- **O** (Organization) : Organisation
- **L** (Locality) : Ville
- **ST** (State/Province) : √âtat/r√©gion
- **C** (Country) : Code pays (2 lettres)

#### Subject Alternative Names (SAN)

Extensions permettant plusieurs identit√©s dans un certificat :

```
X509v3 Subject Alternative Name:
    DNS:mongodb01.production.internal
    DNS:mongodb01
    DNS:mongo-primary
    IP:10.0.1.100
```

**Importance** : MongoDB utilise SAN pour valider les connexions.

#### Certificate Chain (Cha√Æne de Certificats)

S√©quence de certificats permettant la validation :

```
Client Certificate
    ‚Üì signed by
Intermediate CA Certificate
    ‚Üì signed by
Root CA Certificate (self-signed)
```

**Validation** : Le client/serveur doit avoir la cha√Æne compl√®te pour valider un certificat.

## Configuration de l'Infrastructure PKI

### Cr√©ation de la Root CA

#### G√©n√©ration de la Cl√© Priv√©e Root CA

```bash
#!/bin/bash
# create-root-ca.sh

# Cr√©er la structure de r√©pertoires
mkdir -p /etc/mongodb-pki/{ca,server,client,crl}
cd /etc/mongodb-pki

# G√©n√©rer la cl√© priv√©e Root CA (4096 bits recommand√©)
openssl genrsa -aes256 -out ca/root-ca-key.pem 4096

# Permissions strictes
chmod 400 ca/root-ca-key.pem

# Cr√©er le certificat Root CA auto-sign√© (validit√© 20 ans)
openssl req -new -x509 -days 7300 -key ca/root-ca-key.pem -out ca/root-ca.pem \
  -subj "/C=FR/ST=IDF/L=Paris/O=MyCompany/OU=IT Security/CN=MongoDB Root CA"

# V√©rifier le certificat
openssl x509 -in ca/root-ca.pem -text -noout
```

**Configuration OpenSSL** pour la Root CA :

```ini
# /etc/mongodb-pki/ca/root-ca.cnf
[ ca ]
default_ca = CA_default

[ CA_default ]
dir              = /etc/mongodb-pki/ca
certs            = $dir/certs
crl_dir          = $dir/crl
new_certs_dir    = $dir/newcerts
database         = $dir/index.txt
serial           = $dir/serial
RANDFILE         = $dir/private/.rand

private_key      = $dir/root-ca-key.pem
certificate      = $dir/root-ca.pem

crlnumber        = $dir/crlnumber
crl              = $dir/crl.pem
crl_extensions   = crl_ext
default_crl_days = 30

default_md       = sha256
preserve         = no
policy           = policy_strict

[ policy_strict ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
default_bits        = 4096
distinguished_name  = req_distinguished_name
string_mask         = utf8only
default_md          = sha256
x509_extensions     = v3_ca

[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ server_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = "MongoDB Server Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth

[ client_cert ]
basicConstraints = CA:FALSE
nsCertType = client
nsComment = "MongoDB Client Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
```

### G√©n√©ration de Certificats Serveur

#### Script de G√©n√©ration Automatis√©

```bash
#!/bin/bash
# generate-server-cert.sh

HOSTNAME=$1
IP_ADDRESS=$2

if [ -z "$HOSTNAME" ] || [ -z "$IP_ADDRESS" ]; then
  echo "Usage: $0 <hostname> <ip_address>"
  echo "Example: $0 mongodb01.internal 10.0.1.100"
  exit 1
fi

SERVER_DIR="/etc/mongodb-pki/server/${HOSTNAME}"
mkdir -p "$SERVER_DIR"

# 1. G√©n√©rer la cl√© priv√©e du serveur
openssl genrsa -out "${SERVER_DIR}/server-key.pem" 4096

# 2. Cr√©er la demande de signature (CSR) avec SAN
cat > "${SERVER_DIR}/server.cnf" <<EOF
[req]
default_bits = 4096
prompt = no
default_md = sha256
distinguished_name = dn
req_extensions = v3_req

[dn]
C=FR
ST=IDF
L=Paris
O=MyCompany
OU=Database Infrastructure
CN=${HOSTNAME}

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = ${HOSTNAME}
DNS.2 = $(echo $HOSTNAME | cut -d. -f1)
IP.1 = ${IP_ADDRESS}
EOF

openssl req -new -key "${SERVER_DIR}/server-key.pem" \
  -out "${SERVER_DIR}/server.csr" \
  -config "${SERVER_DIR}/server.cnf"

# 3. Signer le CSR avec la Root CA
openssl x509 -req -in "${SERVER_DIR}/server.csr" \
  -CA /etc/mongodb-pki/ca/root-ca.pem \
  -CAkey /etc/mongodb-pki/ca/root-ca-key.pem \
  -CAcreateserial \
  -out "${SERVER_DIR}/server-cert.pem" \
  -days 730 \
  -sha256 \
  -extfile "${SERVER_DIR}/server.cnf" \
  -extensions v3_req

# 4. Cr√©er le fichier PEM combin√© (certificat + cl√©)
cat "${SERVER_DIR}/server-cert.pem" \
    "${SERVER_DIR}/server-key.pem" \
    > "${SERVER_DIR}/server.pem"

# 5. Cr√©er le fichier de la cha√Æne compl√®te (server + CA)
cat "${SERVER_DIR}/server-cert.pem" \
    /etc/mongodb-pki/ca/root-ca.pem \
    > "${SERVER_DIR}/server-chain.pem"

# 6. Permissions s√©curis√©es
chmod 400 "${SERVER_DIR}/server-key.pem"
chmod 400 "${SERVER_DIR}/server.pem"
chmod 444 "${SERVER_DIR}/server-cert.pem"

# 7. V√©rification
echo "=== V√©rification du certificat ==="
openssl x509 -in "${SERVER_DIR}/server-cert.pem" -text -noout | grep -A 5 "Subject:"
openssl x509 -in "${SERVER_DIR}/server-cert.pem" -text -noout | grep -A 10 "Subject Alternative Name"

# 8. V√©rification de la cha√Æne
openssl verify -CAfile /etc/mongodb-pki/ca/root-ca.pem "${SERVER_DIR}/server-cert.pem"

echo "‚úÖ Certificat serveur g√©n√©r√©: ${SERVER_DIR}/server.pem"
```

**Usage** :

```bash
# G√©n√©rer certificat pour mongodb01
./generate-server-cert.sh mongodb01.production.internal 10.0.1.100

# G√©n√©rer pour tous les membres d'un replica set
./generate-server-cert.sh mongodb01.production.internal 10.0.1.101
./generate-server-cert.sh mongodb02.production.internal 10.0.1.102
./generate-server-cert.sh mongodb03.production.internal 10.0.1.103
```

### G√©n√©ration de Certificats Client

```bash
#!/bin/bash
# generate-client-cert.sh

CLIENT_NAME=$1

if [ -z "$CLIENT_NAME" ]; then
  echo "Usage: $0 <client_name>"
  echo "Example: $0 app_user_prod"
  exit 1
fi

CLIENT_DIR="/etc/mongodb-pki/client/${CLIENT_NAME}"
mkdir -p "$CLIENT_DIR"

# 1. G√©n√©rer la cl√© priv√©e du client
openssl genrsa -out "${CLIENT_DIR}/client-key.pem" 4096

# 2. Cr√©er le CSR
openssl req -new -key "${CLIENT_DIR}/client-key.pem" \
  -out "${CLIENT_DIR}/client.csr" \
  -subj "/C=FR/ST=IDF/L=Paris/O=MyCompany/OU=Applications/CN=${CLIENT_NAME}"

# 3. Signer le CSR
cat > "${CLIENT_DIR}/client-ext.cnf" <<EOF
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
EOF

openssl x509 -req -in "${CLIENT_DIR}/client.csr" \
  -CA /etc/mongodb-pki/ca/root-ca.pem \
  -CAkey /etc/mongodb-pki/ca/root-ca-key.pem \
  -CAcreateserial \
  -out "${CLIENT_DIR}/client-cert.pem" \
  -days 730 \
  -sha256 \
  -extfile "${CLIENT_DIR}/client-ext.cnf"

# 4. Cr√©er le fichier PEM combin√©
cat "${CLIENT_DIR}/client-cert.pem" \
    "${CLIENT_DIR}/client-key.pem" \
    > "${CLIENT_DIR}/client.pem"

# 5. Permissions
chmod 400 "${CLIENT_DIR}/client-key.pem"
chmod 400 "${CLIENT_DIR}/client.pem"
chmod 444 "${CLIENT_DIR}/client-cert.pem"

# 6. V√©rification
openssl verify -CAfile /etc/mongodb-pki/ca/root-ca.pem "${CLIENT_DIR}/client-cert.pem"

# 7. Extraire le subject DN (pour cr√©er l'utilisateur MongoDB)
SUBJECT_DN=$(openssl x509 -in "${CLIENT_DIR}/client-cert.pem" -noout -subject | sed 's/subject=//')

echo "‚úÖ Certificat client g√©n√©r√©: ${CLIENT_DIR}/client.pem"
echo "üìã Subject DN pour MongoDB: $SUBJECT_DN"
echo ""
echo "Cr√©er l'utilisateur MongoDB avec:"
echo "db.getSiblingDB(\"\$external\").createUser({"
echo "  user: \"${SUBJECT_DN}\","
echo "  roles: [{ role: \"readWrite\", db: \"myapp\" }]"
echo "})"
```

## Configuration MongoDB avec x.509

### Configuration Serveur (mongod)

#### Standalone avec x.509

```yaml
# /etc/mongod.conf

# Network configuration
net:
  bindIp: 0.0.0.0
  port: 27017

  # TLS/SSL configuration
  tls:
    mode: requireTLS

    # Certificat du serveur (cert + cl√© priv√©e)
    certificateKeyFile: /etc/mongodb-pki/server/mongodb01.internal/server.pem

    # Mot de passe de la cl√© priv√©e (si chiffr√©e)
    # certificateKeyFilePassword: <password>

    # Certificat de la CA pour valider les clients
    CAFile: /etc/mongodb-pki/ca/root-ca.pem

    # Ne pas autoriser les connexions sans certificat client valide
    allowConnectionsWithoutCertificates: false

    # Ne pas autoriser les certificats invalides
    allowInvalidCertificates: false

    # Valider les hostnames
    allowInvalidHostnames: false

    # D√©sactiver les protocoles faibles
    disabledProtocols: TLS1_0,TLS1_1

# Security configuration
security:
  authorization: enabled

  # Mapping du certificat vers le username MongoDB
  clusterAuthMode: x509

# Logging
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    accessControl:
      verbosity: 2  # Logging d√©taill√© pour debug
```

#### Replica Set avec x.509

```yaml
# /etc/mongod.conf

net:
  bindIp: 0.0.0.0
  port: 27017
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/mongodb-pki/server/mongodb01.internal/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem

    # Certificat pour l'authentification interne du replica set
    clusterFile: /etc/mongodb-pki/server/mongodb01.internal/server.pem

    allowConnectionsWithoutCertificates: false
    allowInvalidCertificates: false
    allowInvalidHostnames: false
    disabledProtocols: TLS1_0,TLS1_1

security:
  authorization: enabled
  clusterAuthMode: x509

replication:
  replSetName: rs0

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
```

**‚ö†Ô∏è Important pour Replica Sets** :
- Tous les membres doivent avoir des certificats sign√©s par la m√™me CA
- Le CN de chaque certificat doit √™tre unique (hostname diff√©rent)
- `clusterFile` peut √™tre identique √† `certificateKeyFile` si le certificat serveur contient les bonnes extensions

### Initialisation du Replica Set avec x.509

```bash
# 1. D√©marrer les 3 membres avec x.509 configur√©
systemctl start mongod  # Sur chaque serveur

# 2. Se connecter au premier membre avec certificat client admin
mongosh "mongodb://mongodb01.internal:27017/admin?tls=true&tlsCAFile=/etc/mongodb-pki/ca/root-ca.pem&tlsCertificateKeyFile=/etc/mongodb-pki/client/admin/client.pem&authMechanism=MONGODB-X509"

# 3. Initialiser le replica set
rs.initiate({
  _id: "rs0",
  members: [
    { _id: 0, host: "mongodb01.internal:27017" },
    { _id: 1, host: "mongodb02.internal:27017" },
    { _id: 2, host: "mongodb03.internal:27017" }
  ]
})

# 4. V√©rifier le statut
rs.status()
```

### Configuration Cluster Shard√© avec x.509

#### Config Servers

```yaml
# /etc/mongod-config.conf

net:
  bindIp: 0.0.0.0
  port: 27019
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/mongodb-pki/server/config01.internal/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem
    clusterFile: /etc/mongodb-pki/server/config01.internal/server.pem
    allowConnectionsWithoutCertificates: false

security:
  authorization: enabled
  clusterAuthMode: x509

sharding:
  clusterRole: configsvr

replication:
  replSetName: configReplSet
```

#### Mongos (Query Router)

```yaml
# /etc/mongos.conf

net:
  bindIp: 0.0.0.0
  port: 27017
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/mongodb-pki/server/mongos01.internal/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem
    clusterFile: /etc/mongodb-pki/server/mongos01.internal/server.pem
    allowConnectionsWithoutCertificates: false

security:
  clusterAuthMode: x509

sharding:
  configDB: configReplSet/config01.internal:27019,config02.internal:27019,config03.internal:27019

systemLog:
  destination: file
  path: /var/log/mongodb/mongos.log
```

#### Shards

```yaml
# /etc/mongod-shard.conf

net:
  bindIp: 0.0.0.0
  port: 27018
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/mongodb-pki/server/shard01-01.internal/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem
    clusterFile: /etc/mongodb-pki/server/shard01-01.internal/server.pem
    allowConnectionsWithoutCertificates: false

security:
  authorization: enabled
  clusterAuthMode: x509

sharding:
  clusterRole: shardsvr

replication:
  replSetName: shard01
```

## Authentification Client avec x.509

### Cr√©ation d'Utilisateurs MongoDB pour x.509

Les utilisateurs x.509 doivent √™tre cr√©√©s dans la base `$external` avec le Subject DN complet du certificat.

```javascript
// 1. Extraire le Subject DN du certificat client
// Via shell:
// openssl x509 -in client.pem -noout -subject

// 2. Se connecter avec un admin existant
mongosh "mongodb://mongodb01.internal:27017/admin?tls=true&tlsCAFile=/etc/mongodb-pki/ca/root-ca.pem&tlsCertificateKeyFile=/etc/mongodb-pki/client/admin/client.pem&authMechanism=MONGODB-X509"

// 3. Cr√©er l'utilisateur avec le DN exact
db.getSiblingDB("$external").createUser({
  user: "CN=app_user_prod,OU=Applications,O=MyCompany,L=Paris,ST=IDF,C=FR",
  roles: [
    { role: "readWrite", db: "production" },
    { role: "read", db: "analytics" }
  ]
})

// 4. V√©rifier l'utilisateur
db.getSiblingDB("$external").getUser("CN=app_user_prod,OU=Applications,O=MyCompany,L=Paris,ST=IDF,C=FR")
```

**‚ö†Ô∏è Important** :
- Le DN doit correspondre **EXACTEMENT** au Subject du certificat
- L'ordre des composants du DN est important
- Les espaces autour des virgules doivent correspondre
- Utiliser `$external` comme base de donn√©es d'authentification

### Script de Cr√©ation Automatis√©e

```bash
#!/bin/bash
# create-x509-user.sh

CLIENT_CERT=$1
ROLES=$2

if [ -z "$CLIENT_CERT" ] || [ -z "$ROLES" ]; then
  echo "Usage: $0 <client_cert_path> <roles_json>"
  echo "Example: $0 /path/to/client.pem '{\"role\":\"readWrite\",\"db\":\"myapp\"}'"
  exit 1
fi

# Extraire le Subject DN
SUBJECT_DN=$(openssl x509 -in "$CLIENT_CERT" -noout -subject | sed 's/subject=//')

echo "Creating MongoDB user for certificate:"
echo "  Subject DN: $SUBJECT_DN"
echo "  Roles: $ROLES"

# Cr√©er l'utilisateur
mongosh "mongodb://localhost:27017/admin?authMechanism=MONGODB-X509&tls=true&tlsCertificateKeyFile=/etc/mongodb-pki/client/admin/client.pem&tlsCAFile=/etc/mongodb-pki/ca/root-ca.pem" <<EOF
db.getSiblingDB("\$external").createUser({
  user: "${SUBJECT_DN}",
  roles: [${ROLES}]
})

print("‚úÖ User created successfully");
EOF
```

### Connexion Client avec x.509

#### Connection String

```javascript
// Format complet
mongodb://mongodb01.internal:27017,mongodb02.internal:27017,mongodb03.internal:27017/myapp?replicaSet=rs0&authMechanism=MONGODB-X509&authSource=$external&tls=true&tlsCertificateKeyFile=/path/to/client.pem&tlsCAFile=/path/to/ca.pem

// Note: Le username n'est PAS dans la connection string
// Il est extrait automatiquement du certificat client
```

#### Node.js (MongoDB Driver)

```javascript
const { MongoClient } = require('mongodb');
const fs = require('fs');

// Option 1: Avec fichier PEM
const uri = "mongodb://mongodb01.internal:27017,mongodb02.internal:27017,mongodb03.internal:27017/myapp?replicaSet=rs0";

const client = new MongoClient(uri, {
  authMechanism: 'MONGODB-X509',
  authSource: '$external',
  tls: true,
  tlsCertificateKeyFile: '/etc/mongodb-pki/client/app_user/client.pem',
  tlsCAFile: '/etc/mongodb-pki/ca/root-ca.pem',
  tlsAllowInvalidHostnames: false,
  tlsAllowInvalidCertificates: false
});

// Option 2: Avec certificat et cl√© en m√©moire
const cert = fs.readFileSync('/etc/mongodb-pki/client/app_user/client-cert.pem');
const key = fs.readFileSync('/etc/mongodb-pki/client/app_user/client-key.pem');
const ca = fs.readFileSync('/etc/mongodb-pki/ca/root-ca.pem');

const client2 = new MongoClient(uri, {
  authMechanism: 'MONGODB-X509',
  authSource: '$external',
  tls: true,
  tlsCertificateKey: cert + key,
  tlsCAFile: ca
});

async function connect() {
  try {
    await client.connect();
    console.log("‚úÖ Connected with x.509 certificate");

    const db = client.db("myapp");
    // Op√©rations...

  } catch (err) {
    console.error("‚ùå Authentication failed:", err);
  } finally {
    await client.close();
  }
}

connect();
```

#### Python (PyMongo)

```python
from pymongo import MongoClient
from pymongo.ssl_support import get_ssl_context
import ssl

# Configuration TLS
ssl_context = ssl.create_default_context(
    cafile='/etc/mongodb-pki/ca/root-ca.pem'
)
ssl_context.load_cert_chain(
    certfile='/etc/mongodb-pki/client/app_user/client-cert.pem',
    keyfile='/etc/mongodb-pki/client/app_user/client-key.pem'
)

# Option 1: URI
uri = "mongodb://mongodb01.internal:27017,mongodb02.internal:27017,mongodb03.internal:27017/myapp?replicaSet=rs0&authMechanism=MONGODB-X509&authSource=$external"

client = MongoClient(
    uri,
    tls=True,
    tlsCAFile='/etc/mongodb-pki/ca/root-ca.pem',
    tlsCertificateKeyFile='/etc/mongodb-pki/client/app_user/client.pem'
)

# Option 2: Avec contexte SSL
client = MongoClient(
    'mongodb://mongodb01.internal:27017,mongodb02.internal:27017,mongodb03.internal:27017/myapp?replicaSet=rs0',
    authMechanism='MONGODB-X509',
    authSource='$external',
    ssl=True,
    ssl_context=ssl_context
)

# Test connexion
try:
    client.admin.command('ping')
    print("‚úÖ Connected with x.509 certificate")
except Exception as e:
    print(f"‚ùå Authentication failed: {e}")
```

#### Java

```java
import com.mongodb.MongoClientSettings;
import com.mongodb.MongoCredential;
import com.mongodb.ServerAddress;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.ConnectionString;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.KeyManagerFactory;
import java.security.KeyStore;
import java.io.FileInputStream;

// Configuration SSL
KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
trustStore.load(new FileInputStream("/etc/mongodb-pki/ca/ca-truststore.jks"), "password".toCharArray());

TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(trustStore);

KeyStore keyStore = KeyStore.getInstance("PKCS12");
keyStore.load(new FileInputStream("/etc/mongodb-pki/client/app_user/client.p12"), "password".toCharArray());

KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(keyStore, "password".toCharArray());

SSLContext sslContext = SSLContext.getInstance("TLS");
sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

// Credential x.509
MongoCredential credential = MongoCredential.createMongoX509Credential();

// Connection
MongoClientSettings settings = MongoClientSettings.builder()
    .applyToSslSettings(builder ->
        builder.enabled(true)
               .context(sslContext)
               .invalidHostNameAllowed(false))
    .credential(credential)
    .applyToClusterSettings(builder ->
        builder.hosts(Arrays.asList(
            new ServerAddress("mongodb01.internal", 27017),
            new ServerAddress("mongodb02.internal", 27017),
            new ServerAddress("mongodb03.internal", 27017)
        ))
        .requiredReplicaSetName("rs0"))
    .build();

MongoClient mongoClient = MongoClients.create(settings);
```

#### Go

```go
package main

import (
    "context"
    "crypto/tls"
    "crypto/x509"
    "io/ioutil"
    "log"
    "time"

    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    // Charger le certificat CA
    caCert, err := ioutil.ReadFile("/etc/mongodb-pki/ca/root-ca.pem")
    if err != nil {
        log.Fatal(err)
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    // Charger le certificat client
    clientCert, err := tls.LoadX509KeyPair(
        "/etc/mongodb-pki/client/app_user/client-cert.pem",
        "/etc/mongodb-pki/client/app_user/client-key.pem",
    )
    if err != nil {
        log.Fatal(err)
    }

    // Configuration TLS
    tlsConfig := &tls.Config{
        RootCAs:      caCertPool,
        Certificates: []tls.Certificate{clientCert},
        MinVersion:   tls.VersionTLS12,
    }

    // Credential x.509
    credential := options.Credential{
        AuthMechanism: "MONGODB-X509",
        AuthSource:    "$external",
    }

    // Options client
    clientOpts := options.Client().
        ApplyURI("mongodb://mongodb01.internal:27017,mongodb02.internal:27017,mongodb03.internal:27017/?replicaSet=rs0").
        SetAuth(credential).
        SetTLSConfig(tlsConfig)

    // Connexion
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    client, err := mongo.Connect(ctx, clientOpts)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect(ctx)

    // Test
    err = client.Ping(ctx, nil)
    if err != nil {
        log.Fatal("Authentication failed:", err)
    }

    log.Println("‚úÖ Connected with x.509 certificate")
}
```

## Gestion du Cycle de Vie des Certificats

### Renouvellement de Certificats

Les certificats ont une dur√©e de vie limit√©e (typiquement 1-2 ans). Un processus de renouvellement doit √™tre en place.

#### Script de Renouvellement Automatis√©

```bash
#!/bin/bash
# renew-certificate.sh

CERT_FILE=$1
KEY_FILE=$2
CSR_FILE=$3
DAYS_BEFORE_EXPIRY=30

if [ -z "$CERT_FILE" ]; then
  echo "Usage: $0 <cert_file> [key_file] [csr_file]"
  exit 1
fi

# V√©rifier l'expiration
EXPIRY_DATE=$(openssl x509 -in "$CERT_FILE" -noout -enddate | cut -d= -f2)
EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s)
CURRENT_EPOCH=$(date +%s)
DAYS_LEFT=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))

echo "Certificat: $CERT_FILE"
echo "Expire le: $EXPIRY_DATE"
echo "Jours restants: $DAYS_LEFT"

if [ $DAYS_LEFT -lt $DAYS_BEFORE_EXPIRY ]; then
  echo "‚ö†Ô∏è  Renouvellement n√©cessaire"

  # R√©g√©n√©rer le CSR si n√©cessaire
  if [ -n "$KEY_FILE" ] && [ -n "$CSR_FILE" ]; then
    openssl req -new -key "$KEY_FILE" -out "$CSR_FILE.new" \
      -subj "$(openssl x509 -in $CERT_FILE -noout -subject | sed 's/subject=//')"

    echo "üìù Nouveau CSR g√©n√©r√©: $CSR_FILE.new"
    echo "Soumettre ce CSR √† votre CA pour signature"

    # Si auto-sign√© par votre CA interne
    # openssl x509 -req -in "$CSR_FILE.new" \
    #   -CA /etc/mongodb-pki/ca/root-ca.pem \
    #   -CAkey /etc/mongodb-pki/ca/root-ca-key.pem \
    #   -CAcreateserial \
    #   -out "$CERT_FILE.new" \
    #   -days 730 -sha256
  fi
else
  echo "‚úÖ Certificat valide pour $DAYS_LEFT jours"
fi
```

#### Rotation sans Interruption (Rolling Restart)

Pour un replica set, rotation certificat par certificat :

```bash
#!/bin/bash
# rotate-replica-set-certs.sh

MEMBERS=("mongodb01.internal" "mongodb02.internal" "mongodb03.internal")

for MEMBER in "${MEMBERS[@]}"; do
  echo "=== Rotating certificate for $MEMBER ==="

  # 1. G√©n√©rer nouveau certificat
  ./generate-server-cert.sh "$MEMBER" "$(dig +short $MEMBER)"

  # 2. Copier sur le serveur
  scp "/etc/mongodb-pki/server/$MEMBER/server.pem" "$MEMBER:/tmp/new-server.pem"

  # 3. Remplacer et red√©marrer (sur le serveur distant)
  ssh "$MEMBER" <<'ENDSSH'
    sudo systemctl stop mongod
    sudo mv /tmp/new-server.pem /etc/ssl/mongodb/server.pem
    sudo chown mongodb:mongodb /etc/ssl/mongodb/server.pem
    sudo chmod 400 /etc/ssl/mongodb/server.pem
    sudo systemctl start mongod
ENDSSH

  # 4. Attendre que le membre rejoigne le replica set
  echo "Waiting for member to rejoin..."
  sleep 30

  # 5. V√©rifier le statut
  mongosh "mongodb://$MEMBER:27017/?authMechanism=MONGODB-X509&tls=true&tlsCertificateKeyFile=/etc/mongodb-pki/client/admin/client.pem&tlsCAFile=/etc/mongodb-pki/ca/root-ca.pem" --eval "rs.status()" | grep -A 2 "$MEMBER"

  echo "‚úÖ $MEMBER rotated"
  echo ""
done

echo "=== Rotation compl√®te ==="
```

### R√©vocation de Certificats

#### Cr√©ation d'une Certificate Revocation List (CRL)

```bash
#!/bin/bash
# create-crl.sh

# 1. Pr√©parer la base de donn√©es de la CA
mkdir -p /etc/mongodb-pki/ca/{crl,newcerts}
touch /etc/mongodb-pki/ca/index.txt
echo 1000 > /etc/mongodb-pki/ca/crlnumber

# 2. R√©voquer un certificat
CERT_TO_REVOKE=$1

if [ -n "$CERT_TO_REVOKE" ]; then
  openssl ca -config /etc/mongodb-pki/ca/root-ca.cnf \
    -revoke "$CERT_TO_REVOKE" \
    -crl_reason keyCompromise
fi

# 3. G√©n√©rer la CRL
openssl ca -config /etc/mongodb-pki/ca/root-ca.cnf \
  -gencrl \
  -out /etc/mongodb-pki/ca/crl/root-ca.crl

# 4. V√©rifier la CRL
openssl crl -in /etc/mongodb-pki/ca/crl/root-ca.crl -noout -text

echo "‚úÖ CRL g√©n√©r√©e: /etc/mongodb-pki/ca/crl/root-ca.crl"
```

#### Configuration MongoDB pour Utiliser la CRL

```yaml
# /etc/mongod.conf

net:
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/mongodb-pki/server/mongodb01.internal/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem

    # Activer la v√©rification CRL
    CRLFile: /etc/mongodb-pki/ca/crl/root-ca.crl

    allowConnectionsWithoutCertificates: false
```

**Mise √† Jour de la CRL** :

```bash
# Automatiser avec cron (quotidien)
0 2 * * * /usr/local/bin/update-crl.sh

# /usr/local/bin/update-crl.sh
#!/bin/bash
# T√©l√©charger la CRL depuis la CA
curl -o /etc/mongodb-pki/ca/crl/root-ca.crl https://ca.internal/crl/root-ca.crl

# Recharger MongoDB (sans red√©marrage)
mongosh --eval "db.adminCommand({ rotateCertificates: 1 })"
```

### Rotation de la CA Root

Rotation de la CA racine (op√©ration rare, tous les 10-20 ans) :

```bash
#!/bin/bash
# rotate-root-ca.sh

# 1. Cr√©er nouvelle Root CA
openssl genrsa -aes256 -out /etc/mongodb-pki/ca/root-ca-new-key.pem 4096
openssl req -new -x509 -days 7300 -key /etc/mongodb-pki/ca/root-ca-new-key.pem \
  -out /etc/mongodb-pki/ca/root-ca-new.pem \
  -subj "/C=FR/ST=IDF/L=Paris/O=MyCompany/OU=IT Security/CN=MongoDB Root CA v2"

# 2. Cr√©er bundle avec ancienne + nouvelle CA (p√©riode de transition)
cat /etc/mongodb-pki/ca/root-ca.pem \
    /etc/mongodb-pki/ca/root-ca-new.pem \
    > /etc/mongodb-pki/ca/root-ca-bundle.pem

# 3. D√©ployer le bundle sur tous les serveurs
for HOST in mongodb01 mongodb02 mongodb03; do
  scp /etc/mongodb-pki/ca/root-ca-bundle.pem "$HOST:/etc/ssl/mongodb/ca.pem"
done

# 4. P√©riode de transition: R√©g√©n√©rer tous les certificats avec nouvelle CA
# (Sur plusieurs semaines/mois)

# 5. Apr√®s transition: Retirer l'ancienne CA du bundle
cp /etc/mongodb-pki/ca/root-ca-new.pem /etc/mongodb-pki/ca/root-ca.pem
```

## Troubleshooting x.509

### Probl√®mes Courants

#### 1. "SSL peer certificate validation failed"

**Sympt√¥mes** :
```
MongoServerError: SSL peer certificate validation failed
```

**Causes et Solutions** :

```bash
# Cause 1: Certificat expir√©
openssl x509 -in server.pem -noout -dates
# Solution: Renouveler le certificat

# Cause 2: CN ne correspond pas au hostname
openssl x509 -in server.pem -noout -subject
# Le CN doit correspondre exactement au hostname utilis√© dans la connexion

# Cause 3: Cha√Æne de certificats incompl√®te
openssl s_client -connect mongodb01.internal:27017 -showcerts
# V√©rifier que toute la cha√Æne est pr√©sent√©e

# Cause 4: CA non reconnue
openssl verify -CAfile ca.pem server-cert.pem
# Doit afficher: server-cert.pem: OK

# Cause 5: SAN manquant ou incorrect
openssl x509 -in server.pem -text -noout | grep -A 5 "Subject Alternative Name"
# V√©rifier que le hostname/IP utilis√© est dans les SAN
```

#### 2. "Authentication failed" avec x.509

**Diagnostic** :

```javascript
// V√©rifier que l'utilisateur existe dans $external
use $external
db.getUsers()

// V√©rifier le DN exact du certificat
// Via shell:
openssl x509 -in client.pem -noout -subject

// Le DN doit correspondre EXACTEMENT
// Attention aux espaces, virgules, ordre des composants

// Test avec verbosit√©
db.setLogLevel(2, "accessControl")
```

**Solutions courantes** :

```javascript
// Recr√©er l'utilisateur avec le DN correct
db.getSiblingDB("$external").dropUser("ancien_dn_incorrect")

// Extraire le DN exact
const subjectDN = "CN=...";  // Copier depuis openssl x509 -noout -subject

db.getSiblingDB("$external").createUser({
  user: subjectDN,
  roles: [{ role: "readWrite", db: "myapp" }]
})
```

#### 3. Probl√®mes de Permissions sur les Fichiers

```bash
# Les cl√©s priv√©es doivent √™tre prot√©g√©es
chmod 400 /etc/mongodb-pki/server/*/server-key.pem
chmod 400 /etc/mongodb-pki/server/*/server.pem
chown mongodb:mongodb /etc/mongodb-pki/server/*/server.pem

# Certificats publics peuvent √™tre lisibles
chmod 444 /etc/mongodb-pki/ca/root-ca.pem
```

#### 4. "tlsHandshake failed"

```bash
# Tester la configuration TLS
openssl s_client -connect mongodb01.internal:27017 \
  -CAfile /etc/mongodb-pki/ca/root-ca.pem \
  -cert /etc/mongodb-pki/client/app_user/client-cert.pem \
  -key /etc/mongodb-pki/client/app_user/client-key.pem

# Doit afficher "Verify return code: 0 (ok)"

# V√©rifier les protocoles TLS
openssl s_client -connect mongodb01.internal:27017 -tls1_2
# Doit se connecter avec TLS 1.2

openssl s_client -connect mongodb01.internal:27017 -tls1
# Doit √©chouer si TLS 1.0 d√©sactiv√© (recommand√©)
```

### Diagnostic Avanc√©

```bash
#!/bin/bash
# diagnose-x509.sh

echo "=== Diagnostic x.509 MongoDB ==="

# 1. V√©rifier les certificats serveur
echo -e "\n1. Certificats Serveur:"
for CERT in /etc/mongodb-pki/server/*/server.pem; do
  echo "  Certificat: $CERT"

  # Expiration
  EXPIRY=$(openssl x509 -in "$CERT" -noout -enddate | cut -d= -f2)
  echo "    Expire: $EXPIRY"

  # Subject
  SUBJECT=$(openssl x509 -in "$CERT" -noout -subject)
  echo "    $SUBJECT"

  # SAN
  echo "    SAN:"
  openssl x509 -in "$CERT" -text -noout | grep -A 5 "Subject Alternative Name" | tail -5

  # Validation
  VERIFY=$(openssl verify -CAfile /etc/mongodb-pki/ca/root-ca.pem "$CERT" 2>&1)
  if echo "$VERIFY" | grep -q "OK"; then
    echo "    ‚úÖ Validation: OK"
  else
    echo "    ‚ùå Validation: FAILED"
    echo "       $VERIFY"
  fi

  echo ""
done

# 2. Tester la connexion TLS
echo "2. Test Connexion TLS:"
timeout 5 openssl s_client -connect localhost:27017 \
  -CAfile /etc/mongodb-pki/ca/root-ca.pem \
  </dev/null 2>&1 | grep "Verify return code"

# 3. V√©rifier les utilisateurs x.509
echo -e "\n3. Utilisateurs x.509:"
mongosh "mongodb://localhost:27017/?authMechanism=MONGODB-X509&tls=true&tlsCertificateKeyFile=/etc/mongodb-pki/client/admin/client.pem&tlsCAFile=/etc/mongodb-pki/ca/root-ca.pem" --quiet --eval "db.getSiblingDB('\$external').getUsers()" 2>/dev/null || echo "‚ùå Impossible de se connecter"

# 4. V√©rifier la configuration MongoDB
echo -e "\n4. Configuration MongoDB:"
grep -A 20 "net:" /etc/mongod.conf | grep -v "^#"

echo -e "\n=== Fin du Diagnostic ==="
```

## Automatisation et Int√©gration

### Ansible Playbook pour D√©ploiement x.509

```yaml
# playbooks/mongodb-x509-setup.yml
---
- name: Configure MongoDB with x.509 authentication
  hosts: mongodb_servers
  become: yes
  vars:
    pki_dir: /etc/mongodb-pki
    mongodb_user: mongodb

  tasks:
    - name: Create PKI directory structure
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ mongodb_user }}"
        group: "{{ mongodb_user }}"
        mode: '0755'
      loop:
        - "{{ pki_dir }}/ca"
        - "{{ pki_dir }}/server"
        - "{{ pki_dir }}/client"
        - "{{ pki_dir }}/crl"

    - name: Copy Root CA certificate
      copy:
        src: files/pki/ca/root-ca.pem
        dest: "{{ pki_dir }}/ca/root-ca.pem"
        owner: "{{ mongodb_user }}"
        group: "{{ mongodb_user }}"
        mode: '0444'

    - name: Copy server certificate
      copy:
        src: "files/pki/server/{{ inventory_hostname }}/server.pem"
        dest: "{{ pki_dir }}/server/server.pem"
        owner: "{{ mongodb_user }}"
        group: "{{ mongodb_user }}"
        mode: '0400'

    - name: Configure mongod.conf for x.509
      blockinfile:
        path: /etc/mongod.conf
        block: |
          net:
            tls:
              mode: requireTLS
              certificateKeyFile: {{ pki_dir }}/server/server.pem
              CAFile: {{ pki_dir }}/ca/root-ca.pem
              clusterFile: {{ pki_dir }}/server/server.pem
              allowConnectionsWithoutCertificates: false
              allowInvalidCertificates: false
              allowInvalidHostnames: false
              disabledProtocols: TLS1_0,TLS1_1

          security:
            authorization: enabled
            clusterAuthMode: x509
        marker: "# {mark} ANSIBLE MANAGED x.509 CONFIG"

    - name: Restart MongoDB
      systemd:
        name: mongod
        state: restarted
        enabled: yes

    - name: Wait for MongoDB to be ready
      wait_for:
        port: 27017
        delay: 5
        timeout: 30
```

### Terraform pour MongoDB Atlas avec x.509

```hcl
# mongodb-atlas-x509.tf

# Configure x.509 authentication pour MongoDB Atlas
resource "mongodbatlas_database_user" "x509_user" {
  username           = "CN=app_user,OU=Applications,O=MyCompany,C=FR"
  project_id         = var.project_id
  auth_database_name = "$external"
  x509_type          = "CUSTOMER"

  roles {
    role_name     = "readWrite"
    database_name = "production"
  }

  roles {
    role_name     = "read"
    database_name = "analytics"
  }

  labels {
    key   = "environment"
    value = "production"
  }
}

# Configuration du certificat client (√† fournir par l'utilisateur)
output "x509_connection_string" {
  value = "mongodb+srv://${mongodbatlas_cluster.main.connection_strings[0].standard_srv}/?authMechanism=MONGODB-X509&authSource=$external&tls=true"
}
```

### Docker Compose avec x.509

```yaml
# docker-compose-x509.yml
version: '3.8'

services:
  mongodb-primary:
    image: mongo:7.0
    container_name: mongodb-primary
    hostname: mongodb-primary
    command: mongod --config /etc/mongod.conf
    volumes:
      - ./config/mongod-primary.conf:/etc/mongod.conf
      - ./pki/server/mongodb-primary:/etc/mongodb-pki/server
      - ./pki/ca:/etc/mongodb-pki/ca
      - mongodb-primary-data:/data/db
    ports:
      - "27017:27017"
    networks:
      - mongodb-network

  mongodb-secondary1:
    image: mongo:7.0
    container_name: mongodb-secondary1
    hostname: mongodb-secondary1
    command: mongod --config /etc/mongod.conf
    volumes:
      - ./config/mongod-secondary.conf:/etc/mongod.conf
      - ./pki/server/mongodb-secondary1:/etc/mongodb-pki/server
      - ./pki/ca:/etc/mongodb-pki/ca
      - mongodb-secondary1-data:/data/db
    ports:
      - "27018:27017"
    networks:
      - mongodb-network
    depends_on:
      - mongodb-primary

  mongodb-secondary2:
    image: mongo:7.0
    container_name: mongodb-secondary2
    hostname: mongodb-secondary2
    command: mongod --config /etc/mongod.conf
    volumes:
      - ./config/mongod-secondary.conf:/etc/mongod.conf
      - ./pki/server/mongodb-secondary2:/etc/mongodb-pki/server
      - ./pki/ca:/etc/mongodb-pki/ca
      - mongodb-secondary2-data:/data/db
    ports:
      - "27019:27017"
    networks:
      - mongodb-network
    depends_on:
      - mongodb-primary

volumes:
  mongodb-primary-data:
  mongodb-secondary1-data:
  mongodb-secondary2-data:

networks:
  mongodb-network:
    driver: bridge
```

## Bonnes Pratiques de Production

### Checklist x.509 pour Production

- [ ] **Infrastructure PKI**
  - [ ] Root CA avec cl√© priv√©e s√©curis√©e (HSM ou offline)
  - [ ] Intermediate CA pour isolation
  - [ ] Proc√©dure de backup des cl√©s CA
  - [ ] Documentation de la PKI

- [ ] **Certificats**
  - [ ] Dur√©e de vie appropri√©e (1-2 ans)
  - [ ] SAN configur√©s correctement
  - [ ] CN = hostname exact pour serveurs
  - [ ] CN = username pour clients
  - [ ] Cl√©s priv√©es en 4096 bits minimum

- [ ] **Configuration MongoDB**
  - [ ] `mode: requireTLS` partout
  - [ ] `allowConnectionsWithoutCertificates: false`
  - [ ] `allowInvalidCertificates: false`
  - [ ] `allowInvalidHostnames: false`
  - [ ] `disabledProtocols: TLS1_0,TLS1_1`
  - [ ] `clusterAuthMode: x509` pour replica sets

- [ ] **S√©curit√© des Fichiers**
  - [ ] Cl√©s priv√©es : 400 permissions
  - [ ] Owner: mongodb:mongodb
  - [ ] Certificats CA : 444 permissions
  - [ ] Pas de cl√©s dans Git/repos

- [ ] **Gestion du Cycle de Vie**
  - [ ] Monitoring expiration certificats (alertes 30j avant)
  - [ ] Proc√©dure de renouvellement document√©e
  - [ ] Tests de rotation en staging
  - [ ] CRL mise √† jour quotidiennement

- [ ] **R√©vocation**
  - [ ] CRL configur√©e et test√©e
  - [ ] Proc√©dure de r√©vocation d'urgence
  - [ ] Distribution automatique de la CRL
  - [ ] Monitoring des certificats r√©voqu√©s

- [ ] **Monitoring**
  - [ ] Alertes sur expiration
  - [ ] Surveillance des √©checs TLS
  - [ ] Logs d'audit activ√©s
  - [ ] Dashboard expiration certificats

- [ ] **Documentation**
  - [ ] Inventaire des certificats
  - [ ] Proc√©dures op√©rationnelles
  - [ ] Contacts d'urgence
  - [ ] Diagrammes d'architecture

### Configuration Recommand√©e (Production)

```yaml
# /etc/mongod.conf - Production x.509

net:
  bindIp: 0.0.0.0
  port: 27017
  maxIncomingConnections: 10000

  tls:
    # Mode strict: TLS obligatoire
    mode: requireTLS

    # Certificats
    certificateKeyFile: /etc/mongodb-pki/server/server.pem
    CAFile: /etc/mongodb-pki/ca/root-ca.pem
    clusterFile: /etc/mongodb-pki/server/server.pem

    # CRL pour r√©vocation
    CRLFile: /etc/mongodb-pki/ca/crl/root-ca.crl

    # Validation stricte
    allowConnectionsWithoutCertificates: false
    allowInvalidCertificates: false
    allowInvalidHostnames: false

    # Protocoles s√©curis√©s uniquement
    disabledProtocols: TLS1_0,TLS1_1

    # Ciphers forts
    # MongoDB s√©lectionne automatiquement des ciphers s√©curis√©s

security:
  authorization: enabled
  clusterAuthMode: x509

# Audit (Enterprise)
auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.log
  filter: '{
    "atype": { "$in": [
      "authenticate",
      "authCheck",
      "clientMetadata"
    ]}
  }'

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  component:
    accessControl:
      verbosity: 1
    network:
      verbosity: 1

replication:
  replSetName: rs0

storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: true
```

### Monitoring de l'Expiration

```python
#!/usr/bin/env python3
# monitor-cert-expiry.py

import os
import subprocess
from datetime import datetime, timedelta
import json
import smtplib
from email.mime.text import MIMEText

CERT_DIR = '/etc/mongodb-pki'
WARNING_DAYS = 30
CRITICAL_DAYS = 7
EMAIL_TO = 'ops@company.com'

def check_certificate_expiry(cert_path):
    """V√©rifie l'expiration d'un certificat"""
    try:
        result = subprocess.run(
            ['openssl', 'x509', '-in', cert_path, '-noout', '-enddate'],
            capture_output=True,
            text=True,
            check=True
        )

        # Parse: notAfter=Dec  8 12:00:00 2025 GMT
        expiry_str = result.stdout.split('=')[1].strip()
        expiry_date = datetime.strptime(expiry_str, '%b %d %H:%M:%S %Y %Z')

        days_left = (expiry_date - datetime.now()).days

        return {
            'path': cert_path,
            'expiry_date': expiry_date.isoformat(),
            'days_left': days_left,
            'status': 'critical' if days_left < CRITICAL_DAYS else
                     'warning' if days_left < WARNING_DAYS else 'ok'
        }
    except Exception as e:
        return {
            'path': cert_path,
            'error': str(e),
            'status': 'error'
        }

def find_certificates(base_dir):
    """Trouve tous les certificats .pem"""
    certs = []
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            if file.endswith('-cert.pem') or file == 'server.pem':
                certs.append(os.path.join(root, file))
    return certs

def send_alert(results):
    """Envoie une alerte si n√©cessaire"""
    critical = [r for r in results if r.get('status') == 'critical']
    warnings = [r for r in results if r.get('status') == 'warning']

    if not critical and not warnings:
        return

    body = "Certificats MongoDB n√©cessitant attention:\n\n"

    if critical:
        body += "üî¥ CRITIQUE (< 7 jours):\n"
        for cert in critical:
            body += f"  - {cert['path']}: {cert['days_left']} jours\n"
        body += "\n"

    if warnings:
        body += "‚ö†Ô∏è  AVERTISSEMENT (< 30 jours):\n"
        for cert in warnings:
            body += f"  - {cert['path']}: {cert['days_left']} jours\n"

    # Envoyer email (√† adapter selon votre SMTP)
    msg = MIMEText(body)
    msg['Subject'] = f'[MongoDB] Expiration certificats - {len(critical)} critiques'
    msg['From'] = 'mongodb-monitoring@company.com'
    msg['To'] = EMAIL_TO

    # s = smtplib.SMTP('smtp.company.com')
    # s.send_message(msg)
    # s.quit()

    print(body)  # Debug

def main():
    certs = find_certificates(CERT_DIR)
    results = [check_certificate_expiry(cert) for cert in certs]

    # Afficher r√©sum√©
    print(f"Certificats v√©rifi√©s: {len(results)}")
    print(json.dumps(results, indent=2))

    # Alerter si n√©cessaire
    send_alert(results)

    # Sortie pour int√©gration monitoring (Nagios, etc.)
    critical_count = len([r for r in results if r.get('status') == 'critical'])
    if critical_count > 0:
        exit(2)  # CRITICAL

    warning_count = len([r for r in results if r.get('status') == 'warning'])
    if warning_count > 0:
        exit(1)  # WARNING

    exit(0)  # OK

if __name__ == '__main__':
    main()
```

## Conclusion

L'authentification x.509 offre le plus haut niveau de s√©curit√© pour MongoDB, mais n√©cessite une infrastructure PKI bien g√©r√©e.

**Avantages** :
- ‚úÖ Authentification forte sans mots de passe
- ‚úÖ Authentification mutuelle client-serveur
- ‚úÖ R√©vocation granulaire via CRL
- ‚úÖ Int√©gration PKI enterprise
- ‚úÖ Non-r√©pudiation
- ‚úÖ Automatisation M2M facilit√©e

**D√©fis** :
- ‚ùå Complexit√© op√©rationnelle √©lev√©e
- ‚ùå Infrastructure PKI requise
- ‚ùå Gestion du cycle de vie des certificats
- ‚ùå Formation des √©quipes n√©cessaire

**Recommandations finales** :
1. Utiliser x.509 pour **haute s√©curit√©** et **M2M**
2. Impl√©menter une **PKI robuste** d√®s le d√©but
3. Automatiser la **g√©n√©ration** et le **renouvellement**
4. Monitorer l'**expiration** activement
5. Tester la **r√©vocation** r√©guli√®rement
6. Documenter toutes les **proc√©dures**
7. Former les **√©quipes** op√©rationnelles

x.509 est id√©al pour les environnements o√π la s√©curit√© est prioritaire et o√π l'investissement dans une PKI est justifi√©.

---

**Prochaines Sections** :
- **11.2.3** : LDAP - Int√©gration Active Directory
- **11.2.4** : Kerberos - Authentification enterprise

‚è≠Ô∏è [LDAP](/11-securite/02.3-ldap.md)
