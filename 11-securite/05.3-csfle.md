ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.3 Client-Side Field Level Encryption (CSFLE)

## Introduction

Client-Side Field Level Encryption (CSFLE) reprÃ©sente le niveau le plus Ã©levÃ© de protection des donnÃ©es dans MongoDB. Contrairement au chiffrement au repos (Encryption at Rest) qui chiffre les fichiers sur disque, ou au chiffrement en transit (TLS) qui protÃ¨ge les donnÃ©es sur le rÃ©seau, **CSFLE chiffre les donnÃ©es au niveau applicatif avant mÃªme qu'elles ne quittent le client**.

Cette approche garantit que les donnÃ©es sensibles restent chiffrÃ©es tout au long de leur cycle de vie : en transit, au repos, en mÃ©moire serveur, et dans les backups. Seule l'application cliente possÃ©dant les clÃ©s de chiffrement peut dÃ©chiffrer les donnÃ©es.

### ModÃ¨le de menace

CSFLE protÃ¨ge contre des menaces que les autres formes de chiffrement ne couvrent pas :

```
ScÃ©narios de compromission protÃ©gÃ©s par CSFLE :

âœ“ Administrateur MongoDB malveillant
  â†’ L'admin voit uniquement des donnÃ©es chiffrÃ©es

âœ“ Compromission totale du serveur MongoDB
  â†’ MÃªme avec accÃ¨s root, les donnÃ©es restent illisibles

âœ“ Backups volÃ©s ou compromis
  â†’ Les backups contiennent des donnÃ©es chiffrÃ©es

âœ“ Injection NoSQL rÃ©ussie
  â†’ L'attaquant obtient des donnÃ©es chiffrÃ©es

âœ“ Dump de la mÃ©moire RAM du serveur
  â†’ Les donnÃ©es sont chiffrÃ©es mÃªme en mÃ©moire

âœ“ AccÃ¨s physique aux serveurs
  â†’ Les disques contiennent des donnÃ©es chiffrÃ©es

âœ“ Logs d'audit compromis
  â†’ Les valeurs sensibles n'apparaissent jamais en clair
```

### DiffÃ©rence avec les autres formes de chiffrement

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Application                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  CSFLE : Chiffrement ici (cÃ´tÃ© client)                    â”‚  â”‚
â”‚  â”‚  â€¢ DonnÃ©es chiffrÃ©es AVANT envoi Ã  MongoDB                â”‚  â”‚
â”‚  â”‚  â€¢ ClÃ©s de chiffrement jamais partagÃ©es avec MongoDB      â”‚  â”‚
â”‚  â”‚  â€¢ DÃ©chiffrement uniquement par l'application             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
                   [DonnÃ©es CHIFFRÃ‰ES en transit]
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TLS/SSL : Chiffrement de la couche transport                   â”‚
â”‚  â€¢ DÃ©chiffrÃ© Ã  l'arrivÃ©e sur le serveur                         â”‚
â”‚  â€¢ DonnÃ©es en clair en RAM serveur (sans CSFLE)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      MongoDB Server                             â”‚
â”‚  Avec CSFLE : Voit uniquement des donnÃ©es chiffrÃ©es             â”‚
â”‚  Sans CSFLE : Voit les donnÃ©es en clair                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Encryption at Rest : Chiffrement au niveau disque              â”‚
â”‚  â€¢ MongoDB chiffre avant Ã©criture sur disque                    â”‚
â”‚  â€¢ Avec CSFLE : Double chiffrement (app + MongoDB)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Architecture CSFLE

### Composants principaux

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Customer Master Key (CMK)                                   â”‚
â”‚     â€¢ StockÃ©e dans un KMS externe (AWS KMS, Azure, GCP, etc.)   â”‚
â”‚     â€¢ Ne quitte JAMAIS le KMS                                   â”‚
â”‚     â€¢ UtilisÃ©e pour chiffrer les Data Encryption Keys           â”‚
â”‚     â€¢ GÃ©rÃ©e par l'Ã©quipe sÃ©curitÃ©/compliance                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ chiffre
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Data Encryption Keys (DEK)                                  â”‚
â”‚     â€¢ Une ou plusieurs clÃ©s par champ/type de donnÃ©es           â”‚
â”‚     â€¢ GÃ©nÃ©rÃ©es par l'application                                â”‚
â”‚     â€¢ StockÃ©es chiffrÃ©es dans MongoDB (Key Vault Collection)    â”‚
â”‚     â€¢ UtilisÃ©es pour chiffrer les donnÃ©es rÃ©elles               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ chiffre
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Encrypted Data                                              â”‚
â”‚     â€¢ DonnÃ©es sensibles dans les collections                    â”‚
â”‚     â€¢ Type BSON : Binary (subtype 6)                            â”‚
â”‚     â€¢ MÃ©tadonnÃ©es : Algorithm, Key ID                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Vault Collection

CSFLE utilise une collection spÃ©ciale pour stocker les Data Encryption Keys chiffrÃ©es :

```javascript
// Structure d'un document dans la Key Vault
{
  "_id": UUID("12345678-1234-1234-1234-123456789012"),
  "keyMaterial": BinData(...),  // DEK chiffrÃ©e par la CMK
  "creationDate": ISODate("2024-01-15T10:30:00Z"),
  "updateDate": ISODate("2024-01-15T10:30:00Z"),
  "status": 1,  // 0 = disabled, 1 = enabled
  "masterKey": {
    "provider": "aws",
    "key": "arn:aws:kms:us-east-1:123456789012:key/abcd-1234",
    "region": "us-east-1"
  },
  "keyAltNames": ["payment-card-key", "pci-dss-key"]
}
```

**CaractÃ©ristiques importantes** :
- Collection gÃ©nÃ©ralement nommÃ©e `encryption.__keyVault`
- Permissions strictes (seule l'application doit y accÃ©der)
- Backup critique (perte = impossibilitÃ© de dÃ©chiffrer)
- Peut Ãªtre dans une base MongoDB sÃ©parÃ©e (recommandÃ©)

### Flux de chiffrement

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application veut insÃ©rer : { ssn: "123-45-6789" }              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. CSFLE Library identifie "ssn" comme champ Ã  chiffrer        â”‚
â”‚     (via JSON Schema ou explicit encryption)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. RÃ©cupÃ¨re la DEK depuis le Key Vault                         â”‚
â”‚     (ou depuis le cache local si dÃ©jÃ  rÃ©cupÃ©rÃ©e)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Demande au KMS de dÃ©chiffrer la DEK avec la CMK             â”‚
â”‚     (KMS dÃ©chiffre et retourne la DEK en clair)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Chiffre "123-45-6789" avec la DEK (AES-256-CBC)             â”‚
â”‚     RÃ©sultat : BinData(6, "aGVsbG8gd29ybGQ...")                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. Envoie Ã  MongoDB : { ssn: BinData(6, "...") }               â”‚
â”‚     MongoDB stocke les donnÃ©es chiffrÃ©es                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flux de dÃ©chiffrement

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application exÃ©cute : db.users.findOne({ _id: 123 })           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. MongoDB retourne : { ssn: BinData(6, "...") }               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. CSFLE Library dÃ©tecte le champ chiffrÃ© (subtype 6)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Identifie la DEK utilisÃ©e (via mÃ©tadonnÃ©es)                 â”‚
â”‚     RÃ©cupÃ¨re la DEK depuis le Key Vault                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Demande au KMS de dÃ©chiffrer la DEK                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. DÃ©chiffre la valeur avec la DEK                             â”‚
â”‚     RÃ©sultat : "123-45-6789"                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. Retourne Ã  l'application : { ssn: "123-45-6789" }           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Modes de chiffrement

CSFLE offre deux approches pour chiffrer les donnÃ©es :

### 1. Automatic Encryption (recommandÃ©)

**Chiffrement transparent basÃ© sur un schÃ©ma JSON.**

```javascript
// DÃ©finition du schÃ©ma de chiffrement
const encryptionSchema = {
  "bsonType": "object",
  "properties": {
    "ssn": {
      "encrypt": {
        "keyId": [UUID("12345678-1234-1234-1234-123456789012")],
        "bsonType": "string",
        "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
      }
    },
    "creditCard": {
      "encrypt": {
        "keyId": [UUID("87654321-4321-4321-4321-210987654321")],
        "bsonType": "string",
        "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
      }
    },
    "medicalRecord": {
      "bsonType": "object",
      "properties": {
        "diagnosis": {
          "encrypt": {
            "keyId": [UUID("11111111-2222-3333-4444-555555555555")],
            "bsonType": "string",
            "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
          }
        }
      }
    }
  }
}

// Utilisation transparente
db.patients.insertOne({
  name: "John Doe",
  ssn: "123-45-6789",        // ChiffrÃ© automatiquement
  creditCard: "4111-1111-1111-1111",  // ChiffrÃ© automatiquement
  medicalRecord: {
    diagnosis: "Hypertension"  // ChiffrÃ© automatiquement
  }
})

// Le dÃ©veloppeur n'a pas besoin de chiffrer manuellement
```

**Avantages** :
- Transparent pour le code applicatif
- Moins d'erreurs humaines
- SchÃ©ma centralisÃ© et versionnÃ©
- Facilite l'audit et la conformitÃ©

**InconvÃ©nients** :
- Moins de flexibilitÃ©
- SchÃ©ma doit Ãªtre maintenu
- Overhead de validation du schÃ©ma

### 2. Explicit Encryption

**Chiffrement manuel, champ par champ.**

```javascript
const clientEncryption = new ClientEncryption(client, {
  keyVaultNamespace,
  kmsProviders
})

// Chiffrement manuel
const encryptedSSN = await clientEncryption.encrypt(
  "123-45-6789",
  {
    keyId: UUID("12345678-1234-1234-1234-123456789012"),
    algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
  }
)

// Insertion avec valeur chiffrÃ©e
db.patients.insertOne({
  name: "John Doe",
  ssn: encryptedSSN,
  age: 45
})

// DÃ©chiffrement manuel
const doc = db.patients.findOne({ _id: patientId })
const decryptedSSN = await clientEncryption.decrypt(doc.ssn)
console.log(decryptedSSN)  // "123-45-6789"
```

**Avantages** :
- ContrÃ´le granulaire
- FlexibilitÃ© maximale
- Pas de schÃ©ma requis
- Chiffrement sÃ©lectif Ã  la demande

**InconvÃ©nients** :
- Plus complexe Ã  implÃ©menter
- Risque d'oubli de chiffrement
- Code plus verbeux

## Algorithmes de chiffrement

CSFLE supporte deux algorithmes, chacun avec des caractÃ©ristiques diffÃ©rentes :

### AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic

**Chiffrement dÃ©terministe** : La mÃªme valeur en clair produit toujours la mÃªme valeur chiffrÃ©e.

```javascript
// Deux insertions de la mÃªme valeur
encrypt("123-45-6789") â†’ BinData(6, "aGVsbG8...")
encrypt("123-45-6789") â†’ BinData(6, "aGVsbG8...")  // Identique !

// Permet les requÃªtes d'Ã©galitÃ©
db.users.find({ ssn: "123-45-6789" })  // Fonctionne !
```

**CaractÃ©ristiques** :

```
Avantages :
â”œâ”€ RequÃªtes d'Ã©galitÃ© possibles
â”œâ”€ AgrÃ©gations avec $group possible
â””â”€ Index possible sur le champ

InconvÃ©nients :
â”œâ”€ Moins sÃ©curisÃ© que Random
â”œâ”€ Pattern analysis possible (frÃ©quence des valeurs)
â”œâ”€ Ne protÃ¨ge pas contre les attaques par frÃ©quence
â””â”€ Pas de range queries ($gt, $lt)

Cas d'usage :
â”œâ”€ SSN (besoin de rechercher)
â”œâ”€ NumÃ©ros de compte
â”œâ”€ Identifiants uniques
â””â”€ Champs avec peu de valeurs distinctes
```

### AEAD_AES_256_CBC_HMAC_SHA_512-Random

**Chiffrement alÃ©atoire** : La mÃªme valeur en clair produit une valeur chiffrÃ©e diffÃ©rente Ã  chaque fois.

```javascript
// Deux insertions de la mÃªme valeur
encrypt("123-45-6789") â†’ BinData(6, "aGVsbG8...")
encrypt("123-45-6789") â†’ BinData(6, "d29ybGQ...")  // DiffÃ©rent !

// Pas de requÃªte d'Ã©galitÃ© possible
db.users.find({ creditCard: "4111-1111-1111-1111" })  // NE FONCTIONNE PAS
```

**CaractÃ©ristiques** :

```
Avantages :
â”œâ”€ SÃ©curitÃ© maximale
â”œâ”€ Pas d'analyse de frÃ©quence possible
â”œâ”€ ProtÃ¨ge contre les attaques statistiques
â””â”€ RecommandÃ© par dÃ©faut

InconvÃ©nients :
â”œâ”€ Aucune requÃªte possible sur le champ chiffrÃ©
â”œâ”€ Pas d'index possible
â”œâ”€ Pas d'agrÃ©gation possible
â””â”€ Recherche uniquement par _id

Cas d'usage :
â”œâ”€ NumÃ©ros de carte bancaire (pas de recherche nÃ©cessaire)
â”œâ”€ DonnÃ©es mÃ©dicales confidentielles
â”œâ”€ Secrets d'authentification
â””â”€ Toutes donnÃ©es hautement sensibles sans besoin de recherche
```

### Matrice de dÃ©cision

| Besoin | DÃ©terministe | AlÃ©atoire |
|--------|--------------|-----------|
| RequÃªtes d'Ã©galitÃ© | âœ… Oui | âŒ Non |
| Index | âœ… Oui | âŒ Non |
| Range queries ($gt, $lt) | âŒ Non | âŒ Non |
| AgrÃ©gation $group | âœ… Oui | âŒ Non |
| SÃ©curitÃ© maximale | âš ï¸ Moindre | âœ… Maximum |
| Pattern analysis | âš ï¸ Possible | âœ… Impossible |
| Recherche full-text | âŒ Non | âŒ Non |

**RÃ¨gle d'or** :
```
Utiliser Random par dÃ©faut
â†“
Passer Ã  Deterministic UNIQUEMENT si :
â”œâ”€ Besoin de rechercher sur le champ
â””â”€ ET risque acceptÃ© d'analyse de frÃ©quence
```

## Configuration et implÃ©mentation

### PrÃ©requis

1. **MongoDB Enterprise ou Atlas** (CSFLE n'est pas disponible dans Community)
2. **Driver MongoDB 4.2+** supportant CSFLE
3. **BibliothÃ¨que libmongocrypt** installÃ©e
4. **KMS configurÃ©** (AWS KMS, Azure Key Vault, GCP KMS, ou KMIP)

### Configuration des KMS Providers

#### AWS KMS

```javascript
// Node.js - Configuration AWS KMS
const { MongoClient } = require('mongodb');

const kmsProviders = {
  aws: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    // Optionnel : session token pour rÃ´les IAM temporaires
    sessionToken: process.env.AWS_SESSION_TOKEN
  }
}

const keyVaultNamespace = 'encryption.__keyVault';
const keyVaultClient = new MongoClient(connectionString);

// Configuration du client avec auto-encryption
const autoEncryptionOpts = {
  keyVaultNamespace,
  kmsProviders,
  schemaMap: encryptionSchema
};

const secureClient = new MongoClient(connectionString, {
  autoEncryption: autoEncryptionOpts
});
```

#### Azure Key Vault

```javascript
const kmsProviders = {
  azure: {
    tenantId: process.env.AZURE_TENANT_ID,
    clientId: process.env.AZURE_CLIENT_ID,
    clientSecret: process.env.AZURE_CLIENT_SECRET
  }
}
```

#### Google Cloud KMS

```javascript
const kmsProviders = {
  gcp: {
    email: process.env.GCP_EMAIL,
    privateKey: process.env.GCP_PRIVATE_KEY
  }
}
```

#### KMIP Server

```javascript
const kmsProviders = {
  kmip: {
    endpoint: 'kmip.example.com:5696'
  }
}
```

#### Local KMS (DÃ©veloppement uniquement)

```javascript
// âš ï¸ NE JAMAIS UTILISER EN PRODUCTION
const kmsProviders = {
  local: {
    key: Buffer.from(
      '0123456789abcdef0123456789abcdef' +
      '0123456789abcdef0123456789abcdef' +
      '0123456789abcdef0123456789abcdef' +
      '0123456789abcdef0123456789abcdef',
      'hex'
    )
  }
}
```

### CrÃ©ation des Data Encryption Keys

```javascript
// create-data-keys.js
const { MongoClient, ClientEncryption } = require('mongodb');

async function createDataKeys() {
  const client = new MongoClient(connectionString);

  try {
    await client.connect();

    const encryption = new ClientEncryption(client, {
      keyVaultNamespace: 'encryption.__keyVault',
      kmsProviders: {
        aws: {
          accessKeyId: process.env.AWS_ACCESS_KEY_ID,
          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
        }
      }
    });

    // CrÃ©er une DEK pour les SSN
    const ssnKeyId = await encryption.createDataKey('aws', {
      masterKey: {
        key: 'arn:aws:kms:us-east-1:123456789012:key/abcd-1234',
        region: 'us-east-1'
      },
      keyAltNames: ['ssn-key', 'pii-ssn']
    });

    console.log('SSN Key ID:', ssnKeyId.toString('base64'));

    // CrÃ©er une DEK pour les cartes bancaires
    const cardKeyId = await encryption.createDataKey('aws', {
      masterKey: {
        key: 'arn:aws:kms:us-east-1:123456789012:key/abcd-1234',
        region: 'us-east-1'
      },
      keyAltNames: ['credit-card-key', 'pci-payment']
    });

    console.log('Card Key ID:', cardKeyId.toString('base64'));

    // CrÃ©er une DEK pour les donnÃ©es mÃ©dicales
    const medicalKeyId = await encryption.createDataKey('aws', {
      masterKey: {
        key: 'arn:aws:kms:us-east-1:123456789012:key/wxyz-9876',
        region: 'us-east-1'
      },
      keyAltNames: ['medical-record-key', 'hipaa-phi']
    });

    console.log('Medical Key ID:', medicalKeyId.toString('base64'));

  } finally {
    await client.close();
  }
}

createDataKeys().catch(console.error);
```

### ImplÃ©mentation complÃ¨te (Node.js)

```javascript
// app.js - Application complÃ¨te avec CSFLE
const { MongoClient, Binary } = require('mongodb');
const { ClientEncryption } = require('mongodb-client-encryption');

// Configuration KMS
const kmsProviders = {
  aws: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
  }
};

const keyVaultNamespace = 'encryption.__keyVault';
const connectionString = 'mongodb://mongodb.example.com:27017';

// SchÃ©ma de chiffrement automatique
const patientSchema = {
  bsonType: 'object',
  properties: {
    ssn: {
      encrypt: {
        keyId: '/keyAltName',
        bsonType: 'string',
        algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'
      }
    },
    creditCard: {
      encrypt: {
        keyId: '/keyAltName',
        bsonType: 'string',
        algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'
      }
    },
    medicalRecord: {
      bsonType: 'object',
      properties: {
        diagnosis: {
          encrypt: {
            keyId: '/keyAltName',
            bsonType: 'string',
            algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'
          }
        },
        medication: {
          encrypt: {
            keyId: '/keyAltName',
            bsonType: 'string',
            algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'
          }
        }
      }
    }
  }
};

const schemaMap = {
  'hospital.patients': patientSchema
};

// Client avec auto-encryption
async function createEncryptedClient() {
  const autoEncryptionOpts = {
    keyVaultNamespace,
    kmsProviders,
    schemaMap,
    extraOptions: {
      mongocryptdSpawnPath: '/usr/local/bin/mongocryptd'
    }
  };

  const client = new MongoClient(connectionString, {
    autoEncryption: autoEncryptionOpts,
    useNewUrlParser: true,
    useUnifiedTopology: true
  });

  await client.connect();
  return client;
}

// Exemple d'utilisation
async function main() {
  const client = await createEncryptedClient();

  try {
    const db = client.db('hospital');
    const patients = db.collection('patients');

    // Insertion avec chiffrement automatique
    const result = await patients.insertOne({
      name: 'John Doe',
      dateOfBirth: new Date('1980-01-15'),
      ssn: '123-45-6789',  // Sera chiffrÃ© (Deterministic)
      creditCard: '4111-1111-1111-1111',  // Sera chiffrÃ© (Random)
      medicalRecord: {
        diagnosis: 'Hypertension',  // Sera chiffrÃ© (Random)
        medication: 'Lisinopril 10mg'  // Sera chiffrÃ© (Random)
      },
      contactInfo: {
        phone: '555-1234',  // NON chiffrÃ©
        email: 'john@example.com'  // NON chiffrÃ©
      }
    });

    console.log('Patient inserted:', result.insertedId);

    // Recherche avec dÃ©chiffrement automatique
    // Fonctionne car SSN est Deterministic
    const patient = await patients.findOne({ ssn: '123-45-6789' });
    console.log('Found patient:', patient);
    // Les champs chiffrÃ©s sont automatiquement dÃ©chiffrÃ©s

    // Recherche par _id (toujours possible)
    const patientById = await patients.findOne({ _id: result.insertedId });
    console.log('Patient by ID:', patientById);

  } finally {
    await client.close();
  }
}

main().catch(console.error);
```

### ImplÃ©mentation Python (PyMongo)

```python
# app.py - Application Python avec CSFLE
from pymongo import MongoClient
from pymongo.encryption import ClientEncryption
from pymongo.encryption_options import AutoEncryptionOpts
import os
from bson.binary import Binary, UUID_SUBTYPE
from bson.codec_options import CodecOptions

# Configuration KMS
kms_providers = {
    'aws': {
        'accessKeyId': os.environ['AWS_ACCESS_KEY_ID'],
        'secretAccessKey': os.environ['AWS_SECRET_ACCESS_KEY']
    }
}

key_vault_namespace = 'encryption.__keyVault'
connection_string = 'mongodb://mongodb.example.com:27017'

# SchÃ©ma de chiffrement
patient_schema = {
    "bsonType": "object",
    "properties": {
        "ssn": {
            "encrypt": {
                "keyId": "/keyAltName",
                "bsonType": "string",
                "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
            }
        },
        "creditCard": {
            "encrypt": {
                "keyId": "/keyAltName",
                "bsonType": "string",
                "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
            }
        }
    }
}

schema_map = {
    'hospital.patients': patient_schema
}

# CrÃ©er un client avec auto-encryption
def create_encrypted_client():
    auto_encryption_opts = AutoEncryptionOpts(
        kms_providers,
        key_vault_namespace,
        schema_map=schema_map
    )

    client = MongoClient(
        connection_string,
        auto_encryption_opts=auto_encryption_opts
    )

    return client

# CrÃ©ation de Data Encryption Keys
def create_data_keys():
    client = MongoClient(connection_string)
    client_encryption = ClientEncryption(
        kms_providers,
        key_vault_namespace,
        client,
        CodecOptions(uuid_representation=UUID_SUBTYPE)
    )

    # CrÃ©er une DEK pour SSN
    ssn_key_id = client_encryption.create_data_key(
        'aws',
        master_key={
            'key': 'arn:aws:kms:us-east-1:123456789012:key/abcd-1234',
            'region': 'us-east-1'
        },
        key_alt_names=['ssn-key']
    )

    print(f'SSN Key ID: {ssn_key_id}')

    # CrÃ©er une DEK pour cartes bancaires
    card_key_id = client_encryption.create_data_key(
        'aws',
        master_key={
            'key': 'arn:aws:kms:us-east-1:123456789012:key/abcd-1234',
            'region': 'us-east-1'
        },
        key_alt_names=['credit-card-key']
    )

    print(f'Card Key ID: {card_key_id}')

    client.close()

# Utilisation
def main():
    client = create_encrypted_client()

    try:
        db = client['hospital']
        patients = db['patients']

        # Insertion avec chiffrement automatique
        result = patients.insert_one({
            'name': 'Jane Smith',
            'ssn': '987-65-4321',  # ChiffrÃ© automatiquement
            'creditCard': '5500-0000-0000-0004',  # ChiffrÃ© automatiquement
            'age': 35,
            'email': 'jane@example.com'
        })

        print(f'Inserted patient: {result.inserted_id}')

        # Recherche avec dÃ©chiffrement automatique
        patient = patients.find_one({'ssn': '987-65-4321'})
        print(f'Found patient: {patient}')

    finally:
        client.close()

if __name__ == '__main__':
    main()
```

### ImplÃ©mentation Java

```java
// EncryptedMongoClient.java
import com.mongodb.ClientEncryptionSettings;
import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.vault.DataKeyOptions;
import com.mongodb.client.vault.ClientEncryption;
import com.mongodb.client.vault.ClientEncryptions;
import org.bson.BsonBinary;
import org.bson.BsonDocument;
import org.bson.Document;

import java.util.HashMap;
import java.util.Map;

public class EncryptedMongoClient {

    private static final String CONNECTION_STRING = "mongodb://localhost:27017";
    private static final String KEY_VAULT_NAMESPACE = "encryption.__keyVault";

    public static void main(String[] args) {
        // Configuration KMS
        Map<String, Map<String, Object>> kmsProviders = new HashMap<>();
        Map<String, Object> awsConfig = new HashMap<>();
        awsConfig.put("accessKeyId", System.getenv("AWS_ACCESS_KEY_ID"));
        awsConfig.put("secretAccessKey", System.getenv("AWS_SECRET_ACCESS_KEY"));
        kmsProviders.put("aws", awsConfig);

        // CrÃ©er une Data Encryption Key
        MongoClient keyVaultClient = MongoClients.create(CONNECTION_STRING);
        ClientEncryptionSettings encryptionSettings = ClientEncryptionSettings.builder()
            .keyVaultMongoClientSettings(
                MongoClientSettings.builder()
                    .applyConnectionString(new ConnectionString(CONNECTION_STRING))
                    .build()
            )
            .keyVaultNamespace(KEY_VAULT_NAMESPACE)
            .kmsProviders(kmsProviders)
            .build();

        ClientEncryption clientEncryption = ClientEncryptions.create(encryptionSettings);

        // CrÃ©er une DEK
        BsonBinary dataKeyId = clientEncryption.createDataKey("aws",
            new DataKeyOptions()
                .masterKey(new BsonDocument()
                    .append("key", new BsonString("arn:aws:kms:us-east-1:123456789012:key/abcd-1234"))
                    .append("region", new BsonString("us-east-1"))
                )
                .keyAltNames(Arrays.asList("ssn-key"))
        );

        System.out.println("Data Key ID: " + dataKeyId);

        // Configuration du schÃ©ma
        String schemaJson = "{"
            + "  'bsonType': 'object',"
            + "  'properties': {"
            + "    'ssn': {"
            + "      'encrypt': {"
            + "        'keyId': '/keyAltName',"
            + "        'bsonType': 'string',"
            + "        'algorithm': 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'"
            + "      }"
            + "    }"
            + "  }"
            + "}";

        HashMap<String, BsonDocument> schemaMap = new HashMap<>();
        schemaMap.put("hospital.patients", BsonDocument.parse(schemaJson));

        // Client avec auto-encryption
        AutoEncryptionSettings autoEncryptionSettings = AutoEncryptionSettings.builder()
            .keyVaultNamespace(KEY_VAULT_NAMESPACE)
            .kmsProviders(kmsProviders)
            .schemaMap(schemaMap)
            .build();

        MongoClientSettings clientSettings = MongoClientSettings.builder()
            .applyConnectionString(new ConnectionString(CONNECTION_STRING))
            .autoEncryptionSettings(autoEncryptionSettings)
            .build();

        MongoClient encryptedClient = MongoClients.create(clientSettings);

        // Utilisation
        MongoDatabase database = encryptedClient.getDatabase("hospital");
        MongoCollection<Document> collection = database.getCollection("patients");

        // Insertion avec chiffrement automatique
        Document patient = new Document()
            .append("name", "Alice Johnson")
            .append("ssn", "111-22-3333")  // Sera chiffrÃ© automatiquement
            .append("age", 42);

        collection.insertOne(patient);
        System.out.println("Patient inserted");

        // Recherche avec dÃ©chiffrement automatique
        Document found = collection.find(new Document("ssn", "111-22-3333")).first();
        System.out.println("Found patient: " + found.toJson());

        encryptedClient.close();
        keyVaultClient.close();
    }
}
```

## Performance et considÃ©rations

### Impact sur les performances

```
OpÃ©ration             â”‚ Sans CSFLE â”‚ Avec CSFLE â”‚ Overhead
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Insert (1 champ)      â”‚ 5ms        â”‚ 15ms       â”‚ +200%
Insert (5 champs)     â”‚ 5ms        â”‚ 35ms       â”‚ +600%
Find by _id           â”‚ 2ms        â”‚ 4ms        â”‚ +100%
Find by encrypted     â”‚ 3ms        â”‚ 8ms        â”‚ +167%
Update                â”‚ 8ms        â”‚ 25ms       â”‚ +212%
Bulk insert (100)     â”‚ 180ms      â”‚ 950ms      â”‚ +428%
```

**Facteurs d'impact** :

1. **Nombre de champs chiffrÃ©s** : Chaque champ ajoute un overhead
2. **Appels au KMS** : Peut Ãªtre mis en cache mais initial sync coÃ»teux
3. **Algorithme** : Deterministic lÃ©gÃ¨rement plus rapide que Random
4. **Taille des donnÃ©es** : Plus les donnÃ©es sont volumineuses, plus l'impact est important

### Optimisations

#### 1. Caching des Data Encryption Keys

```javascript
// Configuration du cache local
const autoEncryptionOpts = {
  keyVaultNamespace,
  kmsProviders,
  schemaMap,
  // Cache des DEKs en mÃ©moire
  extraOptions: {
    mongocryptdSpawnPath: '/usr/local/bin/mongocryptd'
  },
  // Taille du cache (nombre de DEKs)
  bypassAutoEncryption: false,
  // Options de cache KMS
  tlsOptions: {
    aws: {
      tlsCAFile: '/path/to/ca.pem',
      tlsCertificateKeyFile: '/path/to/client.pem'
    }
  }
};
```

**Impact** : RÃ©duction de 80-90% des appels au KMS aprÃ¨s le premier accÃ¨s.

#### 2. Chiffrer uniquement les champs nÃ©cessaires

```javascript
// âŒ Mauvais : Tout chiffrer
const badSchema = {
  properties: {
    name: { encrypt: { /* ... */ } },
    email: { encrypt: { /* ... */ } },
    phone: { encrypt: { /* ... */ } },
    address: { encrypt: { /* ... */ } },
    // Overhead massif
  }
};

// âœ… Bon : SÃ©lectif
const goodSchema = {
  properties: {
    ssn: { encrypt: { /* ... */ } },  // Vraiment sensible
    creditCard: { encrypt: { /* ... */ } }  // Vraiment sensible
    // name, email, phone, address en clair (moins sensibles)
  }
};
```

#### 3. Batch operations

```javascript
// âŒ Mauvais : Insertions individuelles
for (const patient of patients) {
  await collection.insertOne(patient);  // Overhead par insertion
}

// âœ… Bon : Batch insert
await collection.insertMany(patients);  // Overhead mutualisÃ©
```

#### 4. Connection pooling appropriÃ©

```javascript
const client = new MongoClient(connectionString, {
  autoEncryption: autoEncryptionOpts,
  maxPoolSize: 50,  // Augmenter pour CSFLE
  minPoolSize: 10,
  maxIdleTimeMS: 30000
});
```

### Limitations

```
Limitations de CSFLE :

âœ— Pas de range queries ($gt, $lt, $gte, $lte)
  â†’ MÃªme avec Deterministic

âœ— Pas de regex ou text search
  â†’ Sur les champs chiffrÃ©s

âœ— Pas de $in avec Random
  â†’ Uniquement avec Deterministic

âœ— Pas d'agrÃ©gation complexe
  â†’ $lookup, $graphLookup limitÃ©s

âœ— Pas de sort sur champs chiffrÃ©s
  â†’ Les valeurs chiffrÃ©es ne sont pas ordonnÃ©es

âœ— Taille maximale : 16 MB
  â†’ Limite BSON standard

âœ— Index limitÃ©s
  â†’ Seulement avec Deterministic

âœ— Change Streams limitÃ©s
  â†’ Filtres sur champs chiffrÃ©s impossibles
```

## Migration vers CSFLE

### StratÃ©gie 1 : Nouvelle application (greenfield)

```javascript
// 1. CrÃ©er le Key Vault et les DEKs
// 2. Configurer le schÃ©ma de chiffrement
// 3. DÃ©marrer l'application avec CSFLE activÃ©
// 4. Toutes les donnÃ©es sont chiffrÃ©es dÃ¨s le dÃ©part

// Aucune migration nÃ©cessaire !
```

### StratÃ©gie 2 : Migration d'une application existante

```javascript
// migration-to-csfle.js
const { MongoClient, ClientEncryption } = require('mongodb');

async function migrateToCSFLE() {
  // Client sans chiffrement pour lire les donnÃ©es existantes
  const plainClient = new MongoClient(connectionString);

  // Client avec chiffrement pour Ã©crire les donnÃ©es chiffrÃ©es
  const encryptedClient = await createEncryptedClient();

  try {
    await plainClient.connect();
    await encryptedClient.connect();

    const plainDb = plainClient.db('hospital');
    const encryptedDb = encryptedClient.db('hospital');

    const plainCollection = plainDb.collection('patients');
    const encryptedCollection = encryptedDb.collection('patients_encrypted');

    // Lire tous les documents
    const cursor = plainCollection.find({});

    let migrated = 0;

    while (await cursor.hasNext()) {
      const doc = await cursor.next();

      // Les champs sensibles seront automatiquement chiffrÃ©s
      // lors de l'insertion dans la collection avec CSFLE
      await encryptedCollection.insertOne(doc);

      migrated++;

      if (migrated % 1000 === 0) {
        console.log(`Migrated ${migrated} documents`);
      }
    }

    console.log(`Migration complete: ${migrated} documents`);

    // Optionnel : Renommer les collections
    // await plainCollection.rename('patients_backup');
    // await encryptedCollection.rename('patients');

  } finally {
    await plainClient.close();
    await encryptedClient.close();
  }
}

migrateToCSFLE().catch(console.error);
```

### StratÃ©gie 3 : Migration progressive (dual-write)

```javascript
// Migration progressive avec double Ã©criture
async function dualWriteStrategy() {
  const plainClient = new MongoClient(connectionString);
  const encryptedClient = await createEncryptedClient();

  await plainClient.connect();
  await encryptedClient.connect();

  const plainDb = plainClient.db('hospital');
  const encryptedDb = encryptedClient.db('hospital');

  // Phase 1 : Ã‰crire dans les deux collections
  async function insertPatient(patientData) {
    // Ã‰criture dans l'ancienne collection (sans chiffrement)
    await plainDb.collection('patients').insertOne(patientData);

    // Ã‰criture dans la nouvelle collection (avec chiffrement)
    await encryptedDb.collection('patients').insertOne(patientData);
  }

  // Phase 2 : Lire depuis la nouvelle collection
  async function findPatient(query) {
    return await encryptedDb.collection('patients').findOne(query);
  }

  // Phase 3 : AprÃ¨s migration complÃ¨te, supprimer l'ancienne collection
  // await plainDb.collection('patients').drop();
}
```

## Monitoring et debugging

### VÃ©rification du chiffrement

```javascript
// verify-encryption.js
async function verifyEncryption() {
  // Client SANS auto-decryption
  const plainClient = new MongoClient(connectionString);
  await plainClient.connect();

  const db = plainClient.db('hospital');
  const collection = db.collection('patients');

  // RÃ©cupÃ©rer un document
  const doc = await collection.findOne({});

  console.log('Document as stored in MongoDB:');
  console.log(JSON.stringify(doc, null, 2));

  // VÃ©rifier les champs chiffrÃ©s
  if (doc.ssn && doc.ssn._bsontype === 'Binary') {
    console.log('âœ“ SSN is encrypted (Binary type)');
    console.log('  Subtype:', doc.ssn.sub_type);  // Devrait Ãªtre 6
  } else {
    console.log('âœ— SSN is NOT encrypted');
  }

  await plainClient.close();
}
```

### Logging des opÃ©rations de chiffrement

```javascript
// Configuration du logging
const MongoClient = require('mongodb').MongoClient;
const Logger = require('mongodb').Logger;

// Activer le debug logging
Logger.setLevel('debug');
Logger.filter('class', ['AutoEncrypter']);

const client = new MongoClient(connectionString, {
  autoEncryption: autoEncryptionOpts,
  loggerLevel: 'debug'
});

// Les logs afficheront :
// - Champs identifiÃ©s pour chiffrement
// - Appels au KMS
// - Cache hits/misses
// - Erreurs de chiffrement/dÃ©chiffrement
```

### MÃ©triques de performance

```javascript
// metrics.js
const { performance } = require('perf_hooks');

async function measureEncryptionOverhead() {
  const plainClient = new MongoClient(connectionString);
  const encryptedClient = await createEncryptedClient();

  await plainClient.connect();
  await encryptedClient.connect();

  const testData = {
    name: 'Test Patient',
    ssn: '123-45-6789',
    creditCard: '4111-1111-1111-1111'
  };

  // Test sans chiffrement
  const plainStart = performance.now();
  await plainClient.db('test').collection('plain').insertOne(testData);
  const plainEnd = performance.now();

  // Test avec chiffrement
  const encryptedStart = performance.now();
  await encryptedClient.db('test').collection('encrypted').insertOne(testData);
  const encryptedEnd = performance.now();

  console.log('Plain insert:', (plainEnd - plainStart).toFixed(2), 'ms');
  console.log('Encrypted insert:', (encryptedEnd - encryptedStart).toFixed(2), 'ms');
  console.log('Overhead:', (((encryptedEnd - encryptedStart) / (plainEnd - plainStart) - 1) * 100).toFixed(1), '%');

  await plainClient.close();
  await encryptedClient.close();
}
```

## Troubleshooting

### Erreur : "key vault error"

```javascript
// Diagnostic
// 1. VÃ©rifier que le Key Vault existe
db = client.db('encryption');
keyVaultExists = db.listCollections({ name: '__keyVault' }).hasNext();
console.log('Key Vault exists:', keyVaultExists);

// 2. VÃ©rifier les permissions
// L'utilisateur doit avoir read/write sur encryption.__keyVault
db.runCommand({
  usersInfo: 'appUser',
  showPrivileges: true
});

// 3. VÃ©rifier les DEKs
db.getSiblingDB('encryption').getCollection('__keyVault').find().pretty();
```

### Erreur : "KMS request failed"

```bash
# Diagnostics
# 1. VÃ©rifier les credentials AWS
aws sts get-caller-identity

# 2. VÃ©rifier les permissions IAM
# La clÃ© KMS doit avoir la policy :
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Allow MongoDB to use the key",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:user/mongodb-app"
      },
      "Action": [
        "kms:Encrypt",
        "kms:Decrypt",
        "kms:GenerateDataKey"
      ],
      "Resource": "*"
    }
  ]
}

# 3. Tester la connectivitÃ© au KMS
curl https://kms.us-east-1.amazonaws.com
```

### Erreur : "mongocryptd not found"

```bash
# Installation de mongocryptd
# Ubuntu/Debian
wget https://downloads.mongodb.com/linux/mongodb-enterprise-cryptd-ubuntu2004-x86_64-4.4.0.tgz
tar -xvf mongodb-enterprise-cryptd-ubuntu2004-x86_64-4.4.0.tgz
sudo cp mongodb-enterprise-cryptd-ubuntu2004-x86_64-4.4.0/bin/mongocryptd /usr/local/bin/

# VÃ©rifier l'installation
mongocryptd --version

# Configuration dans l'application
const autoEncryptionOpts = {
  keyVaultNamespace,
  kmsProviders,
  schemaMap,
  extraOptions: {
    mongocryptdSpawnPath: '/usr/local/bin/mongocryptd',
    mongocryptdURI: 'mongodb://localhost:27020',
    mongocryptdBypassSpawn: false
  }
};
```

### Performance dÃ©gradÃ©e

```javascript
// 1. Activer le cache des DEKs
const autoEncryptionOpts = {
  keyVaultNamespace,
  kmsProviders,
  schemaMap,
  extraOptions: {
    cryptSharedLibPath: '/usr/local/lib/mongo_crypt_v1.so'  // Plus rapide que mongocryptd
  }
};

// 2. RÃ©duire le nombre de champs chiffrÃ©s
// Chiffrer uniquement ce qui est vraiment sensible

// 3. Augmenter le pool de connexions
const client = new MongoClient(connectionString, {
  autoEncryption: autoEncryptionOpts,
  maxPoolSize: 100,
  minPoolSize: 20
});

// 4. Utiliser des batch operations
await collection.insertMany(documents);  // Au lieu de insertOne en boucle
```

## Bonnes pratiques de production

### Checklist de dÃ©ploiement

```
â˜ Architecture
  â˜ KMS externe configurÃ© (AWS KMS, Azure, GCP, KMIP)
  â˜ Key Vault dans une base sÃ©parÃ©e (recommandÃ©)
  â˜ Backup du Key Vault (CRITIQUE)
  â˜ AccÃ¨s au Key Vault strictement contrÃ´lÃ©

â˜ ClÃ©s de chiffrement
  â˜ CMK dans un KMS externe (JAMAIS local en prod)
  â˜ DEKs crÃ©Ã©es pour chaque type de donnÃ©es sensibles
  â˜ Key rotation planifiÃ©e et documentÃ©e
  â˜ Backup des DEKs (avec CMK sÃ©parÃ©ment)

â˜ SchÃ©ma de chiffrement
  â˜ SchÃ©ma JSON validÃ© et testÃ©
  â˜ Algorithme appropriÃ© (Deterministic vs Random)
  â˜ Uniquement les champs vraiment sensibles
  â˜ Documentation des champs chiffrÃ©s

â˜ Application
  â˜ Driver MongoDB avec support CSFLE (4.2+)
  â˜ libmongocrypt installÃ©
  â˜ mongocryptd ou crypt_shared installÃ©
  â˜ Gestion d'erreurs robuste
  â˜ Logging appropriÃ©

â˜ Performance
  â˜ Benchmarks rÃ©alisÃ©s
  â˜ Cache des DEKs activÃ©
  â˜ Connection pooling appropriÃ©
  â˜ Monitoring des latences

â˜ SÃ©curitÃ©
  â˜ Credentials KMS sÃ©curisÃ©s (pas en clair dans le code)
  â˜ Rotation des credentials KMS planifiÃ©e
  â˜ Audit des accÃ¨s aux clÃ©s
  â˜ Tests de restauration

â˜ ConformitÃ©
  â˜ Documentation pour auditeurs
  â˜ Inventaire des donnÃ©es chiffrÃ©es
  â˜ ProcÃ©dures de gestion des clÃ©s
  â˜ Plan de rÃ©cupÃ©ration en cas de perte de clÃ©s
```

### Architecture de rÃ©fÃ©rence

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          VPC / RÃ©seau privÃ©                    â”‚
â”‚                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Application Tier  â”‚              â”‚  Application Tier  â”‚    â”‚
â”‚  â”‚  - Auto-encryption â”‚              â”‚  - Auto-encryption â”‚    â”‚
â”‚  â”‚  - DEKs cached     â”‚              â”‚  - DEKs cached     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚            â”‚                                   â”‚               â”‚
â”‚            â”‚ TLS + CSFLE                       â”‚ TLS + CSFLE   â”‚
â”‚            â†“                                   â†“               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           MongoDB Replica Set (Enterprise)               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚  â”‚
â”‚  â”‚  â”‚  Primary   â”‚  â”‚ Secondary  â”‚  â”‚ Secondary  â”‚          â”‚  â”‚
â”‚  â”‚  â”‚ (chiffrÃ©)  â”‚  â”‚ (chiffrÃ©)  â”‚  â”‚ (chiffrÃ©)  â”‚          â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚  â”‚
â”‚  â”‚                                                          â”‚  â”‚
â”‚  â”‚  Collections:                                            â”‚  â”‚
â”‚  â”‚  - hospital.patients (donnÃ©es chiffrÃ©es avec CSFLE)      â”‚  â”‚
â”‚  â”‚  - encryption.__keyVault (DEKs chiffrÃ©es)                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ API KMS (HTTPS)
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Cloud KMS (AWS/Azure/GCP)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Customer Master Keys (CMK)                                â”‚ â”‚
â”‚  â”‚  - mongodb-prod-cmk                                        â”‚ â”‚
â”‚  â”‚  - Rotation automatique activÃ©e                            â”‚ â”‚
â”‚  â”‚  - Audit logs activÃ©s                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Rotation des Data Encryption Keys

```javascript
// rotate-deks.js
const { MongoClient, ClientEncryption } = require('mongodb');

async function rotateDEKs() {
  const client = new MongoClient(connectionString);
  await client.connect();

  const clientEncryption = new ClientEncryption(client, {
    keyVaultNamespace: 'encryption.__keyVault',
    kmsProviders: {
      aws: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
      }
    }
  });

  try {
    // Lister toutes les DEKs
    const keyVault = client.db('encryption').collection('__keyVault');
    const keys = await keyVault.find({}).toArray();

    console.log(`Found ${keys.length} Data Encryption Keys`);

    for (const key of keys) {
      console.log(`Rotating key: ${key._id}`);

      // CrÃ©er une nouvelle version de la DEK
      const newKeyId = await clientEncryption.createDataKey('aws', {
        masterKey: key.masterKey,
        keyAltNames: key.keyAltNames.map(name => `${name}-v2`)
      });

      console.log(`  New key created: ${newKeyId}`);

      // Re-chiffrer les donnÃ©es avec la nouvelle clÃ©
      // Note : Cette opÃ©ration peut Ãªtre longue pour de grandes collections
      await rewrapData(client, key._id, newKeyId);

      // DÃ©sactiver l'ancienne clÃ© (pas supprimer immÃ©diatement)
      await keyVault.updateOne(
        { _id: key._id },
        { $set: { status: 0 } }  // 0 = disabled
      );

      console.log(`  Old key disabled`);
    }

    console.log('Rotation complete');

  } finally {
    await client.close();
  }
}

async function rewrapData(client, oldKeyId, newKeyId) {
  // ImplÃ©mentation spÃ©cifique Ã  votre schÃ©ma
  // Exemple : re-chiffrer le champ SSN

  const clientEncryption = new ClientEncryption(client, {
    keyVaultNamespace: 'encryption.__keyVault',
    kmsProviders: { /* ... */ }
  });

  const collection = client.db('hospital').collection('patients');
  const cursor = collection.find({});

  while (await cursor.hasNext()) {
    const doc = await cursor.next();

    // DÃ©chiffrer avec l'ancienne clÃ©
    const decrypted = await clientEncryption.decrypt(doc.ssn);

    // Re-chiffrer avec la nouvelle clÃ©
    const reencrypted = await clientEncryption.encrypt(decrypted, {
      keyId: newKeyId,
      algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'
    });

    // Mettre Ã  jour le document
    await collection.updateOne(
      { _id: doc._id },
      { $set: { ssn: reencrypted } }
    );
  }
}

rotateDEKs().catch(console.error);
```

### Disaster Recovery

```javascript
// disaster-recovery.js
async function testDisasterRecovery() {
  console.log('=== CSFLE Disaster Recovery Test ===');

  // ScÃ©nario 1 : Perte du Key Vault
  console.log('\n1. Testing Key Vault loss...');

  // Restaurer depuis backup
  // mongorestore --uri="mongodb://..." --db=encryption --collection=__keyVault /backup/keyVault

  // VÃ©rifier
  const keyVault = client.db('encryption').collection('__keyVault');
  const keyCount = await keyVault.countDocuments();
  console.log(`  Restored ${keyCount} keys`);

  // ScÃ©nario 2 : Perte d'accÃ¨s au KMS
  console.log('\n2. Testing KMS access loss...');

  // Solution : Avoir un KMS secondaire ou backup des CMKs
  // (Complexe, varie selon le provider)

  // ScÃ©nario 3 : Perte des credentials KMS
  console.log('\n3. Testing KMS credentials loss...');

  // Utiliser IAM roles ou managed identities plutÃ´t que des clÃ©s statiques
  // Rotation automatique des credentials

  console.log('\n=== Test complete ===');
}
```

## Conclusion

Client-Side Field Level Encryption (CSFLE) reprÃ©sente le niveau ultime de protection des donnÃ©es dans MongoDB, offrant une dÃ©fense en profondeur contre pratiquement tous les vecteurs d'attaque, y compris les administrateurs malveillants et la compromission totale de l'infrastructure.

**Points clÃ©s Ã  retenir** :

1. **Protection maximale** : Les donnÃ©es sont chiffrÃ©es avant mÃªme de quitter l'application
2. **Zero-trust** : MÃªme les administrateurs MongoDB ne peuvent pas voir les donnÃ©es sensibles
3. **ConformitÃ©** : Essentiel pour PCI-DSS niveau 1, HIPAA, et autres rÃ©glementations strictes
4. **ComplexitÃ©** : Requiert une architecture soignÃ©e et une gestion rigoureuse des clÃ©s
5. **Performance** : Impact significatif (+200-400%), Ã  prendre en compte dans le dimensionnement
6. **Limitations** : Pas de recherche complexe sur les champs chiffrÃ©s (sauf Queryable Encryption)

**Quand utiliser CSFLE** :

```
âœ“ DonnÃ©es hautement sensibles (SSN, cartes bancaires, dossiers mÃ©dicaux)
âœ“ ConformitÃ© rÃ©glementaire stricte (PCI-DSS L1, HIPAA)
âœ“ ModÃ¨le zero-trust requis
âœ“ Protection contre les administrateurs nÃ©cessaire
âœ“ Budget et expertise technique disponibles

âœ— Toutes les donnÃ©es (overhead trop important)
âœ— Besoin de recherche complexe sur tous les champs
âœ— Contraintes de performance strictes
âœ— Ã‰quipe sans expertise cryptographique
```

Pour une protection optimale, combiner CSFLE avec :
- TLS/SSL (chiffrement en transit)
- Encryption at Rest (chiffrement au repos)
- RBAC strict (contrÃ´le d'accÃ¨s)
- Audit logging (traÃ§abilitÃ©)

**Prochaine section** : 11.5.4 Queryable Encryption - CSFLE avec capacitÃ© de recherche sur donnÃ©es chiffrÃ©es.

---

**Ressources complÃ©mentaires** :
- MongoDB Manual : Client-Side Field Level Encryption
- NIST Guidelines for Key Management
- PCI-DSS Requirements for Cryptography
- HIPAA Security Rule Technical Safeguards

â­ï¸ [Queryable Encryption](/11-securite/05.4-queryable-encryption.md)
