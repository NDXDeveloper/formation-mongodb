üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.5.4 deleteOne() et deleteMany()

## Introduction

Nous arrivons √† la derni√®re op√©ration CRUD : la **suppression**. Supprimer des documents est une op√©ration sensible qui n√©cessite de la prudence, car elle est **irr√©versible**.

> **‚ö†Ô∏è ATTENTION :** La suppression est **d√©finitive**. Une fois un document supprim√©, il est impossible de le r√©cup√©rer (sauf si vous avez une sauvegarde).

Dans cette section, nous allons explorer :
- Comment supprimer un document avec `deleteOne()`
- Comment supprimer plusieurs documents avec `deleteMany()`
- Les pr√©cautions essentielles √† prendre
- Les filtres de suppression
- Les alternatives √† la suppression d√©finitive
- Les bonnes pratiques

---

## deleteOne() : Supprimer un Seul Document

### Syntaxe de Base

```javascript
db.collection.deleteOne(filtre, options)
```

**Param√®tres :**
- `filtre` : Crit√®res pour trouver le document √† supprimer
- `options` : Options facultatives (collation, hint, etc.)

**Retour :**
```javascript
{
  acknowledged: true,
  deletedCount: 1    // Nombre de documents supprim√©s (0 ou 1)
}
```

### Premier Exemple Simple

```javascript
// Supprimer un utilisateur par son _id
db.utilisateurs.deleteOne({
  _id: ObjectId("6565d7d8f2a3b4c5d6e7f8a9")
})
```

**R√©sultat :**
```javascript
{
  acknowledged: true,
  deletedCount: 1
}
```

**Explication :**
- `acknowledged: true` ‚Üí L'op√©ration a √©t√© confirm√©e
- `deletedCount: 1` ‚Üí Un document a √©t√© supprim√©

### ‚ö†Ô∏è Important : Un Seul Document

**deleteOne() supprime SEULEMENT le premier document qui correspond au filtre.**

```javascript
// Deux utilisateurs s'appellent "Dupont"
db.utilisateurs.insertMany([
  { nom: "Dupont", prenom: "Jean", age: 30 },
  { nom: "Dupont", prenom: "Marie", age: 28 }
])

// Supprimer par nom
db.utilisateurs.deleteOne({ nom: "Dupont" })

// R√©sultat : SEULEMENT Jean est supprim√© (le premier trouv√©)
// Marie reste dans la base
```

### Document Non Trouv√©

```javascript
// Supprimer un document inexistant
let resultat = db.utilisateurs.deleteOne({
  email: "inexistant@example.com"
})

print(resultat.deletedCount)  // 0
```

**Aucune erreur n'est lev√©e, mais deletedCount = 0.**

### Supprimer par _id (Recommand√©)

**La m√©thode la plus s√ªre : supprimer par identifiant unique.**

```javascript
// Supprimer un document sp√©cifique
db.utilisateurs.deleteOne({
  _id: ObjectId("6565d7d8f2a3b4c5d6e7f8a9")
})

// Avec _id de type String
db.produits.deleteOne({
  _id: "PROD-001"
})

// Avec _id de type Integer
db.commandes.deleteOne({
  _id: 12345
})
```

**Pourquoi c'est plus s√ªr ?**
- ‚úÖ L'_id est **unique**
- ‚úÖ Impossible de supprimer le mauvais document
- ‚úÖ Pas d'ambigu√Øt√©

### Supprimer par un Autre Champ

```javascript
// Supprimer par email (si unique)
db.utilisateurs.deleteOne({
  email: "dupont@example.com"
})

// Supprimer par plusieurs crit√®res
db.articles.deleteOne({
  titre: "Article √† supprimer",
  statut: "brouillon"
})
```

**‚ö†Ô∏è Attention :** Si plusieurs documents correspondent, seul le premier sera supprim√© !

---

## deleteMany() : Supprimer Plusieurs Documents

### Syntaxe

```javascript
db.collection.deleteMany(filtre, options)
```

**La diff√©rence :** deleteMany() supprime **TOUS** les documents qui correspondent au filtre.

### Exemple Simple

```javascript
// Supprimer tous les utilisateurs inactifs
db.utilisateurs.deleteMany({
  actif: false
})
```

**R√©sultat :**
```javascript
{
  acknowledged: true,
  deletedCount: 15    // 15 documents supprim√©s
}
```

### ‚ö†Ô∏è DANGER : Supprimer Tous les Documents

```javascript
// ‚ùå TR√àS DANGEREUX : Supprime TOUS les documents
db.utilisateurs.deleteMany({})

// √âquivalent √† vider la collection
```

**Cons√©quences :**
- Tous les documents sont supprim√©s
- La collection reste (vide)
- Les index restent
- **Op√©ration IRR√âVERSIBLE**

### Cas d'Usage Typiques

**1. Nettoyage de donn√©es obsol√®tes :**
```javascript
// Supprimer les logs de plus d'un mois
db.logs.deleteMany({
  timestamp: {
    $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
  }
})
```

**2. Suppression par statut :**
```javascript
// Supprimer les commandes annul√©es
db.commandes.deleteMany({
  statut: "annulee"
})
```

**3. Suppression par cat√©gorie :**
```javascript
// Supprimer tous les produits d'une cat√©gorie
db.produits.deleteMany({
  categorie: "Obsolete"
})
```

**4. Suppression conditionnelle :**
```javascript
// Supprimer les utilisateurs non activ√©s depuis plus de 7 jours
db.utilisateurs.deleteMany({
  actif: false,
  dateInscription: {
    $lt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
  }
})
```

---

## Pr√©cautions Essentielles

### ‚ö†Ô∏è R√®gles de S√©curit√©

**1. TOUJOURS tester avec find() d'abord :**

```javascript
// ‚úÖ √âTAPE 1 : V√©rifier quels documents seront supprim√©s
db.utilisateurs.find({ actif: false })

// ‚úÖ √âTAPE 2 : Compter combien
db.utilisateurs.countDocuments({ actif: false })
// Sortie : 15

// ‚úÖ √âTAPE 3 : Seulement si c'est correct, supprimer
db.utilisateurs.deleteMany({ actif: false })
```

**2. Utilisez des sauvegardes :**

```javascript
// ‚úÖ Sauvegarder avant suppression massive
// Depuis la ligne de commande :
// mongodump --db=mabase --collection=utilisateurs

// Puis supprimer
db.utilisateurs.deleteMany({ condition: true })
```

**3. Pr√©f√©rez deleteOne() quand possible :**

```javascript
// ‚úÖ Bon : Suppression cibl√©e
db.utilisateurs.deleteOne({ _id: ObjectId("...") })

// ‚ö†Ô∏è Risqu√© : Peut supprimer plusieurs
db.utilisateurs.deleteMany({ nom: "Dupont" })
```

**4. Double v√©rification pour deleteMany({}) :**

```javascript
// ‚ùå NE JAMAIS FAIRE EN PRODUCTION
db.production_users.deleteMany({})

// ‚úÖ Si vraiment n√©cessaire, v√©rifier 10 fois
let count = db.test_users.countDocuments()
print(`ATTENTION : ${count} documents seront supprim√©s`)
// R√©fl√©chir...
// R√©fl√©chir encore...
// db.test_users.deleteMany({})  // D√©commenter seulement si certain
```

---

## V√©rifications Avant Suppression

### Compter les Documents

```javascript
// Compter avant de supprimer
let count = db.logs.countDocuments({
  timestamp: { $lt: new Date("2024-01-01") }
})

print(`${count} documents seront supprim√©s`)

if (count > 0) {
  // Supprimer
  db.logs.deleteMany({
    timestamp: { $lt: new Date("2024-01-01") }
  })
}
```

### Afficher un √âchantillon

```javascript
// Voir quelques exemples de documents √† supprimer
db.articles.find({ statut: "brouillon" }).limit(5)

// Si √ßa semble correct
db.articles.deleteMany({ statut: "brouillon" })
```

### Confirmation Interactive

```javascript
// Script avec confirmation
let filtre = { actif: false }
let count = db.utilisateurs.countDocuments(filtre)

print(`${count} utilisateurs inactifs seront supprim√©s`)
print("√ätes-vous s√ªr ? (D√©commentez pour confirmer)")

// db.utilisateurs.deleteMany(filtre)
```

---

## Filtres de Suppression

### Suppression Simple

```javascript
// Par un champ
db.utilisateurs.deleteMany({ ville: "Paris" })

// Par plusieurs champs
db.produits.deleteMany({
  categorie: "√âlectronique",
  stock: 0
})
```

### Suppression avec Op√©rateurs

```javascript
// Supprimer les vieux documents
db.logs.deleteMany({
  timestamp: { $lt: ISODate("2024-01-01") }
})

// Supprimer par plage
db.commandes.deleteMany({
  total: { $lt: 10 }
})

// Supprimer par exclusion
db.utilisateurs.deleteMany({
  role: { $ne: "admin" }
})
```

### Suppression avec $in

```javascript
// Supprimer plusieurs valeurs
db.produits.deleteMany({
  categorie: { $in: ["Obsolete", "Discontinued", "Retired"] }
})

// Supprimer des IDs sp√©cifiques
db.articles.deleteMany({
  _id: {
    $in: [
      ObjectId("..."),
      ObjectId("..."),
      ObjectId("...")
    ]
  }
})
```

### Suppression avec $or

```javascript
// Supprimer si condition A OU condition B
db.utilisateurs.deleteMany({
  $or: [
    { actif: false },
    { dateInscription: { $lt: ISODate("2020-01-01") } }
  ]
})
```

### Suppression sur Champs Imbriqu√©s

```javascript
// Supprimer par champ imbriqu√©
db.utilisateurs.deleteMany({
  "adresse.pays": "France",
  "adresse.ville": "Paris"
})
```

### Suppression sur Tableaux

```javascript
// Supprimer les documents qui ont un tag sp√©cifique
db.articles.deleteMany({
  tags: "obsolete"
})

// Supprimer si tableau vide
db.produits.deleteMany({
  images: { $size: 0 }
})
```

---

## Alternatives √† la Suppression D√©finitive

### Soft Delete (Suppression Logique)

**Plut√¥t que de supprimer, marquez comme supprim√© :**

```javascript
// Au lieu de deleteOne()
db.utilisateurs.deleteOne({ _id: ObjectId("...") })

// Utilisez updateOne() avec un flag
db.utilisateurs.updateOne(
  { _id: ObjectId("...") },
  {
    $set: {
      supprime: true,
      dateSuppression: new Date()
    }
  }
)
```

**Avantages du Soft Delete :**
- ‚úÖ R√©cup√©ration possible
- ‚úÖ Audit trail (tra√ßabilit√©)
- ‚úÖ Moins risqu√©
- ‚úÖ Possibilit√© de restaurer

**Requ√™tes avec Soft Delete :**
```javascript
// Trouver les documents non supprim√©s
db.utilisateurs.find({ supprime: { $ne: true } })

// Ou avec un index
db.utilisateurs.find({ supprime: false })
```

### Archivage

**D√©placer dans une collection d'archives :**

```javascript
// 1. Copier dans la collection archives
let documents = db.articles.find({ archive: true }).toArray()
db.articles_archives.insertMany(documents)

// 2. Supprimer de la collection principale
db.articles.deleteMany({ archive: true })
```

### Expiration Automatique (TTL)

**Pour les donn√©es temporaires, utilisez un index TTL :**

```javascript
// Cr√©er un index TTL (expire apr√®s 30 jours)
db.logs.createIndex(
  { dateCreation: 1 },
  { expireAfterSeconds: 2592000 }  // 30 jours
)

// Les documents s'auto-suppriment apr√®s 30 jours
db.logs.insertOne({
  message: "Log entry",
  dateCreation: new Date()
})
```

---

## Cas d'Usage Pratiques

### Blog : Suppression d'Articles

```javascript
// Supprimer un brouillon sp√©cifique
db.articles.deleteOne({
  _id: ObjectId("..."),
  statut: "brouillon"
})

// Supprimer tous les brouillons de plus de 30 jours
db.articles.deleteMany({
  statut: "brouillon",
  dateCreation: {
    $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
  }
})

// Soft delete d'un article publi√©
db.articles.updateOne(
  { _id: ObjectId("...") },
  {
    $set: {
      supprime: true,
      dateSuppression: new Date()
    }
  }
)

// Supprimer les commentaires d'un utilisateur
db.commentaires.deleteMany({
  auteurId: ObjectId("...")
})
```

### E-commerce : Gestion de Produits

```javascript
// Supprimer un produit
db.produits.deleteOne({
  _id: "PROD-001"
})

// Supprimer les produits obsol√®tes
db.produits.deleteMany({
  statut: "obsolete"
})

// Supprimer les paniers abandonn√©s (> 7 jours)
db.paniers.deleteMany({
  dateCreation: {
    $lt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
  },
  statut: "en_cours"
})

// Nettoyer les commandes annul√©es de plus d'un an
db.commandes.deleteMany({
  statut: "annulee",
  dateAnnulation: {
    $lt: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000)
  }
})
```

### Application de Gestion : T√¢ches

```javascript
// Supprimer une t√¢che termin√©e
db.taches.deleteOne({
  _id: ObjectId("..."),
  statut: "termine"
})

// Archiver les t√¢ches termin√©es (soft delete)
db.taches.updateMany(
  {
    statut: "termine",
    dateTerminee: {
      $lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
    }
  },
  {
    $set: { archive: true }
  }
)

// Supprimer les t√¢ches annul√©es
db.taches.deleteMany({
  statut: "annulee"
})
```

### Logs et Donn√©es Temporaires

```javascript
// Supprimer les logs de plus d'un mois
db.logs.deleteMany({
  timestamp: {
    $lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
  }
})

// Supprimer les sessions expir√©es
db.sessions.deleteMany({
  expireAt: { $lt: new Date() }
})

// Nettoyer les tokens invalides
db.tokens.deleteMany({
  $or: [
    { expire: { $lt: new Date() } },
    { revoque: true }
  ]
})
```

### Nettoyage de Tests

```javascript
// Supprimer toutes les donn√©es de test
db.utilisateurs.deleteMany({
  email: { $regex: /^test.*@example\.com$/ }
})

// Supprimer les donn√©es de d√©monstration
db.produits.deleteMany({
  demo: true
})
```

---

## Gestion des Erreurs

### V√©rifier le R√©sultat

```javascript
let resultat = db.utilisateurs.deleteOne({
  _id: ObjectId("...")
})

if (resultat.deletedCount === 0) {
  print("Document non trouv√© ou d√©j√† supprim√©")
} else {
  print("Document supprim√© avec succ√®s")
}
```

### Try-Catch

```javascript
try {
  let resultat = db.articles.deleteMany({
    statut: "brouillon"
  })

  print(`${resultat.deletedCount} documents supprim√©s`)

} catch (e) {
  print("Erreur lors de la suppression : " + e.message)
}
```

### Validation Avant Suppression

```javascript
function supprimerUtilisateur(userId) {
  // V√©rifier l'existence
  let user = db.utilisateurs.findOne({ _id: userId })

  if (!user) {
    print("Utilisateur non trouv√©")
    return false
  }

  // V√©rifier les d√©pendances
  let commandesActives = db.commandes.countDocuments({
    userId: userId,
    statut: "en_cours"
  })

  if (commandesActives > 0) {
    print("Impossible : L'utilisateur a des commandes actives")
    return false
  }

  // Supprimer
  let resultat = db.utilisateurs.deleteOne({ _id: userId })
  return resultat.deletedCount === 1
}

// Utilisation
supprimerUtilisateur(ObjectId("..."))
```

---

## Suppression en Cascade

### Supprimer les Documents Li√©s

```javascript
// Supprimer un article et tous ses commentaires
let articleId = ObjectId("...")

// 1. Supprimer les commentaires
db.commentaires.deleteMany({ articleId: articleId })

// 2. Supprimer l'article
db.articles.deleteOne({ _id: articleId })
```

### Fonction de Suppression Compl√®te

```javascript
function supprimerArticleComplet(articleId) {
  try {
    // Supprimer les commentaires
    let commentsResult = db.commentaires.deleteMany({
      articleId: articleId
    })
    print(`${commentsResult.deletedCount} commentaires supprim√©s`)

    // Supprimer les likes
    let likesResult = db.likes.deleteMany({
      articleId: articleId
    })
    print(`${likesResult.deletedCount} likes supprim√©s`)

    // Supprimer l'article
    let articleResult = db.articles.deleteOne({
      _id: articleId
    })

    if (articleResult.deletedCount === 1) {
      print("Article supprim√© avec succ√®s")
      return true
    } else {
      print("Article non trouv√©")
      return false
    }

  } catch (e) {
    print("Erreur : " + e.message)
    return false
  }
}

// Utilisation
supprimerArticleComplet(ObjectId("..."))
```

---

## Performance et Optimisation

### Index pour les Suppressions

**Les suppressions b√©n√©ficient aussi des index :**

```javascript
// Cr√©er un index sur le champ utilis√© pour supprimer
db.logs.createIndex({ timestamp: 1 })

// Suppression plus rapide
db.logs.deleteMany({
  timestamp: { $lt: new Date("2024-01-01") }
})
```

### Suppression par Lots

**Pour supprimer beaucoup de documents, faites-le par lots :**

```javascript
// ‚ùå Lent : Suppression de millions de documents en une fois
db.logs.deleteMany({
  timestamp: { $lt: new Date("2024-01-01") }
})

// ‚úÖ Plus rapide : Suppression par lots
function supprimerParLots(collection, filtre, tailleLot = 1000) {
  let total = 0
  let count = 0

  do {
    let resultat = collection.deleteMany(
      filtre,
      { limit: tailleLot }  // Note : limit pas support√© dans deleteMany
    )
    count = resultat.deletedCount
    total += count
    print(`${total} documents supprim√©s...`)
  } while (count === tailleLot)

  print(`Total : ${total} documents supprim√©s`)
}
```

**Note :** MongoDB ne supporte pas `limit` dans deleteMany. Une alternative :

```javascript
// Alternative avec find + deleteOne en boucle
let idsASupprimer = db.logs
  .find(
    { timestamp: { $lt: new Date("2024-01-01") } },
    { _id: 1 }
  )
  .limit(1000)
  .toArray()
  .map(doc => doc._id)

db.logs.deleteMany({
  _id: { $in: idsASupprimer }
})
```

---

## Bonnes Pratiques

### ‚úÖ √Ä Faire

1. **Toujours tester avec find() d'abord**
   ```javascript
   // ‚úÖ √âtape 1 : Visualiser
   db.logs.find({ old: true }).limit(5)

   // ‚úÖ √âtape 2 : Compter
   db.logs.countDocuments({ old: true })

   // ‚úÖ √âtape 3 : Supprimer
   db.logs.deleteMany({ old: true })
   ```

2. **Utiliser des filtres sp√©cifiques**
   ```javascript
   // ‚úÖ Bon : Filtre pr√©cis
   db.users.deleteOne({ _id: ObjectId("...") })

   // ‚ö†Ô∏è Risqu√© : Filtre vague
   db.users.deleteMany({ actif: false })  // Combien ?
   ```

3. **Pr√©f√©rer le soft delete pour les donn√©es importantes**
   ```javascript
   // ‚úÖ R√©cup√©rable
   db.utilisateurs.updateOne(
     { _id: ObjectId("...") },
     { $set: { supprime: true } }
   )

   // ‚ùå Irr√©versible
   db.utilisateurs.deleteOne({ _id: ObjectId("...") })
   ```

4. **Sauvegarder avant suppressions massives**
   ```bash
   # ‚úÖ Backup avant
   mongodump --db=mabase --collection=logs

   # Puis supprimer
   mongosh mabase --eval "db.logs.deleteMany({})"
   ```

5. **Logger les suppressions importantes**
   ```javascript
   // Logger avant de supprimer
   let doc = db.articles.findOne({ _id: ObjectId("...") })
   db.deletionLogs.insertOne({
     collection: "articles",
     document: doc,
     datesuppression: new Date(),
     utilisateur: "admin"
   })

   // Puis supprimer
   db.articles.deleteOne({ _id: doc._id })
   ```

6. **Utiliser des transactions pour la coh√©rence**
   ```javascript
   // Avec transaction (replica set requis)
   const session = db.getMongo().startSession()
   session.startTransaction()

   try {
     db.articles.deleteOne({ _id: ObjectId("...") }, { session })
     db.commentaires.deleteMany({ articleId: ObjectId("...") }, { session })

     session.commitTransaction()
   } catch (e) {
     session.abortTransaction()
     throw e
   } finally {
     session.endSession()
   }
   ```

### ‚ùå √Ä √âviter

1. **Supprimer sans v√©rification**
   ```javascript
   // ‚ùå DANGEREUX
   db.users.deleteMany({ role: "user" })  // Combien ?

   // ‚úÖ Avec v√©rification
   let count = db.users.countDocuments({ role: "user" })
   print(`${count} utilisateurs seront supprim√©s`)
   // Confirmer manuellement puis :
   // db.users.deleteMany({ role: "user" })
   ```

2. **deleteMany({}) en production**
   ```javascript
   // ‚ùå NE JAMAIS FAIRE
   db.production_data.deleteMany({})

   // ‚úÖ Toujours avec un filtre
   db.test_data.deleteMany({ test: true })
   ```

3. **Supprimer sans g√©rer les d√©pendances**
   ```javascript
   // ‚ùå Laisse des donn√©es orphelines
   db.utilisateurs.deleteOne({ _id: userId })
   // Les commandes de cet utilisateur restent...

   // ‚úÖ Supprimer les d√©pendances d'abord
   db.commandes.deleteMany({ userId: userId })
   db.utilisateurs.deleteOne({ _id: userId })
   ```

4. **Ignorer le r√©sultat de la suppression**
   ```javascript
   // ‚ùå Pas de v√©rification
   db.users.deleteOne({ _id: ObjectId("...") })

   // ‚úÖ V√©rifier le r√©sultat
   let result = db.users.deleteOne({ _id: ObjectId("...") })
   if (result.deletedCount === 0) {
     print("Erreur : Document non trouv√©")
   }
   ```

---

## Comparaison avec SQL

### SQL DELETE

```sql
-- Supprimer un enregistrement
DELETE FROM utilisateurs
WHERE id = 1;

-- Supprimer plusieurs enregistrements
DELETE FROM logs
WHERE timestamp < '2024-01-01';

-- Supprimer tous les enregistrements (DANGER)
DELETE FROM table;

-- Truncate (plus rapide)
TRUNCATE TABLE logs;
```

### MongoDB DELETE

```javascript
// Supprimer un document
db.utilisateurs.deleteOne({ _id: 1 })

// Supprimer plusieurs documents
db.logs.deleteMany({
  timestamp: { $lt: ISODate("2024-01-01") }
})

// Supprimer tous les documents (DANGER)
db.collection.deleteMany({})

// Vider la collection (√©quivalent TRUNCATE)
db.collection.drop()  // Supprime aussi les index
```

**Diff√©rences principales :**
- MongoDB : `deleteOne()` vs `deleteMany()` (explicite)
- SQL : `DELETE` pour tout (risque de tout supprimer par erreur)
- MongoDB : Plus difficile de tout supprimer par accident

---

## Commandes Alternatives

### drop() : Supprimer la Collection Compl√®te

```javascript
// Supprimer la collection enti√®re (structure + donn√©es)
db.logs.drop()

// Plus rapide que deleteMany({})
// Supprime aussi les index
```

**Quand utiliser :**
- ‚úÖ Vous voulez supprimer TOUT (donn√©es + structure)
- ‚úÖ Vous voulez recr√©er la collection
- ‚úÖ Performance critique (plus rapide)

### findOneAndDelete() : Supprimer et Retourner

```javascript
// Supprimer et retourner le document supprim√©
let documentSupprime = db.utilisateurs.findOneAndDelete({
  email: "dupont@example.com"
})

print(documentSupprime)
```

**Utile pour :**
- Logger ce qui a √©t√© supprim√©
- V√©rifier le contenu avant de confirmer
- Afficher un message √† l'utilisateur

---

## Points Cl√©s √† Retenir

### ‚úÖ Essentiel

1. **deleteOne()** : Supprime le premier document correspondant
2. **deleteMany()** : Supprime tous les documents correspondants
3. **Irr√©versible** : Pas de r√©cup√©ration possible (sauf backup)
4. **Toujours v√©rifier** : Utilisez find() avant delete()
5. **Soft delete** : Alternative r√©cup√©rable pour donn√©es importantes
6. **Filtres pr√©cis** : Utilisez des crit√®res sp√©cifiques
7. **Sauvegardes** : Backup avant suppressions massives

### üéØ Syntaxe √† Retenir

```javascript
// Suppression unique
db.collection.deleteOne({ _id: ObjectId("...") })

// Suppression multiple avec filtre
db.collection.deleteMany({ statut: "obsolete" })

// V√©rification avant suppression
let count = db.collection.countDocuments(filtre)
print(`${count} documents seront supprim√©s`)
db.collection.deleteMany(filtre)

// Soft delete (alternative)
db.collection.updateOne(
  { _id: ObjectId("...") },
  { $set: { supprime: true, dateSuppression: new Date() } }
)
```

### ‚ö†Ô∏è R√®gles d'Or

1. **TOUJOURS** tester avec `find()` d'abord
2. **JAMAIS** `deleteMany({})` en production sans triple v√©rification
3. **TOUJOURS** v√©rifier `deletedCount` dans le r√©sultat
4. **TOUJOURS** avoir des sauvegardes √† jour
5. **PR√âF√âRER** le soft delete pour les donn√©es critiques

---

## Conclusion du CRUD

**F√©licitations ! Vous ma√Ætrisez maintenant les 4 op√©rations CRUD :**

1. ‚úÖ **Create** : `insertOne()`, `insertMany()`
2. ‚úÖ **Read** : `find()`, `findOne()`
3. ‚úÖ **Update** : `updateOne()`, `updateMany()`
4. ‚úÖ **Delete** : `deleteOne()`, `deleteMany()`

Ces op√©rations constituent la base de toute interaction avec MongoDB. Vous √™tes maintenant pr√™t pour des concepts plus avanc√©s !

---

## Prochaines √âtapes

Maintenant que vous ma√Ætrisez le CRUD, explorons d'autres op√©rations :

‚û°Ô∏è **2.5.5 replaceOne()** : Remplacer compl√®tement un document

Vous avez termin√© les op√©rations CRUD fondamentales ! üéâ

---

## Ressources Compl√©mentaires

### Documentation Officielle

- [deleteOne() - MongoDB Manual](https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/)
- [deleteMany() - MongoDB Manual](https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/)
- [findOneAndDelete() - MongoDB Manual](https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/)

### Pour Aller Plus Loin

- Soft delete patterns et strat√©gies
- Bulk delete operations pour performances
- Transactions pour suppressions coh√©rentes multi-collections
- TTL indexes pour auto-suppression temporis√©e

---


‚è≠Ô∏è [replaceOne()](/02-fondamentaux-de-mongodb/05.5-replace.md)
