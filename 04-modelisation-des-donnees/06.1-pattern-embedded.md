üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.6.1 Pattern Embedded (Documents Imbriqu√©s)

## Introduction

Le **Pattern Embedded** (ou pattern de documents imbriqu√©s) est l'un des patterns de mod√©lisation les plus fondamentaux et les plus utilis√©s dans MongoDB. Il consiste √† **int√©grer directement les donn√©es li√©es √† l'int√©rieur d'un seul document** plut√¥t que de les s√©parer en plusieurs collections.

Ce pattern tire pleinement parti de la structure flexible des documents MongoDB et de leur capacit√© √† contenir des sous-documents et des tableaux.

---

## Concept de Base

Dans une base de donn√©es relationnelle, vous s√©parez g√©n√©ralement les donn√©es en plusieurs tables li√©es par des cl√©s √©trang√®res. Avec le Pattern Embedded, vous regroupez ces donn√©es dans un seul document.

### Exemple Simple : Blog

**Approche relationnelle (SQL) :**
```sql
-- Table articles
id | titre              | contenu           | auteur_id
1  | MongoDB Tutorial  | Contenu...        | 101

-- Table auteurs
id  | nom           | email
101 | Jean Dupont   | jean@example.com
```

**Approche MongoDB avec Pattern Embedded :**
```javascript
{
  _id: 1,
  titre: "MongoDB Tutorial",
  contenu: "Contenu...",
  auteur: {
    nom: "Jean Dupont",
    email: "jean@example.com"
  }
}
```

Dans cet exemple, les informations de l'auteur sont **imbriqu√©es** directement dans le document de l'article.

---

## Quand Utiliser le Pattern Embedded ?

Le Pattern Embedded est recommand√© dans les situations suivantes :

### 1. **Relation "One-to-One" (Un-√†-Un)**

Lorsqu'une entit√© est toujours associ√©e √† une seule autre entit√©.

**Exemple : Utilisateur et Profil**
```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  username: "marie_dupont",
  email: "marie@example.com",
  profil: {
    dateNaissance: ISODate("1990-05-15"),
    ville: "Paris",
    pays: "France",
    bio: "D√©veloppeuse passionn√©e par MongoDB",
    avatar: "https://example.com/avatars/marie.jpg"
  },
  dateInscription: ISODate("2024-01-10")
}
```

### 2. **Relation "One-to-Few" (Un-√†-Quelques)**

Quand une entit√© est li√©e √† un **petit nombre** d'autres entit√©s (g√©n√©ralement moins de 100).

**Exemple : Commande avec Adresses**
```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439012"),
  numeroCommande: "CMD-2024-001",
  client: "Sophie Martin",
  dateCommande: ISODate("2024-11-15"),
  adresseLivraison: {
    rue: "123 Avenue des Champs",
    ville: "Lyon",
    codePostal: "69001",
    pays: "France"
  },
  adresseFacturation: {
    rue: "456 Rue de la R√©publique",
    ville: "Lyon",
    codePostal: "69002",
    pays: "France"
  },
  montantTotal: 299.99
}
```

### 3. **Les Donn√©es Sont Toujours Consult√©es Ensemble**

Si vous lisez presque toujours les donn√©es en m√™me temps, il est logique de les regrouper.

**Exemple : Article de Blog avec M√©tadonn√©es**
```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439013"),
  titre: "Introduction √† MongoDB",
  contenu: "MongoDB est une base de donn√©es NoSQL...",
  auteur: {
    nom: "Pierre Leroy",
    email: "pierre@example.com"
  },
  metadata: {
    datePublication: ISODate("2024-11-01"),
    derniereModification: ISODate("2024-11-20"),
    categorie: "Tutoriel",
    tags: ["MongoDB", "NoSQL", "Base de donn√©es"],
    nombreVues: 1523,
    tempsLecture: 5
  }
}
```

### 4. **Les Donn√©es Imbriqu√©es N'Ont Pas de Sens Ind√©pendamment**

Quand les sous-documents n'ont de sens que dans le contexte du document parent.

**Exemple : Produit E-commerce avec Variantes**
```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439014"),
  nom: "T-Shirt Classic",
  marque: "FashionCo",
  description: "T-shirt 100% coton",
  prixBase: 29.99,
  variantes: [
    {
      taille: "S",
      couleur: "Bleu",
      sku: "TSH-BLU-S",
      stock: 15
    },
    {
      taille: "M",
      couleur: "Bleu",
      sku: "TSH-BLU-M",
      stock: 23
    },
    {
      taille: "S",
      couleur: "Rouge",
      sku: "TSH-ROU-S",
      stock: 8
    }
  ]
}
```

---

## Avantages du Pattern Embedded

### ‚úÖ 1. **Performance de Lecture**

**Une seule requ√™te suffit** pour obtenir toutes les donn√©es li√©es :

```javascript
// Une seule requ√™te pour tout r√©cup√©rer
db.articles.findOne({ _id: ObjectId("507f1f77bcf86cd799439013") })
```

Vous obtenez l'article, l'auteur et les m√©tadonn√©es en une seule op√©ration, ce qui est **beaucoup plus rapide** que de faire plusieurs requ√™tes s√©par√©es.

### ‚úÖ 2. **Atomicit√©**

Les modifications sur un document sont **atomiques** par nature dans MongoDB :

```javascript
// Mise √† jour atomique de l'article et de ses m√©tadonn√©es
db.articles.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439013") },
  {
    $set: {
      "contenu": "Nouveau contenu mis √† jour...",
      "metadata.derniereModification": new Date(),
      "metadata.nombreVues": 1524
    }
  }
)
```

Toutes ces modifications sont garanties d'√™tre appliqu√©es ensemble ou pas du tout.

### ‚úÖ 3. **Simplicit√© du Code**

Le code applicatif est plus simple car vous manipulez un seul objet :

```javascript
// Exemple en Node.js
const article = await db.collection('articles').findOne({ _id: articleId });

// Acc√®s direct aux donn√©es imbriqu√©es
console.log(article.auteur.nom);
console.log(article.metadata.tags);
```

### ‚úÖ 4. **Coh√©rence des Donn√©es**

Les donn√©es li√©es restent toujours synchronis√©es car elles font partie du m√™me document.

---

## Inconv√©nients et Limitations

### ‚ö†Ô∏è 1. **Limite de Taille (16 Mo)**

Un document MongoDB ne peut pas d√©passer **16 Mo**. Si vous imbriquez trop de donn√©es, vous risquez d'atteindre cette limite.

**Exemple probl√©matique :**
```javascript
// ‚ùå MAUVAISE ID√âE : Imbriquer tous les commentaires
{
  _id: ObjectId("507f1f77bcf86cd799439015"),
  titre: "Article viral",
  contenu: "Contenu...",
  commentaires: [
    // Si vous avez 10 000 commentaires, vous d√©passerez 16 Mo !
    { auteur: "User1", texte: "Super article !", date: ISODate("...") },
    { auteur: "User2", texte: "Merci !", date: ISODate("...") },
    // ... 9 998 autres commentaires
  ]
}
```

### ‚ö†Ô∏è 2. **Duplication de Donn√©es**

Si les m√™mes donn√©es apparaissent dans plusieurs documents, vous devez les mettre √† jour partout.

**Exemple :**
```javascript
// L'auteur "Jean Dupont" appara√Æt dans 50 articles
{
  _id: 1,
  titre: "Article 1",
  auteur: { nom: "Jean Dupont", email: "jean@example.com" }
}

{
  _id: 2,
  titre: "Article 2",
  auteur: { nom: "Jean Dupont", email: "jean@example.com" }
}

// Si Jean change son email, vous devez mettre √† jour 50 documents !
```

### ‚ö†Ô∏è 3. **Croissance du Document**

Si les donn√©es imbriqu√©es grandissent continuellement (comme un tableau qui ne cesse d'ajouter des √©l√©ments), le document peut devenir probl√©matique.

**Exemple probl√©matique :**
```javascript
// ‚ùå Tableau qui grandit ind√©finiment
{
  _id: ObjectId("507f1f77bcf86cd799439016"),
  userId: "user123",
  historiqueAchats: [
    { date: ISODate("2020-01-01"), montant: 50 },
    { date: ISODate("2020-02-15"), montant: 75 },
    // ... potentiellement des milliers d'achats sur plusieurs ann√©es
  ]
}
```

### ‚ö†Ô∏è 4. **Difficult√© de Requ√™te sur les Sous-Documents**

Requ√™ter et indexer des donn√©es imbriqu√©es peut √™tre plus complexe :

```javascript
// Trouver tous les articles d'un auteur sp√©cifique
db.articles.find({ "auteur.nom": "Jean Dupont" })

// N√©cessite un index sur le champ imbriqu√©
db.articles.createIndex({ "auteur.nom": 1 })
```

---

## Exemples Pratiques

### Exemple 1 : Syst√®me de Gestion de Contacts

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439017"),
  prenom: "Claire",
  nom: "Dubois",
  email: "claire.dubois@example.com",
  telephone: "+33612345678",
  adresse: {
    rue: "10 Rue Victor Hugo",
    ville: "Marseille",
    codePostal: "13001",
    pays: "France"
  },
  reseauxSociaux: {
    linkedin: "claire-dubois",
    twitter: "@claireDub",
    github: "claire-dev"
  },
  dateCreation: ISODate("2024-01-15")
}
```

**Pourquoi ce pattern fonctionne ici ?**
- L'adresse et les r√©seaux sociaux sont toujours consult√©s avec le contact
- Ces informations n'ont de sens que dans le contexte du contact
- La taille totale du document reste petite

### Exemple 2 : Menu de Restaurant

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439018"),
  nomRestaurant: "Le Bon Go√ªt",
  categories: [
    {
      nom: "Entr√©es",
      plats: [
        {
          nom: "Salade Caesar",
          description: "Salade romaine, poulet grill√©, parmesan",
          prix: 8.50,
          allergenes: ["gluten", "lait"],
          vegetarien: false
        },
        {
          nom: "Soupe √† l'oignon",
          description: "Soupe traditionnelle gratin√©e",
          prix: 7.00,
          allergenes: ["lait"],
          vegetarien: true
        }
      ]
    },
    {
      nom: "Plats",
      plats: [
        {
          nom: "Steak frites",
          description: "Entrec√¥te 300g avec frites maison",
          prix: 22.00,
          allergenes: [],
          vegetarien: false
        }
      ]
    }
  ],
  derniereMAJ: ISODate("2024-11-01")
}
```

**Pourquoi ce pattern fonctionne ici ?**
- Le menu est toujours consult√© dans son ensemble
- Les cat√©gories et plats n'existent pas ind√©pendamment du menu
- Nombre limit√© de plats (pas de croissance infinie)

### Exemple 3 : √âv√©nement avec Participants

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439019"),
  titre: "Meetup MongoDB Paris",
  date: ISODate("2024-12-15T19:00:00Z"),
  lieu: {
    nom: "Station F",
    adresse: "5 Parvis Alan Turing",
    ville: "Paris",
    codePostal: "75013",
    coordonnees: {
      latitude: 48.8334,
      longitude: 2.3738
    }
  },
  organisateur: {
    nom: "Tech Community Paris",
    email: "contact@techcommunity.fr",
    telephone: "+33123456789"
  },
  capaciteMax: 50,
  nombreInscrits: 42,
  description: "Soir√©e d√©di√©e √† MongoDB et ses nouveaut√©s",
  tags: ["MongoDB", "NoSQL", "Meetup", "Paris"]
}
```

**Note :** Ici, nous n'avons **pas** imbriqu√© la liste compl√®te des 42 participants car :
- Elle risque de cro√Ætre et d√©passer 16 Mo pour un grand √©v√©nement
- On n'a pas toujours besoin de tous les participants
- Les participants peuvent √™tre g√©r√©s dans une collection s√©par√©e

---

## Quand NE PAS Utiliser le Pattern Embedded ?

### ‚ùå 1. **Relation "One-to-Many" avec Beaucoup d'√âl√©ments**

Si le "Many" repr√©sente des centaines ou milliers d'√©l√©ments.

**Exemple : Article avec Milliers de Commentaires**
```javascript
// ‚ùå MAUVAIS
{
  _id: ObjectId("507f1f77bcf86cd799439020"),
  titre: "Article",
  commentaires: [ /* 5000 commentaires */ ]
}

// ‚úÖ MEILLEUR : Collection s√©par√©e
// Collection articles
{ _id: ObjectId("507f1f77bcf86cd799439020"), titre: "Article" }

// Collection commentaires
{ _id: 1, articleId: ObjectId("507f1f77bcf86cd799439020"), texte: "..." }
{ _id: 2, articleId: ObjectId("507f1f77bcf86cd799439020"), texte: "..." }
```

### ‚ùå 2. **Donn√©es Fr√©quemment Mises √† Jour de Mani√®re Ind√©pendante**

Si vous mettez souvent √† jour les donn√©es imbriqu√©es sans toucher au reste du document.

**Exemple : Statistiques en Temps R√©el**
```javascript
// ‚ùå MAUVAIS : Mise √† jour constante
{
  _id: ObjectId("507f1f77bcf86cd799439021"),
  titre: "Article",
  contenu: "...",
  stats: {
    vues: 1523,        // Mis √† jour toutes les secondes
    likes: 45,         // Mis √† jour fr√©quemment
    partages: 12       // Mis √† jour fr√©quemment
  }
}

// ‚úÖ MEILLEUR : Document s√©par√© pour les stats
```

### ‚ùå 3. **Donn√©es Partag√©es par Plusieurs Documents**

Si les m√™mes donn√©es apparaissent dans de nombreux endroits et changent r√©guli√®rement.

**Exemple : Informations d'Auteur dans Multiples Articles**
```javascript
// ‚ùå MAUVAIS : Duplication massive
// 1000 articles de Jean Dupont avec ses infos dupliqu√©es

// ‚úÖ MEILLEUR : R√©f√©rence √† une collection auteurs
{
  _id: 1,
  titre: "Article",
  auteurId: ObjectId("507f1f77bcf86cd799439022")
}
```

---

## Requ√™tes sur Documents Imbriqu√©s

### Acc√®s aux Champs Imbriqu√©s

Utilisez la **notation point√©e** pour acc√©der aux champs imbriqu√©s :

```javascript
// Rechercher tous les utilisateurs de Paris
db.contacts.find({ "adresse.ville": "Paris" })

// Rechercher les articles avec plus de 1000 vues
db.articles.find({ "metadata.nombreVues": { $gt: 1000 } })

// Rechercher les produits avec une variante sp√©cifique
db.produits.find({ "variantes.sku": "TSH-BLU-M" })
```

### Projection sur Documents Imbriqu√©s

```javascript
// R√©cup√©rer uniquement le nom et l'email de l'auteur
db.articles.find(
  {},
  {
    titre: 1,
    "auteur.nom": 1,
    "auteur.email": 1
  }
)

// Exclure certains champs imbriqu√©s
db.articles.find(
  {},
  {
    "metadata.nombreVues": 0
  }
)
```

### Mise √† Jour de Champs Imbriqu√©s

```javascript
// Mettre √† jour un champ imbriqu√© sp√©cifique
db.contacts.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439017") },
  { $set: { "adresse.ville": "Nice" } }
)

// Incr√©menter un compteur imbriqu√©
db.articles.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439013") },
  { $inc: { "metadata.nombreVues": 1 } }
)

// Ajouter un tag
db.articles.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439013") },
  { $push: { "metadata.tags": "Tutorial" } }
)
```

---

## Index sur Documents Imbriqu√©s

Vous pouvez cr√©er des index sur des champs imbriqu√©s :

```javascript
// Index simple sur un champ imbriqu√©
db.contacts.createIndex({ "adresse.ville": 1 })

// Index compos√© avec champs imbriqu√©s
db.articles.createIndex({
  "metadata.categorie": 1,
  "metadata.datePublication": -1
})

// Index texte sur un champ imbriqu√©
db.articles.createIndex({ "metadata.tags": "text" })
```

---

## Bonnes Pratiques

### ‚úÖ 1. Limiter la Profondeur d'Imbrication

√âvitez d'imbriquer trop de niveaux (id√©alement, maximum 2-3 niveaux).

```javascript
// ‚úÖ BON : 2 niveaux
{
  utilisateur: {
    profil: { nom: "Jean", age: 30 }
  }
}

// ‚ö†Ô∏è √âVITER : Trop de niveaux
{
  niveau1: {
    niveau2: {
      niveau3: {
        niveau4: { donnee: "difficile √† maintenir" }
      }
    }
  }
}
```

### ‚úÖ 2. Surveiller la Taille des Documents

Utilisez `Object.bsonsize()` pour v√©rifier la taille :

```javascript
// V√©rifier la taille d'un document
const doc = db.articles.findOne({ _id: ObjectId("507f1f77bcf86cd799439013") });
print(Object.bsonsize(doc)); // Affiche la taille en octets
```

### ‚úÖ 3. Utiliser des Tableaux avec Parcimonie

Ne laissez pas les tableaux grandir ind√©finiment. Fixez une limite logique.

```javascript
// ‚úÖ BON : Tableau limit√© (par exemple, 10 derniers achats)
{
  userId: "user123",
  derniersAchats: [
    { date: ISODate("2024-11-01"), montant: 50 },
    // ... maximum 10 √©l√©ments
  ]
}
```

### ‚úÖ 4. Documenter les Limites

Documentez clairement vos choix de mod√©lisation et leurs limites.

```javascript
/**
 * Collection: produits
 *
 * Pattern: Embedded pour les variantes
 * Limite: Maximum 50 variantes par produit
 * Raison: Les variantes sont toujours consult√©es avec le produit
 */
```

---

## Comparaison : Embedded vs R√©f√©rence

| Crit√®re | Pattern Embedded | Pattern R√©f√©rence |
|---------|-----------------|-------------------|
| **Performance lecture** | ‚ö° Tr√®s rapide (1 requ√™te) | üêå Plus lent (2+ requ√™tes) |
| **Performance √©criture** | ‚úÖ Bonne | ‚úÖ Bonne |
| **Atomicit√©** | ‚úÖ Garantie | ‚ö†Ô∏è N√©cessite transactions |
| **Duplication** | ‚ö†Ô∏è Possible | ‚úÖ Pas de duplication |
| **Limite de taille** | ‚ö†Ô∏è 16 Mo max | ‚úÖ Pas de limite |
| **Croissance** | ‚ö†Ô∏è Probl√©matique si illimit√©e | ‚úÖ Illimit√©e |
| **Complexit√© code** | ‚úÖ Simple | ‚ö†Ô∏è Plus complexe |
| **Flexibilit√©** | ‚ö†Ô∏è Moins flexible | ‚úÖ Tr√®s flexible |

---

## Conclusion

Le **Pattern Embedded** est une approche puissante et naturelle dans MongoDB qui :

- ‚úÖ **Simplifie** le code et les requ√™tes
- ‚úÖ **Am√©liore** les performances de lecture
- ‚úÖ **Garantit** l'atomicit√© des op√©rations
- ‚úÖ Fonctionne parfaitement pour les relations **One-to-One** et **One-to-Few**

**Cependant**, il faut √™tre vigilant concernant :
- ‚ö†Ô∏è La limite de 16 Mo par document
- ‚ö†Ô∏è La duplication potentielle de donn√©es
- ‚ö†Ô∏è La croissance illimit√©e des tableaux

**En r√®gle g√©n√©rale :** Utilisez le Pattern Embedded quand les donn√©es sont toujours consult√©es ensemble et que leur volume reste raisonnable. Pour des relations plus complexes ou des volumes importants, envisagez les r√©f√©rences ou des patterns hybrides.

---

## Ressources Compl√©mentaires

- [Documentation officielle MongoDB - Mod√©lisation des donn√©es](https://docs.mongodb.com/manual/core/data-modeling-introduction/)
- [MongoDB Schema Design Best Practices](https://www.mongodb.com/developer/products/mongodb/schema-design-anti-pattern-summary/)


‚è≠Ô∏è [Pattern Subset](/04-modelisation-des-donnees/06.2-pattern-subset.md)
