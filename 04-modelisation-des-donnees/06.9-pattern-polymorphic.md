ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.6.9 Pattern Polymorphic (Documents Polymorphiques)

## Introduction

Le **Pattern Polymorphic** (ou pattern polymorphique) est une technique de modÃ©lisation qui consiste Ã  **stocker des documents de types diffÃ©rents mais apparentÃ©s dans une mÃªme collection**, en utilisant un champ discriminant pour identifier le type de chaque document.

> **Analogie simple :** Imaginez une bibliothÃ¨que qui contient des livres, des magazines, des DVD et des BD. Au lieu de crÃ©er une Ã©tagÃ¨re sÃ©parÃ©e pour chaque type (4 Ã©tagÃ¨res), vous les rangez tous ensemble avec une Ã©tiquette de couleur : rouge pour les livres, bleu pour les magazines, vert pour les DVD, jaune pour les BD. C'est le Pattern Polymorphic : un seul endroit, plusieurs types, une Ã©tiquette pour distinguer.

Ce pattern est **essentiel** pour gÃ©rer l'hÃ©ritage, les hiÃ©rarchies de types, et les systÃ¨mes qui traitent des entitÃ©s similaires mais avec des variations.

---

## Le ProblÃ¨me : Plusieurs Types Similaires

### ScÃ©nario : SystÃ¨me de Paiement Multi-mÃ©thodes

Votre application accepte plusieurs mÃ©thodes de paiement. Chaque mÃ©thode a des attributs spÃ©cifiques.

#### âŒ Approche 1 : Collection SÃ©parÃ©e par Type

```javascript
// Collection paiements_carte
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  montant: 99.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),

  // SpÃ©cifique carte
  numeroCarte: "****1234",
  typeCarte: "Visa",
  dateExpiration: "12/25",
  nomTitulaire: "Marie Dupont"
}

// Collection paiements_paypal
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  montant: 49.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),

  // SpÃ©cifique PayPal
  emailPaypal: "marie@example.com",
  idTransactionPaypal: "PAY-123456789"
}

// Collection paiements_virement
{
  _id: ObjectId("707f1f77bcf86cd799439013"),
  montant: 199.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),

  // SpÃ©cifique virement
  iban: "FR76 1234 5678 9012 3456 7890 123",
  bic: "BNPAFRPPXXX",
  reference: "FACT-2024-001"
}
```

**ProblÃ¨mes :**
- ğŸ¤¯ **3 collections diffÃ©rentes** Ã  gÃ©rer
- ğŸ” **RequÃªtes compliquÃ©es** : Chercher tous les paiements d'un utilisateur = 3 requÃªtes
- ğŸ“Š **Statistiques difficiles** : Calculer le total des paiements = agrÃ©ger 3 collections
- ğŸ”§ **Maintenance complexe** : Ajouter un champ commun = modifier 3 collections
- ğŸ’¥ **Code dupliquÃ©** : Logique mÃ©tier rÃ©pÃ©tÃ©e pour chaque type

#### âŒ Approche 2 : Tous les Champs dans une Collection

```javascript
// Collection paiements avec TOUS les champs possibles
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  montant: 99.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),

  // Champs carte (utilisÃ©s)
  numeroCarte: "****1234",
  typeCarte: "Visa",
  dateExpiration: "12/25",
  nomTitulaire: "Marie Dupont",

  // Champs PayPal (non utilisÃ©s)
  emailPaypal: null,
  idTransactionPaypal: null,

  // Champs virement (non utilisÃ©s)
  iban: null,
  bic: null,
  reference: null,

  // Champs crypto (non utilisÃ©s)
  adresseWallet: null,
  hashTransaction: null,
  reseau: null
}
```

**ProblÃ¨mes :**
- ğŸ’¾ **Gaspillage d'espace** : Beaucoup de champs null
- ğŸ› **Confusion** : Difficile de savoir quels champs sont valides
- ğŸ” **Maintenance cauchemardesque** : Ajouter une mÃ©thode = ajouter des champs Ã  TOUS les documents

#### âœ… Solution avec Pattern Polymorphic

```javascript
// Collection paiements avec pattern polymorphic
// Type 1 : Carte bancaire
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  type: "carte",  // â† Discriminant de type

  // Champs communs
  montant: 99.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),
  statut: "complete",

  // Champs spÃ©cifiques carte
  numeroCarte: "****1234",
  typeCarte: "Visa",
  dateExpiration: "12/25",
  nomTitulaire: "Marie Dupont"
}

// Type 2 : PayPal
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  type: "paypal",  // â† Discriminant de type

  // Champs communs (identiques)
  montant: 49.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),
  statut: "complete",

  // Champs spÃ©cifiques PayPal
  emailPaypal: "marie@example.com",
  idTransactionPaypal: "PAY-123456789"
}

// Type 3 : Virement bancaire
{
  _id: ObjectId("707f1f77bcf86cd799439013"),
  type: "virement",  // â† Discriminant de type

  // Champs communs (identiques)
  montant: 199.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),
  statut: "en_attente",

  // Champs spÃ©cifiques virement
  iban: "FR76 1234 5678 9012 3456 7890 123",
  bic: "BNPAFRPPXXX",
  reference: "FACT-2024-001"
}

// Type 4 : Cryptomonnaie
{
  _id: ObjectId("807f1f77bcf86cd799439014"),
  type: "crypto",  // â† Discriminant de type

  // Champs communs (identiques)
  montant: 299.99,
  devise: "EUR",
  date: ISODate("2024-11-28"),
  utilisateurId: ObjectId("..."),
  statut: "complete",

  // Champs spÃ©cifiques crypto
  cryptomonnaie: "Bitcoin",
  adresseWallet: "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
  hashTransaction: "0x7f8b...",
  reseau: "Bitcoin Mainnet",
  confirmations: 6
}
```

**Avantages :**
- âœ… **Une seule collection** facile Ã  gÃ©rer
- âœ… **Pas de champs null** inutiles
- âœ… **RequÃªtes simples** : Un seul endroit pour chercher
- âœ… **Statistiques faciles** : AgrÃ©gations sur une collection
- âœ… **FlexibilitÃ©** : Ajouter un type = nouveaux documents

---

## Concept ClÃ© : Discriminant de Type

Le Pattern Polymorphic repose sur un **champ discriminant** qui identifie le type :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Collection Polymorphique                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Doc 1: { type: "carte", ... }                   â”‚
â”‚ Doc 2: { type: "paypal", ... }                  â”‚
â”‚ Doc 3: { type: "virement", ... }                â”‚
â”‚ Doc 4: { type: "carte", ... }                   â”‚
â”‚ Doc 5: { type: "crypto", ... }                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â†“ Traitement selon le type

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Code Application                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if (type === "carte")                           â”‚
â”‚   â†’ Traiter paiement carte                      â”‚
â”‚ if (type === "paypal")                          â”‚
â”‚   â†’ Traiter paiement PayPal                     â”‚
â”‚ if (type === "virement")                        â”‚
â”‚   â†’ Traiter virement                            â”‚
â”‚ if (type === "crypto")                          â”‚
â”‚   â†’ Traiter crypto                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Structure typique :**
```javascript
{
  type: "TYPE_DISCRIMINANT",  // â† Obligatoire : identifie le type

  // Champs communs Ã  tous les types
  champCommun1: valeur,
  champCommun2: valeur,

  // Champs spÃ©cifiques au type
  champSpecifique1: valeur,
  champSpecifique2: valeur
}
```

---

## Quand Utiliser le Pattern Polymorphic ?

### 1. **Contenu MultimÃ©dia Mixte**

Site avec diffÃ©rents types de contenu.

**Exemple : Plateforme de Contenu**

```javascript
// Article de blog
{
  _id: ObjectId("507f1f77bcf86cd799439020"),
  type: "article",  // â† Type

  // Champs communs
  titre: "Introduction Ã  MongoDB",
  auteur: "Jean Dupont",
  datePublication: ISODate("2024-11-15"),
  vues: 1250,
  likes: 45,
  tags: ["mongodb", "database", "nosql"],

  // Champs spÃ©cifiques article
  contenu: "Lorem ipsum...",
  tempsLecture: 8,  // minutes
  nombreMots: 1500
}

// VidÃ©o
{
  _id: ObjectId("607f1f77bcf86cd799439021"),
  type: "video",  // â† Type

  // Champs communs (identiques)
  titre: "Tutoriel MongoDB AgrÃ©gations",
  auteur: "Marie Martin",
  datePublication: ISODate("2024-11-20"),
  vues: 3420,
  likes: 156,
  tags: ["mongodb", "tutorial", "aggregation"],

  // Champs spÃ©cifiques vidÃ©o
  urlVideo: "https://video.com/abc123",
  duree: 1845,  // secondes (30min 45s)
  resolution: "1080p",
  thumbnail: "https://img.com/thumb.jpg",
  sousTitres: ["fr", "en", "es"]
}

// Podcast
{
  _id: ObjectId("707f1f77bcf86cd799439022"),
  type: "podcast",  // â† Type

  // Champs communs (identiques)
  titre: "Les Bases de DonnÃ©es NoSQL",
  auteur: "Pierre Durand",
  datePublication: ISODate("2024-11-25"),
  vues: 890,  // Ã‰coutes
  likes: 67,
  tags: ["nosql", "database", "architecture"],

  // Champs spÃ©cifiques podcast
  urlAudio: "https://audio.com/xyz789",
  duree: 2400,  // secondes (40min)
  taille: 45.6,  // MB
  format: "MP3",
  transcription: "https://transcript.com/xyz789.txt"
}

// Galerie photos
{
  _id: ObjectId("807f1f77bcf86cd799439023"),
  type: "galerie",  // â† Type

  // Champs communs (identiques)
  titre: "Architecture MongoDB",
  auteur: "Sophie Laurent",
  datePublication: ISODate("2024-11-28"),
  vues: 2100,
  likes: 89,
  tags: ["architecture", "diagrammes", "mongodb"],

  // Champs spÃ©cifiques galerie
  images: [
    {
      url: "https://img.com/arch1.jpg",
      legende: "Sharding architecture",
      resolution: "2048x1536"
    },
    {
      url: "https://img.com/arch2.jpg",
      legende: "Replica Set",
      resolution: "2048x1536"
    }
  ],
  nombreImages: 15
}
```

### 2. **Notifications Multi-canaux**

SystÃ¨me de notifications avec diffÃ©rents types.

**Exemple : Application de Notifications**

```javascript
// Notification Email
{
  _id: ObjectId("507f1f77bcf86cd799439030"),
  type: "email",

  // Champs communs
  utilisateurId: ObjectId("..."),
  titre: "Nouveau message de Marie",
  message: "Marie vous a envoyÃ© un message",
  dateCreation: ISODate("2024-11-28T10:00:00Z"),
  dateEnvoi: ISODate("2024-11-28T10:00:05Z"),
  statut: "envoye",
  lue: false,

  // Champs spÃ©cifiques email
  emailDestinataire: "user@example.com",
  sujet: "Nouveau message sur notre plateforme",
  corpsHtml: "<html>...</html>",
  corpsTexte: "Version texte...",
  priorite: "normale"
}

// Notification Push
{
  _id: ObjectId("607f1f77bcf86cd799439031"),
  type: "push",

  // Champs communs (identiques)
  utilisateurId: ObjectId("..."),
  titre: "Nouveau commentaire",
  message: "Jean a commentÃ© votre article",
  dateCreation: ISODate("2024-11-28T11:30:00Z"),
  dateEnvoi: ISODate("2024-11-28T11:30:02Z"),
  statut: "envoye",
  lue: true,

  // Champs spÃ©cifiques push
  deviceTokens: ["token1", "token2"],
  badge: 3,  // Nombre Ã  afficher sur l'icÃ´ne
  son: "default",
  image: "https://img.com/notif.jpg",
  actionUrl: "/article/123",
  categorie: "commentaire"
}

// Notification SMS
{
  _id: ObjectId("707f1f77bcf86cd799439032"),
  type: "sms",

  // Champs communs (identiques)
  utilisateurId: ObjectId("..."),
  titre: "Code de vÃ©rification",
  message: "Votre code: 123456",
  dateCreation: ISODate("2024-11-28T14:00:00Z"),
  dateEnvoi: ISODate("2024-11-28T14:00:01Z"),
  statut: "envoye",
  lue: null,  // Non applicable pour SMS

  // Champs spÃ©cifiques SMS
  telephone: "+33612345678",
  idMessage: "SM-abc123",
  cout: 0.08,  // EUR
  segments: 1
}

// Notification In-App
{
  _id: ObjectId("807f1f77bcf86cd799439033"),
  type: "in_app",

  // Champs communs (identiques)
  utilisateurId: ObjectId("..."),
  titre: "Promotion exclusive",
  message: "50% de rÃ©duction sur tous les cours",
  dateCreation: ISODate("2024-11-28T15:00:00Z"),
  dateEnvoi: ISODate("2024-11-28T15:00:00Z"),
  statut: "affiche",
  lue: false,

  // Champs spÃ©cifiques in-app
  typeAffichage: "banner",  // banner, modal, toast
  dureeAffichage: 5000,  // ms
  boutons: [
    { texte: "Voir les cours", action: "/courses" },
    { texte: "Fermer", action: "dismiss" }
  ],
  couleurFond: "#FF5722"
}
```

### 3. **VÃ©hicules de Location**

SystÃ¨me de location avec diffÃ©rents types de vÃ©hicules.

**Exemple : Plateforme de Location**

```javascript
// Voiture
{
  _id: ObjectId("507f1f77bcf86cd799439040"),
  type: "voiture",

  // Champs communs
  marque: "Renault",
  modele: "Clio",
  annee: 2023,
  immatriculation: "AB-123-CD",
  tarifJour: 45.00,
  disponible: true,
  localisation: {
    agence: "Paris Centre",
    adresse: "123 Rue de Rivoli"
  },

  // Champs spÃ©cifiques voiture
  nombrePortes: 5,
  nombrePlaces: 5,
  typeCarburant: "Essence",
  boiteVitesse: "Manuelle",
  climatisation: true,
  gps: true,
  siegesBebe: 2
}

// Moto
{
  _id: ObjectId("607f1f77bcf86cd799439041"),
  type: "moto",

  // Champs communs (identiques)
  marque: "Yamaha",
  modele: "MT-07",
  annee: 2023,
  immatriculation: "EF-456-GH",
  tarifJour: 65.00,
  disponible: true,
  localisation: {
    agence: "Paris Centre",
    adresse: "123 Rue de Rivoli"
  },

  // Champs spÃ©cifiques moto
  cylindree: 689,
  typePermis: "A2",
  nombreCasques: 2,
  topCase: true,
  abs: true
}

// Camion
{
  _id: ObjectId("707f1f77bcf86cd799439042"),
  type: "camion",

  // Champs communs (identiques)
  marque: "Renault",
  modele: "Master",
  annee: 2022,
  immatriculation: "IJ-789-KL",
  tarifJour: 120.00,
  disponible: false,  // En location
  localisation: {
    agence: "Paris PÃ©riphÃ©rique",
    adresse: "45 Boulevard PÃ©riphÃ©rique"
  },

  // Champs spÃ©cifiques camion
  volumeChargement: 12,  // mÂ³
  chargeUtile: 1200,  // kg
  hayon: true,
  nombrePlaces: 3,
  permisRequis: "B"
}

// VÃ©lo Ã©lectrique
{
  _id: ObjectId("807f1f77bcf86cd799439043"),
  type: "velo",

  // Champs communs (identiques)
  marque: "VanMoof",
  modele: "S3",
  annee: 2024,
  immatriculation: null,  // Pas d'immatriculation pour vÃ©lo
  tarifJour: 15.00,
  disponible: true,
  localisation: {
    agence: "Paris Gare",
    adresse: "Gare du Nord"
  },

  // Champs spÃ©cifiques vÃ©lo
  electrique: true,
  autonomie: 60,  // km
  vitesses: 5,
  antivol: true,
  taille: "M"
}
```

### 4. **Ã‰vÃ©nements SystÃ¨me HÃ©tÃ©rogÃ¨nes**

Logs d'Ã©vÃ©nements avec diffÃ©rents types.

**Exemple : SystÃ¨me de Logs**

```javascript
// Ã‰vÃ©nement connexion utilisateur
{
  _id: ObjectId("507f1f77bcf86cd799439050"),
  type: "connexion_utilisateur",

  // Champs communs
  timestamp: ISODate("2024-11-28T10:15:23Z"),
  severite: "info",

  // Champs spÃ©cifiques connexion
  utilisateurId: ObjectId("..."),
  email: "user@example.com",
  ip: "192.168.1.100",
  navigateur: "Chrome 120",
  systeme: "Windows 10",
  succes: true
}

// Ã‰vÃ©nement erreur application
{
  _id: ObjectId("607f1f77bcf86cd799439051"),
  type: "erreur_application",

  // Champs communs (identiques)
  timestamp: ISODate("2024-11-28T10:20:45Z"),
  severite: "error",

  // Champs spÃ©cifiques erreur
  codeErreur: "DB_CONNECTION_FAILED",
  message: "Impossible de se connecter Ã  la base de donnÃ©es",
  stackTrace: "Error at...",
  fonction: "connectDatabase()",
  fichier: "db.js",
  ligne: 45,
  tentativesReconnexion: 3
}

// Ã‰vÃ©nement paiement
{
  _id: ObjectId("707f1f77bcf86cd799439052"),
  type: "paiement",

  // Champs communs (identiques)
  timestamp: ISODate("2024-11-28T11:00:00Z"),
  severite: "info",

  // Champs spÃ©cifiques paiement
  utilisateurId: ObjectId("..."),
  montant: 99.99,
  devise: "EUR",
  methodePaiement: "carte",
  statut: "complete",
  idTransaction: "TX-123456",
  produits: ["prod_1", "prod_2"]
}

// Ã‰vÃ©nement modification donnÃ©es
{
  _id: ObjectId("807f1f77bcf86cd799439053"),
  type: "modification_donnees",

  // Champs communs (identiques)
  timestamp: ISODate("2024-11-28T12:30:00Z"),
  severite: "warning",

  // Champs spÃ©cifiques modification
  utilisateurId: ObjectId("..."),
  collection: "users",
  documentId: ObjectId("..."),
  action: "update",
  champsModifies: ["email", "telephone"],
  anciennes_valeurs: {
    email: "old@example.com",
    telephone: "+33611111111"
  },
  nouvelles_valeurs: {
    email: "new@example.com",
    telephone: "+33622222222"
  }
}
```

---

## RequÃªtes avec le Pattern Polymorphic

### RequÃªte sur Tous les Documents

```javascript
// RÃ©cupÃ©rer tous les paiements d'un utilisateur (tous types confondus)
const paiements = await db.paiements.find({
  utilisateurId: userId
}).toArray();

// Calculer le total des paiements
const total = await db.paiements.aggregate([
  { $match: { utilisateurId: userId, statut: "complete" } },
  { $group: { _id: null, total: { $sum: "$montant" } } }
]).toArray();
```

### RequÃªte par Type SpÃ©cifique

```javascript
// RÃ©cupÃ©rer seulement les paiements par carte
const paiementsCarte = await db.paiements.find({
  type: "carte",
  utilisateurId: userId
}).toArray();

// Statistiques par type de paiement
const statsByType = await db.paiements.aggregate([
  {
    $group: {
      _id: "$type",
      count: { $sum: 1 },
      montantTotal: { $sum: "$montant" },
      montantMoyen: { $avg: "$montant" }
    }
  },
  { $sort: { count: -1 } }
]).toArray();

// RÃ©sultat :
// [
//   { _id: "carte", count: 145, montantTotal: 14500, montantMoyen: 100 },
//   { _id: "paypal", count: 89, montantTotal: 4450, montantMoyen: 50 },
//   { _id: "virement", count: 23, montantTotal: 11500, montantMoyen: 500 },
//   { _id: "crypto", count: 12, montantTotal: 3600, montantMoyen: 300 }
// ]
```

### RequÃªte avec Champs SpÃ©cifiques

```javascript
// Trouver paiements carte Visa expirant bientÃ´t
const visaExpirant = await db.paiements.find({
  type: "carte",
  typeCarte: "Visa",
  dateExpiration: {
    $lte: "03/25"  // Avant mars 2025
  }
}).toArray();

// Trouver paiements crypto avec peu de confirmations
const cryptoNonConfirme = await db.paiements.find({
  type: "crypto",
  confirmations: { $lt: 3 }
}).toArray();
```

### RequÃªte Polymorphique Complexe

```javascript
// Trouver tous les contenus d'un auteur (articles, vidÃ©os, podcasts)
const contenus = await db.contenus.find({
  auteur: "Marie Martin"
}).sort({ datePublication: -1 }).toArray();

// Statistiques d'engagement par type de contenu
const engagement = await db.contenus.aggregate([
  {
    $match: {
      datePublication: {
        $gte: ISODate("2024-01-01"),
        $lt: ISODate("2025-01-01")
      }
    }
  },
  {
    $group: {
      _id: "$type",
      nombreContenu: { $sum: 1 },
      vuesTotal: { $sum: "$vues" },
      likesTotal: { $sum: "$likes" },
      vuesMoyenne: { $avg: "$vues" }
    }
  },
  {
    $addFields: {
      tauxEngagement: {
        $multiply: [
          { $divide: ["$likesTotal", "$vuesTotal"] },
          100
        ]
      }
    }
  }
]).toArray();
```

---

## Index pour le Pattern Polymorphic

### Index sur le Champ Type

```javascript
// Index simple sur le type
db.paiements.createIndex({ type: 1 });

// RequÃªte optimisÃ©e par type
db.paiements.find({ type: "carte" });
```

### Index ComposÃ©s

```javascript
// Index pour requÃªtes frÃ©quentes
db.paiements.createIndex({
  utilisateurId: 1,
  type: 1,
  date: -1
});

// RequÃªte optimisÃ©e
db.paiements.find({
  utilisateurId: userId,
  type: "carte",
  date: { $gte: dateDebut }
});
```

### Index Partiels par Type

```javascript
// Index partiel seulement pour les cartes
db.paiements.createIndex(
  { dateExpiration: 1 },
  {
    partialFilterExpression: {
      type: "carte"
    }
  }
);

// Index partiel seulement pour les crypto
db.paiements.createIndex(
  { confirmations: 1 },
  {
    partialFilterExpression: {
      type: "crypto"
    }
  }
);
```

---

## Gestion du Polymorphisme dans le Code

### Approche 1 : Switch/Case

```javascript
async function traiterPaiement(paiementId) {
  const paiement = await db.paiements.findOne({ _id: paiementId });

  switch(paiement.type) {
    case "carte":
      return traiterPaiementCarte(paiement);

    case "paypal":
      return traiterPaiementPayPal(paiement);

    case "virement":
      return traiterVirement(paiement);

    case "crypto":
      return traiterPaiementCrypto(paiement);

    default:
      throw new Error(`Type de paiement inconnu: ${paiement.type}`);
  }
}

function traiterPaiementCarte(paiement) {
  console.log(`Traitement paiement carte ${paiement.typeCarte}`);
  // VÃ©rifier date expiration
  // Contacter processeur de paiement
  // etc.
}

function traiterPaiementPayPal(paiement) {
  console.log(`Traitement paiement PayPal ${paiement.emailPaypal}`);
  // VÃ©rifier compte PayPal
  // Initier transfert
  // etc.
}
```

### Approche 2 : Classe Polymorphique

```javascript
// Classe de base
class Paiement {
  constructor(data) {
    this.data = data;
  }

  static fromDocument(doc) {
    switch(doc.type) {
      case "carte":
        return new PaiementCarte(doc);
      case "paypal":
        return new PaiementPayPal(doc);
      case "virement":
        return new PaiementVirement(doc);
      case "crypto":
        return new PaiementCrypto(doc);
      default:
        throw new Error(`Type inconnu: ${doc.type}`);
    }
  }

  // MÃ©thodes communes
  getMontant() {
    return this.data.montant;
  }

  getDevise() {
    return this.data.devise;
  }

  // MÃ©thode polymorphique (Ã  surcharger)
  async traiter() {
    throw new Error("MÃ©thode traiter() doit Ãªtre implÃ©mentÃ©e");
  }

  // MÃ©thode polymorphique (Ã  surcharger)
  afficherDetails() {
    throw new Error("MÃ©thode afficherDetails() doit Ãªtre implÃ©mentÃ©e");
  }
}

// Classe spÃ©cialisÃ©e Carte
class PaiementCarte extends Paiement {
  async traiter() {
    console.log(`Traitement paiement carte ${this.data.typeCarte}`);
    // Logique spÃ©cifique carte
    if (this.estExpire()) {
      throw new Error("Carte expirÃ©e");
    }
    // Contacter processeur
    return { succes: true, message: "Paiement carte acceptÃ©" };
  }

  afficherDetails() {
    return `Carte ${this.data.typeCarte} ****${this.data.numeroCarte.slice(-4)}`;
  }

  estExpire() {
    // VÃ©rifier date expiration
    const [mois, annee] = this.data.dateExpiration.split('/');
    const dateExp = new Date(2000 + parseInt(annee), parseInt(mois) - 1);
    return dateExp < new Date();
  }
}

// Classe spÃ©cialisÃ©e PayPal
class PaiementPayPal extends Paiement {
  async traiter() {
    console.log(`Traitement paiement PayPal ${this.data.emailPaypal}`);
    // Logique spÃ©cifique PayPal
    // Appel API PayPal
    return { succes: true, message: "Paiement PayPal acceptÃ©" };
  }

  afficherDetails() {
    return `PayPal: ${this.data.emailPaypal}`;
  }
}

// Classe spÃ©cialisÃ©e Virement
class PaiementVirement extends Paiement {
  async traiter() {
    console.log(`Traitement virement ${this.data.reference}`);
    // Logique spÃ©cifique virement
    // Validation IBAN
    return { succes: true, message: "Virement en attente" };
  }

  afficherDetails() {
    return `Virement bancaire: ${this.data.iban}`;
  }
}

// Utilisation
const doc = await db.paiements.findOne({ _id: paiementId });
const paiement = Paiement.fromDocument(doc);

console.log(paiement.afficherDetails());
const resultat = await paiement.traiter();
```

### Approche 3 : Factory Pattern

```javascript
// Factory pour crÃ©er le bon type de paiement
class PaiementFactory {
  static creer(type, data) {
    const handlers = {
      carte: () => new PaiementCarte(data),
      paypal: () => new PaiementPayPal(data),
      virement: () => new PaiementVirement(data),
      crypto: () => new PaiementCrypto(data)
    };

    const handler = handlers[type];
    if (!handler) {
      throw new Error(`Type de paiement non supportÃ©: ${type}`);
    }

    return handler();
  }

  static async charger(paiementId) {
    const doc = await db.paiements.findOne({ _id: paiementId });
    if (!doc) {
      throw new Error("Paiement introuvable");
    }
    return this.creer(doc.type, doc);
  }
}

// Utilisation
const paiement = await PaiementFactory.charger(paiementId);
await paiement.traiter();
```

---

## Avantages du Pattern Polymorphic

### âœ… 1. **Une Seule Collection**

Plus simple Ã  gÃ©rer qu'une collection par type :

```javascript
// Au lieu de 4 collections :
// - paiements_carte
// - paiements_paypal
// - paiements_virement
// - paiements_crypto

// â†’ Une seule collection : paiements
```

### âœ… 2. **RequÃªtes UnifiÃ©es**

Chercher dans un seul endroit :

```javascript
// Tous les paiements d'un utilisateur (tous types)
const paiements = await db.paiements.find({
  utilisateurId: userId
});

// Au lieu de 4 requÃªtes sur 4 collections diffÃ©rentes
```

### âœ… 3. **Statistiques SimplifiÃ©es**

AgrÃ©gations sur une seule collection :

```javascript
// Total de tous les paiements
const total = await db.paiements.aggregate([
  { $group: { _id: null, total: { $sum: "$montant" } } }
]);

// Facile de grouper par type si nÃ©cessaire
```

### âœ… 4. **Ajout de Nouveaux Types Facile**

Nouveau type = nouveaux documents, pas de migration :

```javascript
// Ajouter un type "carte_cadeau" ?
// â†’ Juste insÃ©rer des documents avec type: "carte_cadeau"
// â†’ Aucune migration nÃ©cessaire !
```

### âœ… 5. **Champs Communs Garantis**

Tous les types partagent les mÃªmes champs de base :

```javascript
// Chaque paiement a toujours :
// - montant
// - devise
// - date
// - utilisateurId
// - statut
```

---

## InconvÃ©nients et ConsidÃ©rations

### âš ï¸ 1. **Validation de SchÃ©ma Complexe**

Difficile de valider avec JSON Schema :

```javascript
// Chaque type a des champs diffÃ©rents
// â†’ Validation complexe selon le type
```

**Solution :** Utiliser la validation conditionnelle MongoDB :

```javascript
db.createCollection("paiements", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["type", "montant", "devise", "date"],
      properties: {
        type: {
          enum: ["carte", "paypal", "virement", "crypto"]
        },
        montant: { bsonType: "number" },
        devise: { bsonType: "string" }
      },
      // Validation conditionnelle selon le type
      oneOf: [
        {
          properties: {
            type: { const: "carte" }
          },
          required: ["numeroCarte", "typeCarte", "dateExpiration"]
        },
        {
          properties: {
            type: { const: "paypal" }
          },
          required: ["emailPaypal", "idTransactionPaypal"]
        }
      ]
    }
  }
});
```

### âš ï¸ 2. **Index Moins CiblÃ©s**

Certains index ne s'appliquent qu'Ã  certains types :

```javascript
// Index sur dateExpiration inutile pour types autres que "carte"
// Solution : Utiliser des index partiels
```

### âš ï¸ 3. **RequÃªtes Parfois Plus Lentes**

Parcourir tous les types peut Ãªtre plus lent :

```javascript
// Chercher seulement les cartes Visa
// â†’ Doit d'abord filtrer par type "carte"
// â†’ Puis filtrer par typeCarte "Visa"
```

### âš ï¸ 4. **Code Plus Complexe**

GÃ©rer diffÃ©rents types nÃ©cessite de la logique :

```javascript
// Besoin de switch/case ou polymorphisme OOP
// â†’ Plus de code qu'avec une structure uniforme
```

---

## Bonnes Pratiques

### âœ… 1. Toujours Avoir un Champ Type

```javascript
// âœ… BON : Champ type explicite
{
  type: "carte",
  // ...
}

// âŒ Ã‰VITER : Pas de champ discriminant clair
{
  methodePaiement: "carte",  // Nom non standard
  // ...
}
```

### âœ… 2. DÃ©finir des Champs Communs Obligatoires

```javascript
// Champs que TOUS les types doivent avoir
const CHAMPS_COMMUNS = [
  "_id",
  "type",
  "dateCreation",
  "dateModification",
  "statut"
];

// Tous les types de paiement ont :
// - montant
// - devise
// - date
// - utilisateurId
// - statut
```

### âœ… 3. Documenter Chaque Type

```javascript
/**
 * Types de paiements supportÃ©s :
 *
 * Type "carte" :
 * - numeroCarte (string, masquÃ©)
 * - typeCarte (string: Visa|Mastercard|Amex)
 * - dateExpiration (string: MM/YY)
 * - nomTitulaire (string)
 *
 * Type "paypal" :
 * - emailPaypal (string)
 * - idTransactionPaypal (string)
 *
 * Type "virement" :
 * - iban (string)
 * - bic (string)
 * - reference (string)
 *
 * Type "crypto" :
 * - cryptomonnaie (string)
 * - adresseWallet (string)
 * - hashTransaction (string)
 * - reseau (string)
 * - confirmations (number)
 */
```

### âœ… 4. Utiliser des Valeurs Constantes pour les Types

```javascript
// âœ… BON : Constantes dÃ©finies
const TYPE_PAIEMENT = {
  CARTE: "carte",
  PAYPAL: "paypal",
  VIREMENT: "virement",
  CRYPTO: "crypto"
};

// Utilisation
const paiement = {
  type: TYPE_PAIEMENT.CARTE,
  // ...
};

// âŒ Ã‰VITER : Strings en dur partout
const paiement = {
  type: "carte",  // Risque de typo
  // ...
};
```

### âœ… 5. CrÃ©er des Index AppropriÃ©s

```javascript
// Index sur le type
db.paiements.createIndex({ type: 1 });

// Index composÃ©s pour requÃªtes courantes
db.paiements.createIndex({
  utilisateurId: 1,
  type: 1,
  date: -1
});

// Index partiels pour champs spÃ©cifiques
db.paiements.createIndex(
  { dateExpiration: 1 },
  { partialFilterExpression: { type: "carte" } }
);
```

### âœ… 6. Valider les DonnÃ©es Avant Insertion

```javascript
function validerPaiement(paiement) {
  // Validation champs communs
  if (!paiement.type) {
    throw new Error("Le champ 'type' est obligatoire");
  }
  if (!paiement.montant || paiement.montant <= 0) {
    throw new Error("Le montant doit Ãªtre positif");
  }

  // Validation selon le type
  switch(paiement.type) {
    case "carte":
      if (!paiement.numeroCarte) {
        throw new Error("Le numÃ©ro de carte est obligatoire");
      }
      if (!paiement.dateExpiration) {
        throw new Error("La date d'expiration est obligatoire");
      }
      break;

    case "paypal":
      if (!paiement.emailPaypal) {
        throw new Error("L'email PayPal est obligatoire");
      }
      break;

    // ... autres types
  }
}

// Utilisation
try {
  validerPaiement(nouveauPaiement);
  await db.paiements.insertOne(nouveauPaiement);
} catch (error) {
  console.error("Validation Ã©chouÃ©e:", error.message);
}
```

---

## Quand NE PAS Utiliser le Pattern Polymorphic ?

### âŒ 1. Types Trop DiffÃ©rents

```javascript
// Si les types n'ont RIEN en commun
// â†’ Mieux vaut des collections sÃ©parÃ©es
// Exemple : MÃ©langer produits et utilisateurs dans une collection
```

### âŒ 2. Un Seul Type UtilisÃ©

```javascript
// Si 99% des documents sont du mÃªme type
// â†’ Pattern inutile, ajoutez juste de la complexitÃ©
```

### âŒ 3. Performances Critiques sur un Type

```javascript
// Si un type nÃ©cessite des optimisations trÃ¨s spÃ©cifiques
// â†’ Collection sÃ©parÃ©e peut Ãªtre mieux
```

### âŒ 4. SchÃ©ma TrÃ¨s Strict Requis

```javascript
// Si vous avez besoin de validation stricte par type
// â†’ Collections sÃ©parÃ©es avec JSON Schema sont plus simples
```

---

## Conclusion

Le **Pattern Polymorphic** est idÃ©al pour gÃ©rer des **entitÃ©s similaires avec variations** :

**Avantages :**
- ğŸ¯ Une seule collection au lieu de multiples
- ğŸ” RequÃªtes et agrÃ©gations simplifiÃ©es
- ğŸš€ Ajout de nouveaux types sans migration
- ğŸ“Š Statistiques unifiÃ©es faciles
- ğŸ”§ Maintenance centralisÃ©e

**ConsidÃ©rations :**
- ğŸ“ Validation de schÃ©ma plus complexe
- ğŸ” Index moins ciblÃ©s (solution : index partiels)
- ğŸ’» Code applicatif nÃ©cessite logique de dispatch
- ğŸ“š Documentation essentielle

**RÃ¨gle d'or :** Utilisez le Pattern Polymorphic quand :
1. Vous avez **plusieurs types apparentÃ©s** partageant des champs communs
2. Vous effectuez souvent des **requÃªtes transversales** (tous types confondus)
3. Les types ont **suffisamment en commun** (> 50% de champs communs)
4. Vous voulez **ajouter de nouveaux types** facilement

**Recommandation :** Combinez avec une architecture OOP (classes polymorphiques) cÃ´tÃ© application pour un code propre et maintenable.

---

## Ressources ComplÃ©mentaires

- [Documentation MongoDB - Polymorphic Pattern](https://www.mongodb.com/blog/post/building-with-patterns-the-polymorphic-pattern)
- [Schema Design Patterns Guide](https://www.mongodb.com/developer/products/mongodb/schema-design-anti-pattern-separating-data/)

---


â­ï¸ [Anti-patterns Ã  Ã©viter](/04-modelisation-des-donnees/07-anti-patterns.md)
