üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.6.5 Pattern Computed (Valeurs Pr√©-calcul√©es)

## Introduction

Le **Pattern Computed** (ou pattern des valeurs calcul√©es) est une technique de mod√©lisation qui consiste √† **pr√©-calculer et stocker** des valeurs d√©riv√©es au lieu de les calculer √† chaque fois qu'on en a besoin.

> **Analogie simple :** Imaginez que vous devez conna√Ætre le nombre total de pages d'un livre tous les jours. Vous avez deux options :
> 1. Compter toutes les pages √† chaque fois (long et fastidieux)
> 2. Noter le nombre total sur la couverture une fois pour toutes (rapide)
>
> Le Pattern Computed, c'est l'option 2 : calculer une fois, utiliser plusieurs fois.

Ce pattern est essentiel pour am√©liorer drastiquement les performances lorsque vous avez des calculs **co√ªteux et r√©p√©titifs**.

---

## Le Probl√®me : Calculs R√©p√©titifs et Co√ªteux

### Sc√©nario : Boutique E-commerce

Imaginez une boutique en ligne qui affiche des statistiques pour chaque produit.

#### ‚ùå Approche Sans Pattern Computed

```javascript
// Collection produits
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  nom: "Smartphone XYZ",
  prix: 599.99
}

// Collection commandes
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  produitId: ObjectId("507f1f77bcf86cd799439011"),
  quantite: 2,
  montant: 1199.98,
  date: ISODate("2024-11-15")
}

// Pour afficher les statistiques du produit :
// Il faut CALCULER √† chaque fois
const stats = await db.commandes.aggregate([
  { $match: { produitId: produitId } },
  {
    $group: {
      _id: null,
      totalVentes: { $sum: "$quantite" },
      revenusTotal: { $sum: "$montant" },
      nombreCommandes: { $sum: 1 }
    }
  }
]).toArray();
```

**Probl√®mes :**
- üêå **Calcul √† chaque requ√™te** : m√™me si les donn√©es n'ont pas chang√©
- üíª **Ressources CPU** gaspill√©es pour recalculer sans cesse
- ‚è±Ô∏è **Temps de r√©ponse** long pour l'utilisateur
- üìä Si vous avez 1 million de commandes, l'agr√©gation est **tr√®s co√ªteuse**

#### ‚úÖ Approche Avec Pattern Computed

```javascript
// Collection produits
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  nom: "Smartphone XYZ",
  prix: 599.99,

  // Valeurs PR√â-CALCUL√âES
  statistiques: {
    totalVentes: 1547,        // ‚úÖ D√©j√† calcul√©
    revenusTotal: 927653.00,  // ‚úÖ D√©j√† calcul√©
    nombreCommandes: 892,     // ‚úÖ D√©j√† calcul√©
    derniereMiseAJour: ISODate("2024-11-28T10:00:00Z")
  }
}

// Collection commandes (inchang√©e)
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  produitId: ObjectId("507f1f77bcf86cd799439011"),
  quantite: 2,
  montant: 1199.98,
  date: ISODate("2024-11-15")
}

// Affichage des statistiques : UNE SEULE requ√™te simple !
const produit = await db.produits.findOne({ _id: produitId });
console.log(produit.statistiques.totalVentes);  // ‚ö° Instantan√© !
```

**Avantages :**
- ‚ö° **Instantan√©** : pas de calcul, juste une lecture
- üéØ **Simple** : une seule requ√™te
- üí∞ **√âconomique** : pas de ressources CPU gaspill√©es
- üòä **UX excellente** : temps de r√©ponse ultra-rapide

---

## Concept Cl√© : Mat√©rialisation des Calculs

Le Pattern Computed repose sur la **mat√©rialisation** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Donn√©es Sources (Brutes)      ‚îÇ
‚îÇ   ‚Ä¢ Commandes                   ‚îÇ
‚îÇ   ‚Ä¢ Vues                        ‚îÇ
‚îÇ   ‚Ä¢ Likes                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì
      [ CALCUL ]
           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Donn√©es Calcul√©es (Stock√©es)  ‚îÇ
‚îÇ   ‚Ä¢ Total ventes: 1547          ‚îÇ
‚îÇ   ‚Ä¢ Revenus: 927653‚Ç¨            ‚îÇ
‚îÇ   ‚Ä¢ Moyenne: 1040‚Ç¨              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Au lieu de recalculer √† chaque fois, on **stocke le r√©sultat** et on le **met √† jour** quand n√©cessaire.

---

## Quand Utiliser le Pattern Computed ?

### 1. **Calculs Fr√©quemment Consult√©s**

Quand vous lisez une valeur calcul√©e **beaucoup plus souvent** que vous ne la mettez √† jour.

**Exemple : Statistiques d'un Article de Blog**

```javascript
// Collection articles
{
  _id: ObjectId("507f1f77bcf86cd799439020"),
  titre: "Introduction √† MongoDB",
  contenu: "MongoDB est une base de donn√©es...",
  auteurId: ObjectId("607f1f77bcf86cd799439021"),
  datePublication: ISODate("2024-11-01"),

  // Statistiques PR√â-CALCUL√âES
  statistiques: {
    nombreVues: 15234,           // Consult√© √† chaque chargement
    nombreCommentaires: 89,      // Consult√© √† chaque chargement
    nombrePartages: 342,         // Consult√© √† chaque chargement
    tempsLectureMoyen: 5.2,      // En minutes
    tauxEngagement: 8.5,         // Pourcentage
    derniereMiseAJour: ISODate("2024-11-28T12:00:00Z")
  }
}
```

**Ratio lecture/√©criture :**
- üìñ Lectures : 10 000 fois par jour (chaque visiteur)
- ‚úçÔ∏è √âcritures : 50 fois par jour (nouveaux commentaires/partages)
- **Ratio : 200:1** ‚Üí Pattern Computed id√©al !

### 2. **Agr√©gations Complexes et Co√ªteuses**

Quand le calcul n√©cessite de parcourir beaucoup de donn√©es.

**Exemple : Note Moyenne d'un Produit**

```javascript
// Collection produits
{
  _id: ObjectId("507f1f77bcf86cd799439030"),
  nom: "Casque Audio Premium",
  prix: 299.99,

  // Note PR√â-CALCUL√âE
  evaluation: {
    noteMoyenne: 4.7,           // Au lieu de recalculer sur 5000 avis
    nombreAvis: 5234,
    distribution: {
      5: 3890,  // 3890 avis 5 √©toiles
      4: 1123,
      3: 178,
      2: 34,
      1: 9
    },
    derniereMiseAJour: ISODate("2024-11-28")
  }
}

// Sans Pattern Computed, il faudrait :
// 1. Charger 5234 avis
// 2. Calculer la moyenne
// 3. Calculer la distribution
// ‚Üí Tr√®s co√ªteux !
```

### 3. **Rapports et Dashboards**

Quand vous affichez des indicateurs de performance.

**Exemple : Dashboard Vendeur**

```javascript
// Collection vendeurs
{
  _id: ObjectId("507f1f77bcf86cd799439040"),
  nom: "Sophie Martin",
  email: "sophie@example.com",

  // M√©triques PR√â-CALCUL√âES pour le dashboard
  metriques: {
    // Ce mois-ci
    moisCourant: {
      nombreVentes: 47,
      chiffreAffaires: 12450.00,
      panierMoyen: 264.89,
      tauxConversion: 12.3,
      nouveauxClients: 23
    },

    // Mois dernier (pour comparaison)
    moisPrecedent: {
      nombreVentes: 52,
      chiffreAffaires: 13200.00,
      panierMoyen: 253.85
    },

    // Tendances
    tendances: {
      ventes: -9.6,           // % de variation
      chiffreAffaires: -5.7   // % de variation
    },

    // Tous les temps
    tousLesTemps: {
      totalVentes: 1234,
      totalRevenu: 345678.00,
      clientsFideles: 89
    },

    derniereMiseAJour: ISODate("2024-11-28T23:59:00Z")
  }
}
```

**Sans Pattern Computed :**
```javascript
// Il faudrait calculer tout √ßa √† chaque chargement du dashboard !
const ventesActuelles = await db.ventes.aggregate([
  { $match: { vendeurId: vendeurId, date: { $gte: debutMois } } },
  // ... agr√©gation complexe
]);
// Tr√®s lent si des milliers de ventes !
```

### 4. **D√©normalisation de Compteurs**

Quand vous avez besoin de compter des √©l√©ments li√©s.

**Exemple : Profil Utilisateur R√©seau Social**

```javascript
// Collection utilisateurs
{
  _id: ObjectId("507f1f77bcf86cd799439050"),
  username: "marie_dev",
  nom: "Marie Dubois",
  avatar: "marie.jpg",

  // Compteurs PR√â-CALCUL√âS
  compteurs: {
    publications: 342,        // Au lieu de count() √† chaque fois
    followers: 1523,          // Au lieu de count() √† chaque fois
    following: 487,           // Au lieu de count() √† chaque fois
    likes: 8934,              // Total de likes re√ßus
    commentaires: 2341        // Total de commentaires re√ßus
  },

  dateInscription: ISODate("2022-03-15")
}
```

---

## Strat√©gies de Mise √† Jour

Une question cruciale avec le Pattern Computed : **Quand et comment mettre √† jour les valeurs calcul√©es ?**

### Strat√©gie 1 : Mise √† Jour en Temps R√©el

Mettre √† jour imm√©diatement quand les donn√©es sources changent.

**Exemple : Compteur de Likes**

```javascript
// Fonction pour ajouter un like
async function ajouterLike(publicationId, userId) {
  // 1. Cr√©er le like
  await db.likes.insertOne({
    publicationId: publicationId,
    userId: userId,
    date: new Date()
  });

  // 2. Incr√©menter le compteur PR√â-CALCUL√â
  await db.publications.updateOne(
    { _id: publicationId },
    {
      $inc: { "statistiques.nombreLikes": 1 }
    }
  );
}

// Fonction pour retirer un like
async function retirerLike(publicationId, userId) {
  // 1. Supprimer le like
  await db.likes.deleteOne({
    publicationId: publicationId,
    userId: userId
  });

  // 2. D√©cr√©menter le compteur PR√â-CALCUL√â
  await db.publications.updateOne(
    { _id: publicationId },
    {
      $inc: { "statistiques.nombreLikes": -1 }
    }
  );
}
```

**Avantages :**
- ‚úÖ Donn√©es toujours √† jour
- ‚úÖ Pas de d√©lai

**Inconv√©nients :**
- ‚ö†Ô∏è Deux op√©rations pour chaque action (peut √™tre dans une transaction)
- ‚ö†Ô∏è Plus complexe √† g√©rer

### Strat√©gie 2 : Mise √† Jour par Batch (Traitement par Lot)

Recalculer p√©riodiquement (toutes les heures, tous les jours).

**Exemple : Statistiques de Ventes Quotidiennes**

```javascript
// Job ex√©cut√© chaque nuit √† minuit
async function recalculerStatistiquesVendeurs() {
  const vendeurs = await db.vendeurs.find({}).toArray();

  for (const vendeur of vendeurs) {
    // Calculer les stats du mois courant
    const debutMois = new Date(
      new Date().getFullYear(),
      new Date().getMonth(),
      1
    );

    const stats = await db.ventes.aggregate([
      {
        $match: {
          vendeurId: vendeur._id,
          date: { $gte: debutMois }
        }
      },
      {
        $group: {
          _id: null,
          nombreVentes: { $sum: 1 },
          chiffreAffaires: { $sum: "$montant" },
          panierMoyen: { $avg: "$montant" }
        }
      }
    ]).toArray();

    // Mettre √† jour les valeurs calcul√©es
    await db.vendeurs.updateOne(
      { _id: vendeur._id },
      {
        $set: {
          "metriques.moisCourant": stats[0],
          "metriques.derniereMiseAJour": new Date()
        }
      }
    );
  }

  console.log("‚úÖ Statistiques recalcul√©es pour tous les vendeurs");
}

// Planifier l'ex√©cution
// Exemple avec node-cron
const cron = require('node-cron');
cron.schedule('0 0 * * *', recalculerStatistiquesVendeurs);
```

**Avantages :**
- ‚úÖ Simple √† impl√©menter
- ‚úÖ Pas d'impact sur les op√©rations en temps r√©el
- ‚úÖ Peut √™tre optimis√© (agr√©gations massives)

**Inconv√©nients :**
- ‚ö†Ô∏è Donn√©es potentiellement obsol√®tes (d√©lai)
- ‚ö†Ô∏è Charge importante pendant le batch

### Strat√©gie 3 : Mise √† Jour √† la Demande (Lazy Loading)

Calculer seulement quand n√©cessaire et mettre en cache.

**Exemple : Statistiques avec TTL**

```javascript
// Collection produits
{
  _id: ObjectId("507f1f77bcf86cd799439060"),
  nom: "Produit XYZ",

  statistiques: {
    nombreVues: 1234,
    nombreVentes: 89,
    derniereMiseAJour: ISODate("2024-11-28T10:00:00Z"),
    ttl: 3600  // Valable 1 heure (en secondes)
  }
}

// Fonction pour r√©cup√©rer les statistiques
async function getStatistiques(produitId) {
  const produit = await db.produits.findOne({ _id: produitId });

  const maintenant = new Date();
  const derniereMaj = produit.statistiques.derniereMiseAJour;
  const age = (maintenant - derniereMaj) / 1000;  // En secondes

  // Si les stats sont expir√©es, recalculer
  if (age > produit.statistiques.ttl) {
    const statsRecalculees = await recalculerStatistiques(produitId);

    await db.produits.updateOne(
      { _id: produitId },
      {
        $set: {
          statistiques: {
            ...statsRecalculees,
            derniereMiseAJour: new Date(),
            ttl: 3600
          }
        }
      }
    );

    return statsRecalculees;
  }

  // Sinon, utiliser les valeurs en cache
  return produit.statistiques;
}
```

**Avantages :**
- ‚úÖ Calcul seulement quand n√©cessaire
- ‚úÖ √âquilibre entre fra√Æcheur et performance

**Inconv√©nients :**
- ‚ö†Ô∏è Plus complexe √† impl√©menter
- ‚ö†Ô∏è Premi√®re requ√™te apr√®s expiration est lente

### Strat√©gie 4 : Mise √† Jour Hybride

Combiner plusieurs strat√©gies selon les besoins.

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439070"),
  nom: "Produit",

  statistiques: {
    // Temps r√©el (mis √† jour imm√©diatement)
    stock: 45,
    derniereVente: ISODate("2024-11-28T15:30:00Z"),

    // Batch quotidien
    ventesMoisCourant: 234,
    revenusMoisCourant: 12450.00,

    // √Ä la demande (TTL 1 heure)
    tendancesVentes: {
      croissance: 12.5,
      prediction: 280,
      confiance: 0.85,
      calculeLe: ISODate("2024-11-28T14:00:00Z")
    }
  }
}
```

---

## Exemples Pratiques D√©taill√©s

### Exemple 1 : Plateforme de Cours en Ligne

**Contexte :** Plateforme avec des cours, des chapitres et des le√ßons.

```javascript
// Collection cours
{
  _id: ObjectId("507f1f77bcf86cd799439080"),
  titre: "Formation MongoDB Compl√®te",
  instructeur: "Expert MongoDB",
  prix: 149.99,

  // Statistiques PR√â-CALCUL√âES
  statistiques: {
    // Contenu
    nombreChapitres: 23,
    nombreLecons: 347,
    dureeTotale: 2850,  // En minutes (47.5 heures)

    // √âtudiants
    nombreEtudiants: 12547,
    etudinantsActifs: 8234,  // Connect√©s dans les 7 derniers jours
    tauxCompletion: 67.8,    // % qui terminent le cours

    // √âvaluations
    noteMoyenne: 4.8,
    nombreAvis: 3456,
    tauxSatisfaction: 96.2,

    // Engagement
    tempsApprentissageMoyen: 3.2,  // Heures par semaine
    progressionMoyenne: 45.3,      // % de compl√©tion moyenne

    // Financier
    revenuTotal: 1881953.00,
    revenuMoisCourant: 89550.00,

    derniereMiseAJour: ISODate("2024-11-28T23:00:00Z")
  }
}
```

### Exemple 2 : Application de Fitness

**Contexte :** Application de suivi d'entra√Ænement sportif.

```javascript
// Collection utilisateurs
{
  _id: ObjectId("507f1f77bcf86cd799439090"),
  nom: "Pierre Martin",
  email: "pierre@example.com",

  // Statistiques PR√â-CALCUL√âES
  statistiques: {
    // Cette semaine
    semaineCourante: {
      nombreSeances: 4,
      caloriesBrulees: 2340,
      tempsExercice: 285,  // minutes
      distanceParcourue: 18.5  // km
    },

    // Ce mois-ci
    moisCourant: {
      nombreSeances: 16,
      caloriesBrulees: 9876,
      tempsExercice: 1140,
      distanceParcourue: 78.3
    },

    // Tous les temps
    tousLesTemps: {
      nombreSeances: 234,
      caloriesBrulees: 123456,
      tempsExercice: 15780,  // 263 heures
      distanceParcourue: 1234.5
    },

    derniereMiseAJour: ISODate("2024-11-28T20:00:00Z")
  }
}
```

---

## Avantages du Pattern Computed

### ‚úÖ 1. **Performances Exceptionnelles**

Lecture instantan√©e au lieu de calculs co√ªteux :

```javascript
// Sans Pattern Computed : 500ms
const stats = await db.ventes.aggregate([/* agr√©gation complexe */]);

// Avec Pattern Computed : 5ms
const produit = await db.produits.findOne({ _id: produitId });
const stats = produit.statistiques;  // D√©j√† l√† !
```

**Gain : 100x plus rapide !**

### ‚úÖ 2. **R√©duction de la Charge Serveur**

Moins de calculs = moins de CPU

### ‚úÖ 3. **Meilleure Exp√©rience Utilisateur**

Temps de r√©ponse ultra-rapides

### ‚úÖ 4. **Scalabilit√©**

Performances constantes m√™me avec beaucoup de donn√©es

---

## Bonnes Pratiques

### ‚úÖ 1. Stocker la Date de Mise √† Jour

```javascript
{
  statistiques: {
    nombreVues: 1234,
    nombreLikes: 89,
    derniereMiseAJour: ISODate("2024-11-28T10:00:00Z")  // ‚Üê Important !
  }
}
```

### ‚úÖ 2. Utiliser des Transactions pour la Coh√©rence

```javascript
const session = client.startSession();

try {
  await session.withTransaction(async () => {
    await db.ventes.insertOne(vente, { session });
    await db.produits.updateOne(
      { _id: vente.produitId },
      { $inc: { "statistiques.nombreVentes": 1 } },
      { session }
    );
  });
} finally {
  await session.endSession();
}
```

### ‚úÖ 3. Impl√©menter des Recalculs de V√©rification

```javascript
async function verifierEtCorrigerStatistiques() {
  const produits = await db.produits.find({}).toArray();

  for (const produit of produits) {
    const statsReelles = await db.ventes.aggregate([
      { $match: { produitId: produit._id } },
      { $group: { _id: null, count: { $sum: 1 } } }
    ]).toArray();

    if (statsReelles[0].count !== produit.statistiques.nombreVentes) {
      console.warn(`‚ö†Ô∏è Incoh√©rence d√©tect√©e pour produit ${produit._id}`);
      // Corriger...
    }
  }
}
```

---

## Conclusion

Le **Pattern Computed** est une technique puissante pour am√©liorer drastiquement les performances :

**Avantages :**
- ‚ö° Performances exceptionnelles (100x plus rapide)
- üí∞ R√©duction drastique de la charge CPU
- üòä Meilleure exp√©rience utilisateur

**Consid√©rations :**
- üîÑ Complexit√© de mise √† jour
- ‚ö†Ô∏è Risque de d√©synchronisation
- üíæ Espace disque suppl√©mentaire

**R√®gle d'or :** Utilisez le Pattern Computed quand vous lisez beaucoup plus souvent que vous n'√©crivez (ratio > 10:1).

---

## Ressources Compl√©mentaires

- [Documentation MongoDB - Computed Pattern](https://www.mongodb.com/blog/post/building-with-patterns-the-computed-pattern)

---


‚è≠Ô∏è [Pattern Bucket](/04-modelisation-des-donnees/06.6-pattern-bucket.md)
