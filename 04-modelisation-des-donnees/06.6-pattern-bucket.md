üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.6.6 Pattern Bucket (Regroupement par Seaux)

## Introduction

Le **Pattern Bucket** (ou pattern des seaux) est une technique de mod√©lisation qui consiste √† **regrouper plusieurs √©v√©nements ou mesures dans un seul document** au lieu de cr√©er un document pour chaque √©v√©nement individuel.

> **Analogie simple :** Imaginez que vous collectez des pi√®ces de monnaie. Vous avez deux options :
> 1. Garder chaque pi√®ce dans un petit sac individuel (1 000 pi√®ces = 1 000 sacs)
> 2. Mettre 100 pi√®ces dans un seau (1 000 pi√®ces = 10 seaux)
>
> Le Pattern Bucket, c'est l'option 2 : regrouper intelligemment pour mieux g√©rer.

Ce pattern est **essentiel** pour les applications IoT, les s√©ries temporelles, les logs et tout syst√®me g√©n√©rant beaucoup de petits √©v√©nements.

---

## Le Probl√®me : Trop de Petits Documents

### Sc√©nario : Capteurs IoT de Temp√©rature

Imaginez un syst√®me de monitoring avec 1000 capteurs qui envoient la temp√©rature toutes les minutes.

#### ‚ùå Approche Na√Øve : Un Document par Mesure

```javascript
// Collection mesures_temperature
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  capteurId: "sensor_001",
  temperature: 22.5,
  humidite: 65,
  timestamp: ISODate("2024-11-28T10:00:00Z")
}

{
  _id: ObjectId("507f1f77bcf86cd799439012"),
  capteurId: "sensor_001",
  temperature: 22.6,
  humidite: 64,
  timestamp: ISODate("2024-11-28T10:01:00Z")
}

{
  _id: ObjectId("507f1f77bcf86cd799439013"),
  capteurId: "sensor_001",
  temperature: 22.4,
  humidite: 65,
  timestamp: ISODate("2024-11-28T10:02:00Z")
}

// ... et ainsi de suite
```

**Calcul :**
- 1000 capteurs √ó 60 mesures/heure √ó 24 heures = **1 440 000 documents par jour**
- Sur un an : **525 600 000 documents !**

**Probl√®mes :**
- üíæ **Overhead √©norme** : Chaque document a un _id (12 octets), des m√©tadonn√©es, etc.
- üêå **Performances d√©grad√©es** : Des millions de petits documents ralentissent les requ√™tes
- üìä **Index volumineux** : Les index deviennent gigantesques
- üí∞ **Co√ªt de stockage** √©lev√©
- üîç **Agr√©gations lentes** sur autant de documents

#### ‚úÖ Solution avec Pattern Bucket

```javascript
// Collection mesures_temperature_buckets
{
  _id: ObjectId("507f1f77bcf86cd799439020"),
  capteurId: "sensor_001",

  // M√©tadonn√©es du bucket
  dateBucket: ISODate("2024-11-28T10:00:00Z"),  // D√©but de l'heure
  nombreMesures: 60,  // 60 minutes = 1 heure de donn√©es

  // Statistiques pr√©-calcul√©es
  statistiques: {
    temperatureMin: 22.1,
    temperatureMax: 23.8,
    temperatureMoyenne: 22.7,
    humiditeMin: 63,
    humiditeMax: 67,
    humiditeMoyenne: 65.2
  },

  // Tableau de mesures (1 heure = 60 mesures)
  mesures: [
    {
      minute: 0,
      temperature: 22.5,
      humidite: 65,
      timestamp: ISODate("2024-11-28T10:00:00Z")
    },
    {
      minute: 1,
      temperature: 22.6,
      humidite: 64,
      timestamp: ISODate("2024-11-28T10:01:00Z")
    },
    // ... 58 autres mesures
    {
      minute: 59,
      temperature: 22.8,
      humidite: 66,
      timestamp: ISODate("2024-11-28T10:59:00Z")
    }
  ]
}
```

**Calcul avec Buckets :**
- 1000 capteurs √ó 24 buckets/jour (1 par heure) = **24 000 documents par jour**
- Sur un an : **8 760 000 documents**

**Gain : 60x moins de documents !** (525M ‚Üí 8.7M)

**Avantages :**
- ‚úÖ **60x moins de documents** √† g√©rer
- ‚úÖ **Index 60x plus petits**
- ‚úÖ **Requ√™tes beaucoup plus rapides**
- ‚úÖ **Statistiques pr√©-calcul√©es** incluses
- ‚úÖ **Moins de stockage** utilis√©

---

## Concept Cl√© : Regroupement Temporel

Le Pattern Bucket repose sur le **regroupement par p√©riode de temps** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              √âv√©nements Individuels                     ‚îÇ
‚îÇ  10:00 ‚Üí 10:01 ‚Üí 10:02 ‚Üí ... ‚Üí 10:59                    ‚îÇ
‚îÇ   (60 √©v√©nements s√©par√©s)                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì
                  [ BUCKETING ]
                        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Bucket Horaire                          ‚îÇ
‚îÇ  { heure: 10:00-11:00, mesures: [60 √©v√©nements] }       ‚îÇ
‚îÇ  (1 seul document)                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Strat√©gies de bucketing courantes :**
- **Par heure** : 1 bucket = 1 heure de donn√©es
- **Par jour** : 1 bucket = 1 jour de donn√©es
- **Par nombre** : 1 bucket = 100 √©v√©nements (quelle que soit la dur√©e)

---

## Quand Utiliser le Pattern Bucket ?

### 1. **Donn√©es de S√©ries Temporelles**

Toutes les donn√©es avec un horodatage (timestamp) qui arrivent r√©guli√®rement.

**Exemple : Monitoring Serveur**

```javascript
// Collection metriques_serveur_buckets
{
  _id: ObjectId("507f1f77bcf86cd799439030"),
  serveurId: "web-server-01",
  dateBucket: ISODate("2024-11-28T10:00:00Z"),

  // M√©tadonn√©es
  nombreMetriques: 60,
  interval: "1_heure",

  // Statistiques globales
  statistiques: {
    cpuMoyen: 45.3,
    cpuMax: 87.2,
    cpuMin: 12.5,
    memoireMoyenne: 6.2,  // GB
    memoireMax: 7.8,
    disqueUtilisation: 72.5  // %
  },

  // M√©triques minute par minute
  metriques: [
    {
      minute: 0,
      timestamp: ISODate("2024-11-28T10:00:00Z"),
      cpu: 45.2,
      memoire: 6.1,
      disque: 72.3,
      reseau: { in: 1250, out: 890 }  // KB/s
    },
    {
      minute: 1,
      timestamp: ISODate("2024-11-28T10:01:00Z"),
      cpu: 47.8,
      memoire: 6.3,
      disque: 72.4,
      reseau: { in: 1340, out: 920 }
    },
    // ... 58 autres m√©triques
  ]
}
```

### 2. **Donn√©es IoT (Internet des Objets)**

Capteurs, compteurs, dispositifs connect√©s.

**Exemple : Compteurs √âlectriques Intelligents**

```javascript
// Collection consommation_electrique_buckets
{
  _id: ObjectId("507f1f77bcf86cd799439040"),
  compteurId: "COMP-78945-FR",
  adresse: "123 Rue de la Paix, Paris",
  dateBucket: ISODate("2024-11-28T00:00:00Z"),  // 1 bucket par jour

  // M√©tadonn√©es
  nombreReleves: 96,  // Relev√© toutes les 15 minutes

  // Statistiques journali√®res
  statistiques: {
    consommationTotale: 28.5,  // kWh
    consommationMoyenne: 1.19,  // kWh par p√©riode
    consommationMax: 3.2,
    consommationMin: 0.3,
    heurePointe: ISODate("2024-11-28T19:30:00Z"),
    coutEstime: 5.70  // EUR
  },

  // Relev√©s (toutes les 15 minutes = 96 par jour)
  releves: [
    {
      heure: ISODate("2024-11-28T00:00:00Z"),
      consommation: 0.8,  // kWh
      puissance: 320  // W
    },
    {
      heure: ISODate("2024-11-28T00:15:00Z"),
      consommation: 0.6,
      puissance: 240
    },
    // ... 94 autres relev√©s
  ]
}
```

### 3. **Logs et √âv√©nements Applicatifs**

Journalisation d'√©v√©nements, erreurs, acc√®s.

**Exemple : Logs d'Acc√®s Web**

```javascript
// Collection logs_web_buckets
{
  _id: ObjectId("507f1f77bcf86cd799439050"),
  serveurId: "web-01",
  dateBucket: ISODate("2024-11-28T10:00:00Z"),

  // M√©tadonn√©es
  nombreRequetes: 5423,

  // Statistiques
  statistiques: {
    reussies: 5234,  // Status 200-299
    erreurs: 89,     // Status 400-499
    serveurDown: 100, // Status 500-599
    tempsMoyenReponse: 145,  // ms
    tempsMaxReponse: 3420,
    bandwidthTotal: 1.2  // GB
  },

  // √âchantillon de requ√™tes (pas toutes, trop volumineux)
  echantillonRequetes: [
    {
      timestamp: ISODate("2024-11-28T10:05:23Z"),
      ip: "192.168.1.100",
      methode: "GET",
      url: "/api/users/123",
      status: 200,
      duree: 145,  // ms
      userAgent: "Mozilla/5.0..."
    },
    // ... 99 autres requ√™tes √©chantillonn√©es (1 sur 50)
  ],

  // Agr√©gations par URL
  topURLs: [
    { url: "/api/products", count: 1234, tempsMoyen: 120 },
    { url: "/api/users", count: 892, tempsMoyen: 95 },
    { url: "/", count: 567, tempsMoyen: 45 }
  ]
}
```

### 4. **Donn√©es Financi√®res et Trading**

Prix, transactions, ordres.

**Exemple : Cours de Bourse**

```javascript
// Collection cours_actions_buckets
{
  _id: ObjectId("507f1f77bcf86cd799439060"),
  symbole: "AAPL",
  dateBucket: ISODate("2024-11-28T09:00:00Z"),  // 1 heure de trading

  // M√©tadonn√©es
  nombreTicks: 3600,  // Donn√©es par seconde

  // Statistiques horaires (OHLC)
  statistiques: {
    ouverture: 189.50,
    hauteur: 191.25,
    bas: 189.10,
    fermeture: 190.80,
    volumeTotal: 2456789,
    nombreTransactions: 12543
  },

  // Donn√©es secondes (3600 points)
  ticks: [
    {
      seconde: 0,
      timestamp: ISODate("2024-11-28T09:00:00Z"),
      prix: 189.50,
      volume: 850
    },
    {
      seconde: 1,
      timestamp: ISODate("2024-11-28T09:00:01Z"),
      prix: 189.52,
      volume: 420
    },
    // ... 3598 autres ticks
  ]
}
```

---

## Strat√©gies de Bucketing

### Strat√©gie 1 : Bucketing Temporel Fixe

Grouper par p√©riode de temps fixe (heure, jour, semaine).

**Exemple : Bucket Horaire**

```javascript
{
  capteurId: "sensor_001",
  dateBucket: ISODate("2024-11-28T10:00:00Z"),  // D√©but de l'heure
  mesures: [/* 60 mesures */]
}

{
  capteurId: "sensor_001",
  dateBucket: ISODate("2024-11-28T11:00:00Z"),  // Heure suivante
  mesures: [/* 60 mesures */]
}
```

**Avantages :**
- ‚úÖ Simple √† impl√©menter
- ‚úÖ Pr√©dictible
- ‚úÖ Facile √† requ√™ter par p√©riode

**Inconv√©nients :**
- ‚ö†Ô∏è Taille variable si le flux de donn√©es est irr√©gulier

### Strat√©gie 2 : Bucketing par Nombre

Grouper par nombre d'√©v√©nements (ex: 1000 √©v√©nements par bucket).

**Exemple : Bucket de 1000 Transactions**

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439070"),
  utilisateurId: "user_123",
  bucketNumero: 5,  // 5√®me bucket pour cet utilisateur

  // M√©tadonn√©es
  nombreTransactions: 1000,
  dateDebut: ISODate("2024-11-15T08:23:00Z"),
  dateFin: ISODate("2024-11-28T15:47:00Z"),

  // Transactions
  transactions: [
    /* 1000 transactions */
  ]
}
```

**Avantages :**
- ‚úÖ Taille de document pr√©visible
- ‚úÖ Bon pour donn√©es irr√©guli√®res

**Inconv√©nients :**
- ‚ö†Ô∏è Plus complexe √† requ√™ter par p√©riode
- ‚ö†Ô∏è N√©cessite un compteur

### Strat√©gie 3 : Bucketing Hybride

Combiner temps ET nombre avec des limites.

**Exemple : Bucket Horaire ou 10 000 √âv√©nements Max**

```javascript
{
  capteurId: "sensor_001",
  dateBucket: ISODate("2024-11-28T10:00:00Z"),

  // Le bucket se ferme si :
  // - L'heure est √©coul√©e OU
  // - 10 000 mesures sont atteintes

  nombreMesures: 8234,  // Peut varier
  bucketFerme: false,   // Toujours ouvert

  mesures: [/* jusqu'√† 10 000 */]
}
```

**Avantages :**
- ‚úÖ Taille de document ma√Ætris√©e
- ‚úÖ Requ√™tes temporelles possibles

---

## Impl√©mentation du Pattern Bucket

### Insertion de Donn√©es

```javascript
// Fonction pour ins√©rer une nouvelle mesure
async function insererMesure(capteurId, mesure) {
  // 1. D√©terminer le bucket (d√©but de l'heure)
  const maintenant = new Date(mesure.timestamp);
  const debutHeure = new Date(
    maintenant.getFullYear(),
    maintenant.getMonth(),
    maintenant.getDate(),
    maintenant.getHours(),
    0, 0, 0
  );

  // 2. Chercher le bucket existant ou le cr√©er
  const resultat = await db.mesures_temperature_buckets.updateOne(
    {
      capteurId: capteurId,
      dateBucket: debutHeure,
      nombreMesures: { $lt: 60 }  // Pas encore plein
    },
    {
      $push: {
        mesures: {
          minute: maintenant.getMinutes(),
          temperature: mesure.temperature,
          humidite: mesure.humidite,
          timestamp: mesure.timestamp
        }
      },
      $inc: { nombreMesures: 1 },
      $min: { "statistiques.temperatureMin": mesure.temperature },
      $max: { "statistiques.temperatureMax": mesure.temperature },
      $setOnInsert: {
        capteurId: capteurId,
        dateBucket: debutHeure,
        statistiques: {
          temperatureMin: mesure.temperature,
          temperatureMax: mesure.temperature
        }
      }
    },
    { upsert: true }
  );

  return resultat;
}

// Utilisation
await insererMesure("sensor_001", {
  temperature: 22.5,
  humidite: 65,
  timestamp: new Date()
});
```

### Requ√™tes sur les Buckets

**Requ√™te 1 : Obtenir les donn√©es d'une p√©riode**

```javascript
// R√©cup√©rer toutes les mesures d'un capteur pour une journ√©e
async function getMesuresJour(capteurId, date) {
  const debutJour = new Date(date);
  debutJour.setHours(0, 0, 0, 0);

  const finJour = new Date(date);
  finJour.setHours(23, 59, 59, 999);

  const buckets = await db.mesures_temperature_buckets
    .find({
      capteurId: capteurId,
      dateBucket: {
        $gte: debutJour,
        $lte: finJour
      }
    })
    .sort({ dateBucket: 1 })
    .toArray();

  // Aplatir toutes les mesures
  const toutesMesures = buckets.flatMap(bucket => bucket.mesures);

  return toutesMesures;
}
```

**Requ√™te 2 : Statistiques sur une p√©riode**

```javascript
// Obtenir les statistiques agr√©g√©es sur une semaine
async function getStatistiquesSemaine(capteurId, dateDebut) {
  const dateFin = new Date(dateDebut);
  dateFin.setDate(dateFin.getDate() + 7);

  const stats = await db.mesures_temperature_buckets.aggregate([
    {
      $match: {
        capteurId: capteurId,
        dateBucket: {
          $gte: dateDebut,
          $lt: dateFin
        }
      }
    },
    {
      $group: {
        _id: null,
        temperatureMin: { $min: "$statistiques.temperatureMin" },
        temperatureMax: { $max: "$statistiques.temperatureMax" },
        temperatureMoyenne: { $avg: "$statistiques.temperatureMoyenne" },
        nombreMesuresTotal: { $sum: "$nombreMesures" }
      }
    }
  ]).toArray();

  return stats[0];
}
```

**Requ√™te 3 : Trouver les anomalies**

```javascript
// Trouver tous les buckets o√π la temp√©rature a d√©pass√© un seuil
async function trouverAnomalies(capteurId, seuilMax) {
  const anomalies = await db.mesures_temperature_buckets
    .find({
      capteurId: capteurId,
      "statistiques.temperatureMax": { $gt: seuilMax }
    })
    .project({
      dateBucket: 1,
      "statistiques.temperatureMax": 1,
      // Filtrer les mesures pour n'avoir que celles au-dessus du seuil
      mesures: {
        $filter: {
          input: "$mesures",
          as: "mesure",
          cond: { $gt: ["$$mesure.temperature", seuilMax] }
        }
      }
    })
    .toArray();

  return anomalies;
}
```

---

## Gestion du Cycle de Vie des Buckets

### Fermeture des Buckets

```javascript
// Fonction pour fermer un bucket (quand plein ou p√©riode √©coul√©e)
async function fermerBucket(bucketId) {
  // 1. Calculer les statistiques finales
  const bucket = await db.mesures_temperature_buckets.findOne({
    _id: bucketId
  });

  const temperatures = bucket.mesures.map(m => m.temperature);
  const moyenne = temperatures.reduce((a, b) => a + b, 0) / temperatures.length;

  // 2. Marquer comme ferm√© et mettre √† jour les stats
  await db.mesures_temperature_buckets.updateOne(
    { _id: bucketId },
    {
      $set: {
        bucketFerme: true,
        "statistiques.temperatureMoyenne": moyenne,
        dateFermeture: new Date()
      }
    }
  );
}
```

### Archivage des Anciens Buckets

```javascript
// Job pour archiver les buckets de plus de 90 jours
async function archiverAnciensBuckets() {
  const dateArchivage = new Date();
  dateArchivage.setDate(dateArchivage.getDate() - 90);

  // 1. Trouver les buckets √† archiver
  const bucketsAArchiver = await db.mesures_temperature_buckets
    .find({
      dateBucket: { $lt: dateArchivage }
    })
    .toArray();

  if (bucketsAArchiver.length === 0) {
    console.log("Aucun bucket √† archiver");
    return;
  }

  // 2. Copier vers collection d'archives
  await db.mesures_temperature_archives.insertMany(bucketsAArchiver);

  // 3. Supprimer de la collection principale
  await db.mesures_temperature_buckets.deleteMany({
    dateBucket: { $lt: dateArchivage }
  });

  console.log(`${bucketsAArchiver.length} buckets archiv√©s`);
}

// Planifier l'ex√©cution mensuelle
const cron = require('node-cron');
cron.schedule('0 2 1 * *', archiverAnciensBuckets);  // 1er du mois √† 2h
```

---

## Avantages du Pattern Bucket

### ‚úÖ 1. **R√©duction Massive du Nombre de Documents**

```javascript
// Sans Bucket : 525 millions de documents par an
// Avec Bucket : 8.7 millions de documents par an
// ‚Üí 60x moins de documents !
```

### ‚úÖ 2. **Performances Am√©lior√©es**

Les requ√™tes sont beaucoup plus rapides :

```javascript
// Requ√™te sur 1 journ√©e :
// - Sans bucket : Scanner 1.4 million de documents
// - Avec bucket : Scanner 24 documents (1 par heure)
// ‚Üí 58 000x moins de documents √† parcourir !
```

### ‚úÖ 3. **Index Plus Petits**

```javascript
// Taille d'index sur le champ capteurId :
// - Sans bucket : ~6.3 GB (525M documents)
// - Avec bucket : ~105 MB (8.7M documents)
// ‚Üí 60x plus petit !
```

### ‚úÖ 4. **Statistiques Pr√©-calcul√©es**

Les min/max/moyenne sont d√©j√† disponibles :

```javascript
// R√©cup√©rer la temp√©rature max d'une journ√©e :
// Sans bucket : Agr√©gation sur 1440 documents
// Avec bucket : Lire 24 valeurs d√©j√† calcul√©es
```

### ‚úÖ 5. **Meilleure Utilisation du Stockage**

Moins d'overhead par mesure :

```javascript
// Overhead par mesure :
// - Sans bucket : 12 octets (_id) + 16 octets (metadata) = 28 octets
// - Avec bucket : ~0.5 octet par mesure
// ‚Üí 56x moins d'overhead !
```

---

## Inconv√©nients et Consid√©rations

### ‚ö†Ô∏è 1. **Complexit√© d'Impl√©mentation**

Plus complexe que l'insertion simple :

```javascript
// Sans bucket : Simple insert
await db.mesures.insertOne(mesure);

// Avec bucket : Logique de bucketing n√©cessaire
await insererDansBucket(mesure);  // Plus complexe
```

### ‚ö†Ô∏è 2. **Requ√™tes Plus Complexes**

Acc√©der √† une mesure sp√©cifique n√©cessite de naviguer dans les tableaux :

```javascript
// Trouver une mesure pr√©cise √† 10:15:23
const bucket = await db.buckets.findOne({
  dateBucket: ISODate("2024-11-28T10:00:00Z"),
  "mesures.timestamp": ISODate("2024-11-28T10:15:23Z")
});

// Puis filtrer dans l'application
const mesure = bucket.mesures.find(m =>
  m.timestamp.getTime() === targetTime.getTime()
);
```

### ‚ö†Ô∏è 3. **Mises √† Jour Limit√©es**

Difficile de modifier une mesure dans un bucket :

```javascript
// Modifier une temp√©rature √† 10:15
// N√©cessite un update avec position dans le tableau
await db.buckets.updateOne(
  {
    dateBucket: ISODate("2024-11-28T10:00:00Z"),
    "mesures.minute": 15
  },
  {
    $set: {
      "mesures.$.temperature": 23.5  // Mise √† jour positionnelle
    }
  }
);
```

### ‚ö†Ô∏è 4. **Taille de Document √† Surveiller**

Risque d'approcher la limite de 16 Mo :

```javascript
// Calcul de taille pour bucket horaire :
// 3600 mesures (1 par seconde) √ó 50 octets = 180 KB
// ‚Üí OK, loin des 16 MB

// Mais bucket journalier :
// 86400 mesures √ó 50 octets = 4.3 MB
// ‚Üí Attention si donn√©es plus complexes !
```

---

## Bonnes Pratiques

### ‚úÖ 1. Choisir la Bonne Granularit√©

```javascript
/**
 * Guides de granularit√© :
 *
 * - Donn√©es par seconde ‚Üí Bucket horaire (3600 points)
 * - Donn√©es par minute ‚Üí Bucket journalier (1440 points)
 * - Donn√©es par heure ‚Üí Bucket mensuel (~720 points)
 * - Donn√©es irr√©guli√®res ‚Üí Bucket par nombre (ex: 1000 points)
 *
 * R√®gle : Viser 100-1000 points par bucket
 */
```

### ‚úÖ 2. Inclure des M√©tadonn√©es Utiles

```javascript
{
  _id: ObjectId("..."),
  capteurId: "sensor_001",
  dateBucket: ISODate("2024-11-28T10:00:00Z"),

  // ‚úÖ M√©tadonn√©es utiles
  nombreMesures: 60,
  bucketFerme: true,
  dateFermeture: ISODate("2024-11-28T11:00:05Z"),
  version: 1,  // Pour √©volution du sch√©ma

  // ‚úÖ Informations contextuelles
  localisation: {
    batiment: "A",
    etage: 3,
    salle: "301"
  },

  mesures: [/* ... */]
}
```

### ‚úÖ 3. Utiliser des Index Appropri√©s

```javascript
// Index compos√© pour requ√™tes temporelles
db.mesures_temperature_buckets.createIndex({
  capteurId: 1,
  dateBucket: 1
});

// Index pour statistiques
db.mesures_temperature_buckets.createIndex({
  "statistiques.temperatureMax": 1,
  dateBucket: 1
});

// Index pour buckets ferm√©s (archivage)
db.mesures_temperature_buckets.createIndex({
  bucketFerme: 1,
  dateBucket: 1
});
```

### ‚úÖ 4. Pr√©voir un M√©canisme de Fermeture

```javascript
// Job pour fermer automatiquement les buckets expir√©s
async function fermerBucketsExpires() {
  const heureActuelle = new Date();
  heureActuelle.setHours(heureActuelle.getHours() - 1);  // Buckets de plus d'1h

  const resultat = await db.mesures_temperature_buckets.updateMany(
    {
      bucketFerme: false,
      dateBucket: { $lt: heureActuelle }
    },
    {
      $set: {
        bucketFerme: true,
        dateFermeture: new Date()
      }
    }
  );

  console.log(`${resultat.modifiedCount} buckets ferm√©s`);
}

// Ex√©cuter toutes les heures
cron.schedule('0 * * * *', fermerBucketsExpires);
```

### ‚úÖ 5. Impl√©menter une Strat√©gie d'Archivage

```javascript
/**
 * Strat√©gie d'archivage recommand√©e :
 *
 * - Collection active : Donn√©es des 30 derniers jours
 * - Collection archives : Donn√©es de 30-365 jours
 * - Stockage froid : Donn√©es > 365 jours (S3, etc.)
 *
 * Avec compression et agr√©gation progressive
 */

// Exemple : Compresser en buckets journaliers apr√®s 30 jours
async function compresserEnBucketsJournaliers(date) {
  const bucketsHoraires = await db.mesures_temperature_buckets
    .find({
      dateBucket: {
        $gte: new Date(date.setHours(0, 0, 0, 0)),
        $lt: new Date(date.setHours(23, 59, 59, 999))
      }
    })
    .toArray();

  // Agr√©ger en un seul bucket journalier
  const bucketJournalier = {
    capteurId: bucketsHoraires[0].capteurId,
    dateBucket: new Date(date.setHours(0, 0, 0, 0)),
    type: "journalier",

    statistiques: {
      temperatureMin: Math.min(...bucketsHoraires.map(b => b.statistiques.temperatureMin)),
      temperatureMax: Math.max(...bucketsHoraires.map(b => b.statistiques.temperatureMax)),
      // ... autres stats
    },

    // Garder seulement les moyennes horaires
    moyennesHoraires: bucketsHoraires.map(b => ({
      heure: b.dateBucket,
      temperatureMoyenne: b.statistiques.temperatureMoyenne,
      humiditeMoyenne: b.statistiques.humiditeMoyenne
    }))
  };

  // Ins√©rer dans collection archives
  await db.mesures_temperature_archives.insertOne(bucketJournalier);

  // Supprimer les buckets horaires
  await db.mesures_temperature_buckets.deleteMany({
    _id: { $in: bucketsHoraires.map(b => b._id) }
  });
}
```

### ‚úÖ 6. Monitorer les Tailles de Buckets

```javascript
// Script de monitoring
async function monitorerTaillesBuckets() {
  const stats = await db.mesures_temperature_buckets.aggregate([
    {
      $project: {
        taille: { $bsonSize: "$$ROOT" },
        nombreMesures: 1,
        dateBucket: 1
      }
    },
    {
      $group: {
        _id: null,
        tailleMin: { $min: "$taille" },
        tailleMax: { $max: "$taille" },
        tailleMoyenne: { $avg: "$taille" },
        nombreMesuresMax: { $max: "$nombreMesures" }
      }
    }
  ]).toArray();

  console.log(`
    Statistiques des buckets :
    - Taille min : ${stats[0].tailleMin} octets
    - Taille max : ${stats[0].tailleMax} octets
    - Taille moyenne : ${Math.round(stats[0].tailleMoyenne)} octets
    - Mesures max : ${stats[0].nombreMesuresMax}
  `);

  // Alerte si approche de 16 MB
  if (stats[0].tailleMax > 15000000) {
    console.warn("‚ö†Ô∏è ALERTE : Un bucket approche la limite de 16 MB !");
  }
}
```

---

## Quand NE PAS Utiliser le Pattern Bucket ?

### ‚ùå 1. Besoin de Mises √† Jour Fr√©quentes

```javascript
// Si vous modifiez souvent des mesures individuelles
// ‚Üí Bucket rend √ßa complexe
// ‚Üí Mieux vaut des documents s√©par√©s
```

### ‚ùå 2. √âv√©nements Rares et Espac√©s

```javascript
// Si vous avez 1 √©v√©nement par jour
// ‚Üí Pas besoin de bucketing
// ‚Üí Un document par √©v√©nement suffit
```

### ‚ùå 3. Besoin d'Acc√®s Individuel Fr√©quent

```javascript
// Si vous acc√©dez souvent √† UNE mesure pr√©cise
// ‚Üí Naviguer dans les buckets est inefficace
// ‚Üí Documents s√©par√©s avec bon index sont meilleurs
```

### ‚ùå 4. Donn√©es Tr√®s H√©t√©rog√®nes

```javascript
// Si chaque mesure a une structure tr√®s diff√©rente
// ‚Üí Difficile de bucketer efficacement
```

---

## Pattern Bucket et Time Series Collections

MongoDB 5.0+ propose des **Time Series Collections** qui impl√©mentent automatiquement le pattern bucket !

```javascript
// Cr√©er une Time Series Collection
db.createCollection("mesures_temperature", {
  timeseries: {
    timeField: "timestamp",
    metaField: "capteurId",
    granularity: "minutes"  // ou "seconds", "hours"
  }
});

// Ins√©rer des donn√©es (MongoDB g√®re le bucketing automatiquement)
await db.mesures_temperature.insertOne({
  timestamp: new Date(),
  capteurId: "sensor_001",
  temperature: 22.5,
  humidite: 65
});

// MongoDB cr√©e automatiquement des buckets optimis√©s !
```

**Avantages des Time Series Collections :**
- ‚úÖ Bucketing automatique
- ‚úÖ Compression optimis√©e
- ‚úÖ Requ√™tes temporelles optimis√©es
- ‚úÖ Moins de code √† √©crire

**Quand utiliser Time Series Collections vs Pattern Bucket manuel :**
- Time Series : Pour nouveaux projets avec MongoDB 5.0+
- Pattern Bucket manuel : Pour contr√¥le fin, versions MongoDB < 5.0, ou logique m√©tier sp√©cifique

---

## Comparaison : Bucket vs Autres Patterns

| Aspect | Documents S√©par√©s | Pattern Bucket | Time Series Collection |
|--------|-------------------|----------------|------------------------|
| **Nombre de docs** | Tr√®s √©lev√© | R√©duit 50-100x | R√©duit (automatique) |
| **Performances** | ‚ö†Ô∏è Lent | ‚ö°‚ö° Rapide | ‚ö°‚ö°‚ö° Tr√®s rapide |
| **Complexit√©** | ‚úÖ Simple | ‚ö†Ô∏è Moyenne | ‚úÖ Simple |
| **Flexibilit√©** | ‚úÖ Totale | ‚ö†Ô∏è Limit√©e | ‚ö†Ô∏è Limit√©e |
| **Mises √† jour** | ‚úÖ Facile | ‚ö†Ô∏è Complexe | ‚ö†Ô∏è Complexe |
| **Cas d'usage** | √âv√©nements rares | S√©ries temporelles | S√©ries temporelles |
| **Version MongoDB** | Toutes | Toutes | 5.0+ |

---

## Conclusion

Le **Pattern Bucket** est essentiel pour g√©rer efficacement les **s√©ries temporelles** et les **donn√©es IoT** :

**Avantages :**
- üöÄ R√©duction massive du nombre de documents (50-100x)
- ‚ö° Performances excellentes (requ√™tes 1000x plus rapides)
- üíæ √âconomie de stockage importante
- üìä Statistiques pr√©-calcul√©es int√©gr√©es
- üìâ Index beaucoup plus petits

**Consid√©rations :**
- üîß Impl√©mentation plus complexe
- üîç Requ√™tes sur mesures individuelles plus difficiles
- ‚ö†Ô∏è Mises √† jour limit√©es
- üìè Taille de bucket √† surveiller (limite 16 Mo)

**R√®gle d'or :** Utilisez le Pattern Bucket quand :
1. Vous avez des **donn√©es temporelles** avec horodatage
2. Vous g√©n√©rez **beaucoup de petits √©v√©nements** (> 1000/jour)
3. Vous consultez principalement par **plages temporelles**
4. Les **mises √† jour sont rares** (principalement lecture)

**Recommandation moderne :** Pour MongoDB 5.0+, privil√©giez les **Time Series Collections** qui impl√©mentent le bucketing automatiquement avec optimisations suppl√©mentaires.

---

## Ressources Compl√©mentaires

- [Documentation MongoDB - Bucket Pattern](https://www.mongodb.com/blog/post/building-with-patterns-the-bucket-pattern)
- [Time Series Collections](https://docs.mongodb.com/manual/core/timeseries-collections/)

---


‚è≠Ô∏è [Pattern Schema Versioning](/04-modelisation-des-donnees/06.7-pattern-schema-versioning.md)
