ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.6.7 Pattern Schema Versioning (Versionnage de SchÃ©ma)

## Introduction

Le **Pattern Schema Versioning** (ou pattern de versionnage de schÃ©ma) est une technique de modÃ©lisation qui consiste Ã  **ajouter un numÃ©ro de version** aux documents pour gÃ©rer l'Ã©volution de la structure des donnÃ©es au fil du temps.

> **Analogie simple :** Imaginez que vous rangez des documents dans des classeurs. Au dÃ©but, vous utilisez une mÃ©thode simple. Avec le temps, vous trouvez une meilleure organisation. Au lieu de rÃ©organiser tous les anciens documents immÃ©diatement, vous ajoutez un autocollant "Version 2" sur les nouveaux classeurs. Vous pouvez ainsi gÃ©rer les deux versions en parallÃ¨le et migrer progressivement.

Ce pattern est **essentiel** pour faire Ã©voluer votre application sans interruption de service et sans migrer massivement toutes vos donnÃ©es d'un coup.

---

## Le ProblÃ¨me : Ã‰volution des Besoins

### ScÃ©nario : Application de Profils Utilisateur

Votre application Ã©volue et la structure des donnÃ©es change avec elle.

#### Version 1 (2022) : Structure Initiale

```javascript
// Version initiale simple
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  nom: "Marie Dupont",
  email: "marie@example.com",
  adresse: "123 Rue de Paris, 75001 Paris",
  dateInscription: ISODate("2022-01-15")
}
```

#### Version 2 (2023) : Ajout de Champs

Un an plus tard, vous voulez structurer l'adresse :

```javascript
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  nom: "Pierre Martin",
  email: "pierre@example.com",

  // âœ¨ Nouvelle structure d'adresse
  adresse: {
    rue: "456 Avenue des Champs",
    ville: "Lyon",
    codePostal: "69001",
    pays: "France"
  },

  dateInscription: ISODate("2023-06-20")
}
```

#### Version 3 (2024) : SÃ©paration PrÃ©nom/Nom

Encore plus tard, vous voulez sÃ©parer prÃ©nom et nom :

```javascript
{
  _id: ObjectId("707f1f77bcf86cd799439013"),

  // âœ¨ SÃ©paration prÃ©nom/nom
  prenom: "Sophie",
  nom: "Laurent",

  email: "sophie@example.com",
  adresse: {
    rue: "789 Boulevard Victor Hugo",
    ville: "Marseille",
    codePostal: "13001",
    pays: "France"
  },
  dateInscription: ISODate("2024-11-28")
}
```

**Le ProblÃ¨me :**
- ğŸ˜° Vous avez maintenant **3 structures diffÃ©rentes** dans la mÃªme collection
- ğŸ¤” Comment votre code sait-il quelle structure utiliser ?
- ğŸ’¥ Comment migrer les anciennes donnÃ©es sans tout casser ?

#### âœ… Solution avec Schema Versioning

```javascript
// Version 1 (ancien document)
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  schemaVersion: 1,  // â† Indicateur de version
  nom: "Marie Dupont",
  email: "marie@example.com",
  adresse: "123 Rue de Paris, 75001 Paris",
  dateInscription: ISODate("2022-01-15")
}

// Version 2
{
  _id: ObjectId("607f1f77bcf86cd799439012"),
  schemaVersion: 2,  // â† Version plus rÃ©cente
  nom: "Pierre Martin",
  email: "pierre@example.com",
  adresse: {
    rue: "456 Avenue des Champs",
    ville: "Lyon",
    codePostal: "69001",
    pays: "France"
  },
  dateInscription: ISODate("2023-06-20")
}

// Version 3 (actuelle)
{
  _id: ObjectId("707f1f77bcf86cd799439013"),
  schemaVersion: 3,  // â† Version la plus rÃ©cente
  prenom: "Sophie",
  nom: "Laurent",
  email: "sophie@example.com",
  adresse: {
    rue: "789 Boulevard Victor Hugo",
    ville: "Marseille",
    codePostal: "13001",
    pays: "France"
  },
  dateInscription: ISODate("2024-11-28")
}
```

**Avantages :**
- âœ… Identification claire de la version de chaque document
- âœ… Migration progressive possible
- âœ… CompatibilitÃ© ascendante facile Ã  gÃ©rer
- âœ… Pas d'interruption de service

---

## Concept ClÃ© : Coexistence de Versions

Le Pattern Schema Versioning permet Ã  diffÃ©rentes versions de coexister :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Collection Utilisateurs         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Doc 1: schemaVersion: 1 (10% des docs)  â”‚
â”‚ Doc 2: schemaVersion: 1                 â”‚
â”‚ Doc 3: schemaVersion: 2 (30% des docs)  â”‚
â”‚ Doc 4: schemaVersion: 2                 â”‚
â”‚ Doc 5: schemaVersion: 3 (60% des docs)  â”‚
â”‚ Doc 6: schemaVersion: 3                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            â†“ Traitement

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Code Application                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if (schemaVersion === 1)                â”‚
â”‚   â†’ Traiter format V1                   â”‚
â”‚ if (schemaVersion === 2)                â”‚
â”‚   â†’ Traiter format V2                   â”‚
â”‚ if (schemaVersion === 3)                â”‚
â”‚   â†’ Traiter format V3                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Quand Utiliser le Pattern Schema Versioning ?

### 1. **Ã‰volution Naturelle de l'Application**

Votre application grandit et vos besoins changent.

**Exemple : E-commerce - Ã‰volution du Produit**

```javascript
// Version 1 (2020) : Structure de base
{
  _id: ObjectId("507f1f77bcf86cd799439020"),
  schemaVersion: 1,
  nom: "T-Shirt Bleu",
  prix: 29.99,
  categorie: "VÃªtements",
  stock: 50
}

// Version 2 (2022) : Ajout de variantes
{
  _id: ObjectId("607f1f77bcf86cd799439021"),
  schemaVersion: 2,
  nom: "T-Shirt Classic",
  prixBase: 29.99,
  categorie: "VÃªtements",

  // âœ¨ Nouveau : Variantes
  variantes: [
    { taille: "S", couleur: "Bleu", sku: "TSH-BLU-S", stock: 15 },
    { taille: "M", couleur: "Bleu", sku: "TSH-BLU-M", stock: 25 },
    { taille: "L", couleur: "Rouge", sku: "TSH-ROU-L", stock: 10 }
  ]
}

// Version 3 (2024) : Ajout de durabilitÃ© et traÃ§abilitÃ©
{
  _id: ObjectId("707f1f77bcf86cd799439022"),
  schemaVersion: 3,
  nom: "T-Shirt Ã‰co-responsable",
  prixBase: 39.99,
  categorie: "VÃªtements",
  variantes: [/* ... */],

  // âœ¨ Nouveau : Informations Ã©co-responsables
  durabilite: {
    certification: "GOTS",
    materiaux: ["Coton bio 95%", "Ã‰lasthanne 5%"],
    origineProduction: "Portugal",
    empreinteCO2: 2.3  // kg
  },

  // âœ¨ Nouveau : TraÃ§abilitÃ© blockchain
  tracabilite: {
    blockchainId: "0x7f8b...",
    verificationsQualite: [/* ... */]
  }
}
```

### 2. **Refactoring de Structure**

AmÃ©liorer l'organisation des donnÃ©es.

**Exemple : Commandes - De Tableau Ã  Objet**

```javascript
// Version 1 : Statuts dans un tableau
{
  _id: ObjectId("507f1f77bcf86cd799439030"),
  schemaVersion: 1,
  numeroCommande: "CMD-2022-001",

  // Ancien format : Tableau de statuts
  statuts: [
    { statut: "creee", date: ISODate("2022-01-15T10:00:00Z") },
    { statut: "payee", date: ISODate("2022-01-15T10:05:00Z") },
    { statut: "expediee", date: ISODate("2022-01-16T14:30:00Z") }
  ]
}

// Version 2 : Statuts comme objet (plus facile Ã  requÃªter)
{
  _id: ObjectId("607f1f77bcf86cd799439031"),
  schemaVersion: 2,
  numeroCommande: "CMD-2024-001",

  // Nouveau format : Objet avec propriÃ©tÃ©s
  statut: {
    actuel: "expediee",
    creee: ISODate("2024-11-20T10:00:00Z"),
    payee: ISODate("2024-11-20T10:05:00Z"),
    expediee: ISODate("2024-11-21T14:30:00Z"),
    livree: null  // Pas encore livrÃ©e
  }
}
```

### 3. **Ajout de FonctionnalitÃ©s**

Nouvelles features nÃ©cessitant de nouveaux champs.

**Exemple : SystÃ¨me de Notifications**

```javascript
// Version 1 : Email uniquement
{
  _id: ObjectId("507f1f77bcf86cd799439040"),
  schemaVersion: 1,
  userId: ObjectId("807f1f77bcf86cd799439041"),
  type: "nouveau_message",
  contenu: "Vous avez reÃ§u un nouveau message",
  envoyeePar: "email",
  dateEnvoi: ISODate("2023-01-15")
}

// Version 2 : Multi-canal avec prÃ©fÃ©rences
{
  _id: ObjectId("607f1f77bcf86cd799439042"),
  schemaVersion: 2,
  userId: ObjectId("807f1f77bcf86cd799439041"),
  type: "nouveau_message",
  contenu: "Vous avez reÃ§u un nouveau message",

  // âœ¨ Nouveau : Support multi-canal
  canaux: {
    email: {
      envoye: true,
      dateEnvoi: ISODate("2024-11-28T10:00:00Z")
    },
    push: {
      envoye: true,
      dateEnvoi: ISODate("2024-11-28T10:00:05Z")
    },
    sms: {
      envoye: false,
      raison: "utilisateur_non_abonne"
    }
  },

  // âœ¨ Nouveau : Tracking d'engagement
  engagement: {
    ouverte: true,
    dateOuverture: ISODate("2024-11-28T10:15:00Z"),
    cliquee: false
  }
}
```

### 4. **ConformitÃ© et RÃ©glementation**

Nouvelles lois nÃ©cessitant des changements de structure.

**Exemple : RGPD - Ajout de Consentements**

```javascript
// Version 1 (avant RGPD)
{
  _id: ObjectId("507f1f77bcf86cd799439050"),
  schemaVersion: 1,
  email: "user@example.com",
  nom: "Jean Dupont",
  newsletterActive: true
}

// Version 2 (aprÃ¨s RGPD - 2018)
{
  _id: ObjectId("607f1f77bcf86cd799439051"),
  schemaVersion: 2,
  email: "user@example.com",
  nom: "Jean Dupont",

  // âœ¨ Nouveau : Gestion des consentements RGPD
  consentements: {
    newsletter: {
      accepte: true,
      date: ISODate("2024-11-15T10:00:00Z"),
      ip: "192.168.1.100",
      methode: "opt_in_explicite"
    },
    partageDonnees: {
      accepte: false,
      date: ISODate("2024-11-15T10:00:00Z")
    },
    cookies: {
      essentiels: true,
      analytiques: true,
      marketing: false,
      date: ISODate("2024-11-15T10:00:00Z")
    }
  },

  // âœ¨ Nouveau : Droit Ã  l'oubli
  suppressionProgrammee: null
}
```

---

## StratÃ©gies d'ImplÃ©mentation

### StratÃ©gie 1 : Version Explicite

Ajouter un champ `schemaVersion` Ã  chaque document.

```javascript
// Chaque document a sa version explicite
{
  _id: ObjectId("..."),
  schemaVersion: 3,  // â† Version explicite
  // ... autres champs
}
```

**Avantages :**
- âœ… TrÃ¨s clair et explicite
- âœ… Facile Ã  requÃªter par version
- âœ… Simple Ã  comprendre

**InconvÃ©nients :**
- âš ï¸ Ajoute un champ Ã  tous les documents
- âš ï¸ NÃ©cessite de mettre Ã  jour ce champ lors des migrations

### StratÃ©gie 2 : DÃ©tection Implicite

DÃ©tecter la version en fonction de la prÃ©sence/absence de champs.

```javascript
// Fonction pour dÃ©tecter la version
function detecterVersion(document) {
  // Version 3 : A les champs prÃ©nom ET nom sÃ©parÃ©s
  if (document.prenom && document.nom && document.adresse?.rue) {
    return 3;
  }

  // Version 2 : A l'adresse structurÃ©e
  if (document.adresse?.rue) {
    return 2;
  }

  // Version 1 : A l'adresse en string
  if (typeof document.adresse === 'string') {
    return 1;
  }

  return 0;  // Version inconnue
}

// Utilisation
const user = await db.users.findOne({ _id: userId });
const version = detecterVersion(user);
```

**Avantages :**
- âœ… Pas de champ supplÃ©mentaire
- âœ… Ã‰conomie d'espace

**InconvÃ©nients :**
- âš ï¸ Logique de dÃ©tection peut Ãªtre complexe
- âš ï¸ Erreurs possibles si structures se chevauchent
- âš ï¸ Impossible de requÃªter par version facilement

### StratÃ©gie 3 : Version + Date de Migration

Tracer quand les documents ont Ã©tÃ© migrÃ©s.

```javascript
{
  _id: ObjectId("..."),
  schemaVersion: 3,
  schemaMigrationDate: ISODate("2024-11-28T15:30:00Z"),
  schemaVersionPrecedente: 2,
  // ... autres champs
}
```

**Avantages :**
- âœ… Audit trail complet
- âœ… Permet de mesurer le progrÃ¨s de migration
- âœ… Utile pour le debugging

**InconvÃ©nients :**
- âš ï¸ Plus de mÃ©tadonnÃ©es
- âš ï¸ Plus complexe Ã  gÃ©rer

---

## Gestion des Versions dans le Code

### Approche 1 : Switch/Case par Version

```javascript
async function chargerUtilisateur(userId) {
  const user = await db.users.findOne({ _id: userId });

  // Traiter selon la version
  switch(user.schemaVersion) {
    case 1:
      return normaliserVersionV1(user);

    case 2:
      return normaliserVersionV2(user);

    case 3:
      return user;  // Version actuelle, pas besoin de normaliser

    default:
      throw new Error(`Version de schÃ©ma inconnue: ${user.schemaVersion}`);
  }
}

// Normaliser V1 vers format actuel
function normaliserVersionV1(user) {
  // SÃ©parer le nom complet
  const nomComplet = user.nom.split(' ');

  return {
    ...user,
    prenom: nomComplet[0],
    nom: nomComplet.slice(1).join(' '),
    adresse: parseAdresseString(user.adresse),
    schemaVersion: 3  // Maintenant traitÃ© comme V3
  };
}

// Normaliser V2 vers format actuel
function normaliserVersionV2(user) {
  // SÃ©parer le nom complet
  const nomComplet = user.nom.split(' ');

  return {
    ...user,
    prenom: nomComplet[0],
    nom: nomComplet.slice(1).join(' '),
    schemaVersion: 3
  };
}
```

### Approche 2 : Classe avec Adaptateurs

```javascript
// Classe de base
class Utilisateur {
  constructor(data) {
    this.data = data;
  }

  static fromDocument(doc) {
    const version = doc.schemaVersion || 1;

    switch(version) {
      case 1:
        return new UtilisateurV1Adapter(doc);
      case 2:
        return new UtilisateurV2Adapter(doc);
      case 3:
        return new Utilisateur(doc);
      default:
        throw new Error(`Version inconnue: ${version}`);
    }
  }

  get prenom() {
    return this.data.prenom;
  }

  get nom() {
    return this.data.nom;
  }

  get adresse() {
    return this.data.adresse;
  }
}

// Adaptateur pour V1
class UtilisateurV1Adapter extends Utilisateur {
  get prenom() {
    return this.data.nom.split(' ')[0];
  }

  get nom() {
    return this.data.nom.split(' ').slice(1).join(' ');
  }

  get adresse() {
    return this.parseAdresseString(this.data.adresse);
  }

  parseAdresseString(adresseStr) {
    // Parser "123 Rue de Paris, 75001 Paris"
    const parties = adresseStr.split(', ');
    return {
      rue: parties[0],
      ville: parties[1]?.split(' ').slice(-1)[0] || '',
      codePostal: parties[1]?.split(' ')[0] || ''
    };
  }
}

// Adaptateur pour V2
class UtilisateurV2Adapter extends Utilisateur {
  get prenom() {
    return this.data.nom.split(' ')[0];
  }

  get nom() {
    return this.data.nom.split(' ').slice(1).join(' ');
  }
}

// Utilisation
const doc = await db.users.findOne({ _id: userId });
const user = Utilisateur.fromDocument(doc);

console.log(user.prenom);  // Fonctionne quelle que soit la version
console.log(user.nom);
console.log(user.adresse);
```

---

## Migration de SchÃ©mas

### Migration Lazy (Ã€ la Demande)

Migrer les documents quand ils sont accÃ©dÃ©s.

```javascript
async function chargerEtMigrerUtilisateur(userId) {
  const user = await db.users.findOne({ _id: userId });

  // Si version ancienne, migrer
  if (user.schemaVersion < 3) {
    const userMigre = migrerVersV3(user);

    // Sauvegarder la version migrÃ©e
    await db.users.replaceOne(
      { _id: userId },
      userMigre
    );

    return userMigre;
  }

  return user;
}

function migrerVersV3(user) {
  let migre = { ...user };

  // Migrer V1 â†’ V2
  if (user.schemaVersion === 1) {
    migre.adresse = parseAdresseString(user.adresse);
  }

  // Migrer V2 â†’ V3
  if (user.schemaVersion <= 2) {
    const nomComplet = user.nom.split(' ');
    migre.prenom = nomComplet[0];
    migre.nom = nomComplet.slice(1).join(' ');
  }

  // Mettre Ã  jour la version
  migre.schemaVersion = 3;
  migre.schemaMigrationDate = new Date();

  return migre;
}
```

**Avantages :**
- âœ… Pas de migration massive
- âœ… Migration progressive naturelle
- âœ… Peu d'impact sur les performances

**InconvÃ©nients :**
- âš ï¸ Documents rarement accÃ©dÃ©s restent en vieille version
- âš ï¸ SurcoÃ»t lors de la premiÃ¨re lecture

### Migration par Batch (En Lot)

Migrer tous les documents d'un coup ou par lots.

```javascript
// Script de migration V2 â†’ V3
async function migrerTousUtilisateursV2VersV3() {
  const BATCH_SIZE = 1000;
  let processed = 0;

  while (true) {
    // RÃ©cupÃ©rer un lot d'utilisateurs V2
    const usersV2 = await db.users
      .find({ schemaVersion: 2 })
      .limit(BATCH_SIZE)
      .toArray();

    if (usersV2.length === 0) {
      break;  // Tous les documents sont migrÃ©s
    }

    // PrÃ©parer les opÃ©rations bulk
    const operations = usersV2.map(user => {
      const nomComplet = user.nom.split(' ');

      return {
        updateOne: {
          filter: { _id: user._id },
          update: {
            $set: {
              prenom: nomComplet[0],
              nom: nomComplet.slice(1).join(' '),
              schemaVersion: 3,
              schemaMigrationDate: new Date()
            }
          }
        }
      };
    });

    // ExÃ©cuter les mises Ã  jour en bulk
    await db.users.bulkWrite(operations);

    processed += usersV2.length;
    console.log(`${processed} utilisateurs migrÃ©s...`);

    // Pause pour ne pas surcharger la DB
    await sleep(100);
  }

  console.log(`âœ… Migration terminÃ©e : ${processed} utilisateurs migrÃ©s`);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Planifier la migration
// Ã€ exÃ©cuter pendant les heures creuses
cron.schedule('0 2 * * *', migrerTousUtilisateursV2VersV3);
```

**Avantages :**
- âœ… Migration complÃ¨te et contrÃ´lÃ©e
- âœ… Tous les documents Ã  jour rapidement
- âœ… Pas de surcoÃ»t Ã  la lecture

**InconvÃ©nients :**
- âš ï¸ Peut prendre du temps
- âš ï¸ Charge importante sur la DB
- âš ï¸ Risque d'erreurs en masse

### Migration Hybride

Combiner lazy et batch.

```javascript
// 1. Migration batch pour documents rÃ©cents/actifs
async function migrerUtilisateursActifs() {
  const il30Jours = new Date();
  il30Jours.setDate(il30Jours.getDate() - 30);

  const usersActifs = await db.users
    .find({
      schemaVersion: { $lt: 3 },
      derniereConnexion: { $gte: il30Jours }
    })
    .toArray();

  // Migrer en batch
  for (const user of usersActifs) {
    const userMigre = migrerVersV3(user);
    await db.users.replaceOne({ _id: user._id }, userMigre);
  }

  console.log(`${usersActifs.length} utilisateurs actifs migrÃ©s`);
}

// 2. Migration lazy pour documents inactifs
async function chargerUtilisateur(userId) {
  const user = await db.users.findOne({ _id: userId });

  // Si version ancienne, migrer Ã  la volÃ©e
  if (user.schemaVersion < 3) {
    const userMigre = migrerVersV3(user);
    await db.users.replaceOne({ _id: userId }, userMigre);
    return userMigre;
  }

  return user;
}
```

---

## Avantages du Pattern Schema Versioning

### âœ… 1. **DÃ©ploiements Sans Interruption**

DÃ©ployer de nouvelles versions sans downtime :

```javascript
// Version de l'application compatible avec V2 et V3
// Ancien code continue de fonctionner pendant la migration
```

### âœ… 2. **Migration Progressive**

Migrer les donnÃ©es au fil du temps :

```javascript
// Jour 1 : 10% migrÃ©s
// Jour 7 : 50% migrÃ©s
// Jour 30 : 90% migrÃ©s
// Jour 90 : 100% migrÃ©s
```

### âœ… 3. **Rollback Facile**

PossibilitÃ© de revenir en arriÃ¨re en cas de problÃ¨me :

```javascript
// Si problÃ¨me avec V3, on peut continuer Ã  traiter V2
// Pas besoin de restaurer toute la base de donnÃ©es
```

### âœ… 4. **Audit et TraÃ§abilitÃ©**

Savoir exactement quelle version est utilisÃ©e :

```javascript
// Statistiques de migration
const stats = await db.users.aggregate([
  {
    $group: {
      _id: "$schemaVersion",
      count: { $sum: 1 }
    }
  }
]).toArray();

// RÃ©sultat :
// Version 1 : 1 250 documents (5%)
// Version 2 : 3 780 documents (15%)
// Version 3 : 20 000 documents (80%)
```

### âœ… 5. **Tests A/B Possibles**

Tester une nouvelle structure sur un sous-ensemble :

```javascript
// 10% des utilisateurs avec V3 (nouvelle structure)
// 90% restent en V2
// Comparer les performances et l'expÃ©rience utilisateur
```

---

## Bonnes Pratiques

### âœ… 1. Toujours Utiliser des Versions NumÃ©riques

```javascript
// âœ… BON : Entiers sÃ©quentiels
schemaVersion: 1
schemaVersion: 2
schemaVersion: 3

// âŒ Ã‰VITER : Strings ou flottants
schemaVersion: "v1.0"
schemaVersion: 1.5
```

### âœ… 2. Documenter Chaque Version

```javascript
/**
 * Historique des versions de schÃ©ma - Utilisateurs
 *
 * Version 1 (2022-01-01) :
 * - Structure initiale
 * - Champs : nom, email, adresse (string)
 *
 * Version 2 (2023-06-01) :
 * - Structuration de l'adresse en objet
 * - Ajout : adresse.rue, adresse.ville, adresse.codePostal
 * - Migration : 45 jours, 98% complÃ©tÃ©e
 *
 * Version 3 (2024-11-01) :
 * - SÃ©paration prÃ©nom/nom
 * - Ajout : prenom, nom (sÃ©parÃ©s)
 * - Suppression : nom (complet)
 * - Migration : en cours, 80% complÃ©tÃ©e
 */
```

### âœ… 3. Garder le Code Compatible

```javascript
// Code compatible avec plusieurs versions
async function afficherNomComplet(userId) {
  const user = await db.users.findOne({ _id: userId });

  // GÃ©rer toutes les versions
  if (user.schemaVersion >= 3) {
    return `${user.prenom} ${user.nom}`;
  } else {
    return user.nom;  // V1 et V2 ont le nom complet
  }
}
```

### âœ… 4. CrÃ©er des Index par Version si NÃ©cessaire

```javascript
// Index pour requÃªtes sur anciennes versions
db.users.createIndex({ schemaVersion: 1 });

// Index pour migration
db.users.createIndex({
  schemaVersion: 1,
  derniereConnexion: -1
});
```

### âœ… 5. Monitorer l'Avancement de la Migration

```javascript
// Dashboard de migration
async function afficherStatsMigration() {
  const stats = await db.users.aggregate([
    {
      $group: {
        _id: "$schemaVersion",
        count: { $sum: 1 }
      }
    },
    {
      $project: {
        version: "$_id",
        count: 1,
        _id: 0
      }
    },
    {
      $sort: { version: 1 }
    }
  ]).toArray();

  const total = stats.reduce((sum, s) => sum + s.count, 0);

  console.log("Ã‰tat de la migration :");
  stats.forEach(s => {
    const pourcentage = ((s.count / total) * 100).toFixed(1);
    console.log(`  Version ${s.version}: ${s.count} (${pourcentage}%)`);
  });

  // Alerte si migration bloquÃ©e
  const v1Count = stats.find(s => s.version === 1)?.count || 0;
  if (v1Count > total * 0.05) {  // Plus de 5%
    console.warn("âš ï¸ Plus de 5% des documents sont encore en V1");
  }
}
```

### âœ… 6. Nettoyer le Code Ancien

```javascript
/**
 * Plan de nettoyage du code :
 *
 * T+0 : DÃ©ployer code compatible V2 et V3
 * T+30j : 90% migrÃ©s â†’ DÃ©prÃ©cier code V1
 * T+60j : 99% migrÃ©s â†’ Supprimer code V1
 * T+90j : 100% migrÃ©s â†’ Supprimer code V2
 *
 * AprÃ¨s 90 jours, seul le code V3 reste
 */
```

### âœ… 7. Tester les Migrations

```javascript
// Tests unitaires pour chaque migration
describe('Migration V2 vers V3', () => {
  it('devrait sÃ©parer le nom complet', () => {
    const userV2 = {
      schemaVersion: 2,
      nom: "Jean Pierre Dupont",
      email: "jean@example.com",
      adresse: { rue: "123 Rue", ville: "Paris" }
    };

    const userV3 = migrerVersV3(userV2);

    expect(userV3.prenom).toBe("Jean");
    expect(userV3.nom).toBe("Pierre Dupont");
    expect(userV3.schemaVersion).toBe(3);
  });

  it('devrait prÃ©server tous les autres champs', () => {
    const userV2 = {
      schemaVersion: 2,
      nom: "Marie Curie",
      email: "marie@example.com",
      adresse: { rue: "456 Ave", ville: "Lyon" },
      dateInscription: new Date("2023-01-15")
    };

    const userV3 = migrerVersV3(userV2);

    expect(userV3.email).toBe("marie@example.com");
    expect(userV3.adresse.ville).toBe("Lyon");
    expect(userV3.dateInscription).toEqual(userV2.dateInscription);
  });
});
```

---

## Quand NE PAS Utiliser le Pattern Schema Versioning ?

### âŒ 1. Application Toute Neuve

```javascript
// Si vous dÃ©marrez un nouveau projet
// â†’ Pas besoin de versioning dÃ¨s le dÃ©but
// â†’ Ajoutez-le quand vous avez besoin de faire Ã©voluer le schÃ©ma
```

### âŒ 2. Petite Base de DonnÃ©es

```javascript
// Si vous avez < 1000 documents
// â†’ Migration massive est rapide et simple
// â†’ Le versioning ajoute de la complexitÃ© inutile
```

### âŒ 3. DonnÃ©es Ã‰phÃ©mÃ¨res

```javascript
// Si vos donnÃ©es ont une courte durÃ©e de vie (< 30 jours)
// â†’ Pas besoin de gÃ©rer plusieurs versions
// â†’ Les anciennes donnÃ©es disparaissent naturellement
```

### âŒ 4. Changements TrÃ¨s Rares

```javascript
// Si vous changez le schÃ©ma tous les 5 ans
// â†’ Une migration massive unique est acceptable
// â†’ Moins complexe que le versioning
```

---

## Comparaison avec Autres Approches

| Approche | ComplexitÃ© | Downtime | Rollback | CoÃ»t |
|----------|------------|----------|----------|------|
| **Migration massive** | Simple | âš ï¸ Oui | Difficile | Faible |
| **Schema Versioning** | Moyenne | âœ… Non | Facile | Moyen |
| **Dual write** | Ã‰levÃ©e | âœ… Non | Facile | Ã‰levÃ© |
| **Collection sÃ©parÃ©e** | Moyenne | âœ… Non | Moyen | Moyen |

---

## Exemple Complet : Ã‰volution d'un Produit

```javascript
// ============ VERSION 1 (2020) ============
{
  _id: ObjectId("..."),
  schemaVersion: 1,
  nom: "Laptop Pro",
  prix: 1299.99,
  stock: 50,
  categorie: "Informatique"
}

// ============ VERSION 2 (2022) ============
// Ajout : SpÃ©cifications techniques
{
  _id: ObjectId("..."),
  schemaVersion: 2,
  nom: "Laptop Pro",
  prix: 1299.99,
  stock: 50,
  categorie: "Informatique",

  specifications: {
    processeur: "Intel i7",
    ram: 16,
    stockage: 512,
    ecran: 15.6
  }
}

// ============ VERSION 3 (2024) ============
// Ajout : Images multiples, avis, SEO
{
  _id: ObjectId("..."),
  schemaVersion: 3,
  nom: "Laptop Pro 2024",
  prix: 1499.99,
  stock: 50,
  categorie: "Informatique",

  specifications: {
    processeur: "Intel i9",
    ram: 32,
    stockage: 1024,
    ecran: 16
  },

  images: [
    { url: "laptop1.jpg", ordre: 1, alt: "Vue de face" },
    { url: "laptop2.jpg", ordre: 2, alt: "Vue de cÃ´tÃ©" },
    { url: "laptop3.jpg", ordre: 3, alt: "Vue ouverte" }
  ],

  avis: {
    noteMoyenne: 4.7,
    nombreAvis: 234,
    dernierAvis: ISODate("2024-11-25")
  },

  seo: {
    slug: "laptop-pro-2024",
    metaDescription: "Le laptop le plus puissant pour professionnels",
    motsCles: ["laptop", "pro", "haute performance"]
  }
}

// ============ CODE DE GESTION ============
class Produit {
  static async charger(produitId) {
    const doc = await db.produits.findOne({ _id: produitId });
    return this.normaliser(doc);
  }

  static normaliser(doc) {
    const version = doc.schemaVersion || 1;

    switch(version) {
      case 1:
        return this.normaliserV1(doc);
      case 2:
        return this.normaliserV2(doc);
      case 3:
        return doc;
      default:
        throw new Error(`Version inconnue: ${version}`);
    }
  }

  static normaliserV1(doc) {
    return {
      ...doc,
      specifications: null,
      images: [],
      avis: { noteMoyenne: 0, nombreAvis: 0 },
      seo: { slug: doc.nom.toLowerCase().replace(/\s/g, '-') },
      schemaVersion: 3
    };
  }

  static normaliserV2(doc) {
    return {
      ...doc,
      images: [],
      avis: { noteMoyenne: 0, nombreAvis: 0 },
      seo: { slug: doc.nom.toLowerCase().replace(/\s/g, '-') },
      schemaVersion: 3
    };
  }
}
```

---

## Conclusion

Le **Pattern Schema Versioning** est essentiel pour faire Ã©voluer votre application sans interruption :

**Avantages :**
- ğŸš€ DÃ©ploiements sans downtime
- ğŸ”„ Migration progressive et contrÃ´lÃ©e
- â†©ï¸ Rollback facile en cas de problÃ¨me
- ğŸ“Š Audit et traÃ§abilitÃ© complets
- ğŸ§ª Tests A/B possibles

**ConsidÃ©rations :**
- ğŸ”§ ComplexitÃ© accrue du code
- ğŸ“ Documentation essentielle
- ğŸ§¹ Nettoyage du code nÃ©cessaire
- â±ï¸ PÃ©riode de transition Ã  gÃ©rer

**RÃ¨gle d'or :** Utilisez le Schema Versioning quand :
1. Votre application est en **production** avec des utilisateurs
2. Vous avez **beaucoup de donnÃ©es** (> 10 000 documents)
3. Vous ne pouvez **pas vous permettre** d'interruption de service
4. Vous Ã©voluez le schÃ©ma **rÃ©guliÃ¨rement** (plusieurs fois par an)

**Recommandation :** Commencez avec une version explicite simple (`schemaVersion`), documentez chaque changement, et migrez progressivement avec une stratÃ©gie hybride (batch pour actifs + lazy pour inactifs).

---

## Ressources ComplÃ©mentaires

- [Documentation MongoDB - Schema Design Patterns](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)
- [MongoDB Schema Versioning Best Practices](https://www.mongodb.com/developer/products/mongodb/schema-design-anti-pattern-massive-arrays/)

---


â­ï¸ [Pattern Attribute](/04-modelisation-des-donnees/06.8-pattern-attribute.md)
