üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.12.3 Spring Data MongoDB (Java)

## Introduction

**Spring Data MongoDB** fait partie de la famille Spring Data et fournit une int√©gration √©l√©gante et puissante entre Spring et MongoDB. Il offre une abstraction de haut niveau bas√©e sur le pattern Repository, tout en permettant un contr√¥le fin avec MongoTemplate.

### Qu'est-ce que Spring Data MongoDB ?

Spring Data MongoDB est un framework qui :
- Simplifie l'acc√®s aux donn√©es MongoDB dans les applications Spring
- Fournit le pattern Repository avec des m√©thodes d√©riv√©es automatiquement
- Offre un support natif pour les transactions, l'auditing et les projections
- S'int√®gre parfaitement avec Spring Boot

### Pourquoi Spring Data MongoDB ?

**Avantages :**
- **Productivit√©** : Moins de code boilerplate, focus sur la logique m√©tier
- **Type-safe** : Typage fort au moment de la compilation
- **Int√©gration Spring** : Transaction management, security, caching
- **Abstraction** : Repository pattern avec m√©thodes d√©riv√©es automatiques
- **Flexibilit√©** : MongoTemplate pour requ√™tes complexes

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Application Layer               ‚îÇ
‚îÇ    (Controllers, Services)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Repository Interface               ‚îÇ
‚îÇ  (Query derivation, @Query)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Spring Data MongoDB                ‚îÇ
‚îÇ  (Repository Implementation)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       MongoDB Java Driver               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Statistiques

```
üì¶ Artifact: spring-boot-starter-data-mongodb
‚≠ê Spring Data: Core framework
üìù Version: 3.x+ (Spring Boot 3.x)
üè¢ Utilisateurs: Entreprises Java, microservices Spring
```

---

## Configuration et Setup

### D√©pendances Maven

```xml
<!-- pom.xml -->
<project>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
    </parent>

    <dependencies>
        <!-- Spring Data MongoDB -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>

        <!-- Spring Web (pour REST APIs) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Lombok (optionnel mais recommand√©) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Embedded MongoDB pour tests -->
        <dependency>
            <groupId>de.flapdoodle.embed</groupId>
            <artifactId>de.flapdoodle.embed.mongo</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### D√©pendances Gradle

```gradle
// build.gradle
plugins {
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'java'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
}
```

### Configuration application.properties

```properties
# application.properties

# MongoDB Connection
spring.data.mongodb.uri=mongodb://localhost:27017/myapp
# Ou avec authentification
# spring.data.mongodb.uri=mongodb://user:password@localhost:27017/myapp?authSource=admin

# Configuration d√©taill√©e alternative
# spring.data.mongodb.host=localhost
# spring.data.mongodb.port=27017
# spring.data.mongodb.database=myapp
# spring.data.mongodb.username=user
# spring.data.mongodb.password=password
# spring.data.mongodb.authentication-database=admin

# Pool de connexions
spring.data.mongodb.max-connection-pool-size=100
spring.data.mongodb.min-connection-pool-size=10
spring.data.mongodb.max-connection-idle-time=60000

# Replica Set
# spring.data.mongodb.uri=mongodb://host1:27017,host2:27017,host3:27017/myapp?replicaSet=rs0

# Options de logging
logging.level.org.springframework.data.mongodb.core=DEBUG
logging.level.org.mongodb.driver=DEBUG

# D√©sactiver auto-index en production
spring.data.mongodb.auto-index-creation=false
```

### Configuration application.yml

```yaml
# application.yml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/myapp
      # Configuration d√©taill√©e
      # host: localhost
      # port: 27017
      # database: myapp
      # username: user
      # password: password
      # authentication-database: admin

      # Pool
      max-connection-pool-size: 100
      min-connection-pool-size: 10
      max-connection-idle-time: 60000

      # Auto-index
      auto-index-creation: false

# Profils d'environnement
---
spring:
  config:
    activate:
      on-profile: dev
  data:
    mongodb:
      uri: mongodb://localhost:27017/myapp_dev

---
spring:
  config:
    activate:
      on-profile: prod
  data:
    mongodb:
      uri: mongodb://user:password@prod-host:27017/myapp_prod?ssl=true
```

### Configuration Java

```java
// config/MongoConfig.java
package com.example.config;

import com.mongodb.ConnectionString;
import com.mongodb.MongoClientSettings;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.AbstractMongoClientConfiguration;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;
import org.springframework.data.mongodb.core.convert.MappingMongoConverter;
import org.springframework.data.mongodb.core.mapping.MongoMappingContext;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableMongoRepositories(basePackages = "com.example.repository")
public class MongoConfig extends AbstractMongoClientConfiguration {

    @Value("${spring.data.mongodb.database}")
    private String databaseName;

    @Value("${spring.data.mongodb.uri}")
    private String connectionString;

    @Override
    protected String getDatabaseName() {
        return databaseName;
    }

    @Override
    public MongoClient mongoClient() {
        ConnectionString connString = new ConnectionString(connectionString);

        MongoClientSettings settings = MongoClientSettings.builder()
            .applyConnectionString(connString)
            .applyToConnectionPoolSettings(builder ->
                builder
                    .maxSize(100)
                    .minSize(10)
                    .maxWaitTime(60, TimeUnit.SECONDS)
                    .maxConnectionIdleTime(30, TimeUnit.SECONDS)
            )
            .applyToSocketSettings(builder ->
                builder
                    .connectTimeout(10, TimeUnit.SECONDS)
                    .readTimeout(10, TimeUnit.SECONDS)
            )
            .build();

        return MongoClients.create(settings);
    }

    @Bean
    public MongoTemplate mongoTemplate() throws Exception {
        MongoTemplate mongoTemplate = new MongoTemplate(mongoClient(), getDatabaseName());

        // Supprimer le champ _class ajout√© par d√©faut
        MappingMongoConverter converter = (MappingMongoConverter) mongoTemplate.getConverter();
        converter.setTypeMapper(new DefaultMongoTypeMapper(null));

        return mongoTemplate;
    }

    @Override
    protected boolean autoIndexCreation() {
        // D√©sactiver en production
        return false;
    }
}
```

---

## Entities et Mapping

### Document basique

```java
// model/User.java
package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import jakarta.validation.constraints.*;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "users")  // Nom de la collection
public class User {

    @Id
    private String id;  // MongoDB utilise String pour ObjectId

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 30)
    @Indexed(unique = true)  // Index unique
    private String username;

    @Email(message = "Invalid email format")
    @NotBlank
    @Indexed(unique = true)
    private String email;

    @NotBlank
    @Size(min = 8)
    @Field("pwd")  // Nom diff√©rent dans MongoDB
    private String password;

    @Min(18)
    @Max(150)
    private Integer age;

    private Boolean isActive = true;

    @Field("role")
    private UserRole role = UserRole.USER;

    private List<String> tags;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    // Constructeur personnalis√©
    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}
```

### Enum et types personnalis√©s

```java
// model/UserRole.java
package com.example.model;

public enum UserRole {
    USER,
    MODERATOR,
    ADMIN
}
```

### Document avec sous-documents

```java
// model/Post.java
package com.example.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.TextIndexed;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@Document(collection = "posts")
@CompoundIndex(name = "author_status_idx", def = "{'author': 1, 'status': 1}")
public class Post {

    @Id
    private String id;

    @TextIndexed(weight = 2)  // Index text avec poids
    private String title;

    @TextIndexed
    private String content;

    private String slug;

    // R√©f√©rence √† un autre document
    @DBRef
    private User author;

    private PostStatus status = PostStatus.DRAFT;

    private List<String> tags = new ArrayList<>();

    // Document imbriqu√©
    private List<Comment> comments = new ArrayList<>();

    // Document imbriqu√©
    private Metadata metadata = new Metadata();

    private LocalDateTime publishedAt;
    private LocalDateTime createdAt = LocalDateTime.now();
    private LocalDateTime updatedAt = LocalDateTime.now();

    // Classe interne pour sous-document
    @Data
    public static class Comment {
        private String id;

        @DBRef
        private User author;

        private String text;
        private List<String> likes = new ArrayList<>();
        private LocalDateTime createdAt = LocalDateTime.now();
    }

    @Data
    public static class Metadata {
        private Long views = 0L;
        private Long shares = 0L;
        private Integer readTime;
        private Boolean featured = false;
    }
}

// model/PostStatus.java
package com.example.model;

public enum PostStatus {
    DRAFT,
    PUBLISHED,
    ARCHIVED
}
```

### Documents avec g√©olocalisation

```java
// model/Location.java
package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.geo.Point;
import org.springframework.data.mongodb.core.geo.GeoJsonPoint;
import org.springframework.data.mongodb.core.index.GeoSpatialIndexType;
import org.springframework.data.mongodb.core.index.GeoSpatialIndexed;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Location {

    private String type = "Point";

    @GeoSpatialIndexed(type = GeoSpatialIndexType.GEO_2DSPHERE)
    private GeoJsonPoint coordinates;

    // Constructeur helper
    public Location(double longitude, double latitude) {
        this.coordinates = new GeoJsonPoint(longitude, latitude);
    }
}

// model/Place.java
package com.example.model;

import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Data
@Document(collection = "places")
public class Place {

    @Id
    private String id;

    private String name;
    private String address;
    private Location location;

    // Constructeur
    public Place(String name, String address, double longitude, double latitude) {
        this.name = name;
        this.address = address;
        this.location = new Location(longitude, latitude);
    }
}
```

---

## Repository Interface

### Repository basique

```java
// repository/UserRepository.java
package com.example.repository;

import com.example.model.User;
import com.example.model.UserRole;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends MongoRepository<User, String> {

    // M√©thodes d√©riv√©es automatiquement du nom
    Optional<User> findByEmail(String email);

    Optional<User> findByUsername(String username);

    List<User> findByIsActiveTrue();

    List<User> findByRole(UserRole role);

    List<User> findByAgeGreaterThanEqual(Integer age);

    List<User> findByAgeBetween(Integer minAge, Integer maxAge);

    List<User> findByUsernameStartingWith(String prefix);

    List<User> findByEmailContaining(String domain);

    List<User> findByTagsContaining(String tag);

    List<User> findByCreatedAtAfter(LocalDateTime date);

    // Combinaisons
    List<User> findByRoleAndIsActiveTrue(UserRole role);

    List<User> findByRoleOrAge(UserRole role, Integer age);

    // Sorting
    List<User> findByIsActiveTrueOrderByCreatedAtDesc();

    // Count
    long countByRole(UserRole role);

    long countByIsActiveTrue();

    // Exists
    boolean existsByEmail(String email);

    boolean existsByUsername(String username);

    // Delete
    void deleteByEmail(String email);

    long deleteByIsActiveFalse();
}
```

### Requ√™tes avec @Query

```java
// repository/UserRepository.java (suite)

@Repository
public interface UserRepository extends MongoRepository<User, String> {

    // Requ√™te JSON
    @Query("{ 'email': ?0 }")
    Optional<User> findUserByEmail(String email);

    // Requ√™te avec plusieurs param√®tres
    @Query("{ 'age': { $gte: ?0, $lte: ?1 } }")
    List<User> findUsersInAgeRange(Integer minAge, Integer maxAge);

    // Requ√™te avec projection (ne s√©lectionner que certains champs)
    @Query(value = "{ 'isActive': true }", fields = "{ 'username': 1, 'email': 1 }")
    List<User> findActiveUsersMinimal();

    // Requ√™te avec regex
    @Query("{ 'username': { $regex: ?0, $options: 'i' } }")
    List<User> searchUsersByUsername(String pattern);

    // Requ√™te avec op√©rateurs complexes
    @Query("{ $or: [ { 'role': 'ADMIN' }, { 'age': { $gte: 65 } } ] }")
    List<User> findAdminsOrSeniors();

    // Requ√™te sur tableau
    @Query("{ 'tags': { $all: ?0 } }")
    List<User> findByAllTags(List<String> tags);

    // Count avec requ√™te personnalis√©e
    @Query(value = "{ 'role': ?0 }", count = true)
    long countUsersByRole(UserRole role);

    // Exists avec requ√™te personnalis√©e
    @Query(value = "{ 'email': ?0 }", exists = true)
    boolean userExistsByEmail(String email);

    // Delete avec requ√™te personnalis√©e
    @Query(value = "{ 'isActive': false }", delete = true)
    long deleteInactiveUsers();
}
```

### Repository avec pagination

```java
// repository/PostRepository.java
package com.example.repository;

import com.example.model.Post;
import com.example.model.PostStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import java.util.List;

@Repository
public interface PostRepository extends MongoRepository<Post, String> {

    // Pagination avec Page (retourne total count)
    Page<Post> findByStatus(PostStatus status, Pageable pageable);

    // Pagination avec Slice (pas de total count, plus performant)
    Slice<Post> findByStatusAndAuthor_Id(PostStatus status, String authorId, Pageable pageable);

    // List avec Sort
    List<Post> findByStatus(PostStatus status, Sort sort);

    // Query avec pagination
    @Query("{ 'status': ?0, 'tags': { $in: ?1 } }")
    Page<Post> findByStatusAndTags(PostStatus status, List<String> tags, Pageable pageable);

    // Full-text search avec pagination
    @Query("{ $text: { $search: ?0 } }")
    Page<Post> fullTextSearch(String searchTerm, Pageable pageable);
}

// Utilisation
/*
Pageable pageable = PageRequest.of(
    0,      // page number (0-indexed)
    10,     // page size
    Sort.by("createdAt").descending()
);

Page<Post> page = postRepository.findByStatus(PostStatus.PUBLISHED, pageable);

System.out.println("Total elements: " + page.getTotalElements());
System.out.println("Total pages: " + page.getTotalPages());
System.out.println("Current page: " + page.getNumber());
System.out.println("Has next: " + page.hasNext());
*/
```

### Repository personnalis√©

```java
// repository/CustomUserRepository.java
package com.example.repository;

import com.example.model.User;
import java.util.List;

public interface CustomUserRepository {
    List<User> findUsersWithComplexCriteria(String criteria);
    void updateUserBatch(List<String> userIds, String field, Object value);
}

// repository/CustomUserRepositoryImpl.java
package com.example.repository;

import com.example.model.User;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;

import java.util.List;

@RequiredArgsConstructor
public class CustomUserRepositoryImpl implements CustomUserRepository {

    private final MongoTemplate mongoTemplate;

    @Override
    public List<User> findUsersWithComplexCriteria(String criteria) {
        Query query = new Query();
        // Logique complexe ici
        query.addCriteria(Criteria.where("username").regex(criteria, "i"));
        return mongoTemplate.find(query, User.class);
    }

    @Override
    public void updateUserBatch(List<String> userIds, String field, Object value) {
        Query query = new Query(Criteria.where("_id").in(userIds));
        Update update = new Update().set(field, value);
        mongoTemplate.updateMulti(query, update, User.class);
    }
}

// repository/UserRepository.java (√©tendre avec le custom)
@Repository
public interface UserRepository extends MongoRepository<User, String>, CustomUserRepository {
    // M√©thodes standards + m√©thodes custom disponibles
}
```

---

## MongoTemplate pour requ√™tes avanc√©es

### Configuration et injection

```java
// service/UserService.java
package com.example.service;

import com.example.model.User;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserService {

    private final MongoTemplate mongoTemplate;

    // M√©thodes avec MongoTemplate
}
```

### Op√©rations CRUD avec MongoTemplate

```java
// service/UserService.java
package com.example.service;

import com.example.model.User;
import com.example.model.UserRole;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {

    private final MongoTemplate mongoTemplate;

    // INSERT
    public User createUser(User user) {
        user.setCreatedAt(LocalDateTime.now());
        return mongoTemplate.insert(user);
    }

    public List<User> createUsers(List<User> users) {
        return (List<User>) mongoTemplate.insert(users, User.class);
    }

    // FIND
    public Optional<User> findUserById(String id) {
        return Optional.ofNullable(mongoTemplate.findById(id, User.class));
    }

    public List<User> findAllUsers() {
        return mongoTemplate.findAll(User.class);
    }

    public Optional<User> findUserByEmail(String email) {
        Query query = new Query(Criteria.where("email").is(email));
        return Optional.ofNullable(mongoTemplate.findOne(query, User.class));
    }

    public List<User> findActiveUsers() {
        Query query = new Query(Criteria.where("isActive").is(true));
        return mongoTemplate.find(query, User.class);
    }

    // Requ√™te complexe
    public List<User> findUsersWithCriteria(UserRole role, Integer minAge, Integer maxAge) {
        Query query = new Query();

        Criteria criteria = new Criteria();
        if (role != null) {
            criteria.and("role").is(role);
        }
        if (minAge != null) {
            criteria.and("age").gte(minAge);
        }
        if (maxAge != null) {
            criteria.and("age").lte(maxAge);
        }

        query.addCriteria(criteria);
        query.with(Sort.by(Sort.Direction.DESC, "createdAt"));

        return mongoTemplate.find(query, User.class);
    }

    // UPDATE
    public void updateUserEmail(String userId, String newEmail) {
        Query query = new Query(Criteria.where("_id").is(userId));
        Update update = new Update()
            .set("email", newEmail)
            .set("updatedAt", LocalDateTime.now());

        mongoTemplate.updateFirst(query, update, User.class);
    }

    public void updateMultipleUsers(List<String> userIds, boolean isActive) {
        Query query = new Query(Criteria.where("_id").in(userIds));
        Update update = new Update()
            .set("isActive", isActive)
            .set("updatedAt", LocalDateTime.now());

        mongoTemplate.updateMulti(query, update, User.class);
    }

    // Upsert
    public void upsertUser(String email, User user) {
        Query query = new Query(Criteria.where("email").is(email));
        Update update = new Update()
            .set("username", user.getUsername())
            .set("age", user.getAge())
            .setOnInsert("createdAt", LocalDateTime.now())
            .set("updatedAt", LocalDateTime.now());

        mongoTemplate.upsert(query, update, User.class);
    }

    // DELETE
    public void deleteUser(String userId) {
        Query query = new Query(Criteria.where("_id").is(userId));
        mongoTemplate.remove(query, User.class);
    }

    public long deleteInactiveUsers() {
        Query query = new Query(Criteria.where("isActive").is(false));
        return mongoTemplate.remove(query, User.class).getDeletedCount();
    }

    // COUNT
    public long countUsersByRole(UserRole role) {
        Query query = new Query(Criteria.where("role").is(role));
        return mongoTemplate.count(query, User.class);
    }

    // EXISTS
    public boolean userExists(String email) {
        Query query = new Query(Criteria.where("email").is(email));
        return mongoTemplate.exists(query, User.class);
    }
}
```

### Requ√™tes avec crit√®res complexes

```java
// service/PostService.java
package com.example.service;

import com.example.model.Post;
import com.example.model.PostStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class PostService {

    private final MongoTemplate mongoTemplate;

    public List<Post> searchPosts(
        String keyword,
        PostStatus status,
        List<String> tags,
        LocalDateTime startDate,
        LocalDateTime endDate,
        int page,
        int size
    ) {
        Query query = new Query();
        Criteria criteria = new Criteria();

        // Recherche par mot-cl√© (titre ou contenu)
        if (keyword != null && !keyword.isEmpty()) {
            Criteria keywordCriteria = new Criteria().orOperator(
                Criteria.where("title").regex(keyword, "i"),
                Criteria.where("content").regex(keyword, "i")
            );
            criteria.andOperator(keywordCriteria);
        }

        // Filtrer par statut
        if (status != null) {
            criteria.and("status").is(status);
        }

        // Filtrer par tags (tous les tags doivent √™tre pr√©sents)
        if (tags != null && !tags.isEmpty()) {
            criteria.and("tags").all(tags);
        }

        // Filtrer par date
        if (startDate != null) {
            criteria.and("createdAt").gte(startDate);
        }
        if (endDate != null) {
            criteria.and("createdAt").lte(endDate);
        }

        query.addCriteria(criteria);

        // Pagination et tri
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());
        query.with(pageable);

        // Projection (exclure le contenu complet pour les listes)
        query.fields()
            .include("_id", "title", "slug", "author", "status", "tags", "createdAt")
            .exclude("content");

        return mongoTemplate.find(query, Post.class);
    }

    public List<Post> findPostsWithComments(int minComments) {
        Query query = new Query(
            Criteria.where("comments").size(minComments)
        );
        return mongoTemplate.find(query, Post.class);
    }

    public List<Post> findFeaturedPosts() {
        Query query = new Query(
            Criteria.where("metadata.featured").is(true)
        );
        return mongoTemplate.find(query, Post.class);
    }

    // Requ√™te sur document imbriqu√©
    public List<Post> findPostsByAuthorId(String authorId) {
        Query query = new Query(
            Criteria.where("author.$id").is(authorId)
        );
        return mongoTemplate.find(query, Post.class);
    }

    // Increment field
    public void incrementPostViews(String postId) {
        Query query = new Query(Criteria.where("_id").is(postId));
        Update update = new Update().inc("metadata.views", 1);
        mongoTemplate.updateFirst(query, update, Post.class);
    }

    // Array operations
    public void addTagToPost(String postId, String tag) {
        Query query = new Query(Criteria.where("_id").is(postId));
        Update update = new Update().addToSet("tags", tag);
        mongoTemplate.updateFirst(query, update, Post.class);
    }

    public void removeTagFromPost(String postId, String tag) {
        Query query = new Query(Criteria.where("_id").is(postId));
        Update update = new Update().pull("tags", tag);
        mongoTemplate.updateFirst(query, update, Post.class);
    }

    // Add comment
    public void addComment(String postId, Post.Comment comment) {
        Query query = new Query(Criteria.where("_id").is(postId));
        Update update = new Update().push("comments", comment);
        mongoTemplate.updateFirst(query, update, Post.class);
    }
}
```

---

## Agr√©gations

### Agr√©gation basique

```java
// service/AnalyticsService.java
package com.example.service;

import com.example.model.PostStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.GroupOperation;
import org.springframework.data.mongodb.core.aggregation.MatchOperation;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

@Service
@RequiredArgsConstructor
public class AnalyticsService {

    private final MongoTemplate mongoTemplate;

    // Compter les posts par statut
    public List<Map> countPostsByStatus() {
        GroupOperation groupByStatus = group("status")
            .count().as("count");

        Aggregation aggregation = newAggregation(groupByStatus);

        AggregationResults<Map> results = mongoTemplate.aggregate(
            aggregation,
            "posts",
            Map.class
        );

        return results.getMappedResults();
    }

    // Statistiques par auteur
    public List<Map> getAuthorStatistics() {
        GroupOperation groupByAuthor = group("author")
            .count().as("totalPosts")
            .sum("metadata.views").as("totalViews")
            .avg("metadata.views").as("avgViews");

        Aggregation aggregation = newAggregation(
            match(Criteria.where("status").is(PostStatus.PUBLISHED)),
            groupByAuthor,
            sort(Sort.Direction.DESC, "totalViews")
        );

        AggregationResults<Map> results = mongoTemplate.aggregate(
            aggregation,
            "posts",
            Map.class
        );

        return results.getMappedResults();
    }

    // DTO pour r√©sultat d'agr√©gation
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class UserStatistics {
        private String userId;
        private Long totalPosts;
        private Long totalViews;
        private Double avgViews;
    }

    public List<UserStatistics> getUserStatisticsTyped() {
        Aggregation aggregation = newAggregation(
            match(Criteria.where("status").is(PostStatus.PUBLISHED)),
            group("author.$id")
                .count().as("totalPosts")
                .sum("metadata.views").as("totalViews")
                .avg("metadata.views").as("avgViews"),
            project()
                .and("_id").as("userId")
                .and("totalPosts").as("totalPosts")
                .and("totalViews").as("totalViews")
                .and("avgViews").as("avgViews"),
            sort(Sort.Direction.DESC, "totalViews"),
            limit(10)
        );

        AggregationResults<UserStatistics> results = mongoTemplate.aggregate(
            aggregation,
            "posts",
            UserStatistics.class
        );

        return results.getMappedResults();
    }
}
```

### Agr√©gation avanc√©e avec lookup

```java
// service/AdvancedAnalyticsService.java
package com.example.service;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.LookupOperation;
import org.springframework.stereotype.Service;

import java.util.List;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

@Service
@RequiredArgsConstructor
public class AdvancedAnalyticsService {

    private final MongoTemplate mongoTemplate;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PostWithAuthorDetails {
        private String id;
        private String title;
        private AuthorInfo author;
        private Long views;

        @Data
        @NoArgsConstructor
        @AllArgsConstructor
        public static class AuthorInfo {
            private String id;
            private String username;
            private String email;
        }
    }

    public List<PostWithAuthorDetails> getPostsWithAuthorDetails() {
        // Lookup pour joindre les posts avec les users
        LookupOperation lookupOperation = lookup(
            "users",           // from collection
            "author.$id",      // localField
            "_id",             // foreignField
            "authorDetails"    // as
        );

        Aggregation aggregation = newAggregation(
            match(Criteria.where("status").is("PUBLISHED")),
            lookupOperation,
            unwind("authorDetails"),
            project()
                .and("_id").as("id")
                .and("title").as("title")
                .and("metadata.views").as("views")
                .and("authorDetails._id").as("author.id")
                .and("authorDetails.username").as("author.username")
                .and("authorDetails.email").as("author.email"),
            sort(Sort.Direction.DESC, "views"),
            limit(20)
        );

        AggregationResults<PostWithAuthorDetails> results = mongoTemplate.aggregate(
            aggregation,
            "posts",
            PostWithAuthorDetails.class
        );

        return results.getMappedResults();
    }

    // Agr√©gation avec facet (multiple pipelines)
    public Map<String, Object> getFacetedAnalytics() {
        Aggregation aggregation = newAggregation(
            match(Criteria.where("status").is("PUBLISHED")),
            facet()
                .and(
                    group("author.$id").count().as("count"),
                    sort(Sort.Direction.DESC, "count"),
                    limit(5)
                ).as("topAuthors")
                .and(
                    group("status").count().as("count")
                ).as("byStatus")
                .and(
                    sort(Sort.Direction.DESC, "metadata.views"),
                    limit(10),
                    project().and("title").as("title").and("metadata.views").as("views")
                ).as("topPosts")
        );

        AggregationResults<Map> results = mongoTemplate.aggregate(
            aggregation,
            "posts",
            Map.class
        );

        return results.getUniqueMappedResult();
    }
}
```

---

## Transactions

### Configuration des transactions

```java
// config/MongoConfig.java (ajout)
@Configuration
public class MongoConfig extends AbstractMongoClientConfiguration {

    @Bean
    MongoTransactionManager transactionManager(MongoDatabaseFactory dbFactory) {
        return new MongoTransactionManager(dbFactory);
    }
}
```

### Utilisation avec @Transactional

```java
// service/OrderService.java
package com.example.service;

import com.example.model.Order;
import com.example.model.Product;
import com.example.model.User;
import com.example.repository.OrderRepository;
import com.example.repository.ProductRepository;
import com.example.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    @Transactional
    public Order createOrder(String userId, List<OrderItem> items) {
        // 1. V√©rifier l'utilisateur
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("User not found"));

        // 2. V√©rifier le stock de tous les produits
        for (OrderItem item : items) {
            Product product = productRepository.findById(item.getProductId())
                .orElseThrow(() -> new RuntimeException("Product not found: " + item.getProductId()));

            if (product.getStock() < item.getQuantity()) {
                throw new RuntimeException("Insufficient stock for product: " + product.getName());
            }
        }

        // 3. Calculer le total
        BigDecimal total = items.stream()
            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);

        // 4. V√©rifier le solde
        if (user.getBalance().compareTo(total) < 0) {
            throw new RuntimeException("Insufficient balance");
        }

        // 5. Cr√©er la commande
        Order order = new Order();
        order.setUserId(userId);
        order.setItems(items);
        order.setTotal(total);
        order.setStatus(OrderStatus.PENDING);
        order.setCreatedAt(LocalDateTime.now());

        order = orderRepository.save(order);

        // 6. D√©cr√©menter le stock
        for (OrderItem item : items) {
            Product product = productRepository.findById(item.getProductId()).get();
            product.setStock(product.getStock() - item.getQuantity());
            productRepository.save(product);
        }

        // 7. D√©biter le compte utilisateur
        user.setBalance(user.getBalance().subtract(total));
        userRepository.save(user);

        // Si une exception se produit, toute la transaction est annul√©e
        return order;
    }

    @Transactional
    public void cancelOrder(String orderId) {
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new RuntimeException("Order not found"));

        if (!order.getStatus().equals(OrderStatus.PENDING)) {
            throw new RuntimeException("Cannot cancel order with status: " + order.getStatus());
        }

        // Restaurer le stock
        for (OrderItem item : order.getItems()) {
            Product product = productRepository.findById(item.getProductId()).get();
            product.setStock(product.getStock() + item.getQuantity());
            productRepository.save(product);
        }

        // Recr√©diter l'utilisateur
        User user = userRepository.findById(order.getUserId()).get();
        user.setBalance(user.getBalance().add(order.getTotal()));
        userRepository.save(user);

        // Marquer la commande comme annul√©e
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
    }
}
```

### Transaction programmatique

```java
// service/TransactionService.java
package com.example.service;

import lombok.RequiredArgsConstructor;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.stereotype.Service;
import org.springframework.transaction.support.TransactionTemplate;

@Service
@RequiredArgsConstructor
public class TransactionService {

    private final TransactionTemplate transactionTemplate;
    private final MongoTemplate mongoTemplate;

    public void transferMoney(String fromAccountId, String toAccountId, BigDecimal amount) {
        transactionTemplate.execute(status -> {
            try {
                // D√©biter le compte source
                Query fromQuery = new Query(Criteria.where("_id").is(fromAccountId));
                Update fromUpdate = new Update().inc("balance", amount.negate());
                mongoTemplate.updateFirst(fromQuery, fromUpdate, Account.class);

                // V√©rifier le solde
                Account fromAccount = mongoTemplate.findById(fromAccountId, Account.class);
                if (fromAccount.getBalance().compareTo(BigDecimal.ZERO) < 0) {
                    throw new RuntimeException("Insufficient balance");
                }

                // Cr√©diter le compte destination
                Query toQuery = new Query(Criteria.where("_id").is(toAccountId));
                Update toUpdate = new Update().inc("balance", amount);
                mongoTemplate.updateFirst(toQuery, toUpdate, Account.class);

                return null;
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }
}
```

---

## Auditing

### Configuration de l'auditing

```java
// config/MongoConfig.java (ajout)
@Configuration
@EnableMongoAuditing
public class MongoConfig extends AbstractMongoClientConfiguration {

    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            // R√©cup√©rer l'utilisateur actuel depuis le contexte de s√©curit√©
            // ou depuis un ThreadLocal
            return Optional.of("system"); // Remplacer par l'utilisateur r√©el
        };
    }
}
```

### Entity avec auditing

```java
// model/AuditableEntity.java
package com.example.model;

import lombok.Data;
import org.springframework.data.annotation.*;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;

@Data
@Document(collection = "auditable_documents")
public class AuditableEntity {

    @Id
    private String id;

    private String title;
    private String content;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @CreatedBy
    private String createdBy;

    @LastModifiedBy
    private String lastModifiedBy;

    @Version
    private Long version;  // Optimistic locking
}
```

---

## Validation et Contraintes

### Bean Validation

```java
// model/Product.java
package com.example.model;

import jakarta.validation.constraints.*;
import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.math.BigDecimal;

@Data
@Document(collection = "products")
public class Product {

    @Id
    private String id;

    @NotBlank(message = "Product name is required")
    @Size(min = 3, max = 100, message = "Name must be between 3 and 100 characters")
    private String name;

    @NotBlank
    @Pattern(regexp = "^[A-Z]{3}-\\d{6}$", message = "SKU must be in format ABC-123456")
    private String sku;

    @NotNull
    @DecimalMin(value = "0.01", message = "Price must be greater than 0")
    @Digits(integer = 10, fraction = 2, message = "Invalid price format")
    private BigDecimal price;

    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description;
}

// controller/ProductController.java
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductRepository productRepository;

    @PostMapping
    public ResponseEntity<Product> createProduct(@Valid @RequestBody Product product) {
        Product saved = productRepository.save(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }
}
```

### Custom Validators

```java
// validator/UniqueEmailValidator.java
package com.example.validator;

import com.example.repository.UserRepository;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {

    private final UserRepository userRepository;

    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null) {
            return true;
        }
        return !userRepository.existsByEmail(email);
    }
}

// validator/UniqueEmail.java
package com.example.validator;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
@Documented
public @interface UniqueEmail {
    String message() default "Email already exists";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Utilisation
@Data
@Document(collection = "users")
public class User {
    @Id
    private String id;

    @Email
    @UniqueEmail
    private String email;
}
```

---

## Indexes et Performance

### D√©finition d'indexes

```java
// model/User.java
@Document(collection = "users")
@CompoundIndexes({
    @CompoundIndex(name = "role_active_idx", def = "{'role': 1, 'isActive': 1}"),
    @CompoundIndex(name = "age_created_idx", def = "{'age': 1, 'createdAt': -1}")
})
public class User {

    @Id
    private String id;

    @Indexed(unique = true)
    private String email;

    @Indexed
    private String username;

    @Indexed(sparse = true)
    private String phoneNumber;  // Index sparse pour champs optionnels

    @TextIndexed(weight = 2)
    private String bio;

    private UserRole role;
    private Boolean isActive;
    private Integer age;
}
```

### Cr√©ation d'indexes programmatique

```java
// config/IndexConfig.java
package com.example.config;

import lombok.RequiredArgsConstructor;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.Index;
import org.springframework.data.mongodb.core.index.IndexOperations;

@Configuration
@RequiredArgsConstructor
public class IndexConfig {

    private final MongoTemplate mongoTemplate;

    @Bean
    public CommandLineRunner createIndexes() {
        return args -> {
            IndexOperations indexOps = mongoTemplate.indexOps("users");

            // Index simple
            indexOps.ensureIndex(new Index().on("email", Sort.Direction.ASC).unique());

            // Index compos√©
            indexOps.ensureIndex(
                new Index()
                    .on("role", Sort.Direction.ASC)
                    .on("isActive", Sort.Direction.ASC)
                    .named("role_active_idx")
            );

            // Index TTL (expire apr√®s 30 jours)
            indexOps.ensureIndex(
                new Index()
                    .on("createdAt", Sort.Direction.ASC)
                    .expire(30 * 24 * 60 * 60)  // en secondes
                    .named("ttl_idx")
            );

            // Index partiel
            indexOps.ensureIndex(
                new Index()
                    .on("age", Sort.Direction.ASC)
                    .partial(Query.query(Criteria.where("age").gte(18)))
                    .named("adult_age_idx")
            );
        };
    }
}
```

---

## Projections et DTOs

### Projection avec interface

```java
// projection/UserProjection.java
package com.example.projection;

public interface UserProjection {
    String getId();
    String getUsername();
    String getEmail();
    // Pas de password, etc.
}

// repository/UserRepository.java
public interface UserRepository extends MongoRepository<User, String> {
    List<UserProjection> findAllProjectedBy();

    UserProjection findProjectedById(String id);
}

// Utilisation
List<UserProjection> users = userRepository.findAllProjectedBy();
// Retourne seulement id, username, email
```

### DTO avec MapStruct

```java
// dto/UserDTO.java
package com.example.dto;

import lombok.Data;

import java.time.LocalDateTime;

@Data
public class UserDTO {
    private String id;
    private String username;
    private String email;
    private Integer age;
    private String role;
    private LocalDateTime createdAt;
}

// mapper/UserMapper.java
package com.example.mapper;

import com.example.dto.UserDTO;
import com.example.model.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

@Mapper(componentModel = "spring")
public interface UserMapper {

    @Mapping(target = "role", source = "role")
    UserDTO toDTO(User user);

    List<UserDTO> toDTOList(List<User> users);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    User toEntity(UserDTO dto);
}

// service/UserService.java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;

    public List<UserDTO> getAllUsers() {
        List<User> users = userRepository.findAll();
        return userMapper.toDTOList(users);
    }
}
```

---

## Testing

### Tests unitaires avec Embedded MongoDB

```java
// test/repository/UserRepositoryTest.java
package com.example.repository;

import com.example.model.User;
import com.example.model.UserRole;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.test.context.TestPropertySource;

import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@DataMongoTest
@TestPropertySource(properties = {
    "spring.mongodb.embedded.version=6.0.5"
})
class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
    }

    @Test
    void shouldSaveUser() {
        // Given
        User user = new User("johndoe", "john@example.com", "password123");
        user.setAge(30);
        user.setRole(UserRole.USER);

        // When
        User saved = userRepository.save(user);

        // Then
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getUsername()).isEqualTo("johndoe");
    }

    @Test
    void shouldFindUserByEmail() {
        // Given
        User user = new User("johndoe", "john@example.com", "password123");
        userRepository.save(user);

        // When
        Optional<User> found = userRepository.findByEmail("john@example.com");

        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getUsername()).isEqualTo("johndoe");
    }

    @Test
    void shouldFindActiveUsers() {
        // Given
        User user1 = new User("user1", "user1@example.com", "pass");
        user1.setIsActive(true);

        User user2 = new User("user2", "user2@example.com", "pass");
        user2.setIsActive(false);

        userRepository.saveAll(List.of(user1, user2));

        // When
        List<User> activeUsers = userRepository.findByIsActiveTrue();

        // Then
        assertThat(activeUsers).hasSize(1);
        assertThat(activeUsers.get(0).getUsername()).isEqualTo("user1");
    }

    @Test
    void shouldCountUsersByRole() {
        // Given
        User admin = new User("admin", "admin@example.com", "pass");
        admin.setRole(UserRole.ADMIN);

        User user1 = new User("user1", "user1@example.com", "pass");
        user1.setRole(UserRole.USER);

        User user2 = new User("user2", "user2@example.com", "pass");
        user2.setRole(UserRole.USER);

        userRepository.saveAll(List.of(admin, user1, user2));

        // When
        long userCount = userRepository.countByRole(UserRole.USER);

        // Then
        assertThat(userCount).isEqualTo(2);
    }
}
```

### Tests d'int√©gration

```java
// test/integration/UserIntegrationTest.java
package com.example.integration;

import com.example.dto.UserDTO;
import com.example.model.User;
import com.example.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
class UserIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private UserRepository userRepository;

    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
    }

    @Test
    void shouldCreateUser() throws Exception {
        // Given
        UserDTO userDTO = new UserDTO();
        userDTO.setUsername("johndoe");
        userDTO.setEmail("john@example.com");
        userDTO.setAge(30);

        // When & Then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(userDTO)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.username").value("johndoe"));
    }

    @Test
    void shouldGetUserById() throws Exception {
        // Given
        User user = new User("johndoe", "john@example.com", "password");
        user = userRepository.save(user);

        // When & Then
        mockMvc.perform(get("/api/users/" + user.getId()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.username").value("johndoe"));
    }
}
```

---

## Bonnes Pratiques

### 1. Utiliser les projections pour √©conomiser la bande passante

```java
// ‚ùå Mauvais : Charger tout le document
@GetMapping("/api/users")
public List<User> getAllUsers() {
    return userRepository.findAll();  // Charge password, etc.
}

// ‚úÖ Bon : Utiliser des projections
@GetMapping("/api/users")
public List<UserProjection> getAllUsers() {
    return userRepository.findAllProjectedBy();  // Seulement les champs n√©cessaires
}
```

### 2. Pagination obligatoire pour les listes

```java
// ‚ùå Mauvais : Sans pagination
@GetMapping("/api/posts")
public List<Post> getPosts() {
    return postRepository.findAll();
}

// ‚úÖ Bon : Avec pagination
@GetMapping("/api/posts")
public Page<Post> getPosts(
    @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable
) {
    return postRepository.findAll(pageable);
}
```

### 3. Validation syst√©matique

```java
// Toujours valider les entr√©es
@PostMapping
public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
    // @Valid d√©clenche la validation Bean Validation
    return ResponseEntity.ok(userService.createUser(user));
}
```

### 4. Exception handling global

```java
// exception/GlobalExceptionHandler.java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DuplicateKeyException.class)
    public ResponseEntity<ErrorResponse> handleDuplicateKey(DuplicateKeyException ex) {
        return ResponseEntity
            .status(HttpStatus.CONFLICT)
            .body(new ErrorResponse("Resource already exists"));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException ex) {
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(new ErrorResponse(ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse("An error occurred"));
    }
}
```

### 5. Configuration par environnement

```yaml
# application-dev.yml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/myapp_dev
      auto-index-creation: true
logging:
  level:
    org.springframework.data.mongodb: DEBUG

# application-prod.yml
spring:
  data:
    mongodb:
      uri: ${MONGODB_URI}  # Variable d'environnement
      auto-index-creation: false
logging:
  level:
    org.springframework.data.mongodb: WARN
```

---

## Conclusion

Spring Data MongoDB offre une int√©gration puissante et √©l√©gante entre Spring et MongoDB, combinant la productivit√© des repositories avec la flexibilit√© de MongoTemplate pour les cas avanc√©s.

### Points cl√©s √† retenir

1. **Repository Pattern** : M√©thodes d√©riv√©es automatiquement + @Query pour flexibilit√©
2. **MongoTemplate** : Contr√¥le fin pour requ√™tes complexes et agr√©gations
3. **Type Safety** : Typage fort Java pour √©viter les erreurs au runtime
4. **Transactions** : Support natif avec @Transactional
5. **Auditing** : Tra√ßabilit√© automatique avec annotations
6. **Validation** : Bean Validation int√©gr√©e
7. **Testing** : Embedded MongoDB pour tests isol√©s

### Ressources

- [Spring Data MongoDB Reference](https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/)
- [Spring Boot Documentation](https://spring.io/projects/spring-boot)
- [MongoDB Java Driver](https://www.mongodb.com/docs/drivers/java/)
- [Baeldung Tutorials](https://www.baeldung.com/spring-data-mongodb-tutorial)

---

**Note** : Cette section a couvert Spring Data MongoDB en d√©tail. Les patterns et bonnes pratiques pr√©sent√©s sont applicables √† la majorit√© des projets Spring/MongoDB en production.

‚è≠Ô∏è [Bonnes pratiques d'int√©gration](/15-drivers-integration-applicative/13-bonnes-pratiques-integration.md)
