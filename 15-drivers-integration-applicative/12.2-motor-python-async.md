üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.12.2 Motor (Python async)

## Introduction

**Motor** est le driver MongoDB asynchrone officiel pour Python. Il pr√©sente la m√™me API que PyMongo mais avec un support natif pour `asyncio` et Tornado, permettant des applications Python hautement performantes et non-bloquantes.

### Qu'est-ce que Motor ?

Motor est une couche asynchrone construite au-dessus de PyMongo qui permet :
- Des op√©rations MongoDB non-bloquantes
- Une int√©gration native avec asyncio
- Un support pour Tornado
- Des performances optimales pour les applications async Python

### Pourquoi Motor ?

**Avantages de l'asynchrone :**
- **Concurrence √©lev√©e** : G√©rer des milliers de connexions simultan√©es
- **Performance I/O** : Ne bloque pas en attendant les r√©ponses de la base de donn√©es
- **Scalabilit√©** : Id√©al pour les microservices et APIs modernes
- **Int√©gration** : Parfait avec FastAPI, aiohttp, Sanic

### Statistiques

```
üì¶ Package: motor
‚≠ê GitHub: 2,400+ stars
üì• Downloads: 500K+/semaine
üìù Version: 3.3+ (2023)
üè¢ Utilisateurs: MongoDB officiel, microservices Python
```

---

## Installation et Configuration

### Installation

```bash
# Installation basique
pip install motor

# Avec extras pour SSL/TLS
pip install "motor[srv]"

# Version sp√©cifique
pip install motor==3.3.2

# Avec Poetry
poetry add motor

# Avec pipenv
pipenv install motor
```

### D√©pendances

```bash
# Motor n√©cessite PyMongo
pip install pymongo

# Pour utiliser asyncio (inclus Python 3.7+)
# Pas de d√©pendance suppl√©mentaire

# Pour Tornado (optionnel)
pip install tornado
```

### Configuration de base

```python
# config/database.py
import motor.motor_asyncio
from typing import Optional

class Database:
    client: Optional[motor.motor_asyncio.AsyncIOMotorClient] = None
    db: Optional[motor.motor_asyncio.AsyncIOMotorDatabase] = None

db = Database()

async def connect_to_mongo(uri: str, db_name: str):
    """√âtablir la connexion √† MongoDB"""
    print("Connecting to MongoDB...")

    db.client = motor.motor_asyncio.AsyncIOMotorClient(
        uri,
        maxPoolSize=10,
        minPoolSize=5,
        serverSelectionTimeoutMS=5000,
    )

    db.db = db.client[db_name]

    # V√©rifier la connexion
    try:
        await db.client.admin.command('ping')
        print("Successfully connected to MongoDB!")
    except Exception as e:
        print(f"Error connecting to MongoDB: {e}")
        raise

async def close_mongo_connection():
    """Fermer la connexion proprement"""
    print("Closing MongoDB connection...")
    if db.client:
        db.client.close()
    print("MongoDB connection closed")

# Utilisation
import asyncio

async def main():
    await connect_to_mongo(
        "mongodb://localhost:27017",
        "myapp"
    )

    # Votre code ici

    await close_mongo_connection()

if __name__ == "__main__":
    asyncio.run(main())
```

### Configuration avanc√©e

```python
# config/database_advanced.py
import motor.motor_asyncio
from pymongo import ReadPreference, WriteConcern
from pymongo.errors import ConnectionFailure
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class DatabaseManager:
    def __init__(self):
        self.client: Optional[motor.motor_asyncio.AsyncIOMotorClient] = None
        self.db: Optional[motor.motor_asyncio.AsyncIOMotorDatabase] = None
        self._is_connected: bool = False

    async def connect(
        self,
        uri: str,
        db_name: str,
        max_pool_size: int = 10,
        min_pool_size: int = 5,
        max_idle_time_ms: int = 10000,
        retry_writes: bool = True,
    ):
        """Connexion avec options avanc√©es"""

        try:
            self.client = motor.motor_asyncio.AsyncIOMotorClient(
                uri,
                # Connection Pool
                maxPoolSize=max_pool_size,
                minPoolSize=min_pool_size,
                maxIdleTimeMS=max_idle_time_ms,

                # Timeouts
                serverSelectionTimeoutMS=5000,
                socketTimeoutMS=45000,
                connectTimeoutMS=10000,

                # Retry
                retryWrites=retry_writes,
                retryReads=True,

                # Compression
                compressors=['snappy', 'zlib'],
            )

            # Obtenir la base de donn√©es avec options
            self.db = self.client.get_database(
                db_name,
                write_concern=WriteConcern(w='majority', j=True),
                read_preference=ReadPreference.PRIMARY
            )

            # Test de connexion
            await self.client.admin.command('ping')
            self._is_connected = True

            logger.info(f"Connected to MongoDB: {db_name}")

            # Obtenir les informations du serveur
            server_info = await self.client.server_info()
            logger.info(f"MongoDB version: {server_info['version']}")

        except ConnectionFailure as e:
            logger.error(f"Failed to connect to MongoDB: {e}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error during connection: {e}")
            raise

    async def disconnect(self):
        """Fermeture propre"""
        if self.client:
            self.client.close()
            self._is_connected = False
            logger.info("Disconnected from MongoDB")

    async def health_check(self) -> bool:
        """V√©rifier la sant√© de la connexion"""
        try:
            await self.client.admin.command('ping')
            return True
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False

    def get_collection(self, collection_name: str):
        """Obtenir une collection"""
        if not self._is_connected:
            raise RuntimeError("Database not connected")
        return self.db[collection_name]

    @property
    def is_connected(self) -> bool:
        return self._is_connected

# Singleton
db_manager = DatabaseManager()

# Fonctions helper
async def get_database():
    """Dependency injection pour FastAPI"""
    if not db_manager.is_connected:
        raise RuntimeError("Database not connected")
    return db_manager.db

async def get_collection(collection_name: str):
    """Obtenir une collection"""
    return db_manager.get_collection(collection_name)
```

### Int√©gration avec FastAPI

```python
# main.py (FastAPI)
from fastapi import FastAPI
from contextlib import asynccontextmanager
from config.database_advanced import db_manager

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan events pour g√©rer la connexion"""
    # Startup
    await db_manager.connect(
        uri="mongodb://localhost:27017",
        db_name="myapp"
    )
    yield
    # Shutdown
    await db_manager.disconnect()

app = FastAPI(lifespan=lifespan)

@app.get("/health")
async def health_check():
    """Endpoint de sant√©"""
    is_healthy = await db_manager.health_check()
    return {
        "status": "healthy" if is_healthy else "unhealthy",
        "database": "connected" if is_healthy else "disconnected"
    }

# Routes avec d√©pendance
from fastapi import Depends

@app.get("/users")
async def get_users(db = Depends(get_database)):
    users = await db.users.find().to_list(length=100)
    return users
```

---

## Op√©rations CRUD Asynchrones

### Comparaison PyMongo vs Motor

```python
# PyMongo (synchrone)
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017")
db = client.myapp

# Insertion synchrone - bloque le thread
user = {"name": "John", "email": "john@example.com"}
result = db.users.insert_one(user)
print(result.inserted_id)

# Motor (asynchrone)
import motor.motor_asyncio

client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
db = client.myapp

# Insertion asynchrone - non-bloquante
async def create_user():
    user = {"name": "John", "email": "john@example.com"}
    result = await db.users.insert_one(user)
    print(result.inserted_id)

# Ex√©cuter
import asyncio
asyncio.run(create_user())
```

### Insert Operations

```python
# models/user.py
from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, EmailStr, Field
from bson import ObjectId

class User(BaseModel):
    """Mod√®le utilisateur avec Pydantic"""
    id: Optional[str] = Field(default=None, alias="_id")
    username: str
    email: EmailStr
    age: int = Field(ge=0, le=150)
    is_active: bool = True
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        populate_by_name = True
        json_encoders = {
            ObjectId: str,
            datetime: lambda v: v.isoformat()
        }

# repositories/user_repository.py
import motor.motor_asyncio
from typing import Optional, List
from models.user import User
from bson import ObjectId

class UserRepository:
    def __init__(self, db: motor.motor_asyncio.AsyncIOMotorDatabase):
        self.collection = db.users

    async def create(self, user: User) -> str:
        """Cr√©er un utilisateur"""
        user_dict = user.dict(by_alias=True, exclude={"id"})
        result = await self.collection.insert_one(user_dict)
        return str(result.inserted_id)

    async def create_many(self, users: List[User]) -> List[str]:
        """Cr√©er plusieurs utilisateurs"""
        users_dict = [
            user.dict(by_alias=True, exclude={"id"})
            for user in users
        ]
        result = await self.collection.insert_many(users_dict)
        return [str(id) for id in result.inserted_ids]

    async def find_by_id(self, user_id: str) -> Optional[User]:
        """Trouver un utilisateur par ID"""
        user_dict = await self.collection.find_one({"_id": ObjectId(user_id)})
        if user_dict:
            user_dict["_id"] = str(user_dict["_id"])
            return User(**user_dict)
        return None

    async def find_by_email(self, email: str) -> Optional[User]:
        """Trouver un utilisateur par email"""
        user_dict = await self.collection.find_one({"email": email})
        if user_dict:
            user_dict["_id"] = str(user_dict["_id"])
            return User(**user_dict)
        return None

    async def find_all(
        self,
        skip: int = 0,
        limit: int = 100,
        **filters
    ) -> List[User]:
        """Trouver tous les utilisateurs avec pagination"""
        cursor = self.collection.find(filters).skip(skip).limit(limit)
        users = []
        async for user_dict in cursor:
            user_dict["_id"] = str(user_dict["_id"])
            users.append(User(**user_dict))
        return users

    async def update(
        self,
        user_id: str,
        update_data: dict
    ) -> Optional[User]:
        """Mettre √† jour un utilisateur"""
        update_data["updated_at"] = datetime.utcnow()

        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(user_id)},
            {"$set": update_data},
            return_document=True  # Retourner le document mis √† jour
        )

        if result:
            result["_id"] = str(result["_id"])
            return User(**result)
        return None

    async def delete(self, user_id: str) -> bool:
        """Supprimer un utilisateur"""
        result = await self.collection.delete_one({"_id": ObjectId(user_id)})
        return result.deleted_count > 0

    async def count(self, **filters) -> int:
        """Compter les documents"""
        return await self.collection.count_documents(filters)

    async def exists(self, **filters) -> bool:
        """V√©rifier l'existence"""
        count = await self.collection.count_documents(filters, limit=1)
        return count > 0

# Utilisation
async def main():
    # Connexion
    client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
    db = client.myapp

    repo = UserRepository(db)

    # Cr√©er un utilisateur
    user = User(
        username="johndoe",
        email="john@example.com",
        age=30
    )
    user_id = await repo.create(user)
    print(f"Created user: {user_id}")

    # Trouver par email
    found_user = await repo.find_by_email("john@example.com")
    print(f"Found user: {found_user.username}")

    # Mettre √† jour
    updated = await repo.update(user_id, {"age": 31})
    print(f"Updated user age: {updated.age}")

    # Lister tous les utilisateurs
    all_users = await repo.find_all(limit=10)
    print(f"Total users: {len(all_users)}")

    # Compter
    count = await repo.count(is_active=True)
    print(f"Active users: {count}")

    # Supprimer
    deleted = await repo.delete(user_id)
    print(f"Deleted: {deleted}")
```

---

## Requ√™tes Avanc√©es

### Requ√™tes avec op√©rateurs

```python
# repositories/advanced_queries.py
import motor.motor_asyncio
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta

class AdvancedQueries:
    def __init__(self, db: motor.motor_asyncio.AsyncIOMotorDatabase):
        self.users = db.users
        self.posts = db.posts

    async def find_with_conditions(self):
        """Requ√™tes avec op√©rateurs de comparaison"""

        # $gt, $gte, $lt, $lte
        adults = await self.users.find({
            "age": {"$gte": 18}
        }).to_list(length=100)

        # $in, $nin
        admins_or_mods = await self.users.find({
            "role": {"$in": ["admin", "moderator"]}
        }).to_list(length=100)

        # $and, $or
        query = {
            "$or": [
                {"role": "admin"},
                {"age": {"$gte": 65}}
            ]
        }
        senior_or_admin = await self.users.find(query).to_list(length=100)

        # $not
        not_active = await self.users.find({
            "is_active": {"$not": {"$eq": True}}
        }).to_list(length=100)

        return {
            "adults": len(adults),
            "admins_or_mods": len(admins_or_mods),
            "senior_or_admin": len(senior_or_admin),
            "not_active": len(not_active)
        }

    async def find_with_regex(self, pattern: str):
        """Recherche avec expressions r√©guli√®res"""
        users = await self.users.find({
            "username": {"$regex": pattern, "$options": "i"}  # Case insensitive
        }).to_list(length=100)

        return users

    async def find_with_exists(self):
        """V√©rifier l'existence de champs"""
        # Utilisateurs avec un num√©ro de t√©l√©phone
        with_phone = await self.users.find({
            "phone": {"$exists": True}
        }).to_list(length=100)

        return with_phone

    async def find_with_type(self):
        """Filtrer par type de champ"""
        # Utilisateurs o√π age est un nombre
        numeric_age = await self.users.find({
            "age": {"$type": "number"}
        }).to_list(length=100)

        return numeric_age

    async def find_in_array(self, tag: str):
        """Requ√™tes sur les tableaux"""
        # Posts contenant un tag sp√©cifique
        posts = await self.posts.find({
            "tags": tag  # √âquivalent √† $elemMatch pour valeurs simples
        }).to_list(length=100)

        # Tous les tags sp√©cifi√©s
        posts_with_all = await self.posts.find({
            "tags": {"$all": ["mongodb", "python"]}
        }).to_list(length=100)

        # Taille du tableau
        posts_with_5_tags = await self.posts.find({
            "tags": {"$size": 5}
        }).to_list(length=100)

        return posts

    async def find_nested_documents(self):
        """Requ√™tes sur documents imbriqu√©s"""
        # Dot notation
        users = await self.users.find({
            "address.city": "Paris",
            "address.country": "France"
        }).to_list(length=100)

        # $elemMatch pour tableaux d'objets
        users_with_premium = await self.users.find({
            "subscriptions": {
                "$elemMatch": {
                    "plan": "premium",
                    "status": "active"
                }
            }
        }).to_list(length=100)

        return users

    async def text_search(self, search_term: str):
        """Recherche full-text"""
        # N√©cessite un index text
        # await self.posts.create_index([("title", "text"), ("content", "text")])

        posts = await self.posts.find({
            "$text": {"$search": search_term}
        }).to_list(length=100)

        return posts

    async def geospatial_query(self, longitude: float, latitude: float, max_distance: int):
        """Requ√™te g√©ospatiale"""
        # N√©cessite un index 2dsphere
        # await self.users.create_index([("location", "2dsphere")])

        nearby_users = await self.users.find({
            "location": {
                "$near": {
                    "$geometry": {
                        "type": "Point",
                        "coordinates": [longitude, latitude]
                    },
                    "$maxDistance": max_distance  # en m√®tres
                }
            }
        }).to_list(length=100)

        return nearby_users

# Utilisation
async def example_queries():
    client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
    db = client.myapp

    queries = AdvancedQueries(db)

    # Recherche avec regex
    johns = await queries.find_with_regex("^john")
    print(f"Users starting with 'john': {len(johns)}")

    # Recherche par tag
    python_posts = await queries.find_in_array("python")
    print(f"Posts tagged 'python': {len(python_posts)}")
```

### Curseurs et it√©ration

```python
# It√©ration avec async for
async def iterate_large_collection(collection):
    """It√©rer sur une grande collection"""
    cursor = collection.find().batch_size(100)

    count = 0
    async for document in cursor:
        # Traiter chaque document
        count += 1
        print(f"Processing document {count}: {document['_id']}")

    return count

# Utiliser to_list() pour petites collections
async def get_all_users(collection, limit=100):
    """Obtenir tous les documents en une liste"""
    users = await collection.find().to_list(length=limit)
    return users

# Pagination efficace avec curseur
async def paginate_with_cursor(
    collection,
    last_id: Optional[str] = None,
    limit: int = 20
):
    """Pagination bas√©e sur curseur"""
    query = {}

    if last_id:
        query["_id"] = {"$gt": ObjectId(last_id)}

    cursor = collection.find(query).sort("_id", 1).limit(limit)
    documents = await cursor.to_list(length=limit)

    next_cursor = None
    if documents and len(documents) == limit:
        next_cursor = str(documents[-1]["_id"])

    return {
        "documents": documents,
        "next_cursor": next_cursor,
        "has_more": next_cursor is not None
    }

# Sort, skip, limit
async def advanced_pagination(collection, page: int = 1, per_page: int = 20):
    """Pagination classique avec skip"""
    skip = (page - 1) * per_page

    # Requ√™te avec options
    cursor = (
        collection
        .find({"is_active": True})
        .sort([("created_at", -1), ("_id", 1)])  # Multi-sort
        .skip(skip)
        .limit(per_page)
    )

    documents = await cursor.to_list(length=per_page)
    total = await collection.count_documents({"is_active": True})

    return {
        "documents": documents,
        "page": page,
        "per_page": per_page,
        "total": total,
        "pages": (total + per_page - 1) // per_page
    }

# Projection (s√©lection de champs)
async def get_users_minimal(collection):
    """R√©cup√©rer seulement certains champs"""
    cursor = collection.find(
        {},
        {
            "_id": 1,
            "username": 1,
            "email": 1,
            "password": 0  # Exclure explicitement
        }
    )

    return await cursor.to_list(length=100)
```

---

## Agr√©gations Asynchrones

### Pipeline d'agr√©gation basique

```python
# aggregations/basic_aggregations.py
import motor.motor_asyncio
from typing import List, Dict, Any

class Aggregations:
    def __init__(self, db: motor.motor_asyncio.AsyncIOMotorDatabase):
        self.db = db
        self.users = db.users
        self.orders = db.orders

    async def count_by_status(self) -> List[Dict[str, Any]]:
        """Compter les utilisateurs par statut"""
        pipeline = [
            {
                "$group": {
                    "_id": "$status",
                    "count": {"$sum": 1}
                }
            },
            {
                "$sort": {"count": -1}
            }
        ]

        cursor = self.users.aggregate(pipeline)
        results = await cursor.to_list(length=None)
        return results

    async def average_age_by_role(self) -> List[Dict[str, Any]]:
        """√Çge moyen par r√¥le"""
        pipeline = [
            {
                "$match": {
                    "age": {"$exists": True}
                }
            },
            {
                "$group": {
                    "_id": "$role",
                    "avg_age": {"$avg": "$age"},
                    "min_age": {"$min": "$age"},
                    "max_age": {"$max": "$age"},
                    "count": {"$sum": 1}
                }
            },
            {
                "$sort": {"avg_age": -1}
            }
        ]

        cursor = self.users.aggregate(pipeline)
        return await cursor.to_list(length=None)

    async def top_users_by_orders(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Top utilisateurs par nombre de commandes"""
        pipeline = [
            {
                "$group": {
                    "_id": "$user_id",
                    "total_orders": {"$sum": 1},
                    "total_amount": {"$sum": "$total"}
                }
            },
            {
                "$lookup": {
                    "from": "users",
                    "localField": "_id",
                    "foreignField": "_id",
                    "as": "user_info"
                }
            },
            {
                "$unwind": "$user_info"
            },
            {
                "$project": {
                    "_id": 0,
                    "user_id": "$_id",
                    "username": "$user_info.username",
                    "email": "$user_info.email",
                    "total_orders": 1,
                    "total_amount": 1
                }
            },
            {
                "$sort": {"total_amount": -1}
            },
            {
                "$limit": limit
            }
        ]

        cursor = self.orders.aggregate(pipeline)
        return await cursor.to_list(length=None)

    async def sales_by_date_range(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> List[Dict[str, Any]]:
        """Ventes par p√©riode"""
        pipeline = [
            {
                "$match": {
                    "created_at": {
                        "$gte": start_date,
                        "$lte": end_date
                    },
                    "status": "completed"
                }
            },
            {
                "$group": {
                    "_id": {
                        "year": {"$year": "$created_at"},
                        "month": {"$month": "$created_at"},
                        "day": {"$dayOfMonth": "$created_at"}
                    },
                    "total_sales": {"$sum": "$total"},
                    "order_count": {"$sum": 1},
                    "avg_order": {"$avg": "$total"}
                }
            },
            {
                "$sort": {
                    "_id.year": 1,
                    "_id.month": 1,
                    "_id.day": 1
                }
            }
        ]

        cursor = self.orders.aggregate(pipeline)
        return await cursor.to_list(length=None)

    async def complex_aggregation(self) -> List[Dict[str, Any]]:
        """Agr√©gation complexe avec plusieurs √©tapes"""
        pipeline = [
            # 1. Filtrer les commandes compl√©t√©es
            {
                "$match": {
                    "status": "completed",
                    "created_at": {
                        "$gte": datetime.utcnow() - timedelta(days=30)
                    }
                }
            },
            # 2. D√©composer les items
            {
                "$unwind": "$items"
            },
            # 3. Lookup sur les produits
            {
                "$lookup": {
                    "from": "products",
                    "localField": "items.product_id",
                    "foreignField": "_id",
                    "as": "product"
                }
            },
            {
                "$unwind": "$product"
            },
            # 4. Grouper par cat√©gorie
            {
                "$group": {
                    "_id": "$product.category",
                    "total_revenue": {
                        "$sum": {
                            "$multiply": ["$items.quantity", "$items.price"]
                        }
                    },
                    "total_items_sold": {"$sum": "$items.quantity"},
                    "unique_products": {"$addToSet": "$product._id"}
                }
            },
            # 5. Ajouter des champs calcul√©s
            {
                "$addFields": {
                    "unique_product_count": {"$size": "$unique_products"}
                }
            },
            # 6. Projeter le r√©sultat final
            {
                "$project": {
                    "category": "$_id",
                    "total_revenue": 1,
                    "total_items_sold": 1,
                    "unique_product_count": 1,
                    "_id": 0
                }
            },
            # 7. Trier
            {
                "$sort": {"total_revenue": -1}
            }
        ]

        cursor = self.orders.aggregate(pipeline)
        return await cursor.to_list(length=None)

    async def faceted_search(
        self,
        search_term: str
    ) -> Dict[str, Any]:
        """Recherche avec facettes multiples"""
        pipeline = [
            {
                "$match": {
                    "$text": {"$search": search_term}
                }
            },
            {
                "$facet": {
                    "by_category": [
                        {
                            "$group": {
                                "_id": "$category",
                                "count": {"$sum": 1}
                            }
                        },
                        {"$sort": {"count": -1}}
                    ],
                    "by_price_range": [
                        {
                            "$bucket": {
                                "groupBy": "$price",
                                "boundaries": [0, 50, 100, 200, 500, 1000],
                                "default": "1000+",
                                "output": {
                                    "count": {"$sum": 1},
                                    "products": {"$push": "$name"}
                                }
                            }
                        }
                    ],
                    "top_products": [
                        {"$sort": {"views": -1}},
                        {"$limit": 10},
                        {
                            "$project": {
                                "name": 1,
                                "price": 1,
                                "views": 1
                            }
                        }
                    ]
                }
            }
        ]

        cursor = self.db.products.aggregate(pipeline)
        results = await cursor.to_list(length=1)
        return results[0] if results else {}

# Utilisation
async def run_aggregations():
    client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
    db = client.myapp

    agg = Aggregations(db)

    # Statistiques de base
    status_counts = await agg.count_by_status()
    print("Users by status:", status_counts)

    # √Çge moyen
    age_stats = await agg.average_age_by_role()
    print("Age statistics:", age_stats)

    # Top clients
    top_users = await agg.top_users_by_orders(10)
    print("Top 10 users:", top_users)

    # Ventes par p√©riode
    sales = await agg.sales_by_date_range(
        datetime(2024, 1, 1),
        datetime(2024, 12, 31)
    )
    print("Sales by date:", sales)
```

---

## Transactions Asynchrones

### Transaction simple

```python
# services/transaction_service.py
import motor.motor_asyncio
from pymongo.errors import OperationFailure
from typing import Dict, Any

class TransactionService:
    def __init__(self, client: motor.motor_asyncio.AsyncIOMotorClient):
        self.client = client
        self.db = client.myapp

    async def transfer_money(
        self,
        from_account_id: str,
        to_account_id: str,
        amount: float
    ) -> Dict[str, Any]:
        """Transf√©rer de l'argent entre deux comptes"""

        async with await self.client.start_session() as session:
            async with session.start_transaction():
                try:
                    # 1. V√©rifier le solde du compte source
                    from_account = await self.db.accounts.find_one(
                        {"_id": ObjectId(from_account_id)},
                        session=session
                    )

                    if not from_account:
                        raise ValueError("Source account not found")

                    if from_account["balance"] < amount:
                        raise ValueError("Insufficient balance")

                    # 2. V√©rifier que le compte destination existe
                    to_account = await self.db.accounts.find_one(
                        {"_id": ObjectId(to_account_id)},
                        session=session
                    )

                    if not to_account:
                        raise ValueError("Destination account not found")

                    # 3. D√©biter le compte source
                    await self.db.accounts.update_one(
                        {"_id": ObjectId(from_account_id)},
                        {"$inc": {"balance": -amount}},
                        session=session
                    )

                    # 4. Cr√©diter le compte destination
                    await self.db.accounts.update_one(
                        {"_id": ObjectId(to_account_id)},
                        {"$inc": {"balance": amount}},
                        session=session
                    )

                    # 5. Cr√©er un enregistrement de transaction
                    transaction_record = {
                        "from_account": from_account_id,
                        "to_account": to_account_id,
                        "amount": amount,
                        "timestamp": datetime.utcnow(),
                        "status": "completed"
                    }

                    result = await self.db.transactions.insert_one(
                        transaction_record,
                        session=session
                    )

                    # Transaction r√©ussie, commit automatique √† la sortie du contexte
                    return {
                        "success": True,
                        "transaction_id": str(result.inserted_id),
                        "amount": amount,
                        "from": from_account_id,
                        "to": to_account_id
                    }

                except (ValueError, OperationFailure) as e:
                    # Transaction annul√©e automatiquement √† la sortie du contexte
                    return {
                        "success": False,
                        "error": str(e)
                    }

# Utilisation
async def example_transfer():
    client = motor.motor_asyncio.AsyncIOMotorClient("mongodb://localhost:27017")
    service = TransactionService(client)

    result = await service.transfer_money(
        from_account_id="507f1f77bcf86cd799439011",
        to_account_id="507f1f77bcf86cd799439012",
        amount=100.0
    )

    if result["success"]:
        print(f"Transfer successful: {result['transaction_id']}")
    else:
        print(f"Transfer failed: {result['error']}")
```

### Transaction complexe avec retry

```python
# services/order_service.py
import motor.motor_asyncio
from pymongo.errors import OperationFailure
from typing import List, Dict, Any
import asyncio

class OrderService:
    def __init__(self, client: motor.motor_asyncio.AsyncIOMotorClient):
        self.client = client
        self.db = client.myapp

    async def process_order_with_retry(
        self,
        user_id: str,
        items: List[Dict[str, Any]],
        max_retries: int = 3
    ) -> Dict[str, Any]:
        """Traiter une commande avec retry automatique"""

        for attempt in range(max_retries):
            try:
                result = await self._process_order(user_id, items)
                return result
            except OperationFailure as e:
                # V√©rifier si c'est une erreur transitoire
                if "TransientTransactionError" in str(e) and attempt < max_retries - 1:
                    wait_time = (attempt + 1) * 0.1  # Backoff exponentiel
                    await asyncio.sleep(wait_time)
                    continue
                raise

        raise Exception("Transaction failed after maximum retries")

    async def _process_order(
        self,
        user_id: str,
        items: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Logique de traitement de commande"""

        async with await self.client.start_session() as session:
            async with session.start_transaction():
                # 1. V√©rifier le stock de tous les produits
                for item in items:
                    product = await self.db.products.find_one(
                        {"_id": ObjectId(item["product_id"])},
                        session=session
                    )

                    if not product:
                        raise ValueError(f"Product {item['product_id']} not found")

                    if product["stock"] < item["quantity"]:
                        raise ValueError(f"Insufficient stock for {product['name']}")

                # 2. Calculer le total
                total = sum(item["price"] * item["quantity"] for item in items)

                # 3. V√©rifier le solde de l'utilisateur
                user = await self.db.users.find_one(
                    {"_id": ObjectId(user_id)},
                    session=session
                )

                if not user:
                    raise ValueError("User not found")

                if user.get("balance", 0) < total:
                    raise ValueError("Insufficient balance")

                # 4. Cr√©er la commande
                order = {
                    "user_id": ObjectId(user_id),
                    "items": items,
                    "total": total,
                    "status": "pending",
                    "created_at": datetime.utcnow()
                }

                order_result = await self.db.orders.insert_one(
                    order,
                    session=session
                )

                # 5. D√©cr√©menter le stock de chaque produit
                for item in items:
                    await self.db.products.update_one(
                        {"_id": ObjectId(item["product_id"])},
                        {"$inc": {"stock": -item["quantity"]}},
                        session=session
                    )

                # 6. D√©biter le compte utilisateur
                await self.db.users.update_one(
                    {"_id": ObjectId(user_id)},
                    {"$inc": {"balance": -total}},
                    session=session
                )

                # 7. Vider le panier
                await self.db.carts.update_one(
                    {"user_id": ObjectId(user_id)},
                    {"$set": {"items": []}},
                    session=session
                )

                # 8. Cr√©er un enregistrement de paiement
                payment = {
                    "order_id": order_result.inserted_id,
                    "user_id": ObjectId(user_id),
                    "amount": total,
                    "method": "account_balance",
                    "status": "completed",
                    "created_at": datetime.utcnow()
                }

                await self.db.payments.insert_one(
                    payment,
                    session=session
                )

                return {
                    "success": True,
                    "order_id": str(order_result.inserted_id),
                    "total": total
                }

# Utilisation
async def place_order():
    client = motor.motor_asyncio.AsyncIOMotorClient(
        "mongodb://localhost:27017/?replicaSet=rs0"  # Replica set requis
    )

    service = OrderService(client)

    items = [
        {"product_id": "507f1f77bcf86cd799439011", "quantity": 2, "price": 29.99},
        {"product_id": "507f1f77bcf86cd799439012", "quantity": 1, "price": 49.99}
    ]

    try:
        result = await service.process_order_with_retry(
            user_id="507f1f77bcf86cd799439013",
            items=items
        )
        print(f"Order placed: {result}")
    except Exception as e:
        print(f"Order failed: {e}")
```

---

## Change Streams

### √âcouter les changements en temps r√©el

```python
# services/change_stream_service.py
import motor.motor_asyncio
from typing import Callable, Optional, Dict, Any
import asyncio
import logging

logger = logging.getLogger(__name__)

class ChangeStreamService:
    def __init__(self, client: motor.motor_asyncio.AsyncIOMotorClient):
        self.client = client
        self.db = client.myapp
        self._watching = False

    async def watch_collection(
        self,
        collection_name: str,
        pipeline: Optional[List[Dict[str, Any]]] = None,
        callback: Optional[Callable] = None
    ):
        """√âcouter les changements sur une collection"""

        collection = self.db[collection_name]
        self._watching = True

        try:
            async with collection.watch(pipeline=pipeline) as stream:
                logger.info(f"Watching collection: {collection_name}")

                async for change in stream:
                    if not self._watching:
                        break

                    logger.info(f"Change detected: {change['operationType']}")

                    if callback:
                        await callback(change)
                    else:
                        await self._default_handler(change)

        except Exception as e:
            logger.error(f"Error in change stream: {e}")
            raise

    async def _default_handler(self, change: Dict[str, Any]):
        """Handler par d√©faut pour les changements"""
        operation = change["operationType"]

        if operation == "insert":
            print(f"New document inserted: {change['fullDocument']}")
        elif operation == "update":
            print(f"Document updated: {change['documentKey']}")
        elif operation == "delete":
            print(f"Document deleted: {change['documentKey']}")
        elif operation == "replace":
            print(f"Document replaced: {change['fullDocument']}")

    def stop_watching(self):
        """Arr√™ter l'√©coute"""
        self._watching = False

    async def watch_with_filter(self, collection_name: str):
        """√âcouter seulement certains types de changements"""

        pipeline = [
            {
                "$match": {
                    "operationType": {"$in": ["insert", "update"]},
                    "fullDocument.status": "published"
                }
            }
        ]

        await self.watch_collection(collection_name, pipeline=pipeline)

    async def watch_multiple_collections(self, collection_names: List[str]):
        """√âcouter plusieurs collections en parall√®le"""

        tasks = [
            self.watch_collection(name)
            for name in collection_names
        ]

        await asyncio.gather(*tasks, return_exceptions=True)

# Exemple d'utilisation avec callback personnalis√©
async def handle_user_change(change: Dict[str, Any]):
    """Handler personnalis√© pour les changements utilisateur"""
    operation = change["operationType"]

    if operation == "insert":
        user = change["fullDocument"]
        print(f"New user registered: {user['email']}")
        # Envoyer un email de bienvenue
        # await send_welcome_email(user['email'])

    elif operation == "update":
        updated_fields = change.get("updateDescription", {}).get("updatedFields", {})

        if "status" in updated_fields:
            print(f"User status changed to: {updated_fields['status']}")
            # Notifier les admins

    elif operation == "delete":
        doc_id = change["documentKey"]["_id"]
        print(f"User deleted: {doc_id}")
        # Nettoyer les donn√©es associ√©es

async def example_change_stream():
    client = motor.motor_asyncio.AsyncIOMotorClient(
        "mongodb://localhost:27017/?replicaSet=rs0"
    )

    service = ChangeStreamService(client)

    # √âcouter avec callback personnalis√©
    try:
        await service.watch_collection(
            "users",
            callback=handle_user_change
        )
    except KeyboardInterrupt:
        service.stop_watching()
        print("Stopped watching")

# √âcouter dans une t√¢che en arri√®re-plan
async def background_watcher():
    client = motor.motor_asyncio.AsyncIOMotorClient(
        "mongodb://localhost:27017/?replicaSet=rs0"
    )

    service = ChangeStreamService(client)

    # Cr√©er une t√¢che en arri√®re-plan
    task = asyncio.create_task(
        service.watch_collection("orders")
    )

    # Faire autre chose...
    await asyncio.sleep(60)

    # Arr√™ter l'√©coute
    service.stop_watching()
    await task
```

---

## GridFS pour fichiers volumineux

```python
# services/gridfs_service.py
import motor.motor_asyncio
import motor.motor_asyncio.AsyncIOMotorGridFSBucket
from typing import Optional, Dict, Any, AsyncIterator
from bson import ObjectId
import aiofiles

class GridFSService:
    def __init__(self, db: motor.motor_asyncio.AsyncIOMotorDatabase):
        self.fs = motor.motor_asyncio.AsyncIOMotorGridFSBucket(db)

    async def upload_file(
        self,
        file_data: bytes,
        filename: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Uploader un fichier dans GridFS"""

        file_id = await self.fs.upload_from_stream(
            filename,
            file_data,
            metadata=metadata
        )

        return str(file_id)

    async def upload_from_path(
        self,
        file_path: str,
        filename: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Uploader un fichier depuis le disque"""

        if not filename:
            filename = file_path.split("/")[-1]

        async with aiofiles.open(file_path, 'rb') as f:
            file_data = await f.read()

        return await self.upload_file(file_data, filename, metadata)

    async def download_file(self, file_id: str) -> bytes:
        """T√©l√©charger un fichier par son ID"""

        grid_out = await self.fs.open_download_stream(ObjectId(file_id))
        contents = await grid_out.read()
        return contents

    async def download_to_path(self, file_id: str, destination_path: str):
        """T√©l√©charger un fichier vers le disque"""

        contents = await self.download_file(file_id)

        async with aiofiles.open(destination_path, 'wb') as f:
            await f.write(contents)

    async def download_by_name(self, filename: str) -> bytes:
        """T√©l√©charger par nom de fichier"""

        grid_out = await self.fs.open_download_stream_by_name(filename)
        contents = await grid_out.read()
        return contents

    async def delete_file(self, file_id: str):
        """Supprimer un fichier"""
        await self.fs.delete(ObjectId(file_id))

    async def get_file_info(self, file_id: str) -> Dict[str, Any]:
        """Obtenir les m√©tadonn√©es d'un fichier"""

        grid_out = await self.fs.open_download_stream(ObjectId(file_id))

        return {
            "_id": str(grid_out._id),
            "filename": grid_out.filename,
            "length": grid_out.length,
            "chunk_size": grid_out.chunk_size,
            "upload_date": grid_out.upload_date,
            "metadata": grid_out.metadata
        }

    async def list_files(self, filter: Optional[Dict] = None) -> list:
        """Lister tous les fichiers"""

        cursor = self.fs.find(filter or {})
        files = []

        async for grid_out in cursor:
            files.append({
                "_id": str(grid_out._id),
                "filename": grid_out.filename,
                "length": grid_out.length,
                "upload_date": grid_out.upload_date,
                "metadata": grid_out.metadata
            })

        return files

    async def stream_download(
        self,
        file_id: str,
        chunk_size: int = 1024 * 1024  # 1MB
    ) -> AsyncIterator[bytes]:
        """T√©l√©charger un fichier en streaming"""

        grid_out = await self.fs.open_download_stream(ObjectId(file_id))

        while True:
            chunk = await grid_out.readchunk()
            if not chunk:
                break
            yield chunk

# Utilisation avec FastAPI
from fastapi import FastAPI, UploadFile, File
from fastapi.responses import StreamingResponse

app = FastAPI()

@app.post("/upload")
async def upload_file(file: UploadFile = File(...)):
    """Endpoint pour uploader un fichier"""

    contents = await file.read()

    gridfs = GridFSService(db_manager.db)
    file_id = await gridfs.upload_file(
        contents,
        file.filename,
        metadata={
            "content_type": file.content_type,
            "size": len(contents)
        }
    )

    return {"file_id": file_id, "filename": file.filename}

@app.get("/download/{file_id}")
async def download_file(file_id: str):
    """Endpoint pour t√©l√©charger un fichier"""

    gridfs = GridFSService(db_manager.db)

    # Obtenir les m√©tadonn√©es
    info = await gridfs.get_file_info(file_id)

    # Streaming response
    async def stream_generator():
        async for chunk in gridfs.stream_download(file_id):
            yield chunk

    return StreamingResponse(
        stream_generator(),
        media_type=info.get("metadata", {}).get("content_type", "application/octet-stream"),
        headers={
            "Content-Disposition": f'attachment; filename="{info["filename"]}"'
        }
    )
```

---

## Performance et Optimisation

### Connection pooling et configuration

```python
# Optimiser le pool de connexions
client = motor.motor_asyncio.AsyncIOMotorClient(
    "mongodb://localhost:27017",
    maxPoolSize=50,  # Max connexions dans le pool
    minPoolSize=10,  # Min connexions maintenues
    maxIdleTimeMS=30000,  # Fermer connexions inactives apr√®s 30s
    waitQueueTimeoutMS=10000,  # Timeout d'attente pour une connexion
)

# Monitoring du pool
async def monitor_connection_pool():
    """Monitorer l'utilisation du pool"""
    while True:
        # Obtenir les stats du serveur
        stats = await client.admin.command("serverStatus")
        connections = stats.get("connections", {})

        print(f"Current: {connections.get('current', 0)}")
        print(f"Available: {connections.get('available', 0)}")
        print(f"Total created: {connections.get('totalCreated', 0)}")

        await asyncio.sleep(10)
```

### Batch operations

```python
# services/batch_service.py
import motor.motor_asyncio
from typing import List, Dict, Any

class BatchService:
    def __init__(self, db: motor.motor_asyncio.AsyncIOMotorDatabase):
        self.db = db

    async def bulk_insert(
        self,
        collection_name: str,
        documents: List[Dict[str, Any]],
        ordered: bool = False
    ):
        """Insertion en masse"""

        collection = self.db[collection_name]

        # Insert many est plus rapide qu'une boucle d'insert_one
        result = await collection.insert_many(
            documents,
            ordered=ordered  # False = continue m√™me si erreur
        )

        return {
            "inserted_count": len(result.inserted_ids),
            "inserted_ids": [str(id) for id in result.inserted_ids]
        }

    async def bulk_update(
        self,
        collection_name: str,
        updates: List[Dict[str, Any]]
    ):
        """Mise √† jour en masse avec bulk_write"""

        collection = self.db[collection_name]

        # Pr√©parer les op√©rations
        operations = [
            motor.motor_asyncio.UpdateOne(
                update["filter"],
                update["update"],
                upsert=update.get("upsert", False)
            )
            for update in updates
        ]

        result = await collection.bulk_write(operations, ordered=False)

        return {
            "matched_count": result.matched_count,
            "modified_count": result.modified_count,
            "upserted_count": result.upserted_count
        }

    async def bulk_delete(
        self,
        collection_name: str,
        filters: List[Dict[str, Any]]
    ):
        """Suppression en masse"""

        collection = self.db[collection_name]

        operations = [
            motor.motor_asyncio.DeleteOne(filter)
            for filter in filters
        ]

        result = await collection.bulk_write(operations, ordered=False)

        return {
            "deleted_count": result.deleted_count
        }

# Exemple: Importer 10000 documents
async def import_large_dataset():
    client = motor.motor_asyncio.AsyncIOMotorClient()
    db = client.myapp
    batch_service = BatchService(db)

    # G√©n√©rer des donn√©es
    documents = [
        {
            "name": f"User {i}",
            "email": f"user{i}@example.com",
            "age": 20 + (i % 50)
        }
        for i in range(10000)
    ]

    # Ins√©rer par batch de 1000
    batch_size = 1000
    for i in range(0, len(documents), batch_size):
        batch = documents[i:i + batch_size]
        result = await batch_service.bulk_insert("users", batch)
        print(f"Inserted batch {i//batch_size + 1}: {result['inserted_count']} documents")
```

### Indexes et requ√™tes optimis√©es

```python
# Cr√©er des indexes
async def create_indexes(db):
    """Cr√©er les indexes n√©cessaires"""

    users = db.users

    # Index simple
    await users.create_index("email", unique=True)

    # Index compos√©
    await users.create_index([("status", 1), ("created_at", -1)])

    # Index text
    await users.create_index([("username", "text"), ("bio", "text")])

    # Index g√©ospatial
    await users.create_index([("location", "2dsphere")])

    # Index partiel
    await users.create_index(
        "age",
        partialFilterExpression={"age": {"$gte": 18}}
    )

    # Index TTL (expiration automatique)
    await db.sessions.create_index(
        "created_at",
        expireAfterSeconds=3600  # 1 heure
    )

    print("Indexes created successfully")

# V√©rifier les indexes
async def list_indexes(db):
    """Lister tous les indexes"""

    indexes = await db.users.list_indexes().to_list(length=None)

    for index in indexes:
        print(f"Index: {index['name']}")
        print(f"Keys: {index['key']}")
        if "unique" in index:
            print(f"Unique: {index['unique']}")
        print("---")

# Expliquer une requ√™te
async def explain_query(collection):
    """Analyser la performance d'une requ√™te"""

    query = {"age": {"$gte": 18}, "status": "active"}

    explain_result = await collection.find(query).explain()

    print(f"Execution time: {explain_result['executionStats']['executionTimeMillis']}ms")
    print(f"Documents examined: {explain_result['executionStats']['totalDocsExamined']}")
    print(f"Documents returned: {explain_result['executionStats']['nReturned']}")

    if "indexName" in explain_result['executionStats']['executionStages']:
        print(f"Index used: {explain_result['executionStats']['executionStages']['indexName']}")
    else:
        print("‚ö†Ô∏è No index used (COLLSCAN)")
```

---

## Bonnes Pratiques

### Pattern Repository avec Motor

```python
# repositories/base_repository.py
from typing import TypeVar, Generic, List, Optional, Dict, Any
from pydantic import BaseModel
import motor.motor_asyncio
from bson import ObjectId

T = TypeVar('T', bound=BaseModel)

class BaseRepository(Generic[T]):
    """Repository de base g√©n√©rique"""

    def __init__(
        self,
        db: motor.motor_asyncio.AsyncIOMotorDatabase,
        collection_name: str,
        model_class: type[T]
    ):
        self.collection = db[collection_name]
        self.model_class = model_class

    async def create(self, entity: T) -> str:
        """Cr√©er une entit√©"""
        data = entity.dict(by_alias=True, exclude={"id"})
        result = await self.collection.insert_one(data)
        return str(result.inserted_id)

    async def find_by_id(self, entity_id: str) -> Optional[T]:
        """Trouver par ID"""
        data = await self.collection.find_one({"_id": ObjectId(entity_id)})
        if data:
            data["_id"] = str(data["_id"])
            return self.model_class(**data)
        return None

    async def find_one(self, **filters) -> Optional[T]:
        """Trouver un document"""
        data = await self.collection.find_one(filters)
        if data:
            data["_id"] = str(data["_id"])
            return self.model_class(**data)
        return None

    async def find_many(
        self,
        skip: int = 0,
        limit: int = 100,
        **filters
    ) -> List[T]:
        """Trouver plusieurs documents"""
        cursor = self.collection.find(filters).skip(skip).limit(limit)
        entities = []

        async for data in cursor:
            data["_id"] = str(data["_id"])
            entities.append(self.model_class(**data))

        return entities

    async def update(self, entity_id: str, updates: Dict[str, Any]) -> Optional[T]:
        """Mettre √† jour"""
        result = await self.collection.find_one_and_update(
            {"_id": ObjectId(entity_id)},
            {"$set": updates},
            return_document=True
        )

        if result:
            result["_id"] = str(result["_id"])
            return self.model_class(**result)
        return None

    async def delete(self, entity_id: str) -> bool:
        """Supprimer"""
        result = await self.collection.delete_one({"_id": ObjectId(entity_id)})
        return result.deleted_count > 0

    async def count(self, **filters) -> int:
        """Compter"""
        return await self.collection.count_documents(filters)

    async def exists(self, **filters) -> bool:
        """V√©rifier l'existence"""
        count = await self.collection.count_documents(filters, limit=1)
        return count > 0

# Utilisation
from models.user import User

class UserRepository(BaseRepository[User]):
    def __init__(self, db):
        super().__init__(db, "users", User)

    async def find_by_email(self, email: str) -> Optional[User]:
        return await self.find_one(email=email)

    async def find_active_users(self) -> List[User]:
        return await self.find_many(is_active=True)
```

### Gestion des erreurs

```python
# utils/error_handling.py
from pymongo.errors import (
    DuplicateKeyError,
    ConnectionFailure,
    OperationFailure,
    ServerSelectionTimeoutError
)
from functools import wraps
import logging

logger = logging.getLogger(__name__)

def handle_mongo_errors(func):
    """D√©corateur pour g√©rer les erreurs MongoDB"""

    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)

        except DuplicateKeyError as e:
            logger.error(f"Duplicate key error: {e}")
            raise ValueError("Resource already exists")

        except ConnectionFailure as e:
            logger.error(f"Connection failure: {e}")
            raise RuntimeError("Database connection failed")

        except ServerSelectionTimeoutError as e:
            logger.error(f"Server selection timeout: {e}")
            raise RuntimeError("Database server unavailable")

        except OperationFailure as e:
            logger.error(f"Operation failure: {e}")
            raise RuntimeError(f"Database operation failed: {str(e)}")

        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            raise

    return wrapper

# Utilisation
class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    @handle_mongo_errors
    async def create_user(self, user: User) -> str:
        return await self.repository.create(user)
```

### Testing avec Motor

```python
# tests/test_user_repository.py
import pytest
import motor.motor_asyncio
from mongomock_motor import AsyncMongoMockClient

@pytest.fixture
async def mock_db():
    """Fixture pour base de donn√©es de test"""
    client = AsyncMongoMockClient()
    db = client.test_db
    yield db
    client.close()

@pytest.fixture
def user_repository(mock_db):
    """Fixture pour repository"""
    return UserRepository(mock_db)

@pytest.mark.asyncio
async def test_create_user(user_repository):
    """Test cr√©ation utilisateur"""
    user = User(
        username="testuser",
        email="test@example.com",
        age=25
    )

    user_id = await user_repository.create(user)
    assert user_id is not None

    found_user = await user_repository.find_by_id(user_id)
    assert found_user.username == "testuser"

@pytest.mark.asyncio
async def test_find_by_email(user_repository):
    """Test recherche par email"""
    user = User(
        username="testuser",
        email="test@example.com",
        age=25
    )

    await user_repository.create(user)

    found_user = await user_repository.find_by_email("test@example.com")
    assert found_user is not None
    assert found_user.username == "testuser"

@pytest.mark.asyncio
async def test_update_user(user_repository):
    """Test mise √† jour utilisateur"""
    user = User(
        username="testuser",
        email="test@example.com",
        age=25
    )

    user_id = await user_repository.create(user)

    updated_user = await user_repository.update(
        user_id,
        {"age": 26}
    )

    assert updated_user.age == 26
```

---

## Conclusion

Motor est le choix id√©al pour les applications Python asynchrones n√©cessitant des interactions avec MongoDB. Sa compatibilit√© avec asyncio et son int√©gration native avec les frameworks modernes comme FastAPI en font un outil puissant pour construire des APIs performantes et scalables.

### Points cl√©s √† retenir

1. **Asynchrone natif** : Parfait pour applications haute concurrence
2. **API PyMongo** : M√™me interface que PyMongo, facile √† apprendre
3. **Performance** : Ne bloque pas sur les I/O, meilleure scalabilit√©
4. **Int√©gration** : S'int√®gre parfaitement avec FastAPI, aiohttp, Sanic
5. **Transactions** : Support complet des transactions multi-documents
6. **Change Streams** : √âcoute temps r√©el des modifications
7. **GridFS** : Stockage de fichiers volumineux de mani√®re asynchrone

### Ressources

- [Documentation officielle Motor](https://motor.readthedocs.io/)
- [PyMongo Documentation](https://pymongo.readthedocs.io/)
- [FastAPI + Motor Tutorial](https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/)
- [GitHub Motor](https://github.com/mongodb/motor)

---

**Prochaine section** : 15.12.3 Spring Data MongoDB (Java) - Framework Spring pour MongoDB

‚è≠Ô∏è [Spring Data MongoDB (Java)](/15-drivers-integration-applicative/12.3-spring-data-mongodb.md)
