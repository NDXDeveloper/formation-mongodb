üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.12.1 Mongoose (Node.js)

## Introduction

**Mongoose** est l'ODM (Object-Document Mapper) le plus populaire pour MongoDB dans l'√©cosyst√®me Node.js. Cr√©√© en 2010, il s'est impos√© comme la r√©f√©rence pour g√©rer les interactions avec MongoDB dans les applications JavaScript et TypeScript.

### Pourquoi Mongoose ?

- **Validation robuste** : Sch√©mas avec validation int√©gr√©e
- **Middleware puissant** : Hooks pre/post sur toutes les op√©rations
- **Population** : Gestion des r√©f√©rences entre documents
- **Plugins** : √âcosyst√®me riche et extensible
- **Type safety** : Support TypeScript natif
- **Communaut√©** : 26k+ stars GitHub, documentation exhaustive

### Statistiques

```
üì¶ Package: mongoose
‚≠ê GitHub: 26,000+ stars
üì• Downloads: 3M+/semaine
üìù Version: 8.x (d√©cembre 2023)
üè¢ Utilisateurs: Airbnb, Uber, Netflix, LinkedIn
```

---

## Installation et Configuration

### Installation basique

```bash
# NPM
npm install mongoose

# Yarn
yarn add mongoose

# PNPM
pnpm add mongoose
```

### Installation avec TypeScript

```bash
npm install mongoose
npm install --save-dev @types/node

# TypeScript est nativement support√© depuis Mongoose 5.11
```

### Configuration de base

```javascript
// config/database.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      // Options recommand√©es (certaines sont maintenant par d√©faut)
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`MongoDB Connected: ${conn.connection.host}`);

    // √âv√©nements de connexion
    mongoose.connection.on('connected', () => {
      console.log('Mongoose connected to MongoDB');
    });

    mongoose.connection.on('error', (err) => {
      console.error('Mongoose connection error:', err);
    });

    mongoose.connection.on('disconnected', () => {
      console.log('Mongoose disconnected');
    });

    // Fermeture gracieuse
    process.on('SIGINT', async () => {
      await mongoose.connection.close();
      console.log('Mongoose connection closed through app termination');
      process.exit(0);
    });

  } catch (error) {
    console.error('Error connecting to MongoDB:', error);
    process.exit(1);
  }
};

module.exports = connectDB;
```

### Configuration avanc√©e

```javascript
// config/database.advanced.js
const mongoose = require('mongoose');

const connectDB = async () => {
  const options = {
    // Pool de connexions
    maxPoolSize: 10,
    minPoolSize: 5,

    // Timeouts
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,

    // Retry
    retryWrites: true,
    retryReads: true,

    // Monitoring
    autoIndex: process.env.NODE_ENV !== 'production',

    // Compression
    compressors: ['zlib'],
  };

  await mongoose.connect(process.env.MONGODB_URI, options);

  // Debug mode en d√©veloppement
  if (process.env.NODE_ENV === 'development') {
    mongoose.set('debug', true);
  }

  // D√©sactiver la cr√©ation automatique d'index en production
  if (process.env.NODE_ENV === 'production') {
    mongoose.set('autoIndex', false);
  }
};

module.exports = connectDB;
```

### Configuration avec TypeScript

```typescript
// config/database.ts
import mongoose from 'mongoose';

interface ConnectionOptions {
  maxPoolSize?: number;
  minPoolSize?: number;
  serverSelectionTimeoutMS?: number;
  socketTimeoutMS?: number;
}

class Database {
  private static instance: Database;
  private isConnected: boolean = false;

  private constructor() {}

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  public async connect(uri: string, options?: ConnectionOptions): Promise<void> {
    if (this.isConnected) {
      console.log('Already connected to MongoDB');
      return;
    }

    try {
      const defaultOptions: ConnectionOptions = {
        maxPoolSize: 10,
        minPoolSize: 5,
        serverSelectionTimeoutMS: 5000,
        socketTimeoutMS: 45000,
      };

      await mongoose.connect(uri, { ...defaultOptions, ...options });
      this.isConnected = true;
      console.log('MongoDB connected successfully');

      this.setupEventListeners();
    } catch (error) {
      console.error('MongoDB connection error:', error);
      throw error;
    }
  }

  public async disconnect(): Promise<void> {
    if (!this.isConnected) return;

    await mongoose.connection.close();
    this.isConnected = false;
    console.log('MongoDB disconnected');
  }

  private setupEventListeners(): void {
    mongoose.connection.on('disconnected', () => {
      this.isConnected = false;
      console.log('MongoDB disconnected');
    });

    mongoose.connection.on('error', (error) => {
      console.error('MongoDB error:', error);
    });
  }

  public getConnection(): typeof mongoose {
    return mongoose;
  }
}

export default Database.getInstance();
```

---

## Sch√©mas et Mod√®les

### Sch√©ma basique

```javascript
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [30, 'Username cannot exceed 30 characters'],
    lowercase: true,
    validate: {
      validator: function(v) {
        return /^[a-zA-Z0-9_]+$/.test(v);
      },
      message: 'Username can only contain letters, numbers, and underscores'
    }
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    validate: {
      validator: function(v) {
        return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(v);
      },
      message: 'Please enter a valid email'
    }
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false // Ne pas inclure dans les requ√™tes par d√©faut
  },
  age: {
    type: Number,
    min: [18, 'Must be at least 18 years old'],
    max: [120, 'Invalid age']
  },
  isActive: {
    type: Boolean,
    default: true
  },
  role: {
    type: String,
    enum: {
      values: ['user', 'moderator', 'admin'],
      message: '{VALUE} is not a valid role'
    },
    default: 'user'
  },
  lastLogin: {
    type: Date,
    default: null
  }
}, {
  timestamps: true, // Ajoute createdAt et updatedAt
  collection: 'users' // Nom explicite de la collection
});

const User = mongoose.model('User', userSchema);

module.exports = User;
```

### Sch√©ma avec TypeScript

```typescript
// models/User.ts
import mongoose, { Document, Schema, Model } from 'mongoose';

// Interface pour le document
export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  age?: number;
  isActive: boolean;
  role: 'user' | 'moderator' | 'admin';
  lastLogin?: Date;
  createdAt: Date;
  updatedAt: Date;

  // M√©thodes d'instance
  comparePassword(candidatePassword: string): Promise<boolean>;
  getPublicProfile(): Partial<IUser>;
}

// Interface pour les m√©thodes statiques
interface IUserModel extends Model<IUser> {
  findByEmail(email: string): Promise<IUser | null>;
  findActive(): Promise<IUser[]>;
}

const userSchema = new Schema<IUser, IUserModel>({
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [30, 'Username cannot exceed 30 characters'],
    lowercase: true
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false
  },
  age: {
    type: Number,
    min: [18, 'Must be at least 18 years old'],
    max: [120, 'Invalid age']
  },
  isActive: {
    type: Boolean,
    default: true
  },
  role: {
    type: String,
    enum: ['user', 'moderator', 'admin'],
    default: 'user'
  },
  lastLogin: {
    type: Date,
    default: null
  }
}, {
  timestamps: true
});

// M√©thodes d'instance
userSchema.methods.comparePassword = async function(
  candidatePassword: string
): Promise<boolean> {
  const bcrypt = require('bcryptjs');
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.getPublicProfile = function(): Partial<IUser> {
  return {
    username: this.username,
    email: this.email,
    role: this.role,
    createdAt: this.createdAt
  };
};

// M√©thodes statiques
userSchema.statics.findByEmail = function(email: string) {
  return this.findOne({ email: email.toLowerCase() });
};

userSchema.statics.findActive = function() {
  return this.find({ isActive: true });
};

const User = mongoose.model<IUser, IUserModel>('User', userSchema);

export default User;
```

### Sch√©ma avec documents imbriqu√©s

```javascript
// models/Post.js
const mongoose = require('mongoose');

// Sous-sch√©ma pour les commentaires
const commentSchema = new mongoose.Schema({
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  text: {
    type: String,
    required: [true, 'Comment text is required'],
    maxlength: [500, 'Comment cannot exceed 500 characters']
  },
  likes: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
}, {
  _id: true // Chaque commentaire a son propre _id
});

// Sous-sch√©ma pour les m√©tadonn√©es
const metadataSchema = new mongoose.Schema({
  views: { type: Number, default: 0 },
  shares: { type: Number, default: 0 },
  readTime: { type: Number }, // en minutes
  featured: { type: Boolean, default: false }
}, {
  _id: false // Pas d'_id pour les m√©tadonn√©es
});

const postSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Title is required'],
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },
  slug: {
    type: String,
    unique: true,
    lowercase: true
  },
  content: {
    type: String,
    required: [true, 'Content is required']
  },
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  status: {
    type: String,
    enum: ['draft', 'published', 'archived'],
    default: 'draft'
  },
  tags: [{
    type: String,
    lowercase: true,
    trim: true
  }],
  categories: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category'
  }],
  comments: [commentSchema], // Documents imbriqu√©s
  metadata: metadataSchema, // Document imbriqu√©
  publishedAt: Date
}, {
  timestamps: true
});

// Index compos√©
postSchema.index({ slug: 1 });
postSchema.index({ author: 1, status: 1 });
postSchema.index({ tags: 1 });
postSchema.index({ publishedAt: -1 });

// Index text pour la recherche
postSchema.index({ title: 'text', content: 'text' });

const Post = mongoose.model('Post', postSchema);

module.exports = Post;
```

---

## Types de Donn√©es et Validation

### Types de donn√©es Mongoose

```javascript
// models/Examples.js
const mongoose = require('mongoose');

const exampleSchema = new mongoose.Schema({
  // Types de base
  stringField: String,
  numberField: Number,
  dateField: Date,
  booleanField: Boolean,
  bufferField: Buffer,

  // ObjectId
  userId: mongoose.Schema.Types.ObjectId,

  // Mixed (n'importe quel type)
  mixedField: mongoose.Schema.Types.Mixed,

  // Tableaux
  simpleArray: [String],
  objectArray: [{
    name: String,
    value: Number
  }],

  // Map
  mapField: {
    type: Map,
    of: String
  },

  // Decimal128 (pour les calculs financiers)
  price: mongoose.Schema.Types.Decimal128,

  // G√©ospatial
  location: {
    type: {
      type: String,
      enum: ['Point'],
      required: true
    },
    coordinates: {
      type: [Number],
      required: true
    }
  },

  // UUID
  uuid: {
    type: String,
    validate: {
      validator: function(v) {
        return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v);
      },
      message: 'Invalid UUID format'
    }
  }
});

// Index g√©ospatial
exampleSchema.index({ location: '2dsphere' });

module.exports = mongoose.model('Example', exampleSchema);
```

### Validation avanc√©e

```javascript
// models/Product.js
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  sku: {
    type: String,
    required: true,
    unique: true,
    uppercase: true,
    validate: {
      validator: function(v) {
        return /^[A-Z]{3}-\d{6}$/.test(v);
      },
      message: 'SKU must be in format ABC-123456'
    }
  },
  price: {
    type: Number,
    required: true,
    min: [0, 'Price cannot be negative'],
    validate: {
      validator: function(v) {
        return Number.isFinite(v) && v >= 0;
      },
      message: 'Price must be a valid positive number'
    }
  },
  discount: {
    type: Number,
    min: 0,
    max: 100,
    default: 0,
    validate: {
      validator: function(v) {
        // Validation asynchrone
        return v <= 100;
      },
      message: 'Discount cannot exceed 100%'
    }
  },
  finalPrice: {
    type: Number,
    // Validation qui d√©pend d'autres champs
    validate: {
      validator: function(v) {
        const expectedPrice = this.price * (1 - this.discount / 100);
        return Math.abs(v - expectedPrice) < 0.01;
      },
      message: 'Final price does not match calculation'
    }
  },
  stock: {
    type: Number,
    required: true,
    min: 0,
    validate: {
      validator: Number.isInteger,
      message: 'Stock must be an integer'
    }
  },
  email: {
    type: String,
    required: true,
    validate: {
      // Validation asynchrone avec callback
      validator: async function(email) {
        const user = await mongoose.model('User').findOne({ email });
        return !!user;
      },
      message: 'Email must belong to an existing user'
    }
  },
  dimensions: {
    length: {
      type: Number,
      required: true,
      min: 0
    },
    width: {
      type: Number,
      required: true,
      min: 0
    },
    height: {
      type: Number,
      required: true,
      min: 0
    },
    validate: {
      // Validation au niveau du sous-document
      validator: function(dimensions) {
        const volume = dimensions.length * dimensions.width * dimensions.height;
        return volume > 0 && volume < 1000000; // Max 1m¬≥
      },
      message: 'Product dimensions result in invalid volume'
    }
  }
});

// Validation personnalis√©e au niveau du sch√©ma
productSchema.pre('validate', function(next) {
  // Calculer automatiquement le prix final si non fourni
  if (!this.finalPrice) {
    this.finalPrice = this.price * (1 - this.discount / 100);
  }
  next();
});

module.exports = mongoose.model('Product', productSchema);
```

### Validateurs personnalis√©s r√©utilisables

```javascript
// utils/validators.js
const validator = require('validator');

// Validateur d'email robuste
const emailValidator = {
  validator: (v) => validator.isEmail(v),
  message: 'Invalid email address'
};

// Validateur d'URL
const urlValidator = {
  validator: (v) => validator.isURL(v, { protocols: ['http', 'https'] }),
  message: 'Invalid URL'
};

// Validateur de num√©ro de t√©l√©phone
const phoneValidator = {
  validator: (v) => /^(\+\d{1,3}[- ]?)?\d{10}$/.test(v),
  message: 'Invalid phone number'
};

// Validateur de carte de cr√©dit
const creditCardValidator = {
  validator: (v) => validator.isCreditCard(v),
  message: 'Invalid credit card number'
};

// Validateur de code postal (US)
const zipCodeValidator = {
  validator: (v) => /^\d{5}(-\d{4})?$/.test(v),
  message: 'Invalid US zip code'
};

// Validateur de longueur de mot de passe
const strongPasswordValidator = {
  validator: (v) => {
    return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(v);
  },
  message: 'Password must contain at least 8 characters, one uppercase, one lowercase, one number and one special character'
};

// Validateur de date future
const futureDateValidator = {
  validator: (v) => v > new Date(),
  message: 'Date must be in the future'
};

module.exports = {
  emailValidator,
  urlValidator,
  phoneValidator,
  creditCardValidator,
  zipCodeValidator,
  strongPasswordValidator,
  futureDateValidator
};

// Utilisation dans un mod√®le
const { emailValidator, phoneValidator } = require('../utils/validators');

const customerSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    validate: emailValidator
  },
  phone: {
    type: String,
    validate: phoneValidator
  }
});
```

---

## Middleware et Hooks

### Types de middleware

Mongoose offre 4 types de middleware :
1. **Document middleware** : `save`, `validate`, `remove`, `updateOne`, `deleteOne`
2. **Query middleware** : `find`, `findOne`, `findOneAndUpdate`, etc.
3. **Aggregate middleware** : `aggregate`
4. **Model middleware** : `insertMany`

### Pre/Post hooks

```javascript
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  password: String,
  lastLogin: Date,
  loginCount: { type: Number, default: 0 }
}, {
  timestamps: true
});

// ===== DOCUMENT MIDDLEWARE =====

// Pre save - Hash password avant sauvegarde
userSchema.pre('save', async function(next) {
  // 'this' pointe vers le document
  console.log('Pre save hook for user:', this.username);

  // Hasher le password seulement s'il a √©t√© modifi√©
  if (!this.isModified('password')) {
    return next();
  }

  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Post save
userSchema.post('save', function(doc, next) {
  console.log('User saved:', doc.username);
  // On pourrait envoyer un email de bienvenue ici
  next();
});

// Pre validate
userSchema.pre('validate', function(next) {
  console.log('Validating user:', this.username);

  // Normaliser l'email
  if (this.email) {
    this.email = this.email.toLowerCase().trim();
  }

  next();
});

// Pre remove (Document middleware)
userSchema.pre('remove', async function(next) {
  console.log('Removing user:', this.username);

  // Supprimer toutes les publications de l'utilisateur
  await mongoose.model('Post').deleteMany({ author: this._id });

  // Supprimer tous les commentaires
  await mongoose.model('Comment').deleteMany({ author: this._id });

  next();
});

// ===== QUERY MIDDLEWARE =====

// Pre find - Exclure les utilisateurs inactifs par d√©faut
userSchema.pre(/^find/, function(next) {
  // 'this' pointe vers la query
  this.find({ isActive: { $ne: false } });
  next();
});

// Post find - Logger les r√©sultats
userSchema.post(/^find/, function(docs, next) {
  console.log(`Found ${docs.length} users`);
  next();
});

// Pre findOneAndUpdate
userSchema.pre('findOneAndUpdate', function(next) {
  // Mettre √† jour automatiquement updatedAt
  this.set({ updatedAt: new Date() });
  next();
});

// ===== AGGREGATE MIDDLEWARE =====

userSchema.pre('aggregate', function(next) {
  // Ajouter un stage au d√©but du pipeline
  this.pipeline().unshift({ $match: { isActive: true } });
  next();
});

// ===== ERROR HANDLING =====

// Gestion des erreurs de duplication
userSchema.post('save', function(error, doc, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    next(new Error('Email already exists'));
  } else {
    next(error);
  }
});

module.exports = mongoose.model('User', userSchema);
```

### Middleware asynchrone avanc√©

```javascript
// models/Order.js
const mongoose = require('mongoose');

const orderSchema = new mongoose.Schema({
  orderNumber: String,
  userId: mongoose.Schema.Types.ObjectId,
  items: [{
    productId: mongoose.Schema.Types.ObjectId,
    quantity: Number,
    price: Number
  }],
  totalAmount: Number,
  status: {
    type: String,
    enum: ['pending', 'paid', 'shipped', 'delivered', 'cancelled'],
    default: 'pending'
  },
  paidAt: Date,
  shippedAt: Date
}, {
  timestamps: true
});

// Pre save - G√©n√©rer num√©ro de commande et calculer total
orderSchema.pre('save', async function(next) {
  try {
    // G√©n√©rer num√©ro de commande si nouveau document
    if (this.isNew) {
      const count = await mongoose.model('Order').countDocuments();
      this.orderNumber = `ORD-${Date.now()}-${count + 1}`;
    }

    // Calculer le total si items ont chang√©
    if (this.isModified('items')) {
      this.totalAmount = this.items.reduce((sum, item) => {
        return sum + (item.quantity * item.price);
      }, 0);
    }

    next();
  } catch (error) {
    next(error);
  }
});

// Pre findOneAndUpdate - G√©rer les changements de statut
orderSchema.pre('findOneAndUpdate', async function(next) {
  const update = this.getUpdate();

  // Si le statut passe √† 'paid', enregistrer la date
  if (update.$set && update.$set.status === 'paid') {
    update.$set.paidAt = new Date();

    // Mettre √† jour le stock des produits
    const order = await this.model.findOne(this.getQuery());
    for (const item of order.items) {
      await mongoose.model('Product').findByIdAndUpdate(
        item.productId,
        { $inc: { stock: -item.quantity } }
      );
    }
  }

  // Si le statut passe √† 'shipped', enregistrer la date
  if (update.$set && update.$set.status === 'shipped') {
    update.$set.shippedAt = new Date();

    // Envoyer email de tracking (async, ne bloque pas)
    // await sendTrackingEmail(order);
  }

  next();
});

// Post save - Actions apr√®s sauvegarde r√©ussie
orderSchema.post('save', async function(doc) {
  // Envoyer notification de confirmation
  console.log('Order saved:', doc.orderNumber);

  // Cr√©er une entr√©e dans l'historique
  await mongoose.model('OrderHistory').create({
    orderId: doc._id,
    action: 'created',
    timestamp: new Date()
  });

  // Invalider le cache
  // await cache.del(`order:${doc._id}`);
});

module.exports = mongoose.model('Order', orderSchema);
```

### Middleware pour audit trail

```javascript
// plugins/auditPlugin.js
function auditPlugin(schema, options) {
  // Ajouter des champs d'audit
  schema.add({
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    history: [{
      action: {
        type: String,
        enum: ['create', 'update', 'delete']
      },
      user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      timestamp: {
        type: Date,
        default: Date.now
      },
      changes: mongoose.Schema.Types.Mixed
    }]
  });

  // Pre save
  schema.pre('save', function(next) {
    const user = this.$locals.user; // Context inject√©

    if (this.isNew) {
      this.createdBy = user?._id;
      this.history.push({
        action: 'create',
        user: user?._id,
        changes: this.toObject()
      });
    } else {
      this.updatedBy = user?._id;

      // Capturer les changements
      const changes = {};
      this.modifiedPaths().forEach(path => {
        changes[path] = {
          old: this._doc[path],
          new: this[path]
        };
      });

      this.history.push({
        action: 'update',
        user: user?._id,
        changes
      });
    }

    next();
  });

  // Pre findOneAndUpdate
  schema.pre('findOneAndUpdate', async function(next) {
    const update = this.getUpdate();
    const user = this.options.context?.user;

    if (user) {
      update.$set = update.$set || {};
      update.$set.updatedBy = user._id;

      update.$push = update.$push || {};
      update.$push.history = {
        action: 'update',
        user: user._id,
        changes: update.$set
      };
    }

    next();
  });
}

module.exports = auditPlugin;

// Utilisation
const auditPlugin = require('./plugins/auditPlugin');

const documentSchema = new mongoose.Schema({
  title: String,
  content: String
});

documentSchema.plugin(auditPlugin);

// Lors de la sauvegarde, injecter le contexte
const doc = new Document({ title: 'Test' });
doc.$locals.user = req.user; // Contexte de l'utilisateur
await doc.save();
```

---

## Requ√™tes et Population

### Requ√™tes basiques

```javascript
// Exemples de requ√™tes Mongoose
const User = require('./models/User');

// Find all
const users = await User.find();

// Find avec conditions
const activeUsers = await User.find({ isActive: true });

// Find one
const user = await User.findOne({ email: 'user@example.com' });

// Find by ID
const userById = await User.findById(userId);

// Find avec op√©rateurs
const adultUsers = await User.find({
  age: { $gte: 18 },
  role: { $in: ['admin', 'moderator'] }
});

// Select (projection)
const users = await User.find()
  .select('username email') // Inclure ces champs
  .select('-password'); // Exclure password

// Sort
const sortedUsers = await User.find()
  .sort({ createdAt: -1 }); // -1 = DESC, 1 = ASC

// Limit et skip (pagination)
const page = 2;
const limit = 10;
const users = await User.find()
  .skip((page - 1) * limit)
  .limit(limit);

// Count
const count = await User.countDocuments({ isActive: true });

// Exists
const exists = await User.exists({ email: 'test@example.com' });
```

### Requ√™tes avanc√©es

```javascript
// Query builder pattern
const query = User.find();

// Cha√Ænage de conditions
query
  .where('age').gte(18).lte(65)
  .where('role').in(['user', 'admin'])
  .where('email').exists()
  .select('username email age')
  .sort({ createdAt: -1 })
  .limit(10);

const users = await query.exec();

// Or conditions
const users = await User.find({
  $or: [
    { role: 'admin' },
    { age: { $gte: 65 } }
  ]
});

// Regex
const users = await User.find({
  username: { $regex: /^john/i } // Case insensitive, commence par 'john'
});

// √âquivalent avec .regex()
const users = await User.find()
  .where('username').regex(/^john/i);

// Text search
const posts = await Post.find({
  $text: { $search: 'mongodb tutorial' }
});

// Distinct
const roles = await User.distinct('role');

// Find or create
let user = await User.findOne({ email: 'new@example.com' });
if (!user) {
  user = await User.create({ email: 'new@example.com', username: 'newuser' });
}

// findOneAndUpdate avec options
const updated = await User.findOneAndUpdate(
  { _id: userId },
  { $set: { lastLogin: new Date() } },
  {
    new: true, // Retourner le document mis √† jour
    runValidators: true, // Ex√©cuter les validateurs
    upsert: false // Ne pas cr√©er si n'existe pas
  }
);

// Bulk operations
const result = await User.bulkWrite([
  {
    updateOne: {
      filter: { _id: userId1 },
      update: { $set: { isActive: false } }
    }
  },
  {
    deleteOne: {
      filter: { _id: userId2 }
    }
  },
  {
    insertOne: {
      document: { username: 'newuser', email: 'new@example.com' }
    }
  }
]);
```

### Population (r√©f√©rences)

```javascript
// models/Post.js
const postSchema = new mongoose.Schema({
  title: String,
  content: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User' // R√©f√©rence au mod√®le User
  },
  comments: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Comment'
  }]
});

// Population simple
const post = await Post.findById(postId)
  .populate('author'); // Remplace l'ID par le document complet

console.log(post.author.username); // Acc√®s direct

// Population avec s√©lection de champs
const post = await Post.findById(postId)
  .populate('author', 'username email'); // Seulement username et email

// Population multiple
const post = await Post.findById(postId)
  .populate('author')
  .populate('comments');

// Population avec conditions
const posts = await Post.find()
  .populate({
    path: 'author',
    match: { isActive: true }, // Seulement les auteurs actifs
    select: 'username email',
    options: { sort: { username: 1 } }
  });

// Population en cascade
const post = await Post.findById(postId)
  .populate({
    path: 'comments',
    populate: {
      path: 'author', // Peupler l'auteur de chaque commentaire
      select: 'username'
    }
  });

// Population conditionnelle
const post = await Post.findById(postId)
  .populate({
    path: 'comments',
    match: { likes: { $gte: 10 } }, // Seulement les commentaires avec 10+ likes
    options: {
      sort: { likes: -1 },
      limit: 5
    }
  });

// Populate avec virtuals (voir section Virtuals)
postSchema.virtual('commentCount', {
  ref: 'Comment',
  localField: '_id',
  foreignField: 'postId',
  count: true
});

const post = await Post.findById(postId)
  .populate('commentCount');

console.log(post.commentCount); // Nombre de commentaires
```

### Requ√™tes avec lean()

```javascript
// Sans lean() - Documents Mongoose complets
const users = await User.find();
// Retourne des instances Mongoose avec m√©thodes, getters, virtuals

// Avec lean() - Objets JavaScript simples
const users = await User.find().lean();
// Retourne des POJOs (Plain Old JavaScript Objects)

// Performance
console.time('without lean');
const docs1 = await User.find().limit(1000);
console.timeEnd('without lean'); // ~100ms

console.time('with lean');
const docs2 = await User.find().limit(1000).lean();
console.timeEnd('with lean'); // ~20ms

// Cas d'usage de lean()
// ‚úÖ APIs read-only
app.get('/api/users', async (req, res) => {
  const users = await User.find().select('username email').lean();
  res.json(users);
});

// ‚úÖ Agr√©gations
const stats = await User.find().lean().then(users => {
  return {
    total: users.length,
    active: users.filter(u => u.isActive).length
  };
});

// ‚ùå Quand on a besoin de sauvegarder
const user = await User.findById(userId).lean();
user.lastLogin = new Date();
// await user.save(); // ERREUR : user.save is not a function

// ‚ùå Quand on a besoin de virtuals/methods
const user = await User.findById(userId).lean();
// user.fullName // undefined (virtual non disponible)
```

---

## Virtuals et M√©thodes

### Virtual properties

```javascript
// models/User.js
const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  email: String,
  dateOfBirth: Date
});

// Virtual getter
userSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});

// Virtual setter
userSchema.virtual('fullName').set(function(name) {
  const parts = name.split(' ');
  this.firstName = parts[0];
  this.lastName = parts[parts.length - 1];
});

// Virtual calcul√©
userSchema.virtual('age').get(function() {
  if (!this.dateOfBirth) return null;
  const diff = Date.now() - this.dateOfBirth.getTime();
  return Math.floor(diff / (1000 * 60 * 60 * 24 * 365.25));
});

// Inclure les virtuals dans JSON/Object
userSchema.set('toJSON', { virtuals: true });
userSchema.set('toObject', { virtuals: true });

// Utilisation
const user = new User({
  firstName: 'John',
  lastName: 'Doe',
  dateOfBirth: new Date('1990-01-01')
});

console.log(user.fullName); // "John Doe"
user.fullName = 'Jane Smith';
console.log(user.firstName); // "Jane"
console.log(user.age); // 33 (calcul√©)

// Virtual populate (relations invers√©es)
const postSchema = new mongoose.Schema({
  title: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
});

userSchema.virtual('posts', {
  ref: 'Post', // Mod√®le r√©f√©renc√©
  localField: '_id', // Champ local
  foreignField: 'author' // Champ dans Post
});

// Utilisation
const user = await User.findById(userId)
  .populate('posts'); // R√©cup√®re tous les posts de l'utilisateur

console.log(user.posts.length);
```

### M√©thodes d'instance

```javascript
// models/User.js
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  password: String,
  role: String,
  failedLoginAttempts: { type: Number, default: 0 },
  lockedUntil: Date
});

// M√©thode d'instance - disponible sur chaque document
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

userSchema.methods.canLogin = function() {
  if (this.lockedUntil && this.lockedUntil > Date.now()) {
    return false;
  }
  return true;
};

userSchema.methods.lockAccount = function() {
  this.lockedUntil = Date.now() + (60 * 60 * 1000); // Lock pour 1h
  this.failedLoginAttempts = 0;
  return this.save();
};

userSchema.methods.incrementFailedAttempts = function() {
  this.failedLoginAttempts += 1;

  if (this.failedLoginAttempts >= 5) {
    return this.lockAccount();
  }

  return this.save();
};

userSchema.methods.resetFailedAttempts = function() {
  this.failedLoginAttempts = 0;
  this.lockedUntil = undefined;
  return this.save();
};

userSchema.methods.hasRole = function(role) {
  return this.role === role;
};

userSchema.methods.isAdmin = function() {
  return this.role === 'admin';
};

// M√©thode pour obtenir un profil public (sans donn√©es sensibles)
userSchema.methods.toPublicJSON = function() {
  return {
    id: this._id,
    username: this.username,
    email: this.email,
    role: this.role,
    createdAt: this.createdAt
  };
};

// Utilisation
const User = mongoose.model('User', userSchema);

const user = await User.findOne({ email: 'user@example.com' });

// Utiliser les m√©thodes d'instance
const isValid = await user.comparePassword('password123');

if (!user.canLogin()) {
  throw new Error('Account is locked');
}

if (isValid) {
  await user.resetFailedAttempts();
} else {
  await user.incrementFailedAttempts();
}

if (user.isAdmin()) {
  // Acc√®s administrateur
}

const publicProfile = user.toPublicJSON();
```

### M√©thodes statiques

```javascript
// models/User.js
const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  password: String,
  isActive: Boolean,
  lastLogin: Date
});

// M√©thodes statiques - disponibles sur le mod√®le
userSchema.statics.findByEmail = function(email) {
  return this.findOne({ email: email.toLowerCase() });
};

userSchema.statics.findActive = function() {
  return this.find({ isActive: true });
};

userSchema.statics.findInactive = function() {
  return this.find({ isActive: false });
};

userSchema.statics.findByRole = function(role) {
  return this.find({ role });
};

userSchema.statics.countByRole = async function(role) {
  return this.countDocuments({ role });
};

// M√©thode statique plus complexe
userSchema.statics.createUser = async function(userData) {
  const bcrypt = require('bcryptjs');

  // Hasher le password
  const salt = await bcrypt.genSalt(10);
  userData.password = await bcrypt.hash(userData.password, salt);

  // Normaliser l'email
  userData.email = userData.email.toLowerCase();

  // Cr√©er l'utilisateur
  return this.create(userData);
};

// M√©thode avec logique m√©tier
userSchema.statics.authenticate = async function(email, password) {
  const user = await this.findByEmail(email);

  if (!user) {
    throw new Error('User not found');
  }

  if (!user.canLogin()) {
    throw new Error('Account is locked');
  }

  const isValid = await user.comparePassword(password);

  if (!isValid) {
    await user.incrementFailedAttempts();
    throw new Error('Invalid password');
  }

  // Mise √† jour du dernier login
  user.lastLogin = new Date();
  await user.resetFailedAttempts();

  return user;
};

// M√©thode pour les statistiques
userSchema.statics.getUserStats = async function() {
  const total = await this.countDocuments();
  const active = await this.countDocuments({ isActive: true });
  const admins = await this.countDocuments({ role: 'admin' });

  const recentLogins = await this.countDocuments({
    lastLogin: {
      $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
    }
  });

  return {
    total,
    active,
    inactive: total - active,
    admins,
    recentLogins
  };
};

// Utilisation
const User = mongoose.model('User', userSchema);

// M√©thodes statiques appel√©es sur le mod√®le
const user = await User.findByEmail('user@example.com');
const activeUsers = await User.findActive();
const adminCount = await User.countByRole('admin');

const newUser = await User.createUser({
  username: 'johndoe',
  email: 'john@example.com',
  password: 'password123'
});

const authenticatedUser = await User.authenticate('john@example.com', 'password123');

const stats = await User.getUserStats();
console.log(stats);
// { total: 1000, active: 950, inactive: 50, admins: 10, recentLogins: 300 }
```

### Query helpers

```javascript
// models/Post.js
const postSchema = new mongoose.Schema({
  title: String,
  status: String,
  publishedAt: Date,
  author: mongoose.Schema.Types.ObjectId
});

// Query helpers - √©tendent Query.prototype
postSchema.query.byAuthor = function(authorId) {
  return this.where({ author: authorId });
};

postSchema.query.published = function() {
  return this.where({ status: 'published' });
};

postSchema.query.recent = function(days = 7) {
  const date = new Date();
  date.setDate(date.getDate() - days);
  return this.where({ publishedAt: { $gte: date } });
};

postSchema.query.popular = function(minViews = 100) {
  return this.where({ views: { $gte: minViews } });
};

// Utilisation - cha√Ænage de query helpers
const posts = await Post.find()
  .published()
  .recent(30)
  .popular(500)
  .sort({ views: -1 })
  .limit(10);

const authorPosts = await Post.find()
  .byAuthor(authorId)
  .published()
  .recent();
```

---

## Plugins

### Utilisation de plugins existants

```javascript
// Plugins populaires

// 1. mongoose-paginate-v2
const mongoosePaginate = require('mongoose-paginate-v2');

const userSchema = new mongoose.Schema({
  username: String,
  email: String
});

userSchema.plugin(mongoosePaginate);

const User = mongoose.model('User', userSchema);

// Utilisation
const options = {
  page: 1,
  limit: 10,
  sort: { createdAt: -1 },
  select: 'username email'
};

const result = await User.paginate({}, options);
console.log(result.docs); // Documents
console.log(result.totalDocs); // Total
console.log(result.totalPages); // Pages
console.log(result.page); // Page actuelle

// 2. mongoose-unique-validator
const uniqueValidator = require('mongoose-unique-validator');

const emailSchema = new mongoose.Schema({
  email: { type: String, unique: true, required: true }
});

emailSchema.plugin(uniqueValidator, {
  message: 'Email {VALUE} is already taken'
});

// 3. mongoose-autopopulate
const autopopulate = require('mongoose-autopopulate');

const postSchema = new mongoose.Schema({
  title: String,
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    autopopulate: true // Populate automatiquement
  }
});

postSchema.plugin(autopopulate);

// 4. mongoose-timestamp
const timestamps = require('mongoose-timestamp');

const docSchema = new mongoose.Schema({
  title: String
});

docSchema.plugin(timestamps); // Ajoute createdAt et updatedAt

// 5. mongoose-delete (soft delete)
const mongooseDelete = require('mongoose-delete');

const itemSchema = new mongoose.Schema({
  name: String
});

itemSchema.plugin(mongooseDelete, {
  deletedAt: true,
  overrideMethods: 'all'
});

const Item = mongoose.model('Item', itemSchema);

// Soft delete
await item.delete(); // Marque comme supprim√©
await Item.deleteById(id);

// Restaurer
await item.restore();

// Trouver les √©l√©ments non supprim√©s (par d√©faut)
const items = await Item.find();

// Inclure les supprim√©s
const allItems = await Item.findWithDeleted();

// Seulement les supprim√©s
const deletedItems = await Item.findDeleted();
```

### Cr√©er un plugin personnalis√©

```javascript
// plugins/timestampPlugin.js

/**
 * Plugin pour ajouter des timestamps personnalis√©s
 */
function timestampPlugin(schema, options) {
  // Options par d√©faut
  const opts = {
    createdField: 'createdAt',
    updatedField: 'updatedAt',
    deletedField: 'deletedAt',
    ...options
  };

  // Ajouter les champs au sch√©ma
  const timestampFields = {};

  timestampFields[opts.createdField] = {
    type: Date,
    default: Date.now,
    immutable: true // Ne peut pas √™tre modifi√©
  };

  timestampFields[opts.updatedField] = {
    type: Date,
    default: Date.now
  };

  if (opts.softDelete) {
    timestampFields[opts.deletedField] = {
      type: Date,
      default: null
    };
  }

  schema.add(timestampFields);

  // Middleware pour mise √† jour automatique
  schema.pre('save', function(next) {
    this[opts.updatedField] = new Date();
    next();
  });

  schema.pre('findOneAndUpdate', function(next) {
    this.set({ [opts.updatedField]: new Date() });
    next();
  });

  schema.pre('updateMany', function(next) {
    this.set({ [opts.updatedField]: new Date() });
    next();
  });

  // Soft delete si activ√©
  if (opts.softDelete) {
    // Ajouter m√©thode delete
    schema.methods.delete = function() {
      this[opts.deletedField] = new Date();
      return this.save();
    };

    // Ajouter m√©thode restore
    schema.methods.restore = function() {
      this[opts.deletedField] = null;
      return this.save();
    };

    // Ajouter m√©thode statique pour delete
    schema.statics.deleteById = function(id) {
      return this.findByIdAndUpdate(id, {
        [opts.deletedField]: new Date()
      });
    };

    // Query helper
    schema.query.notDeleted = function() {
      return this.where({ [opts.deletedField]: null });
    };

    schema.query.deleted = function() {
      return this.where({ [opts.deletedField]: { $ne: null } });
    };
  }
}

module.exports = timestampPlugin;

// Utilisation
const timestampPlugin = require('./plugins/timestampPlugin');

const userSchema = new mongoose.Schema({
  username: String,
  email: String
});

userSchema.plugin(timestampPlugin, {
  softDelete: true,
  deletedField: 'removedAt'
});

const User = mongoose.model('User', userSchema);

// Utilisation
const user = new User({ username: 'john', email: 'john@example.com' });
await user.save();

console.log(user.createdAt); // Date de cr√©ation
console.log(user.updatedAt); // Date de mise √† jour

// Soft delete
await user.delete();
console.log(user.removedAt); // Date de suppression

// Restaurer
await user.restore();

// Query helpers
const activeUsers = await User.find().notDeleted();
const deletedUsers = await User.find().deleted();
```

### Plugin pour versionning

```javascript
// plugins/versioningPlugin.js

/**
 * Plugin pour g√©rer les versions de documents
 */
function versioningPlugin(schema, options) {
  const opts = {
    collection: 'versions',
    mongoose: null, // Instance de mongoose
    ...options
  };

  if (!opts.mongoose) {
    throw new Error('Mongoose instance is required');
  }

  // Cr√©er le sch√©ma de version
  const versionSchema = new opts.mongoose.Schema({
    documentId: opts.mongoose.Schema.Types.ObjectId,
    model: String,
    version: Number,
    data: opts.mongoose.Schema.Types.Mixed,
    createdAt: { type: Date, default: Date.now },
    createdBy: opts.mongoose.Schema.Types.ObjectId
  });

  const Version = opts.mongoose.model('Version', versionSchema);

  // Ajouter un champ version au sch√©ma principal
  schema.add({
    __v: { type: Number, default: 0 }
  });

  // Sauvegarder une version avant chaque update
  schema.pre('save', async function(next) {
    if (!this.isNew && this.isModified()) {
      try {
        await Version.create({
          documentId: this._id,
          model: this.constructor.modelName,
          version: this.__v,
          data: this.toObject()
        });

        this.__v += 1;
      } catch (error) {
        return next(error);
      }
    }
    next();
  });

  // M√©thodes pour g√©rer les versions
  schema.methods.getVersions = function() {
    return Version.find({
      documentId: this._id,
      model: this.constructor.modelName
    }).sort({ version: -1 });
  };

  schema.methods.getVersion = function(version) {
    return Version.findOne({
      documentId: this._id,
      model: this.constructor.modelName,
      version
    });
  };

  schema.methods.restoreVersion = async function(version) {
    const versionDoc = await this.getVersion(version);

    if (!versionDoc) {
      throw new Error(`Version ${version} not found`);
    }

    // Restaurer les donn√©es
    Object.assign(this, versionDoc.data);
    return this.save();
  };
}

module.exports = versioningPlugin;

// Utilisation
const versioningPlugin = require('./plugins/versioningPlugin');

const documentSchema = new mongoose.Schema({
  title: String,
  content: String
});

documentSchema.plugin(versioningPlugin, { mongoose });

const Document = mongoose.model('Document', documentSchema);

// Utilisation
const doc = new Document({ title: 'Title', content: 'Content' });
await doc.save();

// Modifier
doc.content = 'New content';
await doc.save(); // Sauvegarde automatique de la version pr√©c√©dente

doc.title = 'New title';
await doc.save();

// R√©cup√©rer toutes les versions
const versions = await doc.getVersions();
console.log(versions.length); // 2 versions pr√©c√©dentes

// Restaurer une version
await doc.restoreVersion(1);
```

---

## Transactions

### Transaction simple

```javascript
const mongoose = require('mongoose');

async function transferMoney(fromAccountId, toAccountId, amount) {
  // D√©marrer une session
  const session = await mongoose.startSession();

  try {
    // D√©marrer la transaction
    session.startTransaction();

    // D√©biter le compte source
    const fromAccount = await Account.findById(fromAccountId).session(session);
    if (fromAccount.balance < amount) {
      throw new Error('Insufficient balance');
    }
    fromAccount.balance -= amount;
    await fromAccount.save({ session });

    // Cr√©diter le compte destination
    const toAccount = await Account.findById(toAccountId).session(session);
    toAccount.balance += amount;
    await toAccount.save({ session });

    // Cr√©er un enregistrement de transaction
    await Transaction.create([{
      from: fromAccountId,
      to: toAccountId,
      amount,
      timestamp: new Date()
    }], { session });

    // Commit la transaction
    await session.commitTransaction();
    console.log('Transfer successful');

  } catch (error) {
    // Annuler la transaction en cas d'erreur
    await session.abortTransaction();
    console.error('Transfer failed:', error);
    throw error;

  } finally {
    // Toujours terminer la session
    session.endSession();
  }
}

// Utilisation
await transferMoney(accountId1, accountId2, 100);
```

### Transaction avec retry logic

```javascript
async function withRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    const session = await mongoose.startSession();

    try {
      session.startTransaction();

      const result = await fn(session);

      await session.commitTransaction();
      return result;

    } catch (error) {
      await session.abortTransaction();

      // R√©essayer si erreur de transaction
      if (error.errorLabels && error.errorLabels.includes('TransientTransactionError')) {
        if (i < maxRetries - 1) {
          console.log(`Retrying transaction... (${i + 1}/${maxRetries})`);
          await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
          continue;
        }
      }

      throw error;

    } finally {
      session.endSession();
    }
  }
}

// Utilisation
const result = await withRetry(async (session) => {
  const order = await Order.create([{
    userId: userId,
    items: items,
    total: calculateTotal(items)
  }], { session });

  for (const item of items) {
    await Product.findByIdAndUpdate(
      item.productId,
      { $inc: { stock: -item.quantity } },
      { session }
    );
  }

  return order[0];
});
```

### Transaction complexe (e-commerce)

```javascript
async function processOrder(userId, cartItems) {
  const session = await mongoose.startSession();

  try {
    session.startTransaction();

    // 1. V√©rifier le stock
    for (const item of cartItems) {
      const product = await Product.findById(item.productId).session(session);

      if (!product) {
        throw new Error(`Product ${item.productId} not found`);
      }

      if (product.stock < item.quantity) {
        throw new Error(`Insufficient stock for ${product.name}`);
      }
    }

    // 2. Calculer le total
    const total = cartItems.reduce((sum, item) => {
      return sum + (item.price * item.quantity);
    }, 0);

    // 3. V√©rifier le solde de l'utilisateur
    const user = await User.findById(userId).session(session);
    if (user.balance < total) {
      throw new Error('Insufficient balance');
    }

    // 4. Cr√©er la commande
    const [order] = await Order.create([{
      userId,
      items: cartItems,
      total,
      status: 'pending'
    }], { session });

    // 5. D√©cr√©menter le stock
    for (const item of cartItems) {
      await Product.findByIdAndUpdate(
        item.productId,
        { $inc: { stock: -item.quantity } },
        { session }
      );
    }

    // 6. D√©biter le compte utilisateur
    user.balance -= total;
    await user.save({ session });

    // 7. Vider le panier
    await Cart.findOneAndUpdate(
      { userId },
      { $set: { items: [] } },
      { session }
    );

    // 8. Cr√©er une entr√©e de paiement
    await Payment.create([{
      orderId: order._id,
      userId,
      amount: total,
      method: 'account_balance',
      status: 'completed'
    }], { session });

    await session.commitTransaction();

    return order;

  } catch (error) {
    await session.abortTransaction();
    throw error;

  } finally {
    session.endSession();
  }
}
```

---

## Performance et Optimisation

### Indexes

```javascript
// D√©finir les indexes dans le sch√©ma
const userSchema = new mongoose.Schema({
  username: { type: String, unique: true },
  email: { type: String, unique: true },
  age: Number,
  location: {
    type: { type: String, default: 'Point' },
    coordinates: [Number]
  },
  status: String,
  tags: [String]
});

// Index simples
userSchema.index({ username: 1 }); // Ascendant
userSchema.index({ email: 1 }, { unique: true });

// Index compos√©
userSchema.index({ status: 1, age: -1 });

// Index text pour recherche
userSchema.index({ username: 'text', bio: 'text' });

// Index g√©ospatial
userSchema.index({ location: '2dsphere' });

// Index partiel (MongoDB 3.2+)
userSchema.index(
  { age: 1 },
  { partialFilterExpression: { age: { $gte: 18 } } }
);

// Index sparse
userSchema.index({ optionalField: 1 }, { sparse: true });

// Index avec TTL
userSchema.index({ createdAt: 1 }, { expireAfterSeconds: 86400 });

// Cr√©er les indexes
const User = mongoose.model('User', userSchema);

// En d√©veloppement, les index sont cr√©√©s automatiquement
// En production, d√©sactiver l'auto-cr√©ation et cr√©er manuellement
if (process.env.NODE_ENV === 'production') {
  mongoose.set('autoIndex', false);
}

// Cr√©er les index manuellement
await User.createIndexes();

// V√©rifier les index existants
const indexes = await User.collection.getIndexes();
console.log(indexes);
```

### Optimisation des requ√™tes

```javascript
// ‚ùå Mauvais : N+1 queries
const posts = await Post.find();
for (const post of posts) {
  post.author = await User.findById(post.author); // N requ√™tes suppl√©mentaires
}

// ‚úÖ Bon : Populate
const posts = await Post.find().populate('author');

// ‚ùå Mauvais : R√©cup√©rer tous les champs
const users = await User.find();

// ‚úÖ Bon : Projection
const users = await User.find().select('username email');

// ‚ùå Mauvais : Sans lean() pour lecture seule
const users = await User.find();

// ‚úÖ Bon : Avec lean()
const users = await User.find().lean();

// ‚ùå Mauvais : Pagination avec skip
const page = 100;
const users = await User.find()
  .skip((page - 1) * 20)
  .limit(20); // Lent pour grandes valeurs de skip

// ‚úÖ Bon : Cursor-based pagination
const lastId = req.query.lastId;
const users = await User.find(
  lastId ? { _id: { $gt: lastId } } : {}
)
  .sort({ _id: 1 })
  .limit(20);

// ‚ùå Mauvais : Count avec skip/limit
const total = await User.countDocuments();
const users = await User.find().skip(20).limit(10);

// ‚úÖ Bon : estimatedDocumentCount pour approximation
const total = await User.estimatedDocumentCount();

// ‚ùå Mauvais : Multiples requ√™tes pour agr√©gations
const totalUsers = await User.countDocuments();
const activeUsers = await User.countDocuments({ isActive: true });
const avgAge = await User.aggregate([
  { $group: { _id: null, avg: { $avg: '$age' } } }
]);

// ‚úÖ Bon : Une seule agr√©gation
const stats = await User.aggregate([
  {
    $facet: {
      total: [{ $count: 'count' }],
      active: [
        { $match: { isActive: true } },
        { $count: 'count' }
      ],
      avgAge: [
        { $group: { _id: null, avg: { $avg: '$age' } } }
      ]
    }
  }
]);
```

### Batch operations

```javascript
// ‚ùå Mauvais : Boucle avec save
for (const userData of usersData) {
  const user = new User(userData);
  await user.save(); // N requ√™tes
}

// ‚úÖ Bon : insertMany
await User.insertMany(usersData);

// ‚ùå Mauvais : Mise √† jour en boucle
for (const userId of userIds) {
  await User.findByIdAndUpdate(userId, { isActive: false });
}

// ‚úÖ Bon : updateMany
await User.updateMany(
  { _id: { $in: userIds } },
  { $set: { isActive: false } }
);

// Bulk operations pour op√©rations mixtes
const bulkOps = users.map(user => ({
  updateOne: {
    filter: { _id: user._id },
    update: { $set: { lastSeen: new Date() } },
    upsert: true
  }
}));

await User.bulkWrite(bulkOps);
```

### Connection pooling

```javascript
// Configuration du pool de connexions
const options = {
  maxPoolSize: 10, // Max connexions
  minPoolSize: 5, // Min connexions
  maxIdleTimeMS: 10000, // Fermer connexions inactives
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000
};

await mongoose.connect(uri, options);

// Monitoring du pool
mongoose.connection.on('open', () => {
  console.log('Connection pool opened');
});

mongoose.connection.on('close', () => {
  console.log('Connection pool closed');
});

// Stats du pool (MongoDB 3.6+)
const adminDb = mongoose.connection.db.admin();
const serverStatus = await adminDb.serverStatus();
console.log(serverStatus.connections);
```

---

## Patterns Avanc√©s

### Repository Pattern

```javascript
// repositories/BaseRepository.js
class BaseRepository {
  constructor(model) {
    this.model = model;
  }

  async findById(id, options = {}) {
    let query = this.model.findById(id);

    if (options.populate) {
      query = query.populate(options.populate);
    }

    if (options.select) {
      query = query.select(options.select);
    }

    if (options.lean) {
      query = query.lean();
    }

    return query.exec();
  }

  async findOne(conditions, options = {}) {
    let query = this.model.findOne(conditions);

    if (options.populate) {
      query = query.populate(options.populate);
    }

    if (options.select) {
      query = query.select(options.select);
    }

    if (options.lean) {
      query = query.lean();
    }

    return query.exec();
  }

  async find(conditions = {}, options = {}) {
    let query = this.model.find(conditions);

    if (options.populate) {
      query = query.populate(options.populate);
    }

    if (options.select) {
      query = query.select(options.select);
    }

    if (options.sort) {
      query = query.sort(options.sort);
    }

    if (options.limit) {
      query = query.limit(options.limit);
    }

    if (options.skip) {
      query = query.skip(options.skip);
    }

    if (options.lean) {
      query = query.lean();
    }

    return query.exec();
  }

  async create(data) {
    return this.model.create(data);
  }

  async updateById(id, updates, options = {}) {
    return this.model.findByIdAndUpdate(
      id,
      updates,
      { new: true, runValidators: true, ...options }
    );
  }

  async deleteById(id) {
    return this.model.findByIdAndDelete(id);
  }

  async count(conditions = {}) {
    return this.model.countDocuments(conditions);
  }

  async exists(conditions) {
    return this.model.exists(conditions);
  }

  async paginate(conditions = {}, page = 1, limit = 10, options = {}) {
    const skip = (page - 1) * limit;

    const [docs, total] = await Promise.all([
      this.find(conditions, { ...options, skip, limit }),
      this.count(conditions)
    ]);

    return {
      docs,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit),
      hasNext: page < Math.ceil(total / limit),
      hasPrev: page > 1
    };
  }
}

// repositories/UserRepository.js
class UserRepository extends BaseRepository {
  constructor() {
    super(User);
  }

  async findByEmail(email) {
    return this.findOne({ email: email.toLowerCase() });
  }

  async findActive() {
    return this.find({ isActive: true });
  }

  async updateLastLogin(userId) {
    return this.updateById(userId, { lastLogin: new Date() });
  }

  async findWithStats(userId) {
    return this.model.aggregate([
      { $match: { _id: mongoose.Types.ObjectId(userId) } },
      {
        $lookup: {
          from: 'posts',
          localField: '_id',
          foreignField: 'author',
          as: 'posts'
        }
      },
      {
        $addFields: {
          postCount: { $size: '$posts' }
        }
      }
    ]);
  }
}

module.exports = new UserRepository();

// Utilisation
const userRepository = require('./repositories/UserRepository');

const user = await userRepository.findByEmail('user@example.com');
const activeUsers = await userRepository.findActive();
const result = await userRepository.paginate({}, 1, 20);
```

### Service Layer Pattern

```javascript
// services/UserService.js
const userRepository = require('../repositories/UserRepository');
const emailService = require('./EmailService');
const cacheService = require('./CacheService');

class UserService {
  async registerUser(userData) {
    // Validation m√©tier
    const existingUser = await userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new Error('Email already registered');
    }

    // Cr√©er l'utilisateur
    const user = await userRepository.create({
      ...userData,
      isActive: false,
      verificationToken: this.generateToken()
    });

    // Envoyer l'email de v√©rification
    await emailService.sendVerificationEmail(user.email, user.verificationToken);

    return user;
  }

  async verifyEmail(token) {
    const user = await userRepository.findOne({ verificationToken: token });

    if (!user) {
      throw new Error('Invalid verification token');
    }

    user.isActive = true;
    user.verificationToken = undefined;
    await user.save();

    // Invalider le cache
    await cacheService.del(`user:${user._id}`);

    return user;
  }

  async getUserProfile(userId) {
    // V√©rifier le cache
    const cached = await cacheService.get(`user:${userId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    // Charger depuis la DB
    const user = await userRepository.findById(userId, {
      select: '-password',
      lean: true
    });

    if (!user) {
      throw new Error('User not found');
    }

    // Mettre en cache
    await cacheService.set(`user:${userId}`, JSON.stringify(user), 300);

    return user;
  }

  async updateProfile(userId, updates) {
    // Valider les mises √† jour
    const allowedUpdates = ['username', 'bio', 'avatar'];
    const actualUpdates = Object.keys(updates).filter(key =>
      allowedUpdates.includes(key)
    );

    if (actualUpdates.length === 0) {
      throw new Error('No valid updates provided');
    }

    const updateData = {};
    actualUpdates.forEach(key => {
      updateData[key] = updates[key];
    });

    const user = await userRepository.updateById(userId, updateData);

    // Invalider le cache
    await cacheService.del(`user:${userId}`);

    return user;
  }

  async deactivateAccount(userId) {
    const user = await userRepository.findById(userId);

    if (!user) {
      throw new Error('User not found');
    }

    user.isActive = false;
    user.deactivatedAt = new Date();
    await user.save();

    // Supprimer les sessions actives
    await this.invalidateUserSessions(userId);

    // Notifier par email
    await emailService.sendAccountDeactivationEmail(user.email);

    return user;
  }

  generateToken() {
    return crypto.randomBytes(32).toString('hex');
  }

  async invalidateUserSessions(userId) {
    // Logique pour invalider les sessions
  }
}

module.exports = new UserService();
```

---

## Debugging et Bonnes Pratiques

### Debugging

```javascript
// Activer le mode debug
mongoose.set('debug', true);

// Debug personnalis√©
mongoose.set('debug', (collectionName, method, query, doc) => {
  console.log(`${collectionName}.${method}`, JSON.stringify(query), doc);
});

// Logger seulement certaines collections
mongoose.set('debug', (collectionName, method, query, doc) => {
  if (collectionName === 'users') {
    console.log(`${method}:`, query);
  }
});

// Utiliser un logger
const winston = require('winston');
const logger = winston.createLogger({
  transports: [new winston.transports.File({ filename: 'mongoose.log' })]
});

mongoose.set('debug', (collectionName, method, query, doc) => {
  logger.info({
    collection: collectionName,
    method,
    query,
    doc
  });
});
```

### Gestion des erreurs

```javascript
// Middleware d'erreur global
mongoose.connection.on('error', (error) => {
  console.error('MongoDB connection error:', error);
  // Notifier le monitoring (Sentry, etc.)
});

// Validation errors
try {
  await user.save();
} catch (error) {
  if (error.name === 'ValidationError') {
    const errors = {};
    Object.keys(error.errors).forEach((key) => {
      errors[key] = error.errors[key].message;
    });
    console.log('Validation errors:', errors);
  }
}

// Duplicate key errors
userSchema.post('save', function(error, doc, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    // D√©terminer quel champ est dupliqu√©
    const field = Object.keys(error.keyPattern)[0];
    next(new Error(`${field} already exists`));
  } else {
    next(error);
  }
});

// Cast errors
try {
  await User.findById('invalid-id');
} catch (error) {
  if (error.name === 'CastError') {
    console.error('Invalid ID format');
  }
}
```

### Best practices

```javascript
// 1. Toujours d√©finir les sch√©mas avec strict mode
const userSchema = new mongoose.Schema({
  username: String
}, {
  strict: true, // Rejeter les champs non d√©finis
  strictQuery: true // Strict aussi pour les queries
});

// 2. Utiliser timestamps
const schema = new mongoose.Schema({
  // ...
}, {
  timestamps: true
});

// 3. Index unique avec validation
const schema = new mongoose.Schema({
  email: {
    type: String,
    unique: true,
    required: true,
    validate: emailValidator
  }
});

// 4. select: false pour champs sensibles
const schema = new mongoose.Schema({
  password: {
    type: String,
    required: true,
    select: false // Pas inclus dans les queries par d√©faut
  }
});

// Inclure explicitement si n√©cessaire
const user = await User.findOne({ email }).select('+password');

// 5. Utiliser lean() pour lecture seule
const users = await User.find().lean();

// 6. Projections pour √©conomiser la bande passante
const users = await User.find().select('username email');

// 7. Limiter les r√©sultats
const users = await User.find().limit(100);

// 8. Utiliser estimatedDocumentCount quand la pr√©cision n'est pas critique
const approxCount = await User.estimatedDocumentCount();

// 9. D√©sactiver autoIndex en production
if (process.env.NODE_ENV === 'production') {
  mongoose.set('autoIndex', false);
}

// 10. Fermer proprement la connexion
process.on('SIGINT', async () => {
  await mongoose.connection.close();
  process.exit(0);
});
```

---

## Conclusion

Mongoose est l'ODM de r√©f√©rence pour MongoDB en Node.js, offrant un √©quilibre optimal entre productivit√© et performance pour la majorit√© des cas d'usage.

### Points cl√©s √† retenir

1. **Sch√©mas stricts** : D√©finir des sch√©mas avec validation robuste
2. **Middleware** : Utiliser hooks pour la logique m√©tier
3. **Population** : G√©rer les relations intelligemment
4. **Performance** : lean(), projections, indexes
5. **Transactions** : Pour les op√©rations critiques multi-documents
6. **Plugins** : R√©utiliser et partager la logique
7. **Patterns** : Repository et Service Layer pour code maintenable

### Ressources

- [Documentation officielle](https://mongoosejs.com/)
- [Guide TypeScript](https://mongoosejs.com/docs/typescript.html)
- [Plugins](https://plugins.mongoosejs.io/)
- [GitHub](https://github.com/Automattic/mongoose)

---


‚è≠Ô∏è [Motor (Python async)](/15-drivers-integration-applicative/12.2-motor-python-async.md)
